

# Environment Variables in Go: A Comprehensive Guide

!!! abstract "Overview"
Master environment variable handling in Go using the `os` package. Learn to read, set, and manage environment variables for application configuration, implement best practices for security and validation, and create flexible applications that can be deployed across different environments without code changes.

!!! tip "Key Points"
- Use `os.Getenv` for simple access and `os.LookupEnv` to distinguish unset variables from empty strings
- Provide sensible defaults for optional settings and validate required variables
- Structure configuration logically and document all environment variables
- Never log sensitive information and use `.env` files for development (but don't commit them)
- Environment variables are essential for containerized applications and configuration management

## Understanding Environment Variables

Environment variables are a fundamental mechanism for configuring applications at runtime. They are key-value pairs that can affect the behavior of running processes on a computer system. In Go, environment variables are commonly used for:

- Application configuration (database URLs, API keys, etc.)
- Controlling application behavior (debug mode, log levels, etc.)
- Providing environment-specific settings (development, staging, production)
- Storing sensitive information that shouldn't be hardcoded

Go provides the `os` package for working with environment variables, offering a simple and effective API.

!!! info "Environment Variable Operations in Go"
```mermaid
graph TD
A[Environment Variables] --> B[Reading Variables]
A --> C[Setting Variables]
A --> D[Unsetting Variables]
A --> E[Listing Variables]
B --> F[os.Getenv]
B --> G[os.LookupEnv]
C --> H[os.Setenv]
D --> I[os.Unsetenv]
E --> J[os.Environ]
style A fill:#999,stroke:#333,stroke-width:2px,color:#000
```

## Reading Environment Variables

### Getting a Single Environment Variable

The `os.Getenv` function retrieves the value of an environment variable. It returns an empty string if the variable is not set:

!!! example "Getting a Single Environment Variable"
```go title="get_single_env.go" linenums="1" hl_lines="8-15"
package main

import (
    "fmt"
    "os"
)

func main() {
    // Get the value of the HOME environment variable
    home := os.Getenv("HOME")
    fmt.Println("Home directory:", home)
    
    // Try to get a variable that might not exist
    path := os.Getenv("NON_EXISTENT_VAR")
    fmt.Println("Non-existent variable:", path)
}
```

### Getting a Variable with a Default Value

Since `os.Getenv` returns an empty string for unset variables, you can provide a default value:

!!! example "Getting a Variable with Default Value"
```go title="default_value.go" linenums="1" hl_lines="8-18"
package main

import (
    "fmt"
    "os"
)

func main() {
    // Get the PORT variable, default to 8080 if not set
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }
    fmt.Println("Server will run on port:", port)
}
```

### Checking if a Variable Exists

To distinguish between an unset variable and a variable set to an empty string, use `os.LookupEnv`:

!!! example "Checking if a Variable Exists"
```go title="check_variable_exists.go" linenums="1" hl_lines="8-25"
package main

import (
    "fmt"
    "os"
)

func main() {
    // Check if DEBUG is set
    debug, exists := os.LookupEnv("DEBUG")
    if exists {
        fmt.Println("DEBUG is set to:", debug)
    } else {
        fmt.Println("DEBUG is not set")
    }
    
    // Set an empty variable for demonstration
    os.Setenv("EMPTY_VAR", "")
    
    // Check if EMPTY_VAR exists
    empty, exists := os.LookupEnv("EMPTY_VAR")
    if exists {
        fmt.Println("EMPTY_VAR exists and is set to:", empty)
    } else {
        fmt.Println("EMPTY_VAR does not exist")
    }
}
```

## Setting Environment Variables

### Setting a Variable

Use `os.Setenv` to set an environment variable:

!!! example "Setting a Variable"
```go title="setting_variable.go" linenums="1" hl_lines="8-20"
package main

import (
    "fmt"
    "os"
)

func main() {
    // Set an environment variable
    err := os.Setenv("APP_ENV", "development")
    if err != nil {
        fmt.Println("Error setting environment variable:", err)
        return
    }
    
    // Verify it was set
    env := os.Getenv("APP_ENV")
    fmt.Println("APP_ENV is now:", env)
}
```

### Modifying Existing Variables

`os.Setenv` will overwrite existing variables:

!!! example "Modifying Existing Variables"
```go title="modifying_variables.go" linenums="1" hl_lines="8-20"
package main

import (
    "fmt"
    "os"
)

func main() {
    // Set initial value
    os.Setenv("LOG_LEVEL", "info")
    fmt.Println("Initial LOG_LEVEL:", os.Getenv("LOG_LEVEL"))
    
    // Change the value
    os.Setenv("LOG_LEVEL", "debug")
    fmt.Println("Updated LOG_LEVEL:", os.Getenv("LOG_LEVEL"))
}
```

## Unsetting Environment Variables

Use `os.Unsetenv` to remove an environment variable:

!!! example "Unsetting Environment Variables"
```go title="unsetting_variables.go" linenums="1" hl_lines="8-25"
package main

import (
    "fmt"
    "os"
)

func main() {
    // Set a variable
    os.Setenv("TEMP_VAR", "temporary")
    fmt.Println("TEMP_VAR set to:", os.Getenv("TEMP_VAR"))
    
    // Unset the variable
    err := os.Unsetenv("TEMP_VAR")
    if err != nil {
        fmt.Println("Error unsetting environment variable:", err)
        return
    }
    
    // Verify it was unset
    value, exists := os.LookupEnv("TEMP_VAR")
    if exists {
        fmt.Println("TEMP_VAR still exists with value:", value)
    } else {
        fmt.Println("TEMP_VAR has been unset")
    }
}
```

## Listing All Environment Variables

To get all environment variables, use `os.Environ`, which returns a slice of strings in the format "KEY=VALUE":

!!! example "Listing All Environment Variables"
```go title="listing_all_variables.go" linenums="1" hl_lines="8-25"
package main

import (
    "fmt"
    "os"
    "strings"
)

func main() {
    // Get all environment variables
    envVars := os.Environ()
    
    fmt.Println("Environment variables:")
    for _, env := range envVars {
        // Split into key and value
        pair := strings.SplitN(env, "=", 2)
        if len(pair) == 2 {
            fmt.Printf("%s = %s\n", pair[0], pair[1])
        }
    }
}
```

## Using Environment Variables for Configuration

Environment variables are an excellent way to configure applications without hardcoding values. Here's a common pattern for configuration management:

!!! example "Configuration Management Pattern"
```go title="config_management.go" linenums="1" hl_lines="8-70"
package main

import (
    "fmt"
    "os"
    "strconv"
    "time"
)

type Config struct {
    Port         int
    DatabaseURL  string
    DebugMode    bool
    LogLevel     string
    MaxConnections int
    Timeout      time.Duration
}

func LoadConfig() (*Config, error) {
    config := &Config{}
    
    // Get port with default
    portStr := os.Getenv("PORT")
    if portStr == "" {
        portStr = "8080"
    }
    port, err := strconv.Atoi(portStr)
    if err != nil {
        return nil, fmt.Errorf("invalid PORT: %v", err)
    }
    config.Port = port
    
    // Get database URL (required)
    config.DatabaseURL = os.Getenv("DATABASE_URL")
    if config.DatabaseURL == "" {
        return nil, fmt.Errorf("DATABASE_URL is required")
    }
    
    // Get debug mode
    debugStr := os.Getenv("DEBUG")
    config.DebugMode = debugStr == "true" || debugStr == "1" || debugStr == "yes"
    
    // Get log level with default
    config.LogLevel = os.Getenv("LOG_LEVEL")
    if config.LogLevel == "" {
        config.LogLevel = "info"
    }
    
    // Get max connections with default
    maxConnStr := os.Getenv("MAX_CONNECTIONS")
    if maxConnStr == "" {
        maxConnStr = "10"
    }
    maxConn, err := strconv.Atoi(maxConnStr)
    if err != nil {
        return nil, fmt.Errorf("invalid MAX_CONNECTIONS: %v", err)
    }
    config.MaxConnections = maxConn
    
    // Get timeout with default
    timeoutStr := os.Getenv("TIMEOUT")
    if timeoutStr == "" {
        timeoutStr = "30s"
    }
    timeout, err := time.ParseDuration(timeoutStr)
    if err != nil {
        return nil, fmt.Errorf("invalid TIMEOUT: %v", err)
    }
    config.Timeout = timeout
    
    return config, nil
}

func main() {
    // Set some environment variables for demonstration
    os.Setenv("DATABASE_URL", "postgres://user:pass@localhost/dbname")
    os.Setenv("DEBUG", "true")
    os.Setenv("TIMEOUT", "5s")
    
    // Load configuration
    config, err := LoadConfig()
    if err != nil {
        fmt.Println("Error loading configuration:", err)
        os.Exit(1)
    }
    
    // Print configuration
    fmt.Printf("Port: %d\n", config.Port)
    fmt.Printf("Database URL: %s\n", config.DatabaseURL)
    fmt.Printf("Debug Mode: %v\n", config.DebugMode)
    fmt.Printf("Log Level: %s\n", config.LogLevel)
    fmt.Printf("Max Connections: %d\n", config.MaxConnections)
    fmt.Printf("Timeout: %v\n", config.Timeout)
}
```

## Best Practices for Environment Variables

!!! tip "Naming Conventions"
Use uppercase letters and underscores, be descriptive but concise, and group related variables with a common prefix.

!!! example "Naming Conventions"
```go title="naming_conventions.go" linenums="1" hl_lines="8-15"
package main

import (
    "os"
)

func main() {
    // Good
    os.Setenv("DATABASE_URL", "postgres://...")
    os.Setenv("DATABASE_MAX_CONNECTIONS", "10")

    // Less clear
    os.Setenv("DB", "postgres://...")
    os.Setenv("MAXCONN", "10")
}
```

!!! tip "Documentation"
Document all environment variables your application uses.

!!! example "Documentation"
```go title="documentation.go" linenums="1" hl_lines="1-8"
// Configuration via environment variables:
//
// PORT: Port to listen on (default: 8080)
// DATABASE_URL: Database connection string (required)
// DEBUG: Enable debug mode (true/false, default: false)
// LOG_LEVEL: Logging level (debug, info, warn, error, default: info)
// MAX_CONNECTIONS: Maximum database connections (default: 10)
// TIMEOUT: Request timeout (e.g., 30s, 1m, default: 30s)
package main
```

!!! tip "Validation"
Validate environment variables and provide clear error messages.

!!! example "Validation"
```go title="validation.go" linenums="1" hl_lines="8-35"
package main

import (
    "fmt"
    "os"
    "strconv"
)

func LoadConfig() (*Config, error) {
    config := &Config{}
    
    // Required variable
    config.DatabaseURL = os.Getenv("DATABASE_URL")
    if config.DatabaseURL == "" {
        return nil, fmt.Errorf("DATABASE_URL environment variable is required")
    }
    
    // Validate port range
    portStr := os.Getenv("PORT")
    if portStr == "" {
        portStr = "8080"
    }
    port, err := strconv.Atoi(portStr)
    if err != nil {
        return nil, fmt.Errorf("invalid PORT: must be a number")
    }
    if port < 1 || port > 65535 {
        return nil, fmt.Errorf("invalid PORT: must be between 1 and 65535")
    }
    config.Port = port
    
    // ... rest of configuration
    
    return config, nil
}
```

!!! warning "Security Considerations"
Never log sensitive environment variables, use `.env` files for development (but don't commit them), and consider using secrets management for production.

!!! example "Security Considerations"
```go title="security_considerations.go" linenums="1" hl_lines="8-15"
package main

import (
    "fmt"
    "os"
)

func main() {
    // Don't do this - exposes secrets in logs
    // fmt.Printf("Connecting to database with URL: %s\n", os.Getenv("DATABASE_URL"))
    
    // Instead, log a generic message
    fmt.Println("Connecting to database...")
}
```

!!! tip "Defaults and Overrides"
Provide sensible defaults for optional settings and allow configuration files to override environment variables if needed.

## Real-World Example: Web Application Configuration

Let's create a more comprehensive example of a web application that uses environment variables for configuration:

!!! example "Web Application Configuration"
```go title="web_app_config.go" linenums="1" hl_lines="8-180"
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
    "strconv"
    "time"
)

// AppConfig holds the application configuration
type AppConfig struct {
    Server      ServerConfig
    Database    DatabaseConfig
    Auth        AuthConfig
    Logging     LoggingConfig
    Features    FeatureFlags
}

// ServerConfig holds HTTP server configuration
type ServerConfig struct {
    Port         int
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
    IdleTimeout  time.Duration
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
    URL             string
    MaxOpenConns    int
    MaxIdleConns    int
    ConnMaxLifetime time.Duration
}

// AuthConfig holds authentication configuration
type AuthConfig struct {
    JWTSecret      string
    TokenExpiry    time.Duration
    RefreshExpiry  time.Duration
}

// LoggingConfig holds logging configuration
type LoggingConfig struct {
    Level  string
    Format string
}

// FeatureFlags holds feature toggle configuration
type FeatureFlags struct {
    EnableNewUI    bool
    EnableCache    bool
    EnableAnalytics bool
}

// LoadConfig loads configuration from environment variables
func LoadConfig() (*AppConfig, error) {
    config := &AppConfig{}
    
    // Server configuration
    serverPort, err := getIntEnv("SERVER_PORT", 8080)
    if err != nil {
        return nil, fmt.Errorf("invalid SERVER_PORT: %v", err)
    }
    
    serverReadTimeout, err := getDurationEnv("SERVER_READ_TIMEOUT", "15s")
    if err != nil {
        return nil, fmt.Errorf("invalid SERVER_READ_TIMEOUT: %v", err)
    }
    
    serverWriteTimeout, err := getDurationEnv("SERVER_WRITE_TIMEOUT", "15s")
    if err != nil {
        return nil, fmt.Errorf("invalid SERVER_WRITE_TIMEOUT: %v", err)
    }
    
    serverIdleTimeout, err := getDurationEnv("SERVER_IDLE_TIMEOUT", "60s")
    if err != nil {
        return nil, fmt.Errorf("invalid SERVER_IDLE_TIMEOUT: %v", err)
    }
    
    config.Server = ServerConfig{
        Port:         serverPort,
        ReadTimeout:  serverReadTimeout,
        WriteTimeout: serverWriteTimeout,
        IdleTimeout:  serverIdleTimeout,
    }
    
    // Database configuration
    dbURL := os.Getenv("DATABASE_URL")
    if dbURL == "" {
        return nil, fmt.Errorf("DATABASE_URL is required")
    }
    
    dbMaxOpenConns, err := getIntEnv("DATABASE_MAX_OPEN_CONNS", 25)
    if err != nil {
        return nil, fmt.Errorf("invalid DATABASE_MAX_OPEN_CONNS: %v", err)
    }
    
    dbMaxIdleConns, err := getIntEnv("DATABASE_MAX_IDLE_CONNS", 25)
    if err != nil {
        return nil, fmt.Errorf("invalid DATABASE_MAX_IDLE_CONNS: %v", err)
    }
    
    dbConnMaxLifetime, err := getDurationEnv("DATABASE_CONN_MAX_LIFETIME", "5m")
    if err != nil {
        return nil, fmt.Errorf("invalid DATABASE_CONN_MAX_LIFETIME: %v", err)
    }
    
    config.Database = DatabaseConfig{
        URL:             dbURL,
        MaxOpenConns:    dbMaxOpenConns,
        MaxIdleConns:    dbMaxIdleConns,
        ConnMaxLifetime: dbConnMaxLifetime,
    }
    
    // Auth configuration
    jwtSecret := os.Getenv("AUTH_JWT_SECRET")
    if jwtSecret == "" {
        return nil, fmt.Errorf("AUTH_JWT_SECRET is required")
    }
    
    tokenExpiry, err := getDurationEnv("AUTH_TOKEN_EXPIRY", "15m")
    if err != nil {
        return nil, fmt.Errorf("invalid AUTH_TOKEN_EXPIRY: %v", err)
    }
    
    refreshExpiry, err := getDurationEnv("AUTH_REFRESH_EXPIRY", "7d")
    if err != nil {
        return nil, fmt.Errorf("invalid AUTH_REFRESH_EXPIRY: %v", err)
    }
    
    config.Auth = AuthConfig{
        JWTSecret:     jwtSecret,
        TokenExpiry:   tokenExpiry,
        RefreshExpiry: refreshExpiry,
    }
    
    // Logging configuration
    logLevel := os.Getenv("LOGGING_LEVEL")
    if logLevel == "" {
        logLevel = "info"
    }
    
    logFormat := os.Getenv("LOGGING_FORMAT")
    if logFormat == "" {
        logFormat = "json"
    }
    
    config.Logging = LoggingConfig{
        Level:  logLevel,
        Format: logFormat,
    }
    
    // Feature flags
    config.Features = FeatureFlags{
        EnableNewUI:    getBoolEnv("FEATURE_NEW_UI", false),
        EnableCache:    getBoolEnv("FEATURE_CACHE", true),
        EnableAnalytics: getBoolEnv("FEATURE_ANALYTICS", false),
    }
    
    return config, nil
}

// Helper functions for environment variable parsing
func getIntEnv(key string, defaultValue int) (int, error) {
    valueStr := os.Getenv(key)
    if valueStr == "" {
        return defaultValue, nil
    }
    
    value, err := strconv.Atoi(valueStr)
    if err != nil {
        return 0, err
    }
    
    return value, nil
}

func getDurationEnv(key, defaultValue string) (time.Duration, error) {
    valueStr := os.Getenv(key)
    if valueStr == "" {
        valueStr = defaultValue
    }
    
    value, err := time.ParseDuration(valueStr)
    if err != nil {
        return 0, err
    }
    
    return value, nil
}

func getBoolEnv(key string, defaultValue bool) bool {
    valueStr := os.Getenv(key)
    if valueStr == "" {
        return defaultValue
    }
    
    return valueStr == "true" || valueStr == "1" || valueStr == "yes" || valueStr == "on"
}

func main() {
    // Set some environment variables for demonstration
    os.Setenv("DATABASE_URL", "postgres://user:pass@localhost/myapp")
    os.Setenv("AUTH_JWT_SECRET", "super-secret-jwt-key")
    os.Setenv("FEATURE_CACHE", "true")
    
    // Load configuration
    config, err := LoadConfig()
    if err != nil {
        log.Fatalf("Error loading configuration: %v", err)
    }
    
    // Print configuration (in a real app, you might not want to log secrets)
    configJSON, _ := json.MarshalIndent(config, "", "  ")
    fmt.Printf("Application configuration:\n%s\n", string(configJSON))
    
    // Start the server
    server := &http.Server{
        Addr:         fmt.Sprintf(":%d", config.Server.Port),
        ReadTimeout:  config.Server.ReadTimeout,
        WriteTimeout: config.Server.WriteTimeout,
        IdleTimeout:  config.Server.IdleTimeout,
    }
    
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
            "message": "Hello, World!",
            "status":  "ok",
        })
    })
    
    log.Printf("Starting server on port %d", config.Server.Port)
    if err := server.ListenAndServe(); err != nil {
        log.Fatalf("Server error: %v", err)
    }
}
```

### How This Example Demonstrates Environment Variables:

1. **Structured Configuration**:
   - Organizes configuration into logical groups (Server, Database, Auth, etc.)
   - Uses nested structs for better organization

2. **Type Conversion**:
   - Helper functions for converting environment variables to specific types
   - Proper error handling for invalid values

3. **Required vs. Optional Variables**:
   - Clearly distinguishes between required and optional settings
   - Provides sensible defaults for optional variables

4. **Validation**:
   - Validates environment variables and returns clear error messages
   - Ensures critical settings are present

5. **Feature Flags**:
   - Demonstrates using environment variables for feature toggling
   - Allows enabling/disabling functionality without code changes

!!! info "Web Application Configuration Structure"
```mermaid
graph TD
A[AppConfig] --> B[ServerConfig]
A --> C[DatabaseConfig]
A --> D[AuthConfig]
A --> E[LoggingConfig]
A --> F[FeatureFlags]
B --> G[Port]
B --> H[ReadTimeout]
B --> I[WriteTimeout]
B --> J[IdleTimeout]
C --> K[URL]
C --> L[MaxOpenConns]
C --> M[MaxIdleConns]
C --> N[ConnMaxLifetime]
D --> O[JWTSecret]
D --> P[TokenExpiry]
D --> Q[RefreshExpiry]
E --> R[Level]
E --> S[Format]
F --> T[EnableNewUI]
F --> U[EnableCache]
F --> V[EnableAnalytics]
style A fill:#999,stroke:#333,stroke-width:2px,color:#000
```

## Advanced Techniques

### Using .env Files for Development

For development, it's common to use `.env` files to set environment variables. While Go doesn't have built-in support for `.env` files, you can use third-party packages like `godotenv`:

!!! example "Using .env Files"
```go title="dotenv_example.go" linenums="1" hl_lines="8-20"
package main

import (
    "fmt"
    "log"
    "os"

    "github.com/joho/godotenv"
)

func main() {
    // Load .env file
    err := godotenv.Load()
    if err != nil {
        log.Println("Warning: .env file not found")
    }
    
    // Access environment variables
    dbURL := os.Getenv("DATABASE_URL")
    fmt.Println("Database URL:", dbURL)
}
```

### Environment Variables in Tests

When writing tests, you might need to set environment variables temporarily:

!!! example "Environment Variables in Tests"
```go title="env_in_tests.go" linenums="1" hl_lines="8-35"
package main

import (
    "os"
    "testing"
)

func TestLoadConfig(t *testing.T) {
    // Save original environment variables
    originalPort := os.Getenv("PORT")
    originalDBURL := os.Getenv("DATABASE_URL")
    
    // Restore original values after the test
    defer func() {
        os.Setenv("PORT", originalPort)
        os.Setenv("DATABASE_URL", originalDBURL)
    }()
    
    // Set test values
    os.Setenv("PORT", "9090")
    os.Setenv("DATABASE_URL", "postgres://test:test@localhost/testdb")
    
    // Test the configuration loading
    config, err := LoadConfig()
    if err != nil {
        t.Fatalf("LoadConfig() error = %v", err)
    }
    
    if config.Port != 9090 {
        t.Errorf("Expected port 9090, got %d", config.Port)
    }
    
    if config.DatabaseURL != "postgres://test:test@localhost/testdb" {
        t.Errorf("Unexpected database URL: %s", config.DatabaseURL)
    }
}
```

### Environment Variables in Docker and Kubernetes

Environment variables are particularly important when containerizing applications:

#### Docker Example

```dockerfile
FROM golang:1.19-alpine AS builder
WORKDIR /app
COPY . .
RUN go build -o main .

FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/main .
# Set default environment variables
ENV PORT=8080
ENV LOG_LEVEL=info
CMD ["./main"]
```

#### Kubernetes Example

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 8080
        env:
        - name: PORT
          value: "8080"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        - name: LOG_LEVEL
          value: "info"
```

## Quick Reference

!!! success "Key Takeaways"
- **Reading Variables**: Use `os.Getenv` for simple access and `os.LookupEnv` to distinguish unset variables from empty strings
- **Setting Variables**: Use `os.Setenv` to set environment variables (changes only affect the current process and its children)
- **Configuration Management**: Structure configuration logically, validate environment variables, and provide clear error messages
- **Best Practices**: Follow naming conventions, document all environment variables, and never log sensitive information
- **Security**: Use `.env` files for development (but don't commit them) and consider secrets management for production
- **Containerization**: Environment variables are essential for Docker and Kubernetes deployments
- **Testing**: Use defer to restore original environment variable values in tests

!!! quote "Remember"
"Environment variables are a powerful and flexible way to configure Go applications. By mastering environment variables in Go, you can create more flexible, secure, and maintainable applications that can be easily deployed across different environments without code changes. They are particularly essential for containerized applications and enable configuration without code changes."