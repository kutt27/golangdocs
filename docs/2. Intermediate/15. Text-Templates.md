# Text Templates in Go: A Comprehensive Guide

!!! abstract "Overview
    Master Go's text/template package - a powerful templating system for generating textual output. Learn template syntax, control structures, custom functions, and patterns for creating HTML, emails, and other text-based content.

!!! tip "Key Points"
    - Templates use double curly braces `{{ }}` for actions
    - Separate presentation logic from business logic
    - Support conditionals, loops, and custom functions
    - Automatic escaping for security
    - Template composition with `define` and `template`

## Understanding Text Templates

Go's `text/template` package provides a powerful templating system for generating textual output. Templates allow you to define reusable text patterns with placeholders that get filled in with data at runtime.

!!! info "Template System Components"
    ```mermaid
    graph LR
        A[Template System] --> B[Template Syntax]
        A --> C[Data Structures]
        A --> D[Control Structures]
        A --> E[Functions]
        B --> F[{{ }} Delimiters]
        C --> G[Structs, Maps, Slices]
        D --> H[if, range, with]
        E --> I[Built-in & Custom]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Basic Template Syntax

### 1. Actions

Templates use double curly braces `{{` and `}}` to delimit actions:

!!! example "Basic Template Action"
    ```go title="basic_action.go" linenum="1" hl_lines="8-20"
    package main

    import (
        "os"
        "text/template"
    )

    func main() {
        // Simple template with a variable
        tmpl := `Hello, {{.Name}}!`
        
        // Data to populate the template
        data := struct {
            Name string
        }{
            Name: "Alice",
        }
        
        // Parse and execute the template
        t := template.Must(template.New("greeting").Parse(tmpl))
        t.Execute(os.Stdout, data) // Output: Hello, Alice!
    }
    ```

### 2. Variables and Pipelines

- `{{.}}` refers to the current data object
- `{{.Field}}` accesses a field of a struct
- `{{.Method}}` calls a method
- Pipelines use `|` to chain operations

!!! example "Variables and Pipelines"
    ```go title="variables_pipelines.go" linenum="1" hl_lines="8-25"
    package main

    import (
        "os"
        "text/template"
    )

    func main() {
        tmpl := `{{.Name}} is {{.Age}} years old. In 5 years: {{add .Age 5}}`
        
        data := struct {
            Name string
            Age  int
        }{
            Name: "Bob",
            Age:  30,
        }
        
        // Create a template with a custom function
        funcMap := template.FuncMap{
            "add": func(a, b int) int { return a + b },
        }
        
        t := template.Must(template.New("age").Funcs(funcMap).Parse(tmpl))
        t.Execute(os.Stdout, data)
        // Output: Bob is 30 years old. In 5 years: 35
    }
    ```

## Template Creation and Execution

### 1. Parsing Templates

!!! example "Template Parsing"
    ```go title="template_parsing.go" linenum="1" hl_lines="8-20"
    package main

    import (
        "text/template"
    )

    func main() {
        // Parse a single template
        t1, err := template.New("template1").Parse("Hello, {{.}}")
        if err != nil {
            panic(err)
        }

        // Parse multiple templates
        t2, err := template.ParseFiles("header.tmpl", "footer.tmpl")
        if err != nil {
            panic(err)
        }

        // Parse from string
        t3 := template.Must(template.New("inline").Parse("Value: {{.Value}}"))
    }
    ```

### 2. Executing Templates

!!! example "Template Execution"
    ```go title="template_execution.go" linenum="1" hl_lines="8-22"
    package main

    import (
        "bytes"
        "os"
        "text/template"
    )

    func main() {
        tmpl := "Hello, {{.Name}}!"
        data := struct{ Name string }{Name: "Alice"}
        
        t := template.Must(template.New("greeting").Parse(tmpl))
        
        // Execute to io.Writer
        err := t.Execute(os.Stdout, data)
        if err != nil {
            panic(err)
        }
        
        // Execute to string
        var buf bytes.Buffer
        err = t.Execute(&buf, data)
        result := buf.String()
        
        // Execute with specific template name (for multiple templates)
        err = t.ExecuteTemplate(os.Stdout, "greeting", data)
    }
    ```

## Data Structures for Templates

### 1. Using Structs

!!! example "Struct Data"
    ```go title="struct_data.go" linenum="1" hl_lines="8-30"
    package main

    import (
        "os"
        "text/template"
    )

    type User struct {
        Name    string
        Age     int
        Email   string
        Active  bool
    }

    func main() {
        tmpl := `
User: {{.Name}}
Age: {{.Age}}
Email: {{.Email}}
Status: {{if .Active}}Active{{else}}Inactive{{end}}
`
        
        user := User{
            Name:   "Charlie",
            Age:    25,
            Email:  "charlie@example.com",
            Active: true,
        }
        
        t := template.Must(template.New("user").Parse(tmpl))
        t.Execute(os.Stdout, user)
    }
    ```

### 2. Using Maps

!!! example "Map Data"
    ```go title="map_data.go" linenum="1" hl_lines="8-18"
    package main

    import (
        "os"
        "text/template"
    )

    func main() {
        tmpl := `{{.name}} lives in {{.city}}`
        
        data := map[string]string{
            "name": "Diana",
            "city": "New York",
        }
        
        t := template.Must(template.New("location").Parse(tmpl))
        t.Execute(os.Stdout, data) // Diana lives in New York
    }
    ```

### 3. Using Slices

!!! example "Slice Data"
    ```go title="slice_data.go" linenum="1" hl_lines="8-18"
    package main

    import (
        "os"
        "text/template"
    )

    func main() {
        tmpl := `{{range .}}{{.}} {{end}}`
        
        items := []string{"apple", "banana", "cherry"}
        
        t := template.Must(template.New("list").Parse(tmpl))
        t.Execute(os.Stdout, items) // apple banana cherry 
    }
    ```

## Control Structures

### 1. Conditionals

!!! example "Conditional Templates"
    ```go title="conditional_templates.go" linenum="1" hl_lines="8-25"
    package main

    import (
        "os"
        "text/template"
    )

    func main() {
        tmpl := `
{{if .Admin}}
    Welcome, Administrator!
{{else if .User}}
    Welcome, {{.User}}!
{{else}}
    Please log in.
{{end}}
`
        
        data := map[string]interface{}{
            "Admin": false,
            "User":  "Alice",
        }
        
        t := template.Must(template.New("auth").Parse(tmpl))
        t.Execute(os.Stdout, data)
        // Output:
        // Welcome, Alice!
    }
    ```

### 2. Loops with `range`

!!! example "Range Loops"
    ```go title="range_loops.go" linenum="1" hl_lines="8-25"
    package main

    import (
        "os"
        "text/template"
    )

    func main() {
        tmpl := `
Users:
{{range .}}
    - {{.Name}} ({{.Age}})
{{end}}
`
        
        type User struct {
            Name string
            Age  int
        }
        
        users := []User{
            {"Alice", 30},
            {"Bob", 25},
            {"Charlie", 35},
        }
        
        t := template.Must(template.New("users").Parse(tmpl))
        t.Execute(os.Stdout, users)
    }
    ```

### 3. `with` for Context

!!! example "With Context"
    ```go title="with_context.go" linenum="1" hl_lines="8-25"
    package main

    import (
        "os"
        "text/template"
    )

    func main() {
        tmpl := `
{{with .User}}
    Name: {{.Name}}
    Email: {{.Email}}
{{end}}
`
        
        data := struct {
            User *struct {
                Name  string
                Email string
            }
        }{
            User: &struct {
                Name  string
                Email string
            }{
                Name:  "David",
                Email: "david@example.com",
            },
        }
        
        t := template.Must(template.New("with").Parse(tmpl))
        t.Execute(os.Stdout, data)
    }
    ```

## Template Functions

### 1. Built-in Functions

!!! example "Built-in Functions"
    ```go title="built_in_functions.go" linenum="1" hl_lines="8-25"
    package main

    import (
        "os"
        "strings"
        "text/template"
    )

    func main() {
        tmpl := `
String: {{.Text | upper}}
Length: {{.Text | len}}
Word count: {{.Text | wordCount}}
HTML escaped: {{.HTML | html}}
URL escaped: {{.URL | urlquery}}
`
        
        funcMap := template.FuncMap{
            "upper":     strings.ToUpper,
            "wordCount": func(s string) int { return len(strings.Fields(s)) },
        }
        
        data := struct {
            Text string
            HTML string
            URL  string
        }{
            Text: "hello world",
            HTML: "<script>alert('xss')</script>",
            URL:  "search?q=go templates",
        }
        
        t := template.Must(template.New("funcs").Funcs(funcMap).Parse(tmpl))
        t.Execute(os.Stdout, data)
    }
    ```

### 2. Custom Functions

!!! example "Custom Functions"
    ```go title="custom_functions.go" linenum="1" hl_lines="8-30"
    package main

    import (
        "fmt"
        "os"
        "text/template"
        "time"
    )

    // Define custom functions
    func formatPrice(price float64) string {
        return fmt.Sprintf("$%.2f", price)
    }

    func formatDate(t time.Time) string {
        return t.Format("2006-01-02")
    }

    func main() {
        funcMap := template.FuncMap{
            "formatPrice": formatPrice,
            "formatDate":  formatDate,
        }
        
        tmpl := `
Product: {{.Name}}
Price: {{.Price | formatPrice}}
Created: {{.Created | formatDate}}
`
        
        data := struct {
            Name    string
            Price   float64
            Created time.Time
        }{
            Name:    "Laptop",
            Price:   999.99,
            Created: time.Now(),
        }
        
        t := template.Must(template.New("product").Funcs(funcMap).Parse(tmpl))
        t.Execute(os.Stdout, data)
    }
    ```

## Template Composition

### 1. Template Inheritance with `block` and `define`

!!! example "Template Inheritance"
    ```go title="template_inheritance.go" linenum="1" hl_lines="8-25"
    package main

    import (
        "os"
        "text/template"
    )

    func main() {
        // Parse base template
        base := `{{define "base"}}Base: {{block "content" .}}Default{{end}}{{end}}`
        t := template.Must(template.New("base").Parse(base))
        
        // Add child template
        child := `{{define "content"}}Child Content{{end}}`
        t = template.Must(t.Parse(child))
        
        // Execute base template
        t.ExecuteTemplate(os.Stdout, "base", nil)
        // Output: Base: Child Content
    }
    ```

### 2. Template Composition in Code

!!! example "Template Composition"
    ```go title="template_composition.go" linenum="1" hl_lines="8-25"
    package main

    import (
        "os"
        "text/template"
    )

    func main() {
        // Define multiple templates
        header := `{{define "header"}}<h1>{{.Title}}</h1>{{end}}`
        content := `{{define "content"}}<p>{{.Body}}</p>{{end}}`
        footer := `{{define "footer"}}<footer>{{.Copyright}}</footer>{{end}}`
        
        // Parse all templates
        t := template.Must(template.New("page").Parse(header))
        t = template.Must(t.Parse(content))
        t = template.Must(t.Parse(footer))
        
        // Execute with data
        data := struct {
            Title     string
            Body      string
            Copyright string
        }{
            Title:     "My Page",
            Body:      "This is the content.",
            Copyright: "2023",
        }
        
        // Execute specific template
        t.ExecuteTemplate(os.Stdout, "header", data)
        t.ExecuteTemplate(os.Stdout, "content", data)
        t.ExecuteTemplate(os.Stdout, "footer", data)
    }
    ```

## Error Handling

### 1. Common Template Errors

!!! example "Template Errors"
    ```go title="template_errors.go" linenum="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "os"
        "text/template"
    )

    func main() {
        // Missing field in template
        tmpl := `Hello, {{.NonExistentField}}!`
        t, err := template.New("error").Parse(tmpl)
        if err != nil {
            fmt.Println("Parse error:", err)
            return
        }
        
        // This will execute without error but output "Hello, <no value>!"
        err = t.Execute(os.Stdout, struct{}{})
        if err != nil {
            fmt.Println("Execute error:", err)
        }
    }
    ```

### 2. Safe Template Execution

!!! example "Safe Template Execution"
    ```go title="safe_template_execution.go" linenum="1" hl_lines="8-25"
    package main

    import (
        "fmt"
        "os"
        "text/template"
    )

    func safeExecute(tmplStr string, data interface{}) error {
        t, err := template.New("safe").Parse(tmplStr)
        if err != nil {
            return fmt.Errorf("template parse error: %w", err)
        }
        
        if err := t.Execute(os.Stdout, data); err != nil {
            return fmt.Errorf("template execute error: %w", err)
        }
        
        return nil
    }

    func main() {
        err := safeExecute("Hello, {{.Name}}!", map[string]string{"Name": "Eve"})
        if err != nil {
            fmt.Println("Error:", err)
        }
    }
    ```

## Real-World Example: HTML Report Generator

Let's build a comprehensive HTML report generator using templates:

!!! example "HTML Report Generator"
    ```go title="html_report_generator.go" linenum="1" hl_lines="8-80"
    package main

    import (
        "html/template"
        "os"
        "time"
    )

    // Data structures
    type Report struct {
        Title       string
        GeneratedAt time.Time
        Summary     Summary
        Sections    []Section
    }

    type Summary struct {
        TotalItems   int
        SuccessCount int
        ErrorCount   int
    }

    type Section struct {
        Title   string
        Items   []Item
    }

    type Item struct {
        ID          string
        Name        string
        Value       float64
        Status      string
        Description string
    }

    // Template definitions
    const baseTemplate = `<!DOCTYPE html>
<html>
<head>
    <title>{{.Title}} - Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { border-bottom: 2px solid #333; padding-bottom: 10px; }
        .summary { background: #f5f5f5; padding: 15px; margin: 20px 0; }
        .section { margin: 30px 0; }
        .section h2 { color: #333; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f2f2f2; }
        .success { color: green; }
        .error { color: red; }
        .footer { margin-top: 40px; font-size: 0.8em; color: #666; }
    </style>
</head>
<body>
    {{template "content" .}}
    <div class="footer">
        Generated on {{.GeneratedAt.Format "2006-01-02 15:04:05"}}
    </div>
</body>
</html>`

    const contentTemplate = `{{define "content"}}
<div class="header">
    <h1>{{.Title}}</h1>
</div>

<div class="summary">
    <h2>Summary</h2>
    <p>Total Items: {{.Summary.TotalItems}}</p>
    <p>Successful: <span class="success">{{.Summary.SuccessCount}}</span></p>
    <p>Errors: <span class="error">{{.Summary.ErrorCount}}</span></p>
</div>

{{range .Sections}}
<div class="section">
    <h2>{{.Title}}</h2>
    <table>
        <thead>
            <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Value</th>
                <th>Status</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            {{range .Items}}
            <tr>
                <td>{{.ID}}</td>
                <td>{{.Name}}</td>
                <td>${{formatCurrency .Value}}</td>
                <td class="{{if eq .Status "Success"}}success{{else}}error{{end}}">
                    {{.Status}}
                </td>
                <td>{{.Description}}</td>
            </tr>
            {{end}}
        </tbody>
    </table>
</div>
{{end}}
{{end}}`

    // Custom functions
    var funcMap = template.FuncMap{
        "formatCurrency": func(value float64) string {
            return fmt.Sprintf("%.2f", value)
        },
        "eq": func(a, b interface{}) bool {
            return a == b
        },
    }

    func main() {
        // Create template
        t := template.Must(template.New("base").Funcs(funcMap).Parse(baseTemplate))
        t = template.Must(t.Parse(contentTemplate))
        
        // Sample data
        report := Report{
            Title:       "Monthly Sales Report",
            GeneratedAt: time.Now(),
            Summary: Summary{
                TotalItems:   10,
                SuccessCount: 8,
                ErrorCount:   2,
            },
            Sections: []Section{
                {
                    Title: "Electronics",
                    Items: []Item{
                        {"E001", "Laptop", 999.99, "Success", "High-performance laptop"},
                        {"E002", "Mouse", 25.50, "Success", "Wireless mouse"},
                        {"E003", "Keyboard", 45.00, "Error", "Out of stock"},
                    },
                },
                {
                    Title: "Clothing",
                    Items: []Item{
                        {"C001", "T-Shirt", 19.99, "Success", "Cotton t-shirt"},
                        {"C002", "Jeans", 49.99, "Success", "Denim jeans"},
                        {"C003", "Jacket", 89.99, "Error", "Size not available"},
                    },
                },
            },
        }
        
        // Execute template
        file, err := os.Create("report.html")
        if err != nil {
            panic(err)
        }
        defer file.Close()
        
        err = t.Execute(file, report)
        if err != nil {
            panic(err)
        }
        
        println("Report generated successfully: report.html")
    }
    ```

### How This Example Works:

1. **Template Structure**:
   - Base template with HTML structure and CSS
   - Content template with report-specific markup
   - Template inheritance using `define` and `template`

2. **Data Organization**:
   - Structured data with nested types
   - Clear separation between different report sections
   - Consistent data model for all items

3. **Custom Functions**:
   - `formatCurrency` for monetary values
   - `eq` for equality comparison in templates

4. **Styling and Presentation**:
   - Embedded CSS for consistent styling
   - Conditional coloring based on status
   - Responsive table layout

## Best Practices

!!! tip "Template Organization"
    Keep templates separate from application logic and use a consistent naming convention.

!!! example "Template Organization"
    ```go title="template_organization.go" linenum="1" hl_lines="8-15"
    package main

    import "text/template"

    func main() {
        // Parse templates from files
        templates := template.Must(template.ParseFiles(
            "templates/base.html",
            "templates/header.html",
            "templates/footer.html",
        ))
        
        // Execute specific template
        templates.ExecuteTemplate(os.Stdout, "header", data)
    }
    ```

!!! warning "Security Considerations"
    Always use automatic escaping for HTML and validate data before template execution.

!!! example "Security Practices"
    ```go title="security_practices.go" linenum="1" hl_lines="8-15"
    package main

    import (
        "html/template"
        "os"
    )

    func main() {
        // Use html/template for automatic HTML escaping
        tmpl := `<div>{{.Content}}</div>`
        t := template.Must(template.New("safe").Parse(tmpl))
        
        data := struct {
            Content string
        }{
            Content: "<script>alert('xss')</script>",
        }
        
        t.Execute(os.Stdout, data) // Output: &lt;script&gt;alert('xss')&lt;/script&gt;
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Template Syntax**: Use `{{ }}` for actions, `{{.}}` for current data
    - **Control Structures**: `if`, `range`, `with` for conditional logic and loops
    - **Functions**: Built-in and custom functions extend template capabilities
    - **Composition**: Use `define` and `template` for reusable template blocks
    - **Data Structures**: Structs, maps, and slices work well with templates
    - **Security**: Use `html/template` for automatic HTML escaping
    - **Error Handling**: Check both parse and execute errors

!!! quote "Remember"
    "Go's text/template package provides a powerful way to separate presentation from logic. By mastering templates, you can create maintainable, reusable text generation systems for HTML, emails, configuration files, and more. Always prioritize security and organization when working with templates."