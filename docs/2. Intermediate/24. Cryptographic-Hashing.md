

# Cryptographic Hashing in Go: SHA-256/512 and the Crypto Package

## Introduction to Cryptographic Hashing
Cryptographic hash functions are fundamental building blocks of modern cryptography. They transform arbitrary input data into fixed-size output values (hashes) with specific security properties. Go's `crypto` package provides robust implementations of various cryptographic algorithms, including SHA-256 and SHA-512.

## Understanding Hash Functions

### Key Properties of Cryptographic Hash Functions
- **Deterministic**: Same input always produces same output
- **Pre-image resistant**: Given a hash, it's computationally infeasible to find the input
- **Second pre-image resistant**: Given an input, it's hard to find another input with same hash
- **Collision resistant**: Hard to find two different inputs with same hash
- **Avalanche effect**: Small change in input produces significant change in output

### Common Hash Algorithms
- **MD5**: 128-bit hash (broken, not recommended for security)
- **SHA-1**: 160-bit hash (deprecated for security)
- **SHA-256**: 256-bit hash (part of SHA-2 family)
- **SHA-512**: 512-bit hash (part of SHA-2 family)
- **SHA-3**: Latest standard (Keccak algorithm)

## SHA-256 Implementation in Go

### 1. Basic SHA-256 Hashing
```go
package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
)

func main() {
	// Simple string hashing
	data := "Hello, World!"
	hash := sha256.Sum256([]byte(data))
	
	// Convert to hexadecimal string
	hashString := hex.EncodeToString(hash[:])
	fmt.Printf("SHA-256 hash of %q: %s\n", data, hashString)
	// Output: SHA-256 hash of "Hello, World!": dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f
}
```

### 2. Hashing Files
```go
func hashFile(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer file.Close()
	
	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", err
	}
	
	return hex.EncodeToString(hasher.Sum(nil)), nil
}

func main() {
	// Create a sample file
	content := []byte("This is a test file for SHA-256 hashing.")
	err := os.WriteFile("test.txt", content, 0644)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	
	// Hash the file
	hash, err := hashFile("test.txt")
	if err != nil {
		fmt.Println("Error hashing file:", err)
		return
	}
	
	fmt.Printf("SHA-256 hash of file: %s\n", hash)
	
	// Clean up
	os.Remove("test.txt")
}
```

### 3. Incremental Hashing
```go
func incrementalHash() {
	hasher := sha256.New()
	
	// Write data in chunks
	hasher.Write([]byte("First part "))
	hasher.Write([]byte("second part "))
	hasher.Write([]byte("third part"))
	
	hash := hasher.Sum(nil)
	fmt.Printf("Incremental hash: %x\n", hash)
}

func main() {
	incrementalHash()
}
```

## SHA-512 Implementation in Go

### 1. Basic SHA-512 Hashing
```go
func main() {
	data := "Hello, World!"
	hash := sha512.Sum512([]byte(data))
	
	fmt.Printf("SHA-512 hash of %q:\n%x\n", data, hash)
}
```

### 2. SHA-512/224 and SHA-512/256 Variants
```go
func main() {
	data := "Hello, World!"
	
	// SHA-512/224 (truncated to 224 bits)
	hash224 := sha512.Sum512_224([]byte(data))
	fmt.Printf("SHA-512/224: %x\n", hash224)
	
	// SHA-512/256 (truncated to 256 bits)
	hash256 := sha512.Sum512_256([]byte(data))
	fmt.Printf("SHA-512/256: %x\n", hash256)
}
```

## The Crypto Package

### 1. Overview of Go's Crypto Package
Go's `crypto` package provides a collection of cryptographic algorithms:
- Hash functions (SHA-256, SHA-512, etc.)
- Message Authentication Codes (HMAC)
- Digital signatures
- Encryption and decryption
- Random number generation

### 2. Available Hash Functions
```go
func availableHashes() {
	data := "Hello, World!"
	
	// MD5 (not secure, for legacy compatibility)
	md5Hash := md5.Sum([]byte(data))
	fmt.Printf("MD5: %x\n", md5Hash)
	
	// SHA-1 (deprecated)
	sha1Hash := sha1.Sum([]byte(data))
	fmt.Printf("SHA-1: %x\n", sha1Hash)
	
	// SHA-224
	sha224Hash := sha256.Sum224([]byte(data))
	fmt.Printf("SHA-224: %x\n", sha224Hash)
	
	// SHA-256
	sha256Hash := sha256.Sum256([]byte(data))
	fmt.Printf("SHA-256: %x\n", sha256Hash)
	
	// SHA-384
	sha384Hash := sha512.Sum384([]byte(data))
	fmt.Printf("SHA-384: %x\n", sha384Hash)
	
	// SHA-512
	sha512Hash := sha512.Sum512([]byte(data))
	fmt.Printf("SHA-512: %x\n", sha512Hash)
}
```

## HMAC (Hash-based Message Authentication Code)

### 1. HMAC with SHA-256
```go
func computeHMAC(message, key []byte) []byte {
	mac := hmac.New(sha256.New, key)
	mac.Write(message)
	return mac.Sum(nil)
}

func main() {
	message := []byte("Important message")
	key := []byte("secret-key")
	
	// Compute HMAC
	hmac := computeHMAC(message, key)
	fmt.Printf("HMAC-SHA256: %x\n", hmac)
	
	// Verify HMAC (in real scenario, receiver would do this)
	receivedHMAC := computeHMAC(message, key)
	if hmac.Equal(receivedHMAC, hmac) {
		fmt.Println("HMAC verification: SUCCESS")
	} else {
		fmt.Println("HMAC verification: FAILED")
	}
}
```

## Password Hashing

### 1. Why Not Use Plain Hash Functions for Passwords?
Plain hash functions are fast, which makes them vulnerable to brute-force attacks. Passwords should be hashed with:
- **Slow hashing functions** (to slow down brute-force)
- **Salting** (to prevent rainbow table attacks)
- **Key stretching** (multiple iterations)

### 2. Using bcrypt for Password Hashing
```go
func hashPassword(password string) (string, error) {
	// Generate a salt (bcrypt handles this automatically)
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashedPassword), nil
}

func checkPassword(hashedPassword, password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
	return err == nil
}

func main() {
	password := "mySecretPassword123"
	
	// Hash the password
	hashed, err := hashPassword(password)
	if err != nil {
		fmt.Println("Error hashing password:", err)
		return
	}
	fmt.Printf("Hashed password: %s\n", hashed)
	
	// Check password
	match := checkPassword(hashed, password)
	fmt.Printf("Password check: %v\n", match)
	
	// Check wrong password
	match = checkPassword(hashed, "wrongPassword")
	fmt.Printf("Wrong password check: %v\n", match)
}
```

### 3. Using scrypt for Password Hashing
```go
func hashPasswordScrypt(password string) (string, error) {
	// Generate a random salt
	salt := make([]byte, 16)
	if _, err := rand.Read(salt); err != nil {
		return "", err
	}
	
	// Hash the password with scrypt
	hash, err := scrypt.Key([]byte(password), salt, 32768, 8, 1, 32)
	if err != nil {
		return "", err
	}
	
	// Prepend salt to hash for storage
	storedHash := append(salt, hash...)
	return base64.StdEncoding.EncodeToString(storedHash), nil
}

func checkPasswordScrypt(hashedPassword, password string) (bool, error) {
	// Decode the stored hash
	storedHash, err := base64.StdEncoding.DecodeString(hashedPassword)
	if err != nil {
		return false, err
	}
	
	// Extract salt and hash
	salt := storedHash[:16]
	expectedHash := storedHash[16:]
	
	// Hash the provided password with the same salt
	hash, err := scrypt.Key([]byte(password), salt, 32768, 8, 1, 32)
	if err != nil {
		return false, err
	}
	
	// Compare hashes
	return subtle.ConstantTimeCompare(expectedHash, hash), nil
}

func main() {
	password := "mySecretPassword123"
	
	// Hash the password
	hashed, err := hashPasswordScrypt(password)
	if err != nil {
		fmt.Println("Error hashing password:", err)
		return
	}
	fmt.Printf("Hashed password: %s\n", hashed)
	
	// Check password
	match, err := checkPasswordScrypt(hashed, password)
	if err != nil {
		fmt.Println("Error checking password:", err)
		return
	}
	fmt.Printf("Password check: %v\n", match)
}
```

## Real-World Example: File Integrity Checker

Let's build a comprehensive file integrity checker that uses SHA-256 to detect file changes:

```go
package main

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"
)

// FileHash represents a file and its hash
type FileHash struct {
	Path     string    `json:"path"`
	Hash     string    `json:"hash"`
	Modified time.Time `json:"modified"`
	Size     int64     `json:"size"`
}

// IntegrityDatabase stores file hashes for integrity checking
type IntegrityDatabase struct {
	Files map[string]FileHash `json:"files"`
}

// NewIntegrityDatabase creates a new integrity database
func NewIntegrityDatabase() *IntegrityDatabase {
	return &IntegrityDatabase{
		Files: make(map[string]FileHash),
	}
}

// AddFile adds a file to the database
func (db *IntegrityDatabase) AddFile(path string) error {
	// Get file info
	info, err := os.Stat(path)
	if err != nil {
		return fmt.Errorf("failed to stat file: %w", err)
	}
	
	// Calculate hash
	hash, err := calculateFileHash(path)
	if err != nil {
		return fmt.Errorf("failed to calculate hash: %w", err)
	}
	
	// Add to database
	db.Files[path] = FileHash{
		Path:     path,
		Hash:     hash,
		Modified: info.ModTime(),
		Size:     info.Size(),
	}
	
	return nil
}

// AddDirectory adds all files in a directory to the database
func (db *IntegrityDatabase) AddDirectory(dirPath string) error {
	return filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		
		// Skip directories
		if info.IsDir() {
			return nil
		}
		
		// Add file to database
		if err := db.AddFile(path); err != nil {
			fmt.Printf("Error adding file %s: %v\n", path, err)
		}
		
		return nil
	})
}

// CheckIntegrity checks if files have been modified
func (db *IntegrityDatabase) CheckIntegrity() ([]string, error) {
	var modifiedFiles []string
	
	for path, storedHash := range db.Files {
		// Check if file still exists
		if _, err := os.Stat(path); os.IsNotExist(err) {
			modifiedFiles = append(modifiedFiles, fmt.Sprintf("DELETED: %s", path))
			continue
		}
		
		// Get current file info
		info, err := os.Stat(path)
		if err != nil {
			modifiedFiles = append(modifiedFiles, fmt.Sprintf("ERROR: %s - %v", path, err))
			continue
		}
		
		// Check modification time
		if info.ModTime() != storedHash.Modified {
			modifiedFiles = append(modifiedFiles, fmt.Sprintf("MODIFIED: %s (timestamp changed)", path))
			continue
		}
		
		// Check size
		if info.Size() != storedHash.Size {
			modifiedFiles = append(modifiedFiles, fmt.Sprintf("MODIFIED: %s (size changed)", path))
			continue
		}
		
		// Check hash
		currentHash, err := calculateFileHash(path)
		if err != nil {
			modifiedFiles = append(modifiedFiles, fmt.Sprintf("ERROR: %s - %v", path, err))
			continue
		}
		
		if currentHash != storedHash.Hash {
			modifiedFiles = append(modifiedFiles, fmt.Sprintf("MODIFIED: %s (content changed)", path))
		}
	}
	
	return modifiedFiles, nil
}

// Save saves the database to a file
func (db *IntegrityDatabase) Save(filename string) error {
	data, err := json.MarshalIndent(db, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal database: %w", err)
	}
	
	return os.WriteFile(filename, data, 0644)
}

// Load loads the database from a file
func (db *IntegrityDatabase) Load(filename string) error {
	data, err := os.ReadFile(filename)
	if err != nil {
		return fmt.Errorf("failed to read database file: %w", err)
	}
	
	return json.Unmarshal(data, db)
}

// calculateFileHash calculates the SHA-256 hash of a file
func calculateFileHash(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer file.Close()
	
	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", err
	}
	
	return hex.EncodeToString(hasher.Sum(nil)), nil
}

func main() {
	// Create a sample directory structure
	baseDir := "test_files"
	subDir := filepath.Join(baseDir, "subdir")
	
	// Create directories
	os.MkdirAll(subDir, 0755)
	defer os.RemoveAll(baseDir) // Clean up
	
	// Create sample files
	files := map[string]string{
		filepath.Join(baseDir, "file1.txt"):          "This is file 1",
		filepath.Join(baseDir, "file2.txt"):          "This is file 2",
		filepath.Join(subDir, "subfile1.txt"):       "This is subfile 1",
		filepath.Join(subDir, "subfile2.txt"):       "This is subfile 2",
	}
	
	for path, content := range files {
		err := os.WriteFile(path, []byte(content), 0644)
		if err != nil {
			fmt.Printf("Error creating file %s: %v\n", path, err)
			continue
		}
	}
	
	// Create integrity database
	db := NewIntegrityDatabase()
	
	// Add all files to database
	fmt.Println("Adding files to integrity database...")
	err := db.AddDirectory(baseDir)
	if err != nil {
		fmt.Printf("Error adding directory: %v\n", err)
		return
	}
	
	// Save database
	dbFile := "integrity_db.json"
	err = db.Save(dbFile)
	if err != nil {
		fmt.Printf("Error saving database: %v\n", err)
		return
	}
	fmt.Printf("Database saved to %s\n", dbFile)
	
	// Check integrity (should be clean)
	fmt.Println("\nChecking integrity (should be clean)...")
	modified, err := db.CheckIntegrity()
	if err != nil {
		fmt.Printf("Error checking integrity: %v\n", err)
		return
	}
	
	if len(modified) == 0 {
		fmt.Println("All files are intact!")
	} else {
		fmt.Println("Modified files:")
		for _, msg := range modified {
			fmt.Println("  -", msg)
		}
	}
	
	// Modify a file
	fmt.Println("\nModifying a file...")
	modifiedFile := filepath.Join(baseDir, "file1.txt")
	err = os.WriteFile(modifiedFile, []byte("This file has been modified!"), 0644)
	if err != nil {
		fmt.Printf("Error modifying file: %v\n", err)
		return
	}
	
	// Check integrity again
	fmt.Println("\nChecking integrity (should detect modification)...")
	modified, err = db.CheckIntegrity()
	if err != nil {
		fmt.Printf("Error checking integrity: %v\n", err)
		return
	}
	
	fmt.Println("Modified files:")
	for _, msg := range modified {
		fmt.Println("  -", msg)
	}
	
	// Delete a file
	fmt.Println("\nDeleting a file...")
	deletedFile := filepath.Join(subDir, "subfile1.txt")
	err = os.Remove(deletedFile)
	if err != nil {
		fmt.Printf("Error deleting file: %v\n", err)
		return
	}
	
	// Check integrity again
	fmt.Println("\nChecking integrity (should detect deletion)...")
	modified, err = db.CheckIntegrity()
	if err != nil {
		fmt.Printf("Error checking integrity: %v\n", err)
		return
	}
	
	fmt.Println("Modified files:")
	for _, msg := range modified {
		fmt.Println("  -", msg)
	}
	
	// Clean up
	os.Remove(dbFile)
}
```

### How This Example Works:

1. **File Integrity Database**:
   - Stores SHA-256 hashes of files along with metadata
   - Tracks file paths, modification times, and sizes
   - Saves and loads database from JSON

2. **Directory Scanning**:
   - Recursively scans directories to add all files
   - Calculates SHA-256 hashes for each file
   - Stores file metadata for comparison

3. **Integrity Checking**:
   - Compares current file state with stored hashes
   - Detects modifications, deletions, and other changes
   - Provides detailed reports of all changes

4. **Security Features**:
   - Uses SHA-256 for cryptographic integrity
   - Checks multiple attributes (hash, size, timestamp)
   - Provides comprehensive change detection

### Real-World Applications:

1. **Security Auditing**:
   - Detect unauthorized file changes
   - Monitor system files for tampering
   - Verify software integrity

2. **Backup Verification**:
   - Ensure backup files haven't been corrupted
   - Verify restore operations
   - Detect bit rot in storage systems

3. **Compliance Monitoring**:
   - Track changes to regulated files
   - Maintain audit trails
   - Demonstrate data integrity

## Best Practices

### 1. Choose the Right Hash Algorithm
```go
// For general purpose integrity checking
hash := sha256.Sum256(data)

// For higher security requirements
hash := sha512.Sum512(data)

// For legacy systems (not recommended for new applications)
hash := sha1.Sum(data) // Deprecated
```

### 2. Use Constant-Time Comparison for Security
```go
// Good: Use constant-time comparison
if subtle.ConstantTimeCompare(expectedHash, actualHash) == 1 {
    // Hashes match
}

// Bad: Regular comparison vulnerable to timing attacks
if expectedHash == actualHash {
    // Hashes match
}
```

### 3. Handle Passwords Properly
```go
// Good: Use bcrypt or scrypt for passwords
hashedPassword, err := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)

// Bad: Use plain hash functions for passwords
hash := sha256.Sum256(password) // Vulnerable to brute-force
```

### 4. Use Salt for Password Hashing
```go
// Good: bcrypt handles salting automatically
hashedPassword, _ := bcrypt.GenerateFromPassword(password, 12)

// Bad: Hash without salt
hash := sha256.Sum256([]byte("password" + "static_salt")) // Vulnerable
```

## Security Considerations

### 1. Hash Function Security
- **MD5 and SHA-1**: Broken, not suitable for security
- **SHA-256**: Currently secure for most applications
- **SHA-512**: More secure, uses more resources
- **SHA-3**: Latest standard, alternative to SHA-2

### 2. Password Hashing Security
- **Never use plain hash functions** for passwords
- **Use specialized algorithms** like bcrypt, scrypt, or Argon2
- **Use appropriate work factors** to slow down brute-force attacks
- **Always use unique salts** for each password

### 3. Integrity Verification Security
- **Store hashes securely** (separate from data)
- **Use HMAC** when hash needs to be verified by untrusted parties
- **Consider digital signatures** for non-repudiation

## Performance Considerations

### 1. Hash Function Performance
```go
// SHA-256 is generally faster than SHA-512
// Benchmark for your specific use case
func benchmarkHashes(data []byte) {
	start := time.Now()
	sha256.Sum256(data)
	sha256Duration := time.Since(start)
	
	start = time.Now()
	sha512.Sum512(data)
	sha512Duration := time.Since(start)
	
	fmt.Printf("SHA-256: %v\n", sha256Duration)
	fmt.Printf("SHA-512: %v\n", sha512Duration)
}
```

### 2. Memory Usage for Large Files
```go
// Good: Stream hashing for large files
func hashLargeFile(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer file.Close()
	
	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", err
	}
	
	return hex.EncodeToString(hasher.Sum(nil)), nil
}

// Bad: Load entire file into memory
func hashLargeFileBad(filename string) (string, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return "", err
	}
	hash := sha256.Sum256(data)
	return hex.EncodeToString(hash[:]), nil
}
```

## Conclusion

Cryptographic hashing is a fundamental security primitive in Go. The `crypto` package provides robust implementations of:

1. **Hash Functions**:
   - SHA-256 and SHA-512 for integrity checking
   - Various output sizes (224, 256, 384, 512 bits)
   - Streaming support for large data

2. **Message Authentication**:
   - HMAC for verifying message integrity and authenticity
   - Support for different hash algorithms

3. **Password Hashing**:
   - bcrypt for secure password storage
   - scrypt for memory-hard password hashing
   - Protection against brute-force attacks

4. **Security Applications**:
   - File integrity verification
   - Digital signatures
   - Data deduplication
   - Blockchain and cryptocurrency

The file integrity checker example demonstrates how to build a practical security application using SHA-256 hashing. By following best practices and understanding security considerations, you can effectively use cryptographic hashing in your Go applications to protect data integrity and enhance security.

Key takeaways:
1. **Use SHA-256 or SHA-512** for integrity checking (avoid MD5/SHA-1)
2. **Use specialized algorithms** (bcrypt, scrypt) for password hashing
3. **Implement constant-time comparison** for security-sensitive operations
4. **Use streaming** for large files to avoid memory issues
5. **Store hashes securely** separate from the data they protect

Cryptographic hashing is a powerful tool for ensuring data integrity and security, but it must be used correctly to be effective. Go's crypto package provides all the tools you need to implement secure hashing in your applications.