

# Regular Expressions in Go: A Comprehensive Guide

## Introduction to Regular Expressions
Regular expressions (regex) are sequences of characters that define search patterns. Go's `regexp` package provides powerful regex capabilities based on the RE2 library, offering fast, safe, and efficient pattern matching. Regular expressions are essential for text processing, validation, parsing, and data extraction.

## Basic Pattern Matching

### 1. Simple Pattern Matching
```go
package main

import (
	"fmt"
	"regexp"
)

func main() {
	// Check if a string contains a pattern
	matched, err := regexp.MatchString("Go", "I love Go programming")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("Contains 'Go':", matched) // true

	// Case-insensitive matching
	matched, _ = regexp.MatchString(`(?i)go`, "I LOVE GO")
	fmt.Println("Contains 'go' (case-insensitive):", matched) // true
}
```

### 2. Character Classes and Quantifiers
```go
func main() {
	// Character classes
	patterns := []string{
		`[aeiou]`,    // Any vowel
		`[A-Z]`,      // Any uppercase letter
		`[0-9]`,      // Any digit
		`[^0-9]`,     // Any non-digit
		`\d`,         // Digit (same as [0-9])
		`\w`,         // Word character (alphanumeric + underscore)
		`\s`,         // Whitespace character
	}

	testStr := "Hello World 123!"
	for _, pattern := range patterns {
		matched, _ := regexp.MatchString(pattern, testStr)
		fmt.Printf("Pattern %q matches: %v\n", pattern, matched)
	}
}
```

## Compiling Regular Expressions

### 1. Pre-compiling Patterns
For better performance, especially when using the same pattern multiple times:

```go
func main() {
	// Compile a regex pattern
	re, err := regexp.Compile(`\d+`) // One or more digits
	if err != nil {
		fmt.Println("Compilation error:", err)
		return
	}

	// Use the compiled regex
	fmt.Println("Matches digits:", re.MatchString("abc123def")) // true
	fmt.Println("Matches digits:", re.MatchString("abcdef"))    // false
}
```

### 2. Using MustCompile for Known Patterns
When you're sure the pattern is valid (e.g., hardcoded patterns):

```go
func main() {
	// MustCompile panics on invalid patterns
	re := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	
	emails := []string{
		"user@example.com",
		"invalid-email",
		"another.user@domain.co.uk",
	}
	
	for _, email := range emails {
		if re.MatchString(email) {
			fmt.Printf("Valid email: %s\n", email)
		} else {
			fmt.Printf("Invalid email: %s\n", email)
		}
	}
}
```

## Finding Matches

### 1. Finding All Matches
```go
func main() {
	re := regexp.MustCompile(`\b\d+\b`) // Whole numbers only
	text := "I have 2 apples and 15 oranges"
	
	// Find all matches
	matches := re.FindAllString(text, -1) // -1 for all matches
	fmt.Println("All numbers:", matches) // [2 15]
	
	// Find first match only
	firstMatch := re.FindString(text)
	fmt.Println("First number:", firstMatch) // 2
}
```

### 2. Finding Match Positions
```go
func main() {
	re := regexp.MustCompile(`Go`)
	text := "Go is great. Go is efficient."
	
	// Find all matches with positions
	matches := re.FindAllStringIndex(text, -1)
	for _, match := range matches {
		fmt.Printf("Found 'Go' at positions %d-%d\n", match[0], match[1])
	}
	// Output:
	// Found 'Go' at positions 0-2
	// Found 'Go' at positions 13-15
}
```

### 3. Finding Submatches (Groups)
```go
func main() {
	// Extract date components
	re := regexp.MustCompile(`(\d{4})-(\d{2})-(\d{2})`)
	text := "Date: 2023-11-15"
	
	// Find submatches
	matches := re.FindStringSubmatch(text)
	if len(matches) > 0 {
		fmt.Println("Full match:", matches[0]) // 2023-11-15
		fmt.Println("Year:", matches[1])       // 2023
		fmt.Println("Month:", matches[2])      // 11
		fmt.Println("Day:", matches[3])        // 15
	}
}
```

## Replacing Text

### 1. Simple Replacement
```go
func main() {
	re := regexp.MustCompile(`apple`)
	text := "I have an apple and another apple"
	
	// Replace all occurrences
	result := re.ReplaceAllString(text, "orange")
	fmt.Println(result) // I have an orange and another orange
}
```

### 2. Using Functions for Replacement
```go
func main() {
	re := regexp.MustCompile(`\b(\w+)\b`)
	text := "hello world"
	
	// Convert to uppercase using a function
	result := re.ReplaceAllStringFunc(text, strings.ToUpper)
	fmt.Println(result) // HELLO WORLD
}
```

### 3. Using Match Groups in Replacement
```go
func main() {
	// Swap first and last name
	re := regexp.MustCompile(`(\w+)\s+(\w+)`)
	text := "John Doe"
	
	// Use $1, $2 for groups
	result := re.ReplaceAllString(text, "$2, $1")
	fmt.Println(result) // Doe, John
}
```

## Splitting Strings

### 1. Splitting by Pattern
```go
func main() {
	re := regexp.MustCompile(`\s*,\s*`) // Split by comma with optional whitespace
	text := "apple, banana, cherry,  date"
	
	// Split the string
	parts := re.Split(text, -1)
	fmt.Println(parts) // [apple banana cherry date]
}
```

### 2. Limiting Splits
```go
func main() {
	re := regexp.MustCompile(`\s+`)
	text := "Split   this   string"
	
	// Split into at most 3 parts
	parts := re.Split(text, 3)
	fmt.Println(parts) // [Split this string]
}
```

## Advanced Patterns

### 1. Lookarounds
```go
func main() {
	// Positive lookahead: password must contain digit
	re := regexp.MustCompile(`^(?=.*\d).+$`)
	fmt.Println("Pass123:", re.MatchString("Pass123")) // true
	fmt.Println("Password:", re.MatchString("Password")) // false
	
	// Negative lookahead: password must not contain 'admin'
	re = regexp.MustCompile(`^(?!.*admin).+$`)
	fmt.Println("user123:", re.MatchString("user123")) // true
	fmt.Println("admin123:", re.MatchString("admin123")) // false
}
```

### 2. Non-capturing Groups
```go
func main() {
	// Using (?:...) for non-capturing groups
	re := regexp.MustCompile(`(?:https?|ftp)://([^/]+)`)
	url := "https://example.com/path"
	
	matches := re.FindStringSubmatch(url)
	if len(matches) > 1 {
		fmt.Println("Domain:", matches[1]) // example.com
	}
}
```

### 3. Greedy vs. Lazy Matching
```go
func main() {
	text := "<div>First</div><div>Second</div>"
	
	// Greedy match (default)
	re := regexp.MustCompile(`<div>.*</div>`)
	fmt.Println("Greedy:", re.FindString(text)) // <div>First</div><div>Second</div>
	
	// Lazy match (non-greedy)
	re = regexp.MustCompile(`<div>.*?</div>`)
	fmt.Println("Lazy:", re.FindString(text)) // <div>First</div>
}
```

## Common Patterns and Examples

### 1. Email Validation
```go
func validateEmail(email string) bool {
	re := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	return re.MatchString(email)
}

func main() {
	emails := []string{
		"user@example.com",
		"user.name@domain.co.uk",
		"invalid-email",
		"@domain.com",
	}
	
	for _, email := range emails {
		fmt.Printf("%s: %v\n", email, validateEmail(email))
	}
}
```

### 2. URL Extraction
```go
func extractURLs(text string) []string {
	// Simplified URL pattern
	re := regexp.MustCompile(`https?://[^\s]+`)
	return re.FindAllString(text, -1)
}

func main() {
	text := `Visit https://example.com or http://test.org for more info.`
	urls := extractURLs(text)
	fmt.Println("URLs found:", urls)
}
```

### 3. Phone Number Formatting
```go
func formatPhoneNumber(phone string) string {
	// Remove all non-digits
	re := regexp.MustCompile(`[^\d]`)
	digits := re.ReplaceAllString(phone, "")
	
	// Format as (XXX) XXX-XXXX
	if len(digits) == 10 {
		return fmt.Sprintf("(%s) %s-%s", digits[0:3], digits[3:6], digits[6:])
	}
	return phone
}

func main() {
	phones := []string{
		"1234567890",
		"(123) 456-7890",
		"123-456-7890",
	}
	
	for _, phone := range phones {
		fmt.Printf("%s -> %s\n", phone, formatPhoneNumber(phone))
	}
}
```

## Real-World Example: Log Parser

Let's build a comprehensive log parser that extracts structured information from log entries:

```go
package main

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// LogEntry represents a parsed log entry
type LogEntry struct {
	Timestamp time.Time
	Level     string
	Message   string
	IP        string
	UserID    string
	Status    int
}

// LogParser handles log parsing with regex
type LogParser struct {
	// Patterns for different log formats
	patterns map[string]*regexp.Regexp
}

func NewLogParser() *LogParser {
	return &LogParser{
		patterns: map[string]*regexp.Regexp{
			"apache": regexp.MustCompile(`^(\S+) \S+ \S+ \[([\w:/]+\s[+\-]\d{4})\] "(\S+) (\S+) (\S+)" (\d{3}) (\d+|-)`),
			"nginx":  regexp.MustCompile(`^(\S+) - - \[([\w:/]+\s[+\-]\d{4})\] "(\S+) (\S+) (\S+)" (\d{3}) (\d+|-) "([^"]*)" "([^"]*)"`),
			"custom": regexp.MustCompile(`^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[(\w+)\] (.+?) (?:user:(\S+))? (?:ip:(\S+))? (?:status:(\d+))?$`),
		},
	}
}

func (lp *LogParser) ParseLog(line string, format string) (*LogEntry, error) {
	re, exists := lp.patterns[format]
	if !exists {
		return nil, fmt.Errorf("unknown log format: %s", format)
	}

	matches := re.FindStringSubmatch(line)
	if matches == nil {
		return nil, fmt.Errorf("line doesn't match format: %s", line)
	}

	entry := &LogEntry{}

	switch format {
	case "apache":
		// Apache log format: IP - - [timestamp] "method path protocol" status size
		entry.IP = matches[1]
		entry.Timestamp = parseApacheTime(matches[2])
		entry.Message = fmt.Sprintf("%s %s %s", matches[3], matches[4], matches[5])
		entry.Status = parseInt(matches[6])
		entry.Level = getLogLevel(entry.Status)

	case "nginx":
		// Nginx log format (extended)
		entry.IP = matches[1]
		entry.Timestamp = parseApacheTime(matches[2])
		entry.Message = fmt.Sprintf("%s %s %s", matches[3], matches[4], matches[5])
		entry.Status = parseInt(matches[6])
		entry.Level = getLogLevel(entry.Status)

	case "custom":
		// Custom format: timestamp [level] message user:user_id ip:ip status:status
		entry.Timestamp = parseCustomTime(matches[1])
		entry.Level = matches[2]
		entry.Message = matches[3]
		entry.UserID = matches[4]
		entry.IP = matches[5]
		if matches[6] != "" {
			entry.Status = parseInt(matches[6])
		}
	}

	return entry, nil
}

// Helper functions
func parseApacheTime(ts string) time.Time {
	// Parse Apache timestamp format: 10/Oct/2000:13:55:36 -0700
	layout := "02/Jan/2006:15:04:05 -0700"
	t, _ := time.Parse(layout, ts)
	return t
}

func parseCustomTime(ts string) time.Time {
	// Parse custom timestamp format: 2023-11-15 14:30:45
	layout := "2006-01-02 15:04:05"
	t, _ := time.Parse(layout, ts)
	return t
}

func parseInt(s string) int {
	i, _ := strconv.Atoi(s)
	return i
}

func getLogLevel(status int) string {
	if status >= 500 {
		return "ERROR"
	} else if status >= 400 {
		return "WARN"
	} else if status >= 300 {
		return "INFO"
	}
	return "DEBUG"
}

func main() {
	parser := NewLogParser()

	// Sample log lines
	logLines := []struct {
		line   string
		format string
	}{
		{
			`127.0.0.1 - - [10/Oct/2023:13:55:36 -0700] "GET /index.html HTTP/1.1" 200 2326`,
			"apache",
		},
		{
			`192.168.1.1 - - [10/Oct/2023:13:56:01 -0700] "POST /api/users HTTP/1.1" 404 1234`,
			"apache",
		},
		{
			`2023-11-15 14:30:45 [INFO] User login successful user:123 ip:192.168.1.100 status:200`,
			"custom",
		},
		{
			`2023-11-15 14:31:02 [ERROR] Database connection failed status:500`,
			"custom",
		},
	}

	for _, logData := range logLines {
		entry, err := parser.ParseLog(logData.line, logData.format)
		if err != nil {
			fmt.Printf("Error parsing log: %v\n", err)
			continue
		}

		fmt.Printf("Parsed Entry:\n")
		fmt.Printf("  Timestamp: %s\n", entry.Timestamp.Format("2006-01-02 15:04:05"))
		fmt.Printf("  Level: %s\n", entry.Level)
		fmt.Printf("  Message: %s\n", entry.Message)
		if entry.IP != "" {
			fmt.Printf("  IP: %s\n", entry.IP)
		}
		if entry.UserID != "" {
			fmt.Printf("  User ID: %s\n", entry.UserID)
		}
		if entry.Status != 0 {
			fmt.Printf("  Status: %d\n", entry.Status)
		}
		fmt.Println()
	}
}
```

### How This Example Works:

1. **Multiple Log Formats**:
   - Supports Apache, Nginx, and custom log formats
   - Each format has its own regex pattern
   - Flexible parsing based on format type

2. **Structured Data Extraction**:
   - Extracts timestamps, IP addresses, user IDs
   - Parses HTTP status codes
   - Determines log levels based on status

3. **Helper Functions**:
   - Time parsing for different formats
   - Integer conversion for status codes
   - Log level determination

4. **Error Handling**:
   - Graceful handling of parsing errors
   - Clear error messages for debugging

### Real-World Applications:

1. **Log Analysis**:
   - Parse application logs
   - Extract metrics and statistics
   - Identify error patterns

2. **Security Monitoring**:
   - Detect suspicious IP addresses
   - Identify failed login attempts
   - Monitor for unusual activity

3. **Data Processing**:
   - Extract structured data from text
   - Transform unstructured logs to JSON
   - Feed data into analytics systems

## Performance Considerations

### 1. Pre-compile Patterns
```go
// Good: Pre-compile for reuse
var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)

func validateEmail(email string) bool {
	return emailRegex.MatchString(email)
}

// Bad: Compile on every call
func validateEmailBad(email string) bool {
	re, _ := regexp.Compile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	return re.MatchString(email)
}
```

### 2. Use Specific Patterns
```go
// Good: Specific pattern
re := regexp.MustCompile(`^user_\d+$`)

// Bad: Too general pattern
re = regexp.MustCompile(`user.*`)
```

### 3. Avoid Catastrophic Backtracking
```go
// Dangerous: Nested quantifiers can cause exponential backtracking
re := regexp.MustCompile(`(a+)+`)

// Better: More specific pattern
re = regexp.MustCompile(`a+`)
```

## Best Practices

### 1. Write Readable Patterns
```go
// Use comments and raw strings for complex patterns
pattern := `^
	(\d{4})-  # Year
	(\d{2})-  # Month
	(\d{2})   # Day
$`
re := regexp.MustCompile(pattern)
```

### 2. Test Your Patterns
```go
func TestEmailRegex(t *testing.T) {
	tests := []struct {
		email string
		valid bool
	}{
		{"user@example.com", true},
		{"invalid-email", false},
		{"@domain.com", false},
	}
	
	for _, test := range tests {
		result := validateEmail(test.email)
		if result != test.valid {
			t.Errorf("Email %s: expected %v, got %v", test.email, test.valid, result)
		}
	}
}
```

### 3. Handle Errors Gracefully
```go
func safeFindString(re *regexp.Regexp, str string) string {
	match := re.FindString(str)
	if match == "" {
		return "default"
	}
	return match
}
```

## Conclusion

Regular expressions are a powerful tool for text processing in Go. The `regexp` package provides efficient and safe regex operations based on RE2. By mastering regular expressions, you can:

1. **Extract and Validate Data**:
   - Parse structured text like logs, emails, URLs
   - Validate user input
   - Extract specific information from documents

2. **Transform Text**:
   - Replace patterns dynamically
   - Reformat strings
   - Clean and normalize data

3. **Build Powerful Text Processing Tools**:
   - Log analyzers
   - Data scrapers
   - Input validators

The log parser example demonstrates how regex can be used to build sophisticated text processing systems that handle multiple formats and extract structured information efficiently.

Key takeaways:
1. **Pre-compile regex patterns** for better performance
2. **Use specific patterns** to avoid false matches
3. **Test your patterns thoroughly** with various inputs
4. **Handle errors gracefully** when patterns don't match
5. **Be mindful of performance** with complex patterns

Regular expressions are an essential skill for any Go developer working with text processing, data validation, or parsing tasks. With practice, you'll be able to write efficient and reliable regex patterns for any text processing need.