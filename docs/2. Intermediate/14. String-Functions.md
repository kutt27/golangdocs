# String Functions in Go: A Comprehensive Guide

## Introduction to String Functions in Go
Go's `strings` package provides a rich set of functions for string manipulation. These functions are essential for text processing, input validation, data transformation, and many other common programming tasks. Understanding these functions is crucial for effective Go development.

## Basic String Manipulation

### 1. Searching Within Strings
```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "Hello, World! Welcome to Go programming."
	
	// Contains - checks if substring exists
	fmt.Println(strings.Contains(s, "World"))    // true
	fmt.Println(strings.Contains(s, "Python"))  // false
	
	// ContainsAny - checks if any character in the set exists
	fmt.Println(strings.ContainsAny(s, "abc"))   // true (because of 'a' in "Welcome")
	fmt.Println(strings.ContainsAny(s, "xyz"))   // false
	
	// HasPrefix - checks if string starts with prefix
	fmt.Println(strings.HasPrefix(s, "Hello"))   // true
	fmt.Println(strings.HasPrefix(s, "World"))   // false
	
	// HasSuffix - checks if string ends with suffix
	fmt.Println(strings.HasSuffix(s, "programming.")) // true
	fmt.Println(strings.HasSuffix(s, "Go"))       // false
	
	// Index - returns first index of substring
	fmt.Println(strings.Index(s, "World"))       // 7
	fmt.Println(strings.Index(s, "Python"))      // -1 (not found)
	
	// LastIndex - returns last index of substring
	fmt.Println(strings.LastIndex(s, "o"))      // 29 (in "programming")
	
	// IndexAny - returns index of any character in the set
	fmt.Println(strings.IndexAny(s, "aeiou"))   // 1 (first 'e')
}
```

### 2. Replacing Content
```go
func main() {
	s := "I like apples, apples are tasty."
	
	// Replace - replaces n occurrences
	fmt.Println(strings.Replace(s, "apples", "oranges", 1)) // "I like oranges, apples are tasty."
	fmt.Println(strings.Replace(s, "apples", "oranges", 2)) // "I like oranges, oranges are tasty."
	fmt.Println(strings.Replace(s, "apples", "oranges", -1)) // Replace all
	
	// ReplaceAll - replaces all occurrences (Go 1.12+)
	fmt.Println(strings.ReplaceAll(s, "apples", "oranges")) // "I like oranges, oranges are tasty."
	
	// Map - applies a function to each character
	rot13 := func(r rune) rune {
		switch {
		case r >= 'A' && r <= 'Z':
			return 'A' + (r-'A'+13)%26
		case r >= 'a' && r <= 'z':
			return 'a' + (r-'a'+13)%26
		default:
			return r
		}
	}
	fmt.Println(strings.Map(rot13, "Hello, World!")) // "Uryyb, Jbeyq!"
}
```

### 3. Splitting and Joining
```go
func main() {
	// Split - splits string by separator
	s := "a,b,c,d"
	parts := strings.Split(s, ",")
	fmt.Println(parts) // [a b c d]
	
	// SplitN - splits into at most n parts
	parts = strings.SplitN(s, ",", 3)
	fmt.Println(parts) // [a b c,d]
	
	// SplitAfter - includes separator in parts
	parts = strings.SplitAfter(s, ",")
	fmt.Println(parts) // [a, b, c, d]
	
	// Fields - splits by whitespace
	s2 := "  Go   is  awesome  "
	fields := strings.Fields(s2)
	fmt.Println(fields) // [Go is awesome]
	
	// FieldsFunc - splits using custom function
	// Split on any non-alphanumeric character
	fieldsFunc := strings.FieldsFunc(s2, func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsNumber(r)
	})
	fmt.Println(fieldsFunc) // [Go is awesome]
	
	// Join - concatenates slice with separator
	joined := strings.Join([]string{"Go", "is", "awesome"}, " ")
	fmt.Println(joined) // "Go is awesome"
}
```

## Case Conversion

### 1. Changing Case
```go
func main() {
	s := "Hello, World! 123"
	
	// ToLower - converts to lowercase
	fmt.Println(strings.ToLower(s)) // "hello, world! 123"
	
	// ToUpper - converts to uppercase
	fmt.Println(strings.ToUpper(s)) // "HELLO, WORLD! 123"
	
	// ToTitle - converts to title case (each word starts with uppercase)
	fmt.Println(strings.ToTitle("hello world")) // "HELLO WORLD"
	
	// Title - converts to title case (first letter of each word uppercase)
	fmt.Println(strings.Title("hello world")) // "Hello World"
	
	// ToLowerSpecial - handles special cases (e.g., Turkish)
	fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, "İ")) // "i"
	
	// ToUpperSpecial - handles special cases
	fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, "i")) // "İ"
}
```

## Trimming Strings

### 1. Removing Characters from Edges
```go
func main() {
	s := "!!!Hello, World!!!"
	
	// Trim - removes characters from both ends
	fmt.Println(strings.Trim(s, "!")) // "Hello, World"
	
	// TrimLeft - removes characters from left
	fmt.Println(strings.TrimLeft(s, "!")) // "Hello, World!!!"
	
	// TrimRight - removes characters from right
	fmt.Println(strings.TrimRight(s, "!")) // "!!!Hello, World"
	
	// TrimSpace - removes whitespace from both ends
	s2 := "  Hello, World  "
	fmt.Println(strings.TrimSpace(s2)) // "Hello, World"
	
	// TrimPrefix - removes specific prefix
	fmt.Println(strings.TrimPrefix("Hello, World", "Hello")) // ", World"
	
	// TrimSuffix - removes specific suffix
	fmt.Println(strings.TrimSuffix("Hello, World", "World")) // "Hello, "
	
	// TrimFunc - removes characters that satisfy a function
	// Remove all non-alphanumeric characters from edges
	trimmed := strings.TrimFunc("!!Hello, World!!", func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsNumber(r)
	})
	fmt.Println(trimmed) // "Hello, World"
}
```

## Comparison Functions

### 1. Comparing Strings
```go
func main() {
	// Compare - compares two strings lexicographically
	fmt.Println(strings.Compare("a", "b"))  // -1 (a < b)
	fmt.Println(strings.Compare("b", "a"))  // 1 (b > a)
	fmt.Println(strings.Compare("a", "a"))  // 0 (equal)
	
	// EqualFold - case-insensitive comparison
	fmt.Println(strings.EqualFold("Go", "go")) // true
	fmt.Println(strings.EqualFold("Go", "Java")) // false
	
	// Basic comparison operators (more idiomatic in Go)
	fmt.Println("Go" == "go")   // false (case-sensitive)
	fmt.Println("Go" == "Go")   // true
}
```

## Substring Functions

### 1. Extracting Substrings
```go
func main() {
	s := "Hello, World!"
	
	// Slice - extracts substring (using byte indices)
	// Note: Be careful with multi-byte characters!
	sub := s[0:5]
	fmt.Println(sub) // "Hello"
	
	// For safe substring extraction with runes, convert to []rune first
	runes := []rune(s)
	subRunes := string(runes[7:12])
	fmt.Println(subRunes) // "World"
	
	// Clone - creates a copy of the string (Go 1.18+)
	clone := strings.Clone(s)
	fmt.Println(clone == s) // true (but different underlying memory)
}
```

## Counting and Repeating

### 1. Counting Occurrences
```go
func main() {
	s := "banana"
	
	// Count - counts non-overlapping occurrences
	fmt.Println(strings.Count(s, "a"))  // 3
	fmt.Println(strings.Count(s, "na")) // 2
	fmt.Println(strings.Count(s, "x"))  // 0
	
	// Repeat - repeats string n times
	fmt.Println(strings.Repeat("Go", 3)) // "GoGoGo"
}
```

## Efficient String Building

### 1. Using strings.Builder
```go
func main() {
	// Inefficient concatenation with +
	s1 := "Hello"
	s2 := "World"
	result := s1 + ", " + s2 + "!"
	fmt.Println(result) // "Hello, World!"
	
	// Efficient concatenation with strings.Builder
	var builder strings.Builder
	
	// WriteString - appends string
	builder.WriteString("Hello")
	builder.WriteString(", ")
	builder.WriteString("World")
	builder.WriteString("!")
	
	fmt.Println(builder.String()) // "Hello, World!"
	
	// Write - appends byte slice
	builder.Reset() // Clear the builder
	builder.Write([]byte{72, 101, 108, 108, 111}) // "Hello"
	fmt.Println(builder.String())
	
	// WriteByte - appends single byte
	builder.WriteByte(32) // space
	builder.WriteByte(87)  // 'W'
	fmt.Println(builder.String()) // "Hello W"
	
	// Grow - pre-allocates space
	builder.Grow(100) // Ensure capacity for 100 more bytes
	fmt.Printf("Builder length: %d, capacity: %d\n", builder.Len(), builder.Cap())
}
```

## Real-World Example: Text Processing Utility

Let's build a comprehensive text processing utility that demonstrates various string functions:

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
	"unicode"
)

// TextProcessor provides various text processing functions
type TextProcessor struct {
	input string
}

func NewTextProcessor(input string) *TextProcessor {
	return &TextProcessor{input: input}
}

// WordCount returns the number of words in the text
func (tp *TextProcessor) WordCount() int {
	return len(strings.Fields(tp.input))
}

// CharacterCount returns the number of characters (runes)
func (tp *TextProcessor) CharacterCount() int {
	return len([]rune(tp.input))
}

// LineCount returns the number of lines
func (tp *TextProcessor) LineCount() int {
	return len(strings.Split(tp.input, "\n"))
}

// UniqueWords returns a sorted slice of unique words
func (tp *TextProcessor) UniqueWords() []string {
	words := strings.Fields(tp.input)
	wordMap := make(map[string]bool)
	
	for _, word := range words {
		// Normalize word (lowercase, remove punctuation)
		normalized := strings.ToLower(word)
		normalized = strings.TrimFunc(normalized, func(r rune) bool {
			return !unicode.IsLetter(r) && !unicode.IsNumber(r)
		})
		if normalized != "" {
			wordMap[normalized] = true
		}
	}
	
	unique := make([]string, 0, len(wordMap))
	for word := range wordMap {
		unique = append(unique, word)
	}
	
	sort.Strings(unique)
	return unique
}

// FindSentences splits text into sentences
func (tp *TextProcessor) FindSentences() []string {
	// Simple sentence splitting on .!?
	re := regexp.MustCompile(`[.!?]+[\s]*`)
	sentences := re.Split(tp.input, -1)
	
	var result []string
	for _, sentence := range sentences {
		sentence = strings.TrimSpace(sentence)
		if sentence != "" {
			result = append(result, sentence)
		}
	}
	
	return result
}

// ReplaceWords replaces all occurrences of oldWord with newWord
func (tp *TextProcessor) ReplaceWords(oldWord, newWord string) string {
	return strings.ReplaceAll(tp.input, oldWord, newWord)
}

// ToTitleCase converts text to title case
func (tp *TextProcessor) ToTitleCase() string {
	words := strings.Fields(tp.input)
	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(string(word[0])) + strings.ToLower(word[1:])
		}
	}
	return strings.Join(words, " ")
}

// RemoveExtraWhitespace normalizes whitespace
func (tp *TextProcessor) RemoveExtraWhitespace() string {
	// Replace multiple spaces with single space
	re := regexp.MustCompile(`\s+`)
	result := re.ReplaceAllString(tp.input, " ")
	
	// Trim leading/trailing whitespace
	return strings.TrimSpace(result)
}

// FindEmailAddresses extracts all email addresses
func (tp *TextProcessor) FindEmailAddresses() []string {
	// Simple email regex (not production-quality)
	re := regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`)
	return re.FindAllString(tp.input, -1)
}

// GenerateSummary creates a summary of the first n words
func (tp *TextProcessor) GenerateSummary(wordCount int) string {
	words := strings.Fields(tp.input)
	if len(words) <= wordCount {
		return tp.input
	}
	
	summary := strings.Join(words[:wordCount], " ")
	return summary + "..."
}

// AnalyzeSentiment simple sentiment analysis based on positive/negative words
func (tp *TextProcessor) AnalyzeSentiment() string {
	positiveWords := []string{"good", "great", "excellent", "awesome", "happy", "love"}
	negativeWords := []string{"bad", "terrible", "awful", "hate", "sad", "angry"}
	
	text := strings.ToLower(tp.input)
	
	positiveCount := 0
	negativeCount := 0
	
	for _, word := range positiveWords {
		positiveCount += strings.Count(text, word)
	}
	
	for _, word := range negativeWords {
		negativeCount += strings.Count(text, word)
	}
	
	if positiveCount > negativeCount {
		return "Positive"
	} else if negativeCount > positiveCount {
		return "Negative"
	}
	return "Neutral"
}

func main() {
	// Sample text
	sampleText := `Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
Go is amazing! I love working with Go. It's fast and efficient.
The Go community is great. For more information, visit golang.org or contact us at info@golang.org.
This is a test. This is only a test. Testing, testing, 1, 2, 3...`

	processor := NewTextProcessor(sampleText)

	// Basic statistics
	fmt.Println("=== Text Analysis ===")
	fmt.Printf("Word count: %d\n", processor.WordCount())
	fmt.Printf("Character count: %d\n", processor.CharacterCount())
	fmt.Printf("Line count: %d\n", processor.LineCount())

	// Unique words
	fmt.Println("\n=== Unique Words ===")
	uniqueWords := processor.UniqueWords()
	fmt.Printf("Found %d unique words:\n", len(uniqueWords))
	for i, word := range uniqueWords {
		if i >= 10 { // Show first 10
			fmt.Println("...")
			break
		}
		fmt.Printf("- %s\n", word)
	}

	// Sentences
	fmt.Println("\n=== Sentences ===")
	sentences := processor.FindSentences()
	for i, sentence := range sentences {
		fmt.Printf("%d. %s\n", i+1, sentence)
	}

	// Email addresses
	fmt.Println("\n=== Email Addresses ===")
	emails := processor.FindEmailAddresses()
	for _, email := range emails {
		fmt.Printf("- %s\n", email)
	}

	// Text transformations
	fmt.Println("\n=== Text Transformations ===")
	fmt.Println("Original:", sampleText[:50]+"...")
	fmt.Println("Title Case:", processor.ToTitleCase()[:50]+"...")
	fmt.Println("Normalized Whitespace:", processor.RemoveExtraWhitespace()[:50]+"...")

	// Word replacement
	fmt.Println("\n=== Word Replacement ===")
	replaced := processor.ReplaceWords("Go", "Golang")
	fmt.Println("Replaced 'Go' with 'Golang':", replaced[:50]+"...")

	// Summary
	fmt.Println("\n=== Summary ===")
	summary := processor.GenerateSummary(10)
	fmt.Println("First 10 words summary:", summary)

	// Sentiment analysis
	fmt.Println("\n=== Sentiment Analysis ===")
	sentiment := processor.AnalyzeSentiment()
	fmt.Printf("Overall sentiment: %s\n", sentiment)

	// Interactive mode
	fmt.Println("\n=== Interactive Mode ===")
	scanner := bufio.NewScanner(os.Stdin)
	
	for {
		fmt.Print("\nEnter text to analyze (or 'quit' to exit): ")
		if !scanner.Scan() {
			break
		}
		
		input := scanner.Text()
		if input == "quit" {
			break
		}
		
		if input == "" {
			continue
		}
		
		processor = NewTextProcessor(input)
		fmt.Printf("Words: %d, Characters: %d, Sentiment: %s\n",
			processor.WordCount(),
			processor.CharacterCount(),
			processor.AnalyzeSentiment())
	}
}
```

### How This Example Demonstrates String Functions:

1. **Basic String Operations**:
   - `strings.Fields()` for word splitting
   - `strings.ToLower()` for case normalization
   - `strings.TrimFunc()` for punctuation removal
   - `strings.ReplaceAll()` for word replacement

2. **Advanced Processing**:
   - Regular expressions for pattern matching
   - `strings.TrimSpace()` for whitespace normalization
   - `strings.Join()` for string concatenation
   - `strings.Count()` for word frequency analysis

3. **Text Analysis**:
   - Sentence splitting with custom logic
   - Email extraction with regex
   - Sentiment analysis using word counting
   - Summary generation

4. **Efficient Processing**:
   - Using maps for unique word tracking
   - Sorting results for consistent output
   - Handling Unicode characters properly

### Real-World Applications:

1. **Content Management Systems**:
   - Text processing for blog posts
   - Search functionality
   - Content summarization

2. **Data Cleaning**:
   - Normalizing user input
   - Removing unwanted characters
   - Standardizing text formats

3. **Natural Language Processing**:
   - Tokenization
   - Feature extraction
   - Text classification

4. **Log Analysis**:
   - Parsing log files
   - Extracting relevant information
   - Generating reports

## Best Practices for String Functions

### 1. Choose the Right Function for the Job
```go
// Good - use Contains for simple checks
if strings.Contains(email, "@") {
    // Valid email format
}

// Bad - using Index for simple existence check
if strings.Index(email, "@") != -1 {
    // Less readable
}
```

### 2. Be Careful with Unicode
```go
// Bad - byte-based slicing can break multi-byte characters
s := "Hello, 世界"
sub := s[7:10] // Might break the Chinese character

// Good - use rune-based slicing
runes := []rune(s)
sub = string(runes[7:9]) // Safe
```

### 3. Use strings.Builder for Efficient Concatenation
```go
// Bad - creates many temporary strings
var result string
for i := 0; i < 1000; i++ {
    result += "x" // Allocates new string each time
}

// Good - efficient with Builder
var builder strings.Builder
for i := 0; i < 1000; i++ {
    builder.WriteByte('x')
}
result := builder.String()
```

### 4. Pre-compile Regular Expressions
```go
// Bad - compiles regex on each call
func extractEmails(text string) []string {
    re := regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`)
    return re.FindAllString(text, -1)
}

// Good - compile once, reuse
var emailRegex = regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`)

func extractEmails(text string) []string {
    return emailRegex.FindAllString(text, -1)
}
```

### 5. Handle Edge Cases
```go
// Good - handle empty strings and edge cases
func safeSubstring(s string, start, end int) string {
	if s == "" || start < 0 || end > len(s) || start >= end {
		return ""
	}
	return s[start:end]
}
```

## Performance Considerations

### 1. Memory Allocation
String operations in Go often create new strings. Be mindful of:
- Concatenation in loops
- Repeated transformations
- Large string processing

### 2. Unicode Awareness
Remember that Go strings are UTF-8 encoded:
- Use `[]rune` for character-level operations
- Be careful with byte-based indexing
- Consider performance implications of Unicode processing

### 3. Alternatives for Large Data
For very large text processing:
- Consider streaming with `bufio.Scanner`
- Use `io.Reader` and `io.Writer` interfaces
- Process in chunks rather than loading entire strings

## Conclusion

The `strings` package in Go provides a comprehensive toolkit for text processing. Mastering these functions enables you to:

1. **Process Text Efficiently**:
   - Search, replace, and transform strings
   - Handle Unicode correctly
   - Write performant string operations

2. **Build Robust Applications**:
   - Validate user input
   - Parse and format data
   - Implement text-based features

3. **Solve Real-World Problems**:
   - Content management
   - Data cleaning
   - Log analysis
   - Natural language processing

Key takeaways:
1. **Choose the right function** for each task
2. **Be Unicode-aware** in all string operations
3. **Use strings.Builder** for efficient concatenation
4. **Pre-compile regexes** for repeated use
5. **Handle edge cases** gracefully

The text processing utility example demonstrates how combining these functions can create powerful tools for analyzing and transforming text. By understanding and effectively using Go's string functions, you can write more efficient, readable, and maintainable code for any application that works with text data.