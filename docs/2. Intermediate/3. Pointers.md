

# Go Pointers: Memory Addresses and References

!!! abstract "Overview"
    Master Go pointers - variables that store memory addresses rather than values. Learn how to use pointers for efficient memory management, data sharing, and building complex data structures while maintaining Go's safety guarantees.

!!! tip "Key Points"
    - Pointers store memory addresses, not values
    - Use `&` to get an address, `*` to dereference
    - Safer than C/C++ pointers with automatic memory management
    - Essential for efficient data sharing and modification
    - Zero value of a pointer is `nil`

## Understanding Pointers

A pointer is a variable that stores the memory address of another variable, providing indirect access to that variable's value.

!!! info "Pointer Concepts"
    ```mermaid
    graph LR
        A[Variable] --> B[Memory Address]
        C[Pointer] --> B
        B --> D[Stored Value]
        A --> D
        C --> E[Indirect Access]
        E --> D
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
        style C fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Memory Layout

Every variable in Go is stored at a specific memory location.

!!! example "Basic Pointer Operations"

    === "Address and Dereference"
        ```go title="basic_pointers.go" linenums="1" hl_lines="7-12"
        package main

        import "fmt"

        func main() {
            x := 42
            p := &x // p holds the address of x

            fmt.Printf("Value of x: %d\n", x)        // 42
            fmt.Printf("Address of x: %p\n", &x)     // 0x...
            fmt.Printf("Value of p: %p\n", p)       // 0x... (same as &x)
            fmt.Printf("Value at p: %d\n", *p)      // 42 (dereference)

            *p = 21 // Modify x through pointer
            fmt.Printf("New value of x: %d\n", x)   // 21
        }
        ```

    === "Pointer Declaration"
        ```go title="pointer_declaration.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func main() {
            var p *int      // Pointer to int (nil initially)
            var q *string   // Pointer to string (nil initially)

            fmt.Printf("p: %v\n", p) // <nil>
            fmt.Printf("q: %v\n", q) // <nil>

            x := 100
            p = &x // Assign address of x to p

            fmt.Printf("p now points to: %d\n", *p) // 100
        }
        ```

    === "Nil Pointer Safety"
        ```go title="nil_safety.go" linenums="1" hl_lines="7-15"
        package main

        import "fmt"

        func main() {
            var p *int

            // Check for nil before dereferencing
            if p != nil {
                fmt.Println(*p)
            } else {
                fmt.Println("Pointer is nil")
            }

            // Safe assignment
            x := 42
            p = &x

            if p != nil {
                fmt.Printf("Value: %d\n", *p) // 42
            }
        }
        ```

## Pointer Operations

### Creating and Using Pointers

Pointers provide multiple ways to work with memory addresses.

!!! example "Pointer Patterns"

    === "Direct Assignment"
        ```go title="direct_assignment.go" linenums="1" hl_lines="7-13"
        package main

        import "fmt"

        func main() {
            name := "Go Programming"
            ptr := &name // Get address of name

            fmt.Printf("Original: %s\n", name)     // Go Programming
            fmt.Printf("Via pointer: %s\n", *ptr)  // Go Programming

            *ptr = "Go Language" // Modify through pointer
            fmt.Printf("Modified: %s\n", name)     // Go Language
        }
        ```

    === "New Function"
        ```go title="new_function.go" linenums="1" hl_lines="6-12"
        package main

        import "fmt"

        func main() {
            p := new(int) // Allocates memory, returns pointer

            fmt.Printf("Initial value: %d\n", *p) // 0 (zero value)

            *p = 100
            fmt.Printf("New value: %d\n", *p)     // 100
        }
        ```

    === "Pointer Arithmetic (Not Allowed)"
        ```go title="no_arithmetic.go" linenums="1" hl_lines="8-12"
        package main

        import "fmt"

        func main() {
            arr := [3]int{10, 20, 30}
            p := &arr[0]

            fmt.Printf("First element: %d\n", *p) // 10

            // This would cause a compile error in Go:
            // p++ // Pointer arithmetic not allowed
            // p = p + 1 // Not allowed

            // Use slices or array indexing instead
            fmt.Printf("Second element: %d\n", arr[1]) // 20
        }
        ```

### Complete Example
```go
func main() {
    x := 100
    p := &x
    
    fmt.Println("Value of x:", x)       // 100
    fmt.Println("Address of x:", &x)   // e.g., 0x1040a124
    fmt.Println("Value of p:", p)       // Same as &x
    fmt.Println("Value at p:", *p)      // 100
    
    *p = 200
    fmt.Println("New value of x:", x)  // 200
}
```

## Pointers vs. Values: When to Use Each

### Using Values
```go
type Person struct {
    Name string
    Age  int
}

func birthday(p Person) {
    p.Age++ // Only modifies the copy
}

func main() {
    alice := Person{"Alice", 30}
    birthday(alice)
    fmt.Println(alice.Age) // Still 30 (original unchanged)
}
```

### Using Pointers
```go
func birthday(p *Person) {
    p.Age++ // Modifies the original
}

func main() {
    alice := Person{"Alice", 30}
    birthday(&alice)
    fmt.Println(alice.Age) // 31 (original modified)
}
```

### Key Differences
| Aspect          | Values                          | Pointers                          |
|-----------------|---------------------------------|-----------------------------------|
| Copy Behavior   | Creates complete copy           | Copies only memory address        |
| Memory Usage    | Higher for large structs        | Constant (8 bytes on 64-bit systems) |
| Mutability      | Original unchanged              | Can modify original data          |
| Nil Safety      | Always valid                    | Can be nil (requires checks)      |
| Performance     | Slower for large data           | Faster for large data             |

## Pointer Safety in Go
Go provides several safety features not found in languages like C:

### 1. No Pointer Arithmetic
Go doesn't allow pointer arithmetic, preventing dangerous memory operations:
```go
// INVALID in Go:
p := &x
p++ // Compiler error: cannot increment pointer
```

### 2. Garbage Collection
Go's garbage collector automatically manages memory:
- No need to manually free memory
- Prevents memory leaks and dangling pointers
- Safe pointer use without manual memory management

### 3. Type Safety
Pointers are strongly typed:
```go
var p *int
var s *string
p = s // Compiler error: type mismatch
```

## Common Pointer Patterns in Go

### 1. Modifying Function Parameters
```go
func setToZero(p *int) {
    *p = 0
}

func main() {
    x := 42
    setToZero(&x)
    fmt.Println(x) // 0
}
```

### 2. Pointer Receivers for Methods
```go
type Counter struct {
    count int
}

func (c *Counter) Increment() {
    c.count++
}

func main() {
    c := Counter{count: 0}
    c.Increment()
    fmt.Println(c.count) // 1
}
```

### 3. Returning Pointers from Functions
```go
func createInt(value int) *int {
    return &value // Safe: Go escapes value to heap
}

func main() {
    p := createInt(42)
    fmt.Println(*p) // 42
}
```

### 4. Pointers to Structs
```go
type User struct {
    Name string
    Email string
}

func newUser(name, email string) *User {
    return &User{Name: name, Email: email}
}

func main() {
    u := newUser("Alice", "alice@example.com")
    fmt.Println((*u).Name) // Alice
    fmt.Println(u.Name)    // Alice (automatic dereferencing)
}
```

## Working with Nil Pointers
A pointer that doesn't point to anything has the value `nil`:

```go
var p *int
fmt.Println(p == nil) // true

// Dereferencing a nil pointer causes a panic:
fmt.Println(*p) // Panic: runtime error: invalid memory address
```

### Safe Dereferencing
Always check for nil before dereferencing:
```go
func safePrint(p *int) {
    if p != nil {
        fmt.Println(*p)
    } else {
        fmt.Println("Pointer is nil")
    }
}
```

## Pointers and Interfaces
Interfaces can hold pointers:
```go
type Writer interface {
    Write([]byte) (int, error)
}

type MyWriter struct{}

func (w *MyWriter) Write(data []byte) (int, error) {
    fmt.Println(string(data))
    return len(data), nil
}

func main() {
    var w Writer = &MyWriter{} // Interface holds pointer
    w.Write([]byte("Hello"))
}
```

## Common Pitfalls and Best Practices

### 1. Unnecessary Pointers
Avoid pointers for small, immutable values:
```go
// Bad: Unnecessary pointer for small value
func isAdult(age *int) bool {
    return *age >= 18
}

// Good: Use value directly
func isAdult(age int) bool {
    return age >= 18
}
```

### 2. Confusing Pointers and Values
Remember that methods with value receivers can't modify the original:
```go
type Value struct {
    x int
}

func (v Value) Set(val int) {
    v.x = val // Only modifies the copy
}

func main() {
    v := Value{x: 10}
    v.Set(20)
    fmt.Println(v.x) // Still 10
}
```

### 3. Returning Pointers to Local Variables
Go handles this safely by escaping to the heap, but be mindful:
```go
func getInt() *int {
    x := 42
    return &x // Safe: Go allocates x on heap
}
```

### 4. Pointer Maps and Slices
Maps and slices are reference types, but you might still need pointers:
```go
// Modifying slice elements
func modifySlice(s []int) {
    s[0] = 100 // Modifies original slice
}

// Modifying slice itself (e.g., resizing)
func modifySlicePointer(s *[]int) {
    *s = append(*s, 200) // Modifies original slice header
}
```

## Real-World Example: Linked List Implementation
A practical application of pointers is implementing a linked list, which is impossible without pointers in Go.

```go
package main

import "fmt"

// Node represents a single element in the linked list
type Node struct {
    Value int
    Next  *Node
}

// LinkedList represents the linked list structure
type LinkedList struct {
    Head *Node
    Length int
}

// Append adds a new node to the end of the list
func (ll *LinkedList) Append(value int) {
    newNode := &Node{Value: value}
    
    if ll.Head == nil {
        ll.Head = newNode
    } else {
        current := ll.Head
        for current.Next != nil {
            current = current.Next
        }
        current.Next = newNode
    }
    ll.Length++
}

// Prepend adds a new node to the beginning of the list
func (ll *LinkedList) Prepend(value int) {
    newNode := &Node{Value: value, Next: ll.Head}
    ll.Head = newNode
    ll.Length++
}

// Delete removes a node with the given value
func (ll *LinkedList) Delete(value int) {
    if ll.Head == nil {
        return
    }
    
    // Special case: deleting the head
    if ll.Head.Value == value {
        ll.Head = ll.Head.Next
        ll.Length--
        return
    }
    
    current := ll.Head
    for current.Next != nil {
        if current.Next.Value == value {
            current.Next = current.Next.Next
            ll.Length--
            return
        }
        current = current.Next
    }
}

// Find searches for a value and returns its node
func (ll *LinkedList) Find(value int) *Node {
    current := ll.Head
    for current != nil {
        if current.Value == value {
            return current
        }
        current = current.Next
    }
    return nil
}

// Display prints all values in the list
func (ll *LinkedList) Display() {
    current := ll.Head
    for current != nil {
        fmt.Printf("%d -> ", current.Value)
        current = current.Next
    }
    fmt.Println("nil")
}

// Reverse reverses the linked list in place
func (ll *LinkedList) Reverse() {
    var prev *Node
    current := ll.Head
    var next *Node
    
    for current != nil {
        next = current.Next   // Store next node
        current.Next = prev   // Reverse current node's pointer
        prev = current        // Move prev one step forward
        current = next        // Move current one step forward
    }
    ll.Head = prev
}

func main() {
    // Create a new linked list
    ll := &LinkedList{}
    
    // Append elements
    ll.Append(10)
    ll.Append(20)
    ll.Append(30)
    fmt.Println("After appending:")
    ll.Display() // 10 -> 20 -> 30 -> nil
    
    // Prepend an element
    ll.Prepend(5)
    fmt.Println("\nAfter prepending:")
    ll.Display() // 5 -> 10 -> 20 -> 30 -> nil
    
    // Find an element
    found := ll.Find(20)
    if found != nil {
        fmt.Println("\nFound node with value:", found.Value)
    }
    
    // Delete an element
    ll.Delete(20)
    fmt.Println("\nAfter deleting 20:")
    ll.Display() // 5 -> 10 -> 30 -> nil
    
    // Reverse the list
    ll.Reverse()
    fmt.Println("\nAfter reversing:")
    ll.Display() // 30 -> 10 -> 5 -> nil
    
    fmt.Println("\nList length:", ll.Length)
}
```

### How This Implementation Uses Pointers:

1. **Node Structure**:
   - `Next *Node` is a pointer to the next node in the sequence
   - This creates the chain that defines the linked list

2. **LinkedList Structure**:
   - `Head *Node` points to the first node in the list
   - Without this pointer, we couldn't access the list

3. **Method Implementations**:
   - All methods use pointer receivers (`*LinkedList`) to modify the original list
   - Traversal relies on following pointers from one node to the next
   - Insertions and deletions manipulate pointers to restructure the list

4. **Key Pointer Operations**:
   - `current.Next` accesses the next node via pointer
   - `current.Next = newNode` changes which node comes next
   - `prev = current` moves pointer references during reversal

### Real-World Applications of Linked Lists:

1. **Implementation of Other Data Structures**:
   - Stacks and queues can be built using linked lists
   - Graph adjacency lists often use linked structures

2. **Memory Management**:
   - Used in memory allocators to track free blocks
   - Garbage collectors use similar pointer structures

3. **Dynamic Data Storage**:
   - When you need frequent insertions/deletions at arbitrary positions
   - When the size is unknown or changes frequently

4. **File Systems**:
   - Some file systems use linked lists for free space management
   - Directory structures can be represented as linked lists

5. **Web Browser History**:
   - Forward/backward navigation can be implemented with a doubly linked list

### Benefits of This Pointer-Based Approach:

1. **Dynamic Sizing**:
   - Can grow or shrink without reallocating entire structure
   - No wasted space from overallocation

2. **Efficient Insertions/Deletions**:
   - O(1) time for operations at known positions
   - No need to shift elements like in arrays

3. **Memory Efficiency**:
   - Only allocates memory for actual elements
   - No preallocation needed

4. **Flexibility**:
   - Easy to implement complex operations like reversal
   - Can be extended to doubly linked lists or circular lists

## Conclusion

Pointers are a powerful feature in Go that enable:
- Efficient memory usage by avoiding copying large data structures
- Shared state across different parts of your program
- Implementation of complex data structures like linked lists, trees, and graphs
- Fine-grained control over mutability

Key takeaways:
1. Use pointers when you need to modify the original data
2. Prefer values for small, immutable data
3. Always check for nil before dereferencing
4. Remember that Go provides safety features not found in C/C++
5. Understand that methods with pointer receivers can modify the original value

The linked list example demonstrates how pointers enable the creation of dynamic data structures that are fundamental to computer science. Mastering pointers is essential for writing efficient, idiomatic Go code, especially when working with complex algorithms or performance-critical applications.

By understanding pointers, you gain deeper insight into how Go manages memory and how to write more efficient programs. They are a cornerstone of systems programming and a key differentiator between high-level and low-level programming languages.