

# Go Pointers: Memory Addresses and References

!!! abstract "Overview"
    Master Go pointers - variables that store memory addresses rather than values. Learn how to use pointers for efficient memory management, data sharing, and building complex data structures while maintaining Go's safety guarantees.

!!! tip "Key Points"
    - Pointers store memory addresses, not values
    - Use `&` to get an address, `*` to dereference
    - Safer than C/C++ pointers with automatic memory management
    - Essential for efficient data sharing and modification
    - Zero value of a pointer is `nil`

## Understanding Pointers

A pointer is a variable that stores the memory address of another variable, providing indirect access to that variable's value.

!!! info "Pointer Concepts"
    ```mermaid
    graph LR
        A[Variable] --> B[Memory Address]
        C[Pointer] --> B
        B --> D[Stored Value]
        A --> D
        C --> E[Indirect Access]
        E --> D
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
        style C fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Basic Pointer Operations

!!! example "Pointer Fundamentals"

    === "Address and Dereference"
        ```go title="basic_pointers.go" linenums="1" hl_lines="7-12"
        package main

        import "fmt"

        func main() {
            x := 42
            p := &x // p holds the address of x

            fmt.Printf("Value of x: %d\n", x)        // 42
            fmt.Printf("Address of x: %p\n", &x)     // 0x...
            fmt.Printf("Value of p: %p\n", p)       // 0x... (same as &x)
            fmt.Printf("Value at p: %d\n", *p)      // 42 (dereference)

            *p = 21 // Modify x through pointer
            fmt.Printf("New value of x: %d\n", x)   // 21
        }
        ```

    === "Pointer Declaration"
        ```go title="pointer_declaration.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func main() {
            var p *int      // Pointer to int (nil initially)
            var q *string   // Pointer to string (nil initially)

            fmt.Printf("p: %v\n", p) // <nil>
            fmt.Printf("q: %v\n", q) // <nil>

            x := 100
            p = &x // Assign address of x to p

            fmt.Printf("p now points to: %d\n", *p) // 100
        }
        ```

    === "Nil Pointer Safety"
        ```go title="nil_safety.go" linenums="1" hl_lines="7-15"
        package main

        import "fmt"

        func main() {
            var p *int

            // Check for nil before dereferencing
            if p != nil {
                fmt.Println(*p)
            } else {
                fmt.Println("Pointer is nil")
            }

            // Safe assignment
            x := 42
            p = &x

            if p != nil {
                fmt.Printf("Value: %d\n", *p) // 42
            }
        }
        ```

## Pointer Operations

### Creating and Using Pointers

Pointers provide multiple ways to work with memory addresses.

!!! example "Pointer Patterns"

    === "Direct Assignment"
        ```go title="direct_assignment.go" linenums="1" hl_lines="7-13"
        package main

        import "fmt"

        func main() {
            name := "Go Programming"
            ptr := &name // Get address of name

            fmt.Printf("Original: %s\n", name)     // Go Programming
            fmt.Printf("Via pointer: %s\n", *ptr)  // Go Programming

            *ptr = "Go Language" // Modify through pointer
            fmt.Printf("Modified: %s\n", name)     // Go Language
        }
        ```

    === "New Function"
        ```go title="new_function.go" linenums="1" hl_lines="6-12"
        package main

        import "fmt"

        func main() {
            p := new(int) // Allocates memory, returns pointer

            fmt.Printf("Initial value: %d\n", *p) // 0 (zero value)

            *p = 100
            fmt.Printf("New value: %d\n", *p)     // 100
        }
        ```

    === "Pointer Arithmetic (Not Allowed)"
        ```go title="no_arithmetic.go" linenums="1" hl_lines="8-12"
        package main

        import "fmt"

        func main() {
            arr := [3]int{10, 20, 30}
            p := &arr[0]

            fmt.Printf("First element: %d\n", *p) // 10

            // This would cause a compile error in Go:
            // p++ // Pointer arithmetic not allowed
            // p = p + 1 // Not allowed

            // Use slices or array indexing instead
            fmt.Printf("Second element: %d\n", arr[1]) // 20
        }
        ```

## Pointers vs. Values: When to Use Each

### Understanding the Difference

!!! example "Value vs Pointer Behavior"

    === "Using Values"
        ```go title="value_parameter.go" linenums="1" hl_lines="7-14"
        package main

        import "fmt"

        type Person struct {
            Name string
            Age  int
        }

        func birthday(p Person) {
            p.Age++ // Only modifies the copy
        }

        func main() {
            alice := Person{"Alice", 30}
            birthday(alice)
            fmt.Println(alice.Age) // Still 30 (original unchanged)
        }
        ```

    === "Using Pointers"
        ```go title="pointer_parameter.go" linenums="1" hl_lines="7-14"
        package main

        import "fmt"

        type Person struct {
            Name string
            Age  int
        }

        func birthday(p *Person) {
            p.Age++ // Modifies the original
        }

        func main() {
            alice := Person{"Alice", 30}
            birthday(&alice)
            fmt.Println(alice.Age) // 31 (original modified)
        }
        ```

### Key Differences

| Aspect          | Values                          | Pointers                          |
|-----------------|---------------------------------|-----------------------------------|
| Copy Behavior   | Creates complete copy           | Copies only memory address        |
| Memory Usage    | Higher for large structs        | Constant (8 bytes on 64-bit systems) |
| Mutability      | Original unchanged              | Can modify original data          |
| Nil Safety      | Always valid                    | Can be nil (requires checks)      |
| Performance     | Slower for large data           | Faster for large data             |

## Pointer Safety in Go

Go provides several safety features not found in languages like C:

!!! info "Safety Features"
    ```mermaid
    graph LR
        A[Go Pointer Safety] --> B[No Pointer Arithmetic]
        A --> C[Garbage Collection]
        A --> D[Type Safety]
        A --> E[Automatic Bounds Checking]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### 1. No Pointer Arithmetic

Go doesn't allow pointer arithmetic, preventing dangerous memory operations:

!!! example "No Pointer Arithmetic"
    ```go title="no_arithmetic.go" linenums="1" hl_lines="8-10"
    package main

    func main() {
        x := 42
        p := &x
        
        // INVALID in Go:
        // p++ // Compiler error: cannot increment pointer
        // p = p + 1 // Not allowed
    }
    ```

### 2. Garbage Collection

Go's garbage collector automatically manages memory:
- No need to manually free memory
- Prevents memory leaks and dangling pointers
- Safe pointer use without manual memory management

### 3. Type Safety

Pointers are strongly typed:

!!! example "Type Safety"
    ```go title="type_safety.go" linenums="1" hl_lines="6-9"
    package main

    func main() {
        var p *int
        var s *string
        // p = s // Compiler error: type mismatch
    }
    ```

## Common Pointer Patterns in Go

### 1. Modifying Function Parameters

!!! example "Function Parameter Modification"
    ```go title="parameter_modification.go" linenums="1" hl_lines="6-12"
    package main

    import "fmt"

    func setToZero(p *int) {
        *p = 0
    }

    func main() {
        x := 42
        setToZero(&x)
        fmt.Println(x) // 0
    }
    ```

### 2. Pointer Receivers for Methods

!!! example "Pointer Receivers"
    ```go title="pointer_receivers.go" linenums="1" hl_lines="8-13"
    package main

    import "fmt"

    type Counter struct {
        count int
    }

    func (c *Counter) Increment() {
        c.count++
    }

    func main() {
        c := Counter{count: 0}
        c.Increment()
        fmt.Println(c.count) // 1
    }
    ```

### 3. Returning Pointers from Functions

!!! example "Returning Pointers"
    ```go title="returning_pointers.go" linenums="1" hl_lines="6-12"
    package main

    import "fmt"

    func createInt(value int) *int {
        return &value // Safe: Go escapes value to heap
    }

    func main() {
        p := createInt(42)
        fmt.Println(*p) // 42
    }
    ```

### 4. Pointers to Structs

!!! example "Struct Pointers"
    ```go title="struct_pointers.go" linenums="1" hl_lines="8-16"
    package main

    import "fmt"

    type User struct {
        Name string
        Email string
    }

    func newUser(name, email string) *User {
        return &User{Name: name, Email: email}
    }

    func main() {
        u := newUser("Alice", "alice@example.com")
        fmt.Println((*u).Name) // Alice
        fmt.Println(u.Name)    // Alice (automatic dereferencing)
    }
    ```

## Working with Nil Pointers

A pointer that doesn't point to anything has the value `nil`:

!!! example "Nil Pointer Handling"
    ```go title="nil_handling.go" linenums="1" hl_lines="6-16"
    package main

    import "fmt"

    func safePrint(p *int) {
        if p != nil {
            fmt.Println(*p)
        } else {
            fmt.Println("Pointer is nil")
        }
    }

    func main() {
        var p *int
        fmt.Println(p == nil) // true

        // Dereferencing a nil pointer causes a panic:
        // fmt.Println(*p) // Panic: runtime error: invalid memory address

        safePrint(p) // "Pointer is nil"
    }
    ```

## Pointers and Interfaces

Interfaces can hold pointers:

!!! example "Interface Pointers"
    ```go title="interface_pointers.go" linenums="1" hl_lines="8-19"
    package main

    import "fmt"

    type Writer interface {
        Write([]byte) (int, error)
    }

    type MyWriter struct{}

    func (w *MyWriter) Write(data []byte) (int, error) {
        fmt.Println(string(data))
        return len(data), nil
    }

    func main() {
        var w Writer = &MyWriter{} // Interface holds pointer
        w.Write([]byte("Hello"))
    }
    ```

## Common Pitfalls and Best Practices

### 1. Unnecessary Pointers

Avoid pointers for small, immutable values:

!!! warning "Unnecessary Pointers"
    ```go title="unnecessary_pointers.go" linenums="1" hl_lines="6-11"
    package main

    // Bad: Unnecessary pointer for small value
    func isAdult(age *int) bool {
        return *age >= 18
    }

    // Good: Use value directly
    func isAdultGood(age int) bool {
        return age >= 18
    }
    ```

### 2. Confusing Pointers and Values

Remember that methods with value receivers can't modify the original:

!!! warning "Value Receiver Pitfall"
    ```go title="value_receiver_pitfall.go" linenums="1" hl_lines="8-15"
    package main

    import "fmt"

    type Value struct {
        x int
    }

    func (v Value) Set(val int) {
        v.x = val // Only modifies the copy
    }

    func main() {
        v := Value{x: 10}
        v.Set(20)
        fmt.Println(v.x) // Still 10
    }
    ```

### 3. Pointer Maps and Slices

Maps and slices are reference types, but you might still need pointers:

!!! example "Map and Slice Pointers"
    ```go title="map_slice_pointers.go" linenums="1" hl_lines="6-17"
    package main

    import "fmt"

    // Modifying slice elements
    func modifySlice(s []int) {
        s[0] = 100 // Modifies original slice
    }

    // Modifying slice itself (e.g., resizing)
    func modifySlicePointer(s *[]int) {
        *s = append(*s, 200) // Modifies original slice header
    }

    func main() {
        data := []int{1, 2, 3}
        modifySlice(data)
        fmt.Println(data) // [100 2 3]
        
        modifySlicePointer(&data)
        fmt.Println(data) // [100 2 3 200]
    }
    ```

## Real-World Example: Linked List Implementation

A practical application of pointers is implementing a linked list, which is impossible without pointers in Go.

!!! example "Linked List Implementation"
    ```go title="linked_list.go" linenums="1" hl_lines="8-20"
    package main

    import "fmt"

    // Node represents a single element in the linked list
    type Node struct {
        Value int
        Next  *Node
    }

    // LinkedList represents the linked list structure
    type LinkedList struct {
        Head *Node
        Length int
    }

    // Append adds a new node to the end of the list
    func (ll *LinkedList) Append(value int) {
        newNode := &Node{Value: value}
        
        if ll.Head == nil {
            ll.Head = newNode
        } else {
            current := ll.Head
            for current.Next != nil {
                current = current.Next
            }
            current.Next = newNode
        }
        ll.Length++
    }

    // Display prints all values in the list
    func (ll *LinkedList) Display() {
        current := ll.Head
        for current != nil {
            fmt.Printf("%d -> ", current.Value)
            current = current.Next
        }
        fmt.Println("nil")
    }

    func main() {
        ll := &LinkedList{}
        ll.Append(10)
        ll.Append(20)
        ll.Append(30)
        ll.Display() // 10 -> 20 -> 30 -> nil
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Memory Efficiency**: Pointers avoid copying large data structures
    - **Data Modification**: Use pointers when you need to modify original data
    - **Nil Safety**: Always check for nil before dereferencing
    - **Type Safety**: Go pointers are strongly typed
    - **No Arithmetic**: Unlike C/C++, Go doesn't allow pointer arithmetic
    - **Garbage Collection**: Automatic memory management prevents leaks

!!! quote "Remember"
    "Pointers in Go provide the power of indirect memory access with safety features that prevent many common errors. They're essential for efficient data sharing and implementing complex data structures, but should be used judiciously - prefer values for small, immutable data."