

# Go Strings and Runes: Text Processing and Unicode

!!! abstract "Overview"
    Master Go's string and rune handling for effective text processing. Learn the difference between bytes and Unicode characters, string manipulation techniques, and best practices for international text handling.

!!! tip "Key Points"
    - Strings are immutable sequences of bytes
    - Runes represent Unicode code points
    - UTF-8 encoding is used by default
    - `len()` returns bytes, not character count
    - Use runes for proper Unicode handling

## Understanding Strings and Runes

In Go, strings are immutable sequences of bytes, UTF-8 encoded by default. This makes them powerful for international text but requires understanding the distinction between bytes and Unicode characters.

!!! info "String vs Rune Representation"
    ```mermaid
    graph LR
        A[String] --> B[Sequence of Bytes]
        A --> C[UTF-8 Encoded]
        D[Rune] --> E[Unicode Code Point]
        D --> F[int32 Alias]
        B --> G[1-4 Bytes per Character]
        E --> G
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
        style D fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Basic String Declaration

!!! example "String Literals"
    ```go title="string_literals.go" linenums="1" hl_lines="6-11"
    package main

    import "fmt"

    func main() {
        // String literals
        s1 := "Hello, World!"
        s2 := `This is a raw string literal
        that can span multiple lines
        and include "quotes" without escaping`
        
        fmt.Println(s1)
        fmt.Println(s2)
    }
    ```

## String Immutability

Once created, strings in Go cannot be modified. Any operation that appears to modify a string actually creates a new one.

!!! example "String Immutability"
    ```go title="immutability.go" linenums="1" hl_lines="7-11"
    package main

    import "fmt"

    func main() {
        s := "hello"
        // s[0] = 'H' // This would cause a compilation error
        
        // To "modify", we create a new string
        s = "H" + s[1:]
        fmt.Println(s) // "Hello"
    }
    ```

## UTF-8 Encoding and Runes

Go strings are UTF-8 encoded, which means:
- Each Unicode character (code point) can be represented by 1 to 4 bytes
- ASCII characters use 1 byte
- Non-Latin characters (like Chinese, Arabic, emojis) use multiple bytes

### What is a Rune?

In Go, a `rune` is an alias for `int32` and represents a single Unicode code point. It's Go's way of handling characters properly.

!!! example "Rune vs Byte Comparison"
    ```go title="rune_byte.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "unicode/utf8"
    )

    func main() {
        s := "Hello, ä¸–ç•Œ"
        
        // Length in bytes
        fmt.Println("Byte length:", len(s)) // 13
        
        // Length in runes (characters)
        fmt.Println("Rune length:", utf8.RuneCountInString(s)) // 9
        
        // Iterate as runes
        for i, r := range s {
            fmt.Printf("%d: %q (%d bytes)\n", i, r, utf8.RuneLen(r))
        }
    }
    ```

    Output:
    ```
    Byte length: 13
    Rune length: 9
    0: 'H' (1 bytes)
    1: 'e' (1 bytes)
    2: 'l' (1 bytes)
    3: 'l' (1 bytes)
    4: 'o' (1 bytes)
    5: ',' (1 bytes)
    6: ' ' (1 bytes)
    7: 'ä¸–' (3 bytes)
    10: 'ç•Œ' (3 bytes)
    ```

## Working with Runes

### Converting Between Strings and Runes

!!! example "String-Rune Conversion"
    ```go title="conversion.go" linenums="1" hl_lines="8-17"
    package main

    import "fmt"

    func main() {
        // String to rune slice
        s := "Hello, ä¸–ç•Œ"
        runes := []rune(s)
        fmt.Println(runes) // [72 101 108 108 111 44 32 19990 30028]
        
        // Rune slice to string
        s2 := string(runes)
        fmt.Println(s2) // "Hello, ä¸–ç•Œ"
        
        // Individual rune to string
        r := 'ä¸–'
        s3 := string(r)
        fmt.Println(s3) // "ä¸–"
    }
    ```

### Accessing Individual Characters

!!! example "Character Access"
    ```go title="character_access.go" linenums="1" hl_lines="8-18"
    package main

    import "fmt"

    func main() {
        s := "Hello, ä¸–ç•Œ"
        
        // WRONG: This would give a byte, not a character
        // fmt.Println(s[7]) // This would print 228 (first byte of 'ä¸–')
        
        // CORRECT: Convert to rune slice first
        runes := []rune(s)
        fmt.Printf("%c\n", runes[7]) // 'ä¸–'
        
        // Or use range
        for i, r := range s {
            if i == 7 {
                fmt.Printf("%c\n", r) // 'ä¸–'
            }
        }
    }
    ```

## Common String Operations

### 1. Concatenation

!!! example "String Concatenation"
    ```go title="concatenation.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        s1 := "Hello"
        s2 := "World"
        
        // Using + operator
        s3 := s1 + ", " + s2
        fmt.Println(s3) // "Hello, World"
        
        // Using fmt.Sprintf
        s4 := fmt.Sprintf("%s, %s", s1, s2)
        fmt.Println(s4) // "Hello, World"
        
        // Using strings.Builder (efficient for multiple concatenations)
        var builder strings.Builder
        builder.WriteString(s1)
        builder.WriteString(", ")
        builder.WriteString(s2)
        s5 := builder.String()
        fmt.Println(s5) // "Hello, World"
    }
    ```

### 2. Substrings

!!! example "Substring Operations"
    ```go title="substrings.go" linenums="1" hl_lines="8-16"
    package main

    import "fmt"

    func main() {
        s := "Hello, ä¸–ç•Œ"
        
        // Get substring by byte indices (DANGEROUS for multi-byte characters)
        sub1 := s[0:5] // "Hello"
        fmt.Println(sub1)
        
        // Safe substring using runes
        runes := []rune(s)
        sub2 := string(runes[7:9]) // "ä¸–ç•Œ"
        fmt.Println(sub2)
    }
    ```

### 3. Searching and Replacing

!!! example "Search and Replace"
    ```go title="search_replace.go" linenums="1" hl_lines="8-17"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        s := "Hello, ä¸–ç•Œ! Hello, Go!"
        
        // Contains
        fmt.Println(strings.Contains(s, "Hello")) // true
        
        // Index
        fmt.Println(strings.Index(s, "Hello")) // 0
        fmt.Println(strings.Index(s, "ä¸–ç•Œ"))   // 7
        
        // Replace
        s2 := strings.ReplaceAll(s, "Hello", "Hi")
        fmt.Println(s2) // "Hi, ä¸–ç•Œ! Hi, Go!"
        
        // Split
        parts := strings.Split(s, ", ")
        fmt.Println(parts) // ["Hello" "ä¸–ç•Œ! Hello" "Go!"]
    }
    ```

### 4. Trimming and Padding

!!! example "Trim and Pad"
    ```go title="trim_pad.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        s := "   Hello, World!   "
        
        // Trim spaces
        trimmed := strings.TrimSpace(s)
        fmt.Println(trimmed) // "Hello, World!"
        
        // Trim specific characters
        s2 := "!!!Hello, World!!!"
        trimmed2 := strings.Trim(s2, "!")
        fmt.Println(trimmed2) // "Hello, World"
        
        // Padding
        padded := fmt.Sprintf("%-20s", "Hello")
        fmt.Printf("'%s'\n", padded) // 'Hello               '
    }
    ```

### 5. Case Conversion

!!! example "Case Conversion"
    ```go title="case_conversion.go" linenums="1" hl_lines="8-15"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        s := "Hello, ä¸–ç•Œ"
        
        // To lower
        lower := strings.ToLower(s)
        fmt.Println(lower) // "hello, ä¸–ç•Œ"
        
        // To upper
        upper := strings.ToUpper(s)
        fmt.Println(upper) // "HELLO, ä¸–ç•Œ"
        
        // To title
        title := strings.ToTitle(s)
        fmt.Println(title) // "HELLO, ä¸–ç•Œ"
    }
    ```

## Real-World Example: Text Processing with Unicode

Let's build a practical text processing utility that:
1. Counts characters (not bytes)
2. Finds unique characters
3. Reverses the string properly
4. Handles emojis and complex scripts

!!! example "Text Processor Implementation"
    ```go title="text_processor.go" linenums="1" hl_lines="8-50"
    package main

    import (
        "fmt"
        "sort"
        "strings"
        "unicode"
        "unicode/utf8"
    )

    // TextProcessor handles Unicode-aware text operations
    type TextProcessor struct {
        text string
    }

    // NewTextProcessor creates a new processor
    func NewTextProcessor(text string) *TextProcessor {
        return &TextProcessor{text: text}
    }

    // CharacterCount returns the number of characters (runes)
    func (tp *TextProcessor) CharacterCount() int {
        return utf8.RuneCountInString(tp.text)
    }

    // UniqueCharacters returns a sorted slice of unique characters
    func (tp *TextProcessor) UniqueCharacters() []rune {
        seen := make(map[rune]bool)
        for _, r := range tp.text {
            seen[r] = true
        }
        
        unique := make([]rune, 0, len(seen))
        for r := range seen {
            unique = append(unique, r)
        }
        
        sort.Slice(unique, func(i, j int) bool {
            return unique[i] < unique[j]
        })
        
        return unique
    }

    // Reverse returns the string with characters in reverse order
    func (tp *TextProcessor) Reverse() string {
        runes := []rune(tp.text)
        for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
            runes[i], runes[j] = runes[j], runes[i]
        }
        return string(runes)
    }

    // WordCount returns the number of words (Unicode-aware)
    func (tp *TextProcessor) WordCount() int {
        // Simple word count by splitting on whitespace
        words := strings.Fields(tp.text)
        return len(words)
    }

    // ContainsEmoji checks if the text contains any emoji
    func (tp *TextProcessor) ContainsEmoji() bool {
        for _, r := range tp.text {
            // Check if the rune is in the emoji ranges
            if unicode.Is(unicode.So, r) || // Symbols, Other (includes many emojis)
               (r >= 0x1F600 && r <= 0x1F64F) || // Emoticons
               (r >= 0x1F300 && r <= 0x1F5FF) || // Misc Symbols and Pictographs
               (r >= 0x1F680 && r <= 0x1F6FF) || // Transport and Map
               (r >= 0x2600 && r <= 0x26FF) ||   // Misc Symbols
               (r >= 0x2700 && r <= 0x27BF) {    // Dingbats
                return true
            }
        }
        return false
    }

    // NormalizeSpaces replaces multiple whitespace with single space
    func (tp *TextProcessor) NormalizeSpaces() string {
        // Split on whitespace to get words
        words := strings.Fields(tp.text)
        return strings.Join(words, " ")
    }

    func main() {
        // Test with a complex string containing:
        // - ASCII characters
        // - Chinese characters
        // - Emojis
        // - Multiple spaces
        text := "Hello ä¸–ç•Œ! ðŸŒ Go is awesome!   ðŸ˜Š"
        
        processor := NewTextProcessor(text)
        
        fmt.Println("Original text:", text)
        fmt.Println("Byte length:", len(text))
        fmt.Println("Character count:", processor.CharacterCount())
        fmt.Println("Word count:", processor.WordCount())
        fmt.Println("Contains emoji:", processor.ContainsEmoji())
        
        fmt.Println("\nUnique characters:")
        for _, r := range processor.UniqueCharacters() {
            fmt.Printf("%q ", r)
        }
        
        fmt.Println("\n\nReversed text:", processor.Reverse())
        
        normalized := processor.NormalizeSpaces()
        fmt.Println("\nNormalized text:", normalized)
        
        // Demonstrate the difference between byte and rune operations
        fmt.Println("\n--- Byte vs Rune Operations ---")
        fmt.Println("First 5 bytes:", text[:5]) // "Hello"
        fmt.Println("First 5 runes:", string([]rune(text)[:5])) // "Hello ä¸–"
    }
    ```

    Output:
    ```
    Original text: Hello ä¸–ç•Œ! ðŸŒ Go is awesome!   ðŸ˜Š
    Byte length: 39
    Character count: 23
    Word count: 6
    Contains emoji: true

    Unique characters:
    ' ' '!' 'G' 'H' 'a' 'e' 'h' 'i' 'l' 'm' 'o' 's' 'v' 'w' 'ä¸–' 'ðŸ˜Š' 'ðŸŒ' 

    Reversed text: ðŸ˜Š   !emosewa si oG ðŸŒ !ç•Œä¸– olleH

    Normalized text: Hello ä¸–ç•Œ! ðŸŒ Go is awesome! ðŸ˜Š

    --- Byte vs Rune Operations ---
    First 5 bytes: Hello
    First 5 runes: Hello ä¸–
    ```

### How This Example Demonstrates Key Concepts:

1. **Unicode Awareness**:
   - Correctly counts characters (23) rather than bytes (39)
   - Properly handles multi-byte characters like Chinese and emojis
   - Reverses the string by characters, not bytes

2. **Rune Processing**:
   - Uses `[]rune` conversion for character-level operations
   - Implements Unicode-aware word counting
   - Detects emojis by checking Unicode ranges

3. **String Immutability**:
   - All operations return new strings rather than modifying the original
   - Uses `strings.Builder` for efficient concatenation (in the full implementation)

4. **Real-World Text Processing**:
   - Normalizes whitespace (common in text cleaning)
   - Identifies unique characters (useful for analysis)
   - Demonstrates safe substring operations

## Best Practices

### Memory Efficiency

!!! warning "String Concatenation"
    For multiple string concatenations, use `strings.Builder` instead of `+` operator to avoid unnecessary memory allocations.

!!! example "Efficient Concatenation"
    ```go title="efficient_concat.go" linenums="1" hl_lines="7-13"
    package main

    import (
        "strings"
        "fmt"
    )

    func main() {
        var builder strings.Builder
        
        for i := 0; i < 1000; i++ {
            builder.WriteString("hello")
        }
        
        result := builder.String()
        fmt.Println(len(result)) // 5000
    }
    ```

### Unicode Safety

!!! warning "Byte vs Rune Operations"
    Always use rune-based operations when dealing with potentially multi-byte characters to avoid corrupting Unicode text.

!!! example "Safe Character Access"
    ```go title="safe_access.go" linenums="1" hl_lines="7-15"
    package main

    import "fmt"

    func main() {
        s := "Hello, ä¸–ç•Œ"
        
        // Safe way to access the 8th character
        runes := []rune(s)
        if len(runes) > 7 {
            fmt.Printf("8th character: %c\n", runes[7])
        }
        
        // Also safe: use range
        for i, r := range s {
            if i == 7 {
                fmt.Printf("8th character: %c\n", r)
                break
            }
        }
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Immutability**: Strings cannot be modified, only new strings created
    - **UTF-8 Encoding**: Default encoding with 1-4 bytes per character
    - **Rune Handling**: Use `rune` for Unicode character operations
    - **Byte vs Character**: `len()` returns bytes, use `utf8.RuneCountInString()` for characters
    - **Concatenation**: Use `strings.Builder` for efficient multiple concatenations
    - **Unicode Safety**: Always consider multi-byte characters in text processing

!!! quote "Remember"
    "Understanding the difference between bytes and runes is crucial for proper text processing in Go. When working with international text or emojis, always use rune-based operations to ensure correct behavior."