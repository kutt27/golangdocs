# Go FMT Package: Formatted Input and Output

!!! abstract "Overview"
    Master the fmt package - Go's primary tool for formatted I/O operations. Learn printing functions, format verbs, scanning input, and best practices for debugging and user interaction.

!!! tip "Key Points"
    - Provides formatted I/O similar to C's printf family
    - Rich set of format verbs for different data types
    - Functions for printing, scanning, and string formatting
    - Essential for debugging and user interaction
    - Type-safe formatting with compile-time checks

## Understanding the FMT Package

The fmt package is Go's primary tool for formatted input and output operations, offering functions for printing, scanning, and formatting data.

## Core Printing Functions

### 1. Basic Output Functions
```go
package main

import "fmt"

func main() {
    // Print - writes to standard output without adding a newline
    fmt.Print("Hello, ")
    fmt.Print("World!\n")
    
    // Println - adds a newline between arguments and at the end
    fmt.Println("Hello,", "World!")
    
    // Printf - formatted printing with verbs
    name := "Alice"
    age := 30
    fmt.Printf("Name: %s, Age: %d\n", name, age)
}
```

### 2. Formatting to Strings
```go
func main() {
    // Sprintf - formats into a string
    status := fmt.Sprintf("Status: %s (Code: %d)", "OK", 200)
    fmt.Println(status)
    
    // Sprintln - adds newline
    line := fmt.Sprintln("Part 1", "Part 2")
    fmt.Printf("Length: %d, Content: %q", len(line), line)
}
```

### 3. Writing to Different Writers
```go
import (
    "bytes"
    "os"
)

func main() {
    // Fprint - writes to any io.Writer
    var buf bytes.Buffer
    fmt.Fprint(&buf, "Buffer content: ")
    fmt.Fprintln(&buf, 42)
    fmt.Println(buf.String())
    
    // Fprintf - formatted writing
    fmt.Fprintf(os.Stderr, "Error: %s occurred at %v\n", "timeout", time.Now())
}
```

## Input Scanning Functions

### 1. Basic Input Functions
```go
func main() {
    var name string
    var age int
    
    // Scan - reads space-separated values
    fmt.Print("Enter name and age: ")
    fmt.Scan(&name, &age)
    fmt.Printf("Read: name=%q, age=%d\n", name, age)
    
    // Scanln - reads until newline
    var city string
    fmt.Print("Enter city: ")
    fmt.Scanln(&city)
    fmt.Println("City:", city)
}
```

### 2. Formatted Scanning
```go
func main() {
    var item string
    var price float64
    var inStock bool
    
    // Sscanf - scans from a string
    input := "Widget 19.99 true"
    fmt.Sscanf(input, "%s %f %t", &item, &price, &inStock)
    fmt.Printf("Item: %s, Price: $%.2f, In Stock: %t\n", item, price, inStock)
}
```

### 3. Scanning from Different Readers
```go
import "strings"

func main() {
    // Fscan - scans from any io.Reader
    input := "123 456"
    reader := strings.NewReader(input)
    var a, b int
    fmt.Fscan(reader, &a, &b)
    fmt.Println("Read:", a, b)
}
```

## Error Handling with `fmt`

### 1. Creating Formatted Errors
```go
func processFile(filename string) error {
    if filename == "" {
        return fmt.Errorf("invalid filename: %q", filename)
    }
    // ... processing logic
    return nil
}

func main() {
    err := processFile("")
    if err != nil {
        fmt.Println("Error:", err)
    }
}
```

### 2. Error Wrapping
```go
func readFile(filename string) error {
    // Simulate file operation
    return fmt.Errorf("readFile failed: %w", 
        fmt.Errorf("permission denied"))
}

func main() {
    err := readFile("config.json")
    if err != nil {
        fmt.Println("Full error:", err)
        // In Go 1.13+, you can unwrap errors
        // fmt.Println(errors.Unwrap(err))
    }
}
```

## Custom Formatters

### 1. Implementing `Stringer` Interface
```go
type User struct {
    ID    int
    Name  string
    Email string
}

func (u User) String() string {
    return fmt.Sprintf("User[%d]: %s <%s>", u.ID, u.Name, u.Email)
}

func main() {
    user := User{1, "Alice", "alice@example.com"}
    fmt.Println(user) // Automatically calls String()
}
```

### 2. Implementing `Formatter` Interface
```go
type Money float64

func (m Money) Format(f fmt.State, verb rune) {
    switch verb {
    case 'f':
        fmt.Fprintf(f, "$%.2f", float64(m))
    case 's':
        fmt.Fprintf(f, "$%.2f", float64(m))
    case 'v':
        if f.Flag('+') {
            fmt.Fprintf(f, "Money(%v)", float64(m))
        } else {
            fmt.Fprintf(f, "$%.2f", float64(m))
        }
    default:
        fmt.Fprintf(f, "%v", float64(m))
    }
}

func main() {
    price := Money(19.99)
    fmt.Printf("Price: %v\n", price)    // $19.99
    fmt.Printf("Price: %+v\n", price)   // Money(19.99)
    fmt.Printf("Price: %f\n", price)    // $19.99
}
```

## Advanced Formatting Features

### 1. Handling Complex Types
```go
func main() {
    // Slices
    nums := []int{1, 2, 3}
    fmt.Printf("Slice: %v\n", nums)     // [1 2 3]
    fmt.Printf("Slice: %#v\n", nums)    // []int{1, 2, 3}
    
    // Maps
    m := map[string]int{"one": 1, "two": 2}
    fmt.Printf("Map: %v\n", m)          // map[one:1 two:2]
    fmt.Printf("Map: %#v\n", m)         // map[string]int{"one":1, "two":2}
    
    // Pointers
    x := 42
    fmt.Printf("Pointer: %p\n", &x)     // 0x1040a124
}
```

### 2. Width and Precision Control
```go
func main() {
    // Integer formatting
    fmt.Printf("|%5d|\n", 42)      // |   42|
    fmt.Printf("|%-5d|\n", 42)     // |42   |
    fmt.Printf("|%05d|\n", 42)     // |00042|
    
    // Floating-point formatting
    pi := 3.14159
    fmt.Printf("|%10.2f|\n", pi)   // |      3.14|
    fmt.Printf("|%-10.2f|\n", pi)  // |3.14      |
    
    // String formatting
    s := "hello"
    fmt.Printf("|%10s|\n", s)      // |     hello|
    fmt.Printf("|%-10s|\n", s)     // |hello     |
    fmt.Printf("|%.3s|\n", s)      // |hel|
}
```

### 3. Formatting Flags
```go
func main() {
    // Sign flag
    fmt.Printf("|%+d|\n", 42)      // |+42|
    fmt.Printf("|%+d|\n", -42)     // |-42|
    
    // Space flag
    fmt.Printf("|% d|\n", 42)      // | 42|
    fmt.Printf("|% d|\n", -42)     // |-42|
    
    // Alternate format
    fmt.Printf("%#o\n", 8)        // 010
    fmt.Printf("%#x\n", 255)      // 0xff
}
```

## Real-World Example: Interactive CLI Tool

Let's build a practical command-line tool that demonstrates various `fmt` package features:

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
    "time"
)

type Task struct {
    ID        int
    Title     string
    Completed bool
    DueDate   time.Time
}

func (t Task) String() string {
    status := "Pending"
    if t.Completed {
        status = "Completed"
    }
    return fmt.Sprintf("#%d: %s [%s] (Due: %s)", 
        t.ID, t.Title, status, t.DueDate.Format("2006-01-02"))
}

type TaskManager struct {
    tasks []Task
    nextID int
}

func NewTaskManager() *TaskManager {
    return &TaskManager{
        tasks: make([]Task, 0),
        nextID: 1,
    }
}

func (tm *TaskManager) AddTask(title string, dueDate time.Time) {
    task := Task{
        ID:        tm.nextID,
        Title:     title,
        Completed: false,
        DueDate:   dueDate,
    }
    tm.tasks = append(tm.tasks, task)
    tm.nextID++
    fmt.Printf("Added task: %v\n", task)
}

func (tm *TaskManager) CompleteTask(id int) error {
    for i := range tm.tasks {
        if tm.tasks[i].ID == id {
            tm.tasks[i].Completed = true
            fmt.Printf("Completed task: %v\n", tm.tasks[i])
            return nil
        }
    }
    return fmt.Errorf("task with ID %d not found", id)
}

func (tm *TaskManager) ListTasks() {
    if len(tm.tasks) == 0 {
        fmt.Println("No tasks found.")
        return
    }
    
    fmt.Println("\nTasks:")
    fmt.Println("----------------------------")
    for _, task := range tm.tasks {
        fmt.Printf("%s\n", task)
    }
    fmt.Println("----------------------------")
}

func (tm *TaskManager) SaveToFile(filename string) error {
    file, err := os.Create(filename)
    if err != nil {
        return fmt.Errorf("failed to create file: %w", err)
    }
    defer file.Close()
    
    for _, task := range tm.tasks {
        line := fmt.Sprintf("%d,%s,%t,%s\n", 
            task.ID, 
            task.Title, 
            task.Completed, 
            task.DueDate.Format("2006-01-02"))
        fmt.Fprint(file, line)
    }
    
    fmt.Printf("Saved %d tasks to %s\n", len(tm.tasks), filename)
    return nil
}

func (tm *TaskManager) LoadFromFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("failed to open file: %w", err)
    }
    defer file.Close()
    
    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        line := scanner.Text()
        parts := strings.Split(line, ",")
        if len(parts) != 4 {
            fmt.Fprintf(os.Stderr, "Invalid line format: %q\n", line)
            continue
        }
        
        id, _ := strconv.Atoi(parts[0])
        completed, _ := strconv.ParseBool(parts[2])
        dueDate, _ := time.Parse("2006-01-02", parts[3])
        
        task := Task{
            ID:        id,
            Title:     parts[1],
            Completed: completed,
            DueDate:   dueDate,
        }
        
        tm.tasks = append(tm.tasks, task)
        if id >= tm.nextID {
            tm.nextID = id + 1
        }
    }
    
    if err := scanner.Err(); err != nil {
        return fmt.Errorf("error reading file: %w", err)
    }
    
    fmt.Printf("Loaded %d tasks from %s\n", len(tm.tasks), filename)
    return nil
}

func displayMenu() {
    fmt.Println("\nTask Manager")
    fmt.Println("1. Add Task")
    fmt.Println("2. Complete Task")
    fmt.Println("3. List Tasks")
    fmt.Println("4. Save Tasks")
    fmt.Println("5. Load Tasks")
    fmt.Println("6. Exit")
    fmt.Print("Enter your choice: ")
}

func main() {
    tm := NewTaskManager()
    scanner := bufio.NewScanner(os.Stdin)
    
    for {
        displayMenu()
        
        if !scanner.Scan() {
            break
        }
        
        choice := strings.TrimSpace(scanner.Text())
        
        switch choice {
        case "1":
            fmt.Print("Enter task title: ")
            scanner.Scan()
            title := strings.TrimSpace(scanner.Text())
            
            fmt.Print("Enter due date (YYYY-MM-DD): ")
            scanner.Scan()
            dateStr := strings.TrimSpace(scanner.Text())
            
            dueDate, err := time.Parse("2006-01-02", dateStr)
            if err != nil {
                fmt.Fprintf(os.Stderr, "Invalid date format: %v\n", err)
                continue
            }
            
            tm.AddTask(title, dueDate)
            
        case "2":
            fmt.Print("Enter task ID to complete: ")
            scanner.Scan()
            idStr := strings.TrimSpace(scanner.Text())
            
            id, err := strconv.Atoi(idStr)
            if err != nil {
                fmt.Fprintf(os.Stderr, "Invalid ID: %v\n", err)
                continue
            }
            
            if err := tm.CompleteTask(id); err != nil {
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
            }
            
        case "3":
            tm.ListTasks()
            
        case "4":
            fmt.Print("Enter filename to save: ")
            scanner.Scan()
            filename := strings.TrimSpace(scanner.Text())
            
            if err := tm.SaveToFile(filename); err != nil {
                fmt.Fprintf(os.Stderr, "Error saving: %v\n", err)
            }
            
        case "5":
            fmt.Print("Enter filename to load: ")
            scanner.Scan()
            filename := strings.TrimSpace(scanner.Text())
            
            if err := tm.LoadFromFile(filename); err != nil {
                fmt.Fprintf(os.Stderr, "Error loading: %v\n", err)
            }
            
        case "6":
            fmt.Println("Goodbye!")
            return
            
        default:
            fmt.Fprintln(os.Stderr, "Invalid choice. Please try again.")
        }
    }
}
```

### How This Example Demonstrates `fmt` Features:

1. **User Interaction**:
   - Uses `fmt.Print` and `fmt.Println` for prompts and messages
   - `fmt.Fprint` and `fmt.Fprintf` for error output to `os.Stderr`
   - `fmt.Scan` for reading user input

2. **String Formatting**:
   - Custom `String()` method for Task struct
   - `fmt.Sprintf` for building formatted strings
   - Various formatting verbs for different data types

3. **File I/O**:
   - `fmt.Fprint` for writing to files
   - `fmt.Fscanf` could be used for reading (though we use scanner here)
   - Formatted output for saving tasks

4. **Error Handling**:
   - `fmt.Errorf` for creating descriptive errors
   - Error wrapping with `%w` verb
   - Formatted error messages to stderr

5. **Advanced Formatting**:
   - Date formatting with custom layouts
   - Number formatting for IDs
   - Boolean formatting for completion status

### Real-World Applications of This Pattern:

1. **CLI Applications**:
   - Interactive command-line tools
   - System administration utilities
   - Development tools and scripts

2. **Data Processing Tools**:
   - Log parsers and analyzers
   - Data transformation utilities
   - Report generators

3. **Configuration Management**:
   - Tools that read/write configuration files
   - Environment variable managers
   - Secret management utilities

4. **Testing and Debugging**:
   - Test output formatters
   - Debug logging utilities
   - Benchmark result reporters

### Benefits of This Approach:

1. **User Experience**:
   - Clear, formatted prompts and messages
   - Consistent output formatting
   - Helpful error messages

2. **Maintainability**:
   - Centralized formatting logic
   - Custom string representations for complex types
   - Clear separation of concerns

3. **Flexibility**:
   - Easy to modify output formats
   - Can redirect output to different writers
   - Supports both interactive and batch modes

4. **Robustness**:
   - Proper error handling with formatted messages
   - Input validation with clear feedback
   - Graceful handling of edge cases

## Best Practices for Using `fmt`

1. **Choose the Right Function**:
   - Use `Print`/`Println` for simple output
   - Use `Printf` for formatted output
   - Use `Sprintf` when you need a string
   - Use `Fprintf` for writing to files or other writers

2. **Error Handling**:
   - Always check errors from `fmt` functions that can return them
   - Use `fmt.Errorf` for creating descriptive errors
   - Wrap errors with context using `%w`

3. **Performance Considerations**:
   - For high-performance logging, consider alternatives like `log`
   - Reuse buffers with `fmt.Fprintf` for repeated formatting
   - Avoid unnecessary string conversions

4. **Custom Formatting**:
   - Implement `Stringer` for custom types
   - Use `Formatter` for complex formatting needs
   - Keep formatting logic simple and readable

5. **Internationalization**:
   - Be careful with formatted strings that might need translation
   - Consider using specialized i18n packages for multilingual apps
   - Avoid concatenating formatted strings for translation

## Conclusion

The `fmt` package is a cornerstone of Go's standard library, providing essential tools for:

1. **Formatted Output**:
   - Printing to console with various formatting options
   - Creating formatted strings for programmatic use
   - Writing formatted data to files and other writers

2. **Input Handling**:
   - Reading and parsing user input
   - Scanning formatted data from strings and readers
   - Converting string representations to Go types

3. **Error Management**:
   - Creating descriptive error messages
   - Wrapping errors with additional context
   - Providing consistent error formatting

4. **Custom Representation**:
   - Implementing custom string representations for types
   - Creating type-specific formatting logic
   - Integrating with Go's printing ecosystem

The task manager example demonstrates how `fmt` can be used to build a complete, interactive command-line application with proper user interaction, file I/O, and error handling. Mastering the `fmt` package is essential for any Go developer working on applications that need to communicate with users or other systems through text-based interfaces.

By understanding and effectively using the `fmt` package, you can:
- Create more user-friendly command-line tools
- Build better logging and debugging systems
- Implement robust data serialization and deserialization
- Improve the overall quality and maintainability of your Go applications

The `fmt` package's simplicity and power make it one of Go's most frequently used and important packages, forming the foundation for much of Go's I/O and text processing capabilities.