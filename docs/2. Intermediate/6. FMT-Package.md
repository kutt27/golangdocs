

# Go FMT Package: Formatted Input and Output

!!! abstract "Overview"
    Master the fmt package - Go's primary tool for formatted I/O operations. Learn printing functions, format verbs, scanning input, and best practices for debugging and user interaction.

!!! tip "Key Points"
    - Provides formatted I/O similar to C's printf family
    - Rich set of format verbs for different data types
    - Functions for printing, scanning, and string formatting
    - Essential for debugging and user interaction
    - Type-safe formatting with compile-time checks

## Understanding the FMT Package

The fmt package is Go's primary tool for formatted input and output operations, offering functions for printing, scanning, and formatting data.

!!! info "FMT Package Components"
    ```mermaid
    graph LR
        A[FMT Package] --> B[Printing Functions]
        A --> C[Scanning Functions]
        A --> D[String Formatting]
        A --> E[Error Formatting]
        B --> F[Print/Println/Printf]
        B --> G[Fprint/Fprintf]
        C --> H[Scan/Scanln/Scanf]
        C --> I[Fscan/Fscanf]
        D --> J[Sprintf/Sprint]
        E --> K[Errorf]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Core Printing Functions

### 1. Basic Output Functions

!!! example "Basic Printing Functions"
    ```go title="basic_printing.go" linenums="1" hl_lines="7-14"
    package main

    import "fmt"

    func main() {
        // Print - writes to standard output without adding a newline
        fmt.Print("Hello, ")
        fmt.Print("World!\n")
        
        // Println - adds a newline between arguments and at the end
        fmt.Println("Hello,", "World!")
        
        // Printf - formatted printing with verbs
        name := "Alice"
        age := 30
        fmt.Printf("Name: %s, Age: %d\n", name, age)
    }
    ```

### 2. Formatting to Strings

!!! example "String Formatting Functions"
    ```go title="string_formatting.go" linenums="1" hl_lines="7-13"
    package main

    import "fmt"

    func main() {
        // Sprintf - formats into a string
        status := fmt.Sprintf("Status: %s (Code: %d)", "OK", 200)
        fmt.Println(status)
        
        // Sprintln - adds newline
        line := fmt.Sprintln("Part 1", "Part 2")
        fmt.Printf("Length: %d, Content: %q", len(line), line)
    }
    ```

### 3. Writing to Different Writers

!!! example "Writing to Different Writers"
    ```go title="different_writers.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "bytes"
        "fmt"
        "os"
    )

    func main() {
        // Fprint - writes to any io.Writer
        var buf bytes.Buffer
        fmt.Fprint(&buf, "Buffer content: ")
        fmt.Fprintln(&buf, 42)
        fmt.Println(buf.String())
        
        // Fprintf - formatted writing
        fmt.Fprintf(os.Stderr, "Error: %s occurred at %v\n", "timeout", time.Now())
    }
    ```

## Input Scanning Functions

### 1. Basic Input Functions

!!! example "Basic Input Functions"
    ```go title="basic_input.go" linenums="1" hl_lines="8-17"
    package main

    import "fmt"

    func main() {
        var name string
        var age int
        
        // Scan - reads space-separated values
        fmt.Print("Enter name and age: ")
        fmt.Scan(&name, &age)
        fmt.Printf("Read: name=%q, age=%d\n", name, age)
        
        // Scanln - reads until newline
        var city string
        fmt.Print("Enter city: ")
        fmt.Scanln(&city)
        fmt.Println("City:", city)
    }
    ```

### 2. Formatted Scanning

!!! example "Formatted Scanning"
    ```go title="formatted_scanning.go" linenums="1" hl_lines="8-16"
    package main

    import "fmt"

    func main() {
        var item string
        var price float64
        var inStock bool
        
        // Sscanf - scans from a string
        input := "Widget 19.99 true"
        fmt.Sscanf(input, "%s %f %t", &item, &price, &inStock)
        fmt.Printf("Item: %s, Price: $%.2f, In Stock: %t\n", item, price, inStock)
    }
    ```

### 3. Scanning from Different Readers

!!! example "Scanning from Readers"
    ```go title="scanning_readers.go" linenums="1" hl_lines="8-15"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        // Fscan - scans from any io.Reader
        input := "123 456"
        reader := strings.NewReader(input)
        var a, b int
        fmt.Fscan(reader, &a, &b)
        fmt.Println("Read:", a, b)
    }
    ```

## Error Handling with `fmt`

### 1. Creating Formatted Errors

!!! example "Formatted Errors"
    ```go title="formatted_errors.go" linenums="1" hl_lines="7-16"
    package main

    import "fmt"

    func processFile(filename string) error {
        if filename == "" {
            return fmt.Errorf("invalid filename: %q", filename)
        }
        // ... processing logic
        return nil
    }

    func main() {
        err := processFile("")
        if err != nil {
            fmt.Println("Error:", err)
        }
    }
    ```

### 2. Error Wrapping

!!! example "Error Wrapping"
    ```go title="error_wrapping.go" linenums="1" hl_lines="7-18"
    package main

    import "fmt"

    func readFile(filename string) error {
        // Simulate file operation
        return fmt.Errorf("readFile failed: %w", 
            fmt.Errorf("permission denied"))
    }

    func main() {
        err := readFile("config.json")
        if err != nil {
            fmt.Println("Full error:", err)
            // In Go 1.13+, you can unwrap errors
            // fmt.Println(errors.Unwrap(err))
        }
    }
    ```

## Custom Formatters

### 1. Implementing `Stringer` Interface

!!! example "Stringer Interface"
    ```go title="stringer_interface.go" linenums="1" hl_lines="8-17"
    package main

    import "fmt"

    type User struct {
        ID    int
        Name  string
        Email string
    }

    func (u User) String() string {
        return fmt.Sprintf("User[%d]: %s <%s>", u.ID, u.Name, u.Email)
    }

    func main() {
        user := User{1, "Alice", "alice@example.com"}
        fmt.Println(user) // Automatically calls String()
    }
    ```

### 2. Implementing `Formatter` Interface

!!! example "Formatter Interface"
    ```go title="formatter_interface.go" linenums="1" hl_lines="8-27"
    package main

    import "fmt"

    type Money float64

    func (m Money) Format(f fmt.State, verb rune) {
        switch verb {
        case 'f':
            fmt.Fprintf(f, "$%.2f", float64(m))
        case 's':
            fmt.Fprintf(f, "$%.2f", float64(m))
        case 'v':
            if f.Flag('+') {
                fmt.Fprintf(f, "Money(%v)", float64(m))
            } else {
                fmt.Fprintf(f, "$%.2f", float64(m))
            }
        default:
            fmt.Fprintf(f, "%v", float64(m))
        }
    }

    func main() {
        price := Money(19.99)
        fmt.Printf("Price: %v\n", price)    // $19.99
        fmt.Printf("Price: %+v\n", price)   // Money(19.99)
        fmt.Printf("Price: %f\n", price)    // $19.99
    }
    ```

## Advanced Formatting Features

### 1. Handling Complex Types

!!! example "Complex Types Formatting"
    ```go title="complex_types.go" linenums="1" hl_lines="7-16"
    package main

    import "fmt"

    func main() {
        // Slices
        nums := []int{1, 2, 3}
        fmt.Printf("Slice: %v\n", nums)     // [1 2 3]
        fmt.Printf("Slice: %#v\n", nums)    // []int{1, 2, 3}
        
        // Maps
        m := map[string]int{"one": 1, "two": 2}
        fmt.Printf("Map: %v\n", m)          // map[one:1 two:2]
        fmt.Printf("Map: %#v\n", m)         // map[string]int{"one":1, "two":2}
        
        // Pointers
        x := 42
        fmt.Printf("Pointer: %p\n", &x)     // 0x1040a124
    }
    ```

### 2. Width and Precision Control

!!! example "Width and Precision"
    ```go title="width_precision.go" linenums="1" hl_lines="7-17"
    package main

    import "fmt"

    func main() {
        // Integer formatting
        fmt.Printf("|%5d|\n", 42)      // |   42|
        fmt.Printf("|%-5d|\n", 42)     // |42   |
        fmt.Printf("|%05d|\n", 42)     // |00042|
        
        // Floating-point formatting
        pi := 3.14159
        fmt.Printf("|%10.2f|\n", pi)   // |      3.14|
        fmt.Printf("|%-10.2f|\n", pi)  // |3.14      |
        
        // String formatting
        s := "hello"
        fmt.Printf("|%10s|\n", s)      // |     hello|
        fmt.Printf("|%-10s|\n", s)     // |hello     |
        fmt.Printf("|%.3s|\n", s)      // |hel|
    }
    ```

### 3. Formatting Flags

!!! example "Formatting Flags"
    ```go title="formatting_flags.go" linenums="1" hl_lines="7-14"
    package main

    import "fmt"

    func main() {
        // Sign flag
        fmt.Printf("|%+d|\n", 42)      // |+42|
        fmt.Printf("|%+d|\n", -42)     // |-42|
        
        // Space flag
        fmt.Printf("|% d|\n", 42)      // | 42|
        fmt.Printf("|% d|\n", -42)     // |-42|
        
        // Alternate format
        fmt.Printf("%#o\n", 8)        // 010
        fmt.Printf("%#x\n", 255)      // 0xff
    }
    ```

## Real-World Example: Interactive CLI Tool

Let's build a practical command-line tool that demonstrates various `fmt` package features:

!!! example "Task Manager CLI"
    ```go title="task_manager.go" linenums="1" hl_lines="8-50"
    package main

    import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"
    )

    type Task struct {
        ID        int
        Title     string
        Completed bool
        DueDate   time.Time
    }

    func (t Task) String() string {
        status := "Pending"
        if t.Completed {
            status = "Completed"
        }
        return fmt.Sprintf("#%d: %s [%s] (Due: %s)", 
            t.ID, t.Title, status, t.DueDate.Format("2006-01-02"))
    }

    type TaskManager struct {
        tasks []Task
        nextID int
    }

    func NewTaskManager() *TaskManager {
        return &TaskManager{
            tasks: make([]Task, 0),
            nextID: 1,
        }
    }

    func (tm *TaskManager) AddTask(title string, dueDate time.Time) {
        task := Task{
            ID:        tm.nextID,
            Title:     title,
            Completed: false,
            DueDate:   dueDate,
        }
        tm.tasks = append(tm.tasks, task)
        tm.nextID++
        fmt.Printf("Added task: %v\n", task)
    }

    func (tm *TaskManager) CompleteTask(id int) error {
        for i := range tm.tasks {
            if tm.tasks[i].ID == id {
                tm.tasks[i].Completed = true
                fmt.Printf("Completed task: %v\n", tm.tasks[i])
                return nil
            }
        }
        return fmt.Errorf("task with ID %d not found", id)
    }

    func (tm *TaskManager) ListTasks() {
        if len(tm.tasks) == 0 {
            fmt.Println("No tasks found.")
            return
        }
        
        fmt.Println("\nTasks:")
        fmt.Println("----------------------------")
        for _, task := range tm.tasks {
            fmt.Printf("%s\n", task)
        }
        fmt.Println("----------------------------")
    }

    func (tm *TaskManager) SaveToFile(filename string) error {
        file, err := os.Create(filename)
        if err != nil {
            return fmt.Errorf("failed to create file: %w", err)
        }
        defer file.Close()
        
        for _, task := range tm.tasks {
            line := fmt.Sprintf("%d,%s,%t,%s\n", 
                task.ID, 
                task.Title, 
                task.Completed, 
                task.DueDate.Format("2006-01-02"))
            fmt.Fprint(file, line)
        }
        
        fmt.Printf("Saved %d tasks to %s\n", len(tm.tasks), filename)
        return nil
    }

    func (tm *TaskManager) LoadFromFile(filename string) error {
        file, err := os.Open(filename)
        if err != nil {
            return fmt.Errorf("failed to open file: %w", err)
        }
        defer file.Close()
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            line := scanner.Text()
            parts := strings.Split(line, ",")
            if len(parts) != 4 {
                fmt.Fprintf(os.Stderr, "Invalid line format: %q\n", line)
                continue
            }
            
            id, _ := strconv.Atoi(parts[0])
            completed, _ := strconv.ParseBool(parts[2])
            dueDate, _ := time.Parse("2006-01-02", parts[3])
            
            task := Task{
                ID:        id,
                Title:     parts[1],
                Completed: completed,
                DueDate:   dueDate,
            }
            
            tm.tasks = append(tm.tasks, task)
            if id >= tm.nextID {
                tm.nextID = id + 1
            }
        }
        
        if err := scanner.Err(); err != nil {
            return fmt.Errorf("error reading file: %w", err)
        }
        
        fmt.Printf("Loaded %d tasks from %s\n", len(tm.tasks), filename)
        return nil
    }

    func displayMenu() {
        fmt.Println("\nTask Manager")
        fmt.Println("1. Add Task")
        fmt.Println("2. Complete Task")
        fmt.Println("3. List Tasks")
        fmt.Println("4. Save Tasks")
        fmt.Println("5. Load Tasks")
        fmt.Println("6. Exit")
        fmt.Print("Enter your choice: ")
    }

    func main() {
        tm := NewTaskManager()
        scanner := bufio.NewScanner(os.Stdin)
        
        for {
            displayMenu()
            
            if !scanner.Scan() {
                break
            }
            
            choice := strings.TrimSpace(scanner.Text())
            
            switch choice {
            case "1":
                fmt.Print("Enter task title: ")
                scanner.Scan()
                title := strings.TrimSpace(scanner.Text())
                
                fmt.Print("Enter due date (YYYY-MM-DD): ")
                scanner.Scan()
                dateStr := strings.TrimSpace(scanner.Text())
                
                dueDate, err := time.Parse("2006-01-02", dateStr)
                if err != nil {
                    fmt.Fprintf(os.Stderr, "Invalid date format: %v\n", err)
                    continue
                }
                
                tm.AddTask(title, dueDate)
                
            case "2":
                fmt.Print("Enter task ID to complete: ")
                scanner.Scan()
                idStr := strings.TrimSpace(scanner.Text())
                
                id, err := strconv.Atoi(idStr)
                if err != nil {
                    fmt.Fprintf(os.Stderr, "Invalid ID: %v\n", err)
                    continue
                }
                
                if err := tm.CompleteTask(id); err != nil {
                    fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                }
                
            case "3":
                tm.ListTasks()
                
            case "4":
                fmt.Print("Enter filename to save: ")
                scanner.Scan()
                filename := strings.TrimSpace(scanner.Text())
                
                if err := tm.SaveToFile(filename); err != nil {
                    fmt.Fprintf(os.Stderr, "Error saving: %v\n", err)
                }
                
            case "5":
                fmt.Print("Enter filename to load: ")
                scanner.Scan()
                filename := strings.TrimSpace(scanner.Text())
                
                if err := tm.LoadFromFile(filename); err != nil {
                    fmt.Fprintf(os.Stderr, "Error loading: %v\n", err)
                }
                
            case "6":
                fmt.Println("Goodbye!")
                return
                
            default:
                fmt.Fprintln(os.Stderr, "Invalid choice. Please try again.")
            }
        }
    }
    ```

### How This Example Demonstrates `fmt` Features:

1. **User Interaction**:
   - Uses `fmt.Print` and `fmt.Println` for prompts and messages
   - `fmt.Fprint` and `fmt.Fprintf` for error output to `os.Stderr`
   - `fmt.Scan` for reading user input

2. **String Formatting**:
   - Custom `String()` method for Task struct
   - `fmt.Sprintf` for building formatted strings
   - Various formatting verbs for different data types

3. **File I/O**:
   - `fmt.Fprint` for writing to files
   - `fmt.Fscanf` could be used for reading (though we use scanner here)
   - Formatted output for saving tasks

4. **Error Handling**:
   - `fmt.Errorf` for creating descriptive errors
   - Error wrapping with `%w` verb
   - Formatted error messages to stderr

5. **Advanced Formatting**:
   - Date formatting with custom layouts
   - Number formatting for IDs
   - Boolean formatting for completion status

## Best Practices

### Choosing the Right Function

!!! tip "Function Selection"
    - Use `Print`/`Println` for simple output
    - Use `Printf` for formatted output
    - Use `Sprintf` when you need a string
    - Use `Fprintf` for writing to files or other writers

### Error Handling

!!! warning "Error Handling"
    Always check errors from `fmt` functions that can return them. Use `fmt.Errorf` for creating descriptive errors and wrap errors with context using `%w`.

!!! example "Error Handling Pattern"
    ```go title="error_handling.go" linenums="1" hl_lines="7-13"
    package main

    import "fmt"

    func processData(data string) error {
        if data == "" {
            return fmt.Errorf("empty data provided")
        }
        // Process data...
        return nil
    }

    func main() {
        err := processData("")
        if err != nil {
            fmt.Printf("Error: %v\n", err)
        }
    }
    ```

### Performance Considerations

!!! warning "Performance"
    For high-performance logging, consider alternatives like `log`. Reuse buffers with `fmt.Fprintf` for repeated formatting and avoid unnecessary string conversions.

!!! example "Efficient String Building"
    ```go title="efficient_formatting.go" linenums="1" hl_lines="7-16"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        var builder strings.Builder
        
        for i := 0; i < 1000; i++ {
            fmt.Fprintf(&builder, "Item %d: %s\n", i, "value")
        }
        
        result := builder.String()
        fmt.Printf("Built string of length %d\n", len(result))
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Basic Printing**: Use `Print`, `Println`, and `Printf` for console output
    - **String Formatting**: Use `Sprintf` and `Sprint` to create formatted strings
    - **File I/O**: Use `Fprint`, `Fprintf`, `Fscan`, and `Fscanf` for file operations
    - **Error Handling**: Use `Errorf` to create descriptive error messages
    - **Custom Formatting**: Implement `Stringer` and `Formatter` interfaces for custom types
    - **Input Scanning**: Use `Scan`, `Scanln`, and `Scanf` to read user input
    - **Width/Precision**: Control formatting with numbers (e.g., `%5.2f`)
    - **Flags**: Modify behavior with `+`, `-`, ` `, `0`, `#`

!!! quote "Remember"
    "The fmt package is the cornerstone of I/O operations in Go. Mastering its functions and formatting verbs enables you to create effective command-line tools, handle user input gracefully, and build robust error handling into your applications."