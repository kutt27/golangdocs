# Go Error Handling: Explicit and Idiomatic

!!! abstract "Overview"
    Master Go's explicit error handling approach. Learn error creation, custom error types, error wrapping, and best practices for building robust applications with clear error management.

!!! tip "Key Points"
    - Errors are values, not exceptions
    - Explicit error checking encourages robust code
    - Custom error types provide rich context
    - Error wrapping preserves error chains
    - Sentinel errors enable error comparison

## Understanding Error Handling

Go treats errors as ordinary values that must be explicitly checked and handled, making error cases visible in code.

!!! info "Error Handling Philosophy"
    ```mermaid
    graph LR
        A[Function Call] --> B[Error Return]
        B --> C[Explicit Check]
        C --> D[Handle or Propagate]
        D --> E[Clear Error Path]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
        style E fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## The Basic Error Type

Go's built-in `error` type is an interface with a single method:

!!! example "Basic Error Type"
    ```go title="basic_error.go" linenums="1" hl_lines="3-5"
    package main

    // The error interface
    type error interface {
        Error() string
    }
    ```

### Creating Simple Errors

!!! example "Error Creation"
    ```go title="error_creation.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "errors"
        "fmt"
    )

    func main() {
        // Using errors.New()
        err1 := errors.New("something went wrong")
        fmt.Println(err1) // "something went wrong"
        
        // Using fmt.Errorf()
        err2 := fmt.Errorf("invalid value: %d", 42)
        fmt.Println(err2) // "invalid value: 42"
    }
    ```

## Error Handling Patterns

### 1. Basic Error Checking

The most common pattern is to check if an error is non-nil:

!!! example "Basic Error Checking"
    ```go title="basic_checking.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "errors"
        "fmt"
    )

    func divide(a, b float64) (float64, error) {
        if b == 0 {
            return 0, errors.New("cannot divide by zero")
        }
        return a / b, nil
    }

    func main() {
        result, err := divide(10, 2)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Println("Result:", result) // 5
    }
    ```

### 2. Handling Errors in Loops

!!! example "Error Handling in Loops"
    ```go title="loop_error_handling.go" linums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
        "errors"
    )

    func processItems(items []string) error {
        for _, item := range items {
            if err := processItem(item); err != nil {
                return fmt.Errorf("failed to process %s: %w", item, err)
            }
        }
        return nil
    }

    func processItem(item string) error {
        // Simulate processing
        if item == "invalid" {
            return errors.New("invalid item")
        }
        fmt.Println("Processed:", item)
        return nil
    }

    func main() {
        items := []string{"item1", "invalid", "item3"}
        err := processItems(items)
        if err != nil {
            fmt.Println("Error:", err)
        }
    }
    ```

### 3. Sentinel Errors

Predefined error values that can be checked with `==`:

!!! example "Sentinel Errors"
    ```go title="sentinel_errors.go" linums="1" hl_lines="6-26"
    package main

    import (
        "errors"
        "fmt"
    )

    var ErrNotFound = errors.New("not found")

    type User struct {
        ID   int
        Name string
    }

    func findUser(id int) (*User, error) {
        // Simulate database lookup
        if id != 1 {
            return nil, ErrNotFound
        }
        return &User{ID: 1, Name: "Alice"}, nil
    }

    func main() {
        user, err := findUser(2)
        if err == ErrNotFound {
            fmt.Println("User not found")
            return
        }
        if err != nil {
            fmt.Println("Other error:", err)
            return
        }
        fmt.Println("Found user:", user.Name)
    }
    ```

## Custom Error Types

### Basic Custom Error

!!! example "Custom Error Type"
    ```go title="custom_error.go" linums="1" hl_lines="8-30"
    package main

    import (
        "fmt"
        "strings"
    )

    type ValidationError struct {
        Field   string
        Message string
    }

    func (e *ValidationError) Error() string {
        return fmt.Sprintf("validation error on field %s: %s", e.Field, e.Message)
    }

    func validateEmail(email string) error {
        if !strings.Contains(email, "@") {
            return &ValidationError{
                Field:   "email",
                Message: "must contain @ symbol",
            }
        }
        return nil
    }

    func main() {
        err := validateEmail("invalid-email")
        if err != nil {
            fmt.Println(err) // "validation error on field email: must contain @ symbol"
            
            // Type assertion to access custom fields
            if ve, ok := err.(*ValidationError); ok {
                fmt.Printf("Field: %s, Message: %s\n", ve.Field, ve.Message)
            }
        }
    }
    ```

### Error Types with Additional Methods

!!! example "Error with Methods"
    ```go title="error_with_methods.go" linums="1" hl_lines="8-32"
    package main

    import (
        "fmt"
        "time"
    )

    type TimeoutError struct {
        Operation string
        Timeout   time.Duration
    }

    func (e *TimeoutError) Error() string {
        return fmt.Sprintf("%s timed out after %v", e.Operation, e.Timeout)
    }

    func (e *TimeoutError) Is(target error) bool {
        _, ok := target.(*TimeoutError)
        return ok
    }

    func (e *TimeoutError) Temporary() bool {
        return true
    }

    func main() {
        err := &TimeoutError{
            Operation: "database query",
            Timeout:   5 * time.Second,
        }
        
        fmt.Println(err) // "database query timed out after 5s"
        
        // Check if error is temporary
        if te, ok := err.(interface{ Temporary() bool }); ok && te.Temporary() {
            fmt.Println("This is a temporary error")
        }
    }
    ```

## Error Wrapping and Unwrapping (Go 1.13+)

### Wrapping Errors

Add context to errors while preserving the original error:

!!! example "Error Wrapping"
    ```go title="error_wrapping.go" linums="1" hl_lines="8-22"
    package main

    import (
        "errors"
        "fmt"
        "os"
    )

    func readFile(filename string) error {
        _, err := os.Open(filename)
        if err != nil {
            return fmt.Errorf("failed to read file %s: %w", filename, err)
        }
        return nil
    }

    func main() {
        err := readFile("nonexistent.txt")
        if err != nil {
            fmt.Println(err) // "failed to read file nonexistent.txt: open nonexistent.txt: no such file or directory"
            
            // Unwrap the error
            unwrapped := errors.Unwrap(err)
            fmt.Println(unwrapped) // "open nonexistent.txt: no such file or directory"
        }
    }
    ```

### Checking Wrapped Errors

Use `errors.Is()` and `errors.As()` to inspect wrapped errors:

!!! example "Checking Wrapped Errors"
    ```go title="checking_wrapped.go" linums="1" hl_lines="8-26"
    package main

    import (
        "errors"
        "fmt"
        "os"
    )

    var ErrPermission = errors.New("permission denied")

    func accessFile(path string) error {
        // Simulate permission error
        return fmt.Errorf("access denied: %w", ErrPermission)
    }

    func main() {
        err := accessFile("/protected/file")
        
        // Check if error is or wraps ErrPermission
        if errors.Is(err, ErrPermission) {
            fmt.Println("Permission denied")
        }
        
        // Check for specific error type
        var pathError *os.PathError
        if errors.As(err, &pathError) {
            fmt.Printf("Path error: %s\n", pathError.Path)
        }
    }
    ```

## Best Practices for Error Handling

### 1. Handle Errors Immediately

Check errors as soon as they're returned:

!!! example "Immediate Handling"
    ```go title="immediate_handling.go" linums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "log"
    )

    // Good
    func process() {
        data, err := fetchData()
        if err != nil {
            log.Printf("Failed to fetch data: %v", err)
            return
        }
        // Use data
    }

    func fetchData() (string, error) {
        return "data", nil
    }
    ```

### 2. Add Context When Wrapping

Provide meaningful context without losing the original error:

!!! example "Contextual Wrapping"
    ```go title="contextual_wrapping.go" linums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
    )

    // Good
    func processUser(id int) error {
        user, err := database.GetUser(id)
        if err != nil {
            return fmt.Errorf("processUser: failed to get user %d: %w", id, err)
        }
        // Process user
        return nil
    }

    // Mock database function
    var database = struct {
        GetUser func(int) (interface{}, error)
    }{
        GetUser: func(id int) (interface{}, error) {
            return nil, fmt.Errorf("user not found")
        },
    }
    ```

### 3. Use Error Types for Programmatic Checks

Custom error types enable precise error handling:

!!! example "Error Type Checks"
    ```go title="error_type_checks.go" linums="1" hl_lines="8-30"
    package main

    import (
        "errors"
        "fmt"
    )

    type RetryableError struct {
        Err error
    }

    func (e *RetryableError) Error() string { return e.Err.Error() }
    func (e *RetryableError) Unwrap() error { return e.Err }

    func processWithRetry() error {
        for i := 0; i < 3; i++ {
            err := doOperation()
            if err == nil {
                return nil
            }
            if errors.As(err, &RetryableError{}) {
                continue // Retry
            }
            return err // Non-retryable error
        }
        return fmt.Errorf("operation failed after 3 retries")
    }

    func doOperation() error {
        return &RetryableError{Err: fmt.Errorf("temporary failure")}
    }

    func main() {
        err := processWithRetry()
        if err != nil {
            fmt.Println("Final error:", err)
        }
    }
    ```

## Common Error Handling Pitfalls

### 1. Ignoring Errors

Never ignore errors without a good reason:

!!! warning "Error Ignoring"
    Always check errors returned by functions. Ignoring errors can lead to silent failures and unexpected behavior.

!!! example "Error Ignoring"
    ```go title="error_ignoring.go" linums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "log"
        "os"
    )

    // Bad
    func badExample() {
        _, _ = os.Open("file.txt") // Error ignored
    }

    // Good - at least log it
    func goodExample() {
        file, err := os.Open("file.txt")
        if err != nil {
            log.Printf("Failed to open file: %v", err)
            return
        }
        defer file.Close()
        fmt.Println("File opened successfully")
    }
    ```

### 2. Over-Wrapping Errors

Don't wrap errors unnecessarily:

!!! warning "Over-Wrapping"
    Avoid wrapping errors multiple times as it can make the error chain difficult to debug.

!!! example "Over-Wrapping"
    ```go title="over_wrapping.go" linums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
    )

    // Bad - redundant wrapping
    func badProcess() error {
        err := doStep1()
        if err != nil {
            return fmt.Errorf("process: step1 failed: %w", err)
        }
        err = doStep2()
        if err != nil {
            return fmt.Errorf("process: step2 failed: %w", err)
        }
        return nil
    }

    // Mock functions
    func doStep1() error { return fmt.Errorf("step1 error") }
    func doStep2() error { return fmt.Errorf("step2 error") }
    ```

### 3. Using Errors for Control Flow

Don't use errors for normal control flow:

!!! warning "Control Flow"
    Use errors for exceptional conditions, not for normal program flow.

!!! example "Control Flow"
    ```go title="control_flow.go" linums="1" hl_lines="8-28"
    package main

    import (
        "encoding/binary"
        "fmt"
        "io"
    )

    // Bad - using error for EOF
    func badReadItems(r io.Reader) ([]int, error) {
        var items []int
        for {
            var item int
            err := binary.Read(r, binary.BigEndian, &item)
            if err != nil {
                if err == io.EOF {
                    return items, nil // Normal end
                }
                return nil, err
            }
            items = append(items, item)
        }
    }

    // Good - handle EOF separately
    func goodReadItems(r io.Reader) ([]int, error) {
        var items []int
        for {
            var item int
            err := binary.Read(r, binary.BigEndian, &item)
            if err != nil {
                if err == io.EOF {
                    break // Normal end
                }
                return nil, err
            }
            items = append(items, item)
        }
        return items, nil
    }
    ```

## Real-World Example: Robust HTTP Service Error Handling

Let's build a complete HTTP service with comprehensive error handling:

!!! example "HTTP Service Error Handling"
    ```go title="http_service_errors.go" linums="1" hl_lines="8-60"
    package main

    import (
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "net/http"
        "time"
    )

    // Custom error types
    type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
    }

    func (e *ValidationError) Error() string {
        return fmt.Sprintf("validation error: %s - %s", e.Field, e.Message)
    }

    type NotFoundError struct {
        Resource string `json:"resource"`
        ID       string `json:"id"`
    }

    func (e *NotFoundError) Error() string {
        return fmt.Sprintf("%s not found: %s", e.Resource, e.ID)
    }

    // API response structure
    type APIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   *APIError   `json:"error,omitempty"`
    }

    type APIError struct {
        Code    string      `json:"code"`
        Message string      `json:"message"`
        Details interface{} `json:"details,omitempty"`
    }

    // User model
    type User struct {
        ID    string `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
    }

    // Mock database
    var users = map[string]*User{
        "1": {ID: "1", Name: "Alice", Email: "alice@example.com"},
        "2": {ID: "2", Name: "Bob", Email: "bob@example.com"},
    }

    // Service functions
    func getUser(id string) (*User, error) {
        user, exists := users[id]
        if !exists {
            return nil, &NotFoundError{Resource: "user", ID: id}
        }
        return user, nil
    }

    func validateUser(user *User) error {
        if user.Name == "" {
            return &ValidationError{Field: "name", Message: "required"}
        }
        if user.Email == "" {
            return &ValidationError{Field: "email", Message: "required"}
        }
        return nil
    }

    // HTTP handler
    func userHandler(w http.ResponseWriter, r *http.Request) {
        id := r.URL.Query().Get("id")
        if id == "" {
            respondWithError(w, http.StatusBadRequest, "missing id parameter")
            return
        }
        
        user, err := getUser(id)
        if err != nil {
            var apiErr APIError
            
            switch {
            case errors.As(err, &ValidationError{}):
                apiErr = APIError{
                    Code:    "VALIDATION_ERROR",
                    Message: err.Error(),
                }
                respondWithError(w, http.StatusBadRequest, apiErr)
            case errors.As(err, &NotFoundError{}):
                apiErr = APIError{
                    Code:    "NOT_FOUND",
                    Message: err.Error(),
                }
                respondWithError(w, http.StatusNotFound, apiErr)
            default:
                apiErr = APIError{
                    Code:    "INTERNAL_ERROR",
                    Message: "failed to get user",
                }
                respondWithError(w, http.StatusInternalServerError, apiErr)
            }
            return
        }
        
        respondWithJSON(w, http.StatusOK, APIResponse{
            Success: true,
            Data:    user,
        })
    }

    // Helper functions
    func respondWithError(w http.ResponseWriter, code int, err interface{}) {
        var apiErr APIError
        
        switch e := err.(type) {
        case string:
            apiErr = APIError{
                Code:    "UNKNOWN_ERROR",
                Message: e,
            }
        case APIError:
            apiErr = e
        default:
            apiErr = APIError{
                Code:    "UNKNOWN_ERROR",
                Message: fmt.Sprintf("%v", err),
            }
        }
        
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)
        json.NewEncoder(w).Encode(APIResponse{
            Success: false,
            Error:   &apiErr,
        })
    }

    func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)
        json.NewEncoder(w).Encode(payload)
    }

    // Logging middleware
    func loggingMiddleware(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            next.ServeHTTP(w, r)
            
            log.Printf(
                "%s %s %v",
				r.Method,
				r.URL.Path,
				time.Since(start),
			)
		})
	}

	func main() {
		// Setup routes
		mux := http.NewServeMux()
		mux.HandleFunc("/user", userHandler)
		
		// Wrap with logging middleware
		handler := loggingMiddleware(mux)
		
		// Start server
		log.Println("Server starting on port 8080...")
		if err := http.ListenAndServe(":8080", handler); err != nil {
			log.Fatalf("Failed to start server: %v", err)
		}
	}
	```

### How This Example Demonstrates Error Handling:

1. **Layered Error Handling**:
   - Service layer returns specific error types
   - Handler layer translates errors to HTTP responses

2. **Custom Error Types**:
   - `ValidationError` for input validation
   - `NotFoundError` for missing resources

3. **Error Translation**:
   - Internal errors are translated to user-friendly API errors
   - HTTP status codes match error types

4. **Logging and Monitoring**:
   - Middleware logs all requests
   - Errors are logged with context

## Best Practices

!!! tip "Error Handling Best Practices"
    - Check errors immediately after function calls
    - Add context when wrapping errors
    - Use custom error types for specific error conditions
    - Provide clear error messages for users
    - Log errors with sufficient context for debugging

!!! example "Best Practice Pattern"
    ```go title="best_practice.go" linums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "log"
    )

    func processData(id string) error {
        // Validate input
        if id == "" {
            return fmt.Errorf("invalid ID: %s", id)
        }
        
        // Get data from database
        data, err := getDataFromDB(id)
        if err != nil {
            return fmt.Errorf("failed to get data: %w", err)
        }
        
        // Process data
        if err := processDataItem(data); err != nil {
            return fmt.Errorf("failed to process data: %w", err)
        }
        
        return nil
    }

    // Mock functions
    func getDataFromDB(id string) (string, error) {
        return "data", nil
    }

    func processDataItem(data string) error {
        return nil
    }

    func main() {
        err := processData("123")
        if err != nil {
            log.Printf("Error processing data: %v", err)
        }
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Error as Values**: Treat errors as return values, not exceptions
    - **Immediate Checking**: Check errors right after function calls
    - **Custom Types**: Create specific error types for different scenarios
    - **Error Wrapping**: Use `fmt.Errorf` with `%w` to preserve error chains
    - **Error Inspection**: Use `errors.Is` and `errors.As` to check wrapped errors
    - **Context Addition**: Add meaningful context when propagating errors
    - **User-Friendly Messages**: Translate technical errors for end users

!!! quote "Remember"
    "Go's explicit error handling makes error paths visible and forces developers to consider failure cases. While it may seem verbose at first, this approach leads to more robust and maintainable code. By creating meaningful error types and wrapping errors with context, you can build systems that are both resilient to failures and easy to debug."