# Go Error Handling: Explicit and Idiomatic

!!! abstract "Overview"
    Master Go's explicit error handling approach. Learn error creation, custom error types, error wrapping, and best practices for building robust applications with clear error management.

!!! tip "Key Points"
    - Errors are values, not exceptions
    - Explicit error checking encourages robust code
    - Custom error types provide rich context
    - Error wrapping preserves error chains
    - Sentinel errors enable error comparison

## Understanding Error Handling

Go treats errors as ordinary values that must be explicitly checked and handled, making error cases visible in code.

## The Basic Error Type
Go's built-in `error` type is an interface with a single method:

```go
type error interface {
    Error() string
}
```

Any type that implements this `Error()` method can be used as an error.

### Creating Simple Errors
```go
package main

import (
    "errors"
    "fmt"
)

func main() {
    // Using errors.New()
    err1 := errors.New("something went wrong")
    fmt.Println(err1) // "something went wrong"
    
    // Using fmt.Errorf()
    err2 := fmt.Errorf("invalid value: %d", 42)
    fmt.Println(err2) // "invalid value: 42"
}
```

## Error Handling Patterns

### 1. Basic Error Checking
The most common pattern is to check if an error is non-nil:

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("cannot divide by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 2)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result) // 5
}
```

### 2. Handling Errors in Loops
```go
func processItems(items []string) error {
    for _, item := range items {
        if err := processItem(item); err != nil {
            return fmt.Errorf("failed to process %s: %w", item, err)
        }
    }
    return nil
}

func processItem(item string) error {
    // Simulate processing
    if item == "invalid" {
        return errors.New("invalid item")
    }
    fmt.Println("Processed:", item)
    return nil
}

func main() {
    items := []string{"item1", "invalid", "item3"}
    err := processItems(items)
    if err != nil {
        fmt.Println("Error:", err)
    }
}
```

### 3. Sentinel Errors
Predefined error values that can be checked with `==`:

```go
var ErrNotFound = errors.New("not found")

func findUser(id int) (*User, error) {
    // Simulate database lookup
    if id != 1 {
        return nil, ErrNotFound
    }
    return &User{ID: 1, Name: "Alice"}, nil
}

func main() {
    user, err := findUser(2)
    if err == ErrNotFound {
        fmt.Println("User not found")
        return
    }
    if err != nil {
        fmt.Println("Other error:", err)
        return
    }
    fmt.Println("Found user:", user.Name)
}
```

## Custom Error Types

### Basic Custom Error
```go
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field %s: %s", e.Field, e.Message)
}

func validateEmail(email string) error {
    if !strings.Contains(email, "@") {
        return &ValidationError{
            Field:   "email",
            Message: "must contain @ symbol",
        }
    }
    return nil
}

func main() {
    err := validateEmail("invalid-email")
    if err != nil {
        fmt.Println(err) // "validation error on field email: must contain @ symbol"
        
        // Type assertion to access custom fields
        if ve, ok := err.(*ValidationError); ok {
            fmt.Printf("Field: %s, Message: %s\n", ve.Field, ve.Message)
        }
    }
}
```

### Error Types with Additional Methods
```go
type TimeoutError struct {
    Operation string
    Timeout   time.Duration
}

func (e *TimeoutError) Error() string {
    return fmt.Sprintf("%s timed out after %v", e.Operation, e.Timeout)
}

func (e *TimeoutError) Is(target error) bool {
    _, ok := target.(*TimeoutError)
    return ok
}

func (e *TimeoutError) Temporary() bool {
    return true
}

func main() {
    err := &TimeoutError{
        Operation: "database query",
        Timeout:   5 * time.Second,
    }
    
    fmt.Println(err) // "database query timed out after 5s"
    
    // Check if error is temporary
    if te, ok := err.(interface{ Temporary() bool }); ok && te.Temporary() {
        fmt.Println("This is a temporary error")
    }
}
```

## Error Wrapping and Unwrapping (Go 1.13+)

### Wrapping Errors
Add context to errors while preserving the original error:

```go
func readFile(filename string) error {
    _, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("failed to read file %s: %w", filename, err)
    }
    return nil
}

func main() {
    err := readFile("nonexistent.txt")
    if err != nil {
        fmt.Println(err) // "failed to read file nonexistent.txt: open nonexistent.txt: no such file or directory"
        
        // Unwrap the error
        unwrapped := errors.Unwrap(err)
        fmt.Println(unwrapped) // "open nonexistent.txt: no such file or directory"
    }
}
```

### Checking Wrapped Errors
Use `errors.Is()` and `errors.As()` to inspect wrapped errors:

```go
var ErrPermission = errors.New("permission denied")

func accessFile(path string) error {
    // Simulate permission error
    return fmt.Errorf("access denied: %w", ErrPermission)
}

func main() {
    err := accessFile("/protected/file")
    
    // Check if error is or wraps ErrPermission
    if errors.Is(err, ErrPermission) {
        fmt.Println("Permission denied")
    }
    
    // Check for specific error type
    var pathError *os.PathError
    if errors.As(err, &pathError) {
        fmt.Printf("Path error: %s\n", pathError.Path)
    }
}
```

## Best Practices for Error Handling

### 1. Handle Errors Immediately
Check errors as soon as they're returned:

```go
// Good
func process() {
    data, err := fetchData()
    if err != nil {
        log.Printf("Failed to fetch data: %v", err)
        return
    }
    // Use data
}

// Bad - error handling deferred
func process() {
    data, _ := fetchData() // Ignoring error!
    // Use data - might panic or behave unexpectedly
}
```

### 2. Add Context When Wrapping
Provide meaningful context without losing the original error:

```go
// Good
func processUser(id int) error {
    user, err := database.GetUser(id)
    if err != nil {
        return fmt.Errorf("processUser: failed to get user %d: %w", id, err)
    }
    // Process user
    return nil
}

// Bad - loses original error
func processUser(id int) error {
    user, err := database.GetUser(id)
    if err != nil {
        return errors.New("failed to get user")
    }
    // Process user
    return nil
}
```

### 3. Use Error Types for Programmatic Checks
Custom error types enable precise error handling:

```go
type RetryableError struct {
    Err error
}

func (e *RetryableError) Error() string { return e.Err.Error() }
func (e *RetryableError) Unwrap() error { return e.Err }

func processWithRetry() error {
    for i := 0; i < 3; i++ {
        err := doOperation()
        if err == nil {
            return nil
        }
        if errors.As(err, &RetryableError{}) {
            continue // Retry
        }
        return err // Non-retryable error
    }
    return fmt.Errorf("operation failed after 3 retries")
}
```

### 4. Document Error Behavior
Clearly document what errors a function can return:

```go
// ParseInt parses a string into an integer.
// Returns strconv.ErrSyntax if the string is not a valid integer,
// or strconv.ErrRange if the integer is out of range.
func ParseInt(s string) (int, error) {
    // Implementation
}
```

## Common Error Handling Pitfalls

### 1. Ignoring Errors
Never ignore errors without a good reason:

```go
// Bad
_, _ = os.Open("file.txt") // Error ignored

// Good - at least log it
file, err := os.Open("file.txt")
if err != nil {
    log.Printf("Failed to open file: %v", err)
    return
}
defer file.Close()
```

### 2. Over-Wrapping Errors
Don't wrap errors unnecessarily:

```go
// Bad - redundant wrapping
func process() error {
    err := doStep1()
    if err != nil {
        return fmt.Errorf("process: step1 failed: %w", err)
    }
    err = doStep2()
    if err != nil {
        return fmt.Errorf("process: step2 failed: %w", err)
    }
    return nil
}

// Good - wrap only at the top level
func process() error {
    if err := doStep1(); err != nil {
        return err
    }
    if err := doStep2(); err != nil {
        return err
    }
    return nil
}
```

### 3. Using Errors for Control Flow
Don't use errors for normal control flow:

```go
// Bad - using error for EOF
func readItems(r io.Reader) ([]Item, error) {
    var items []Item
    for {
        var item Item
        err := binary.Read(r, binary.BigEndian, &item)
        if err != nil {
            if err == io.EOF {
                return items, nil // Normal end
            }
            return nil, err
        }
        items = append(items, item)
    }
}

// Good - handle EOF separately
func readItems(r io.Reader) ([]Item, error) {
    var items []Item
    for {
        var item Item
        err := binary.Read(r, binary.BigEndian, &item)
        if err != nil {
            if err == io.EOF {
                break // Normal end
            }
            return nil, err
        }
        items = append(items, item)
    }
    return items, nil
}
```

## Real-World Example: Robust HTTP Service Error Handling

Let's build a complete HTTP service with comprehensive error handling:

```go
package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"
)

// Custom error types
type ValidationError struct {
	Field   string `json:"field"`
	Message string `json:"message"`
}

func (e *ValidationError) Error() string {
	return fmt.Sprintf("validation error: %s - %s", e.Field, e.Message)
}

type NotFoundError struct {
	Resource string `json:"resource"`
	ID       string `json:"id"`
}

func (e *NotFoundError) Error() string {
	return fmt.Sprintf("%s not found: %s", e.Resource, e.ID)
}

type DatabaseError struct {
	Operation string
	Err       error
}

func (e *DatabaseError) Error() string {
	return fmt.Sprintf("database error during %s: %v", e.Operation, e.Err)
}

func (e *DatabaseError) Unwrap() error {
	return e.Err
}

// API response structure
type APIResponse struct {
	Success bool        `json:"success"`
	Data    interface{} `json:"data,omitempty"`
	Error   *APIError   `json:"error,omitempty"`
}

type APIError struct {
	Code    string      `json:"code"`
	Message string      `json:"message"`
	Details interface{} `json:"details,omitempty"`
}

// User model
type User struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

// Database simulation
type Database struct {
	users map[string]*User
}

func NewDatabase() *Database {
	return &Database{
		users: map[string]*User{
			"1": {ID: "1", Name: "Alice", Email: "alice@example.com"},
			"2": {ID: "2", Name: "Bob", Email: "bob@example.com"},
		},
	}
}

func (db *Database) GetUser(id string) (*User, error) {
	user, exists := db.users[id]
	if !exists {
		return nil, &NotFoundError{Resource: "user", ID: id}
	}
	return user, nil
}

func (db *Database) CreateUser(user *User) error {
	if user.ID == "" {
		return &ValidationError{Field: "id", Message: "required"}
	}
	if user.Name == "" {
		return &ValidationError{Field: "name", Message: "required"}
	}
	if user.Email == "" {
		return &ValidationError{Field: "email", Message: "required"}
	}
	
	if _, exists := db.users[user.ID]; exists {
		return &DatabaseError{
			Operation: "create user",
			Err:       fmt.Errorf("user already exists"),
		}
	}
	
	db.users[user.ID] = user
	return nil
}

// Service layer
type UserService struct {
	db *Database
}

func NewUserService(db *Database) *UserService {
	return &UserService{db: db}
}

func (s *UserService) GetUser(id string) (*User, error) {
	if id == "" {
		return nil, &ValidationError{Field: "id", Message: "required"}
	}
	
	user, err := s.db.GetUser(id)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	
	return user, nil
}

func (s *UserService) CreateUser(user *User) error {
	if err := validateUser(user); err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}
	
	if err := s.db.CreateUser(user); err != nil {
		return fmt.Errorf("failed to create user: %w", err)
	}
	
	return nil
}

func validateUser(user *User) error {
	if user.ID == "" {
		return &ValidationError{Field: "id", Message: "required"}
	}
	if user.Name == "" {
		return &ValidationError{Field: "name", Message: "required"}
	}
	if user.Email == "" {
		return &ValidationError{Field: "email", Message: "required"}
	}
	if !strings.Contains(user.Email, "@") {
		return &ValidationError{Field: "email", Message: "invalid format"}
	}
	return nil
}

// HTTP handlers
type UserHandler struct {
	service *UserService
}

func NewUserHandler(service *UserService) *UserHandler {
	return &UserHandler{service: service}
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
	id := r.URL.Query().Get("id")
	if id == "" {
		respondWithError(w, http.StatusBadRequest, "missing id parameter")
		return
	}
	
	user, err := h.service.GetUser(id)
	if err != nil {
		var apiErr APIError
		
		switch {
		case errors.As(err, &ValidationError{}):
			apiErr = APIError{
				Code:    "VALIDATION_ERROR",
				Message: err.Error(),
			}
			respondWithError(w, http.StatusBadRequest, apiErr)
		case errors.As(err, &NotFoundError{}):
			apiErr = APIError{
				Code:    "NOT_FOUND",
				Message: err.Error(),
			}
			respondWithError(w, http.StatusNotFound, apiErr)
		default:
			apiErr = APIError{
				Code:    "INTERNAL_ERROR",
				Message: "failed to get user",
			}
			respondWithError(w, http.StatusInternalServerError, apiErr)
		}
		return
	}
	
	respondWithJSON(w, http.StatusOK, APIResponse{
		Success: true,
		Data:    user,
	})
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
	var user User
	if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
		respondWithError(w, http.StatusBadRequest, "invalid request body")
		return
	}
	
	if err := h.service.CreateUser(&user); err != nil {
		var apiErr APIError
		
		switch {
		case errors.As(err, &ValidationError{}):
			var ve *ValidationError
			if errors.As(err, &ve) {
				apiErr = APIError{
					Code:    "VALIDATION_ERROR",
					Message: "validation failed",
					Details: ve,
				}
			}
			respondWithError(w, http.StatusBadRequest, apiErr)
		case errors.As(err, &DatabaseError{}):
			apiErr = APIError{
				Code:    "DATABASE_ERROR",
				Message: "failed to create user",
			}
			respondWithError(w, http.StatusInternalServerError, apiErr)
		default:
			apiErr = APIError{
				Code:    "INTERNAL_ERROR",
				Message: "failed to create user",
			}
			respondWithError(w, http.StatusInternalServerError, apiErr)
		}
		return
	}
	
	respondWithJSON(w, http.StatusCreated, APIResponse{
		Success: true,
		Data:    user,
	})
}

// Helper functions
func respondWithError(w http.ResponseWriter, code int, err interface{}) {
	var apiErr APIError
	
	switch e := err.(type) {
	case string:
		apiErr = APIError{
			Code:    "UNKNOWN_ERROR",
			Message: e,
		}
	case APIError:
		apiErr = e
	default:
		apiErr = APIError{
			Code:    "UNKNOWN_ERROR",
			Message: fmt.Sprintf("%v", err),
		}
	}
	
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(APIResponse{
		Success: false,
		Error:   &apiErr,
	})
}

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(payload)
}

// Logging middleware
func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		
		// Wrap the response writer to capture status code
		lrw := &loggingResponseWriter{w, http.StatusOK}
		
		next.ServeHTTP(lrw, r)
		
		log.Printf(
			"%s %s %d %v",
			r.Method,
			r.URL.Path,
			lrw.statusCode,
			time.Since(start),
		)
	})
}

type loggingResponseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (lrw *loggingResponseWriter) WriteHeader(code int) {
	lrw.statusCode = code
	lrw.ResponseWriter.WriteHeader(code)
}

func main() {
	// Setup dependencies
	db := NewDatabase()
	userService := NewUserService(db)
	userHandler := NewUserHandler(userService)
	
	// Setup routes
	mux := http.NewServeMux()
	mux.HandleFunc("/users", userHandler.GetUser)
	mux.HandleFunc("/users/create", userHandler.CreateUser)
	
	// Wrap with logging middleware
	handler := loggingMiddleware(mux)
	
	// Start server
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	
	log.Printf("Server starting on port %s...", port)
	if err := http.ListenAndServe(":"+port, handler); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}
```

### How This Example Demonstrates Error Handling:

1. **Layered Error Handling**:
   - Database layer returns specific error types
   - Service layer adds context and wraps errors
   - Handler layer translates errors to HTTP responses

2. **Custom Error Types**:
   - `ValidationError` for input validation
   - `NotFoundError` for missing resources
   - `DatabaseError` for database operations

3. **Error Wrapping**:
   - Each layer adds context with `fmt.Errorf` and `%w`
   - Original errors are preserved for inspection

4. **Error Translation**:
   - Internal errors are translated to user-friendly API errors
   - HTTP status codes match error types

5. **Logging and Monitoring**:
   - Middleware logs all requests with status codes
   - Errors are logged with context

### Real-World Applications:

1. **API Development**:
   - Consistent error responses across endpoints
   - Proper HTTP status codes
   - Detailed error information for debugging

2. **Microservices**:
   - Error propagation between services
   - Structured error logging
   - Circuit breaker patterns

3. **Database Operations**:
   - Handling connection errors
   - Constraint violations
   - Transaction rollbacks

4. **User Input Validation**:
   - Clear validation error messages
   - Field-specific error details
   - Internationalization support

## Conclusion

Error handling is a critical aspect of Go programming that requires careful attention. By following Go's explicit error handling model, you can create more robust and maintainable applications. Key takeaways:

1. **Embrace Explicit Error Handling**:
   - Check errors immediately
   - Don't ignore errors without reason
   - Make error paths visible in your code

2. **Use Custom Error Types**:
   - Create specific error types for different failure modes
   - Include relevant context in error types
   - Implement additional methods for programmatic checks

3. **Wrap Errors Thoughtfully**:
   - Add context without losing the original error
   - Use `fmt.Errorf` with `%w` for error wrapping
   - Avoid over-wrapping errors

4. **Handle Errors Appropriately**:
   - Translate errors for different contexts (e.g., API responses)
   - Log errors with sufficient context
   - Provide meaningful error messages to users

5. **Design Error-Resilient Systems**:
   - Consider retry mechanisms for transient errors
   - Implement graceful degradation
   - Monitor error rates and patterns

The HTTP service example demonstrates how to build a comprehensive error handling system that provides clear feedback to both developers and users while maintaining the integrity of the application. By following these patterns, you can create Go applications that handle failures gracefully and provide excellent debugging information when things go wrong.