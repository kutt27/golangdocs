

# File I/O in Go: Reading and Writing Files

## Introduction to File Operations in Go
File input/output (I/O) is a fundamental aspect of many applications. Go provides a rich set of packages for file operations, primarily through the `os`, `io`, and `bufio` packages. This guide covers reading from and writing to files, handling different file modes, error handling, and best practices.

## Basic File Operations

### 1. Creating and Writing Files
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// Create a new file
	file, err := os.Create("example.txt")
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close() // Ensure file is closed when done

	// Write a string to the file
	_, err = file.WriteString("Hello, World!\n")
	if err != nil {
		fmt.Println("Error writing to file:", err)
		return
	}

	// Write bytes to the file
	_, err = file.Write([]byte("This is a byte slice.\n"))
	if err != nil {
		fmt.Println("Error writing bytes:", err)
		return
	}

	fmt.Println("File created and written successfully")
}
```

### 2. Reading Files
```go
func main() {
	// Open the file for reading
	file, err := os.Open("example.txt")
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer file.Close()

	// Read the entire file content
	content, err := os.ReadFile("example.txt")
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	fmt.Println("File content:")
	fmt.Println(string(content))
}
```

## File Opening Modes

### 1. Different Open Flags
Go provides various flags for opening files with different modes:

```go
func main() {
	// Open file with different modes
	flags := []struct {
		name string
		flag int
		mode string
	}{
		{"Read Only", os.O_RDONLY, "r"},
		{"Write Only", os.O_WRONLY, "w"},
		{"Read Write", os.O_RDWR, "rw"},
		{"Append", os.O_APPEND, "a"},
		{"Create", os.O_CREATE, "create"},
		{"Truncate", os.O_TRUNC, "truncate"},
		{"Exclusive", os.O_EXCL, "exclusive"},
	}

	for _, f := range flags {
		fmt.Printf("%-12s: %d (%s)\n", f.name, f.flag, f.mode)
	}
}
```

### 2. Using OpenFile with Flags
```go
func main() {
	// Open file in append mode
	file, err := os.OpenFile("example.txt", os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer file.Close()

	// Append content
	_, err = file.WriteString("Appended content.\n")
	if err != nil {
		fmt.Println("Error appending to file:", err)
		return
	}

	fmt.Println("Content appended successfully")
}
```

## Buffered I/O with bufio

### 1. Buffered Writing
```go
func main() {
	// Create file
	file, err := os.Create("buffered_example.txt")
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	// Create buffered writer
	writer := bufio.NewWriter(file)
	defer writer.Flush() // Ensure all buffered data is written

	// Write multiple lines
	lines := []string{
		"First line",
		"Second line",
		"Third line",
	}

	for _, line := range lines {
		_, err := writer.WriteString(line + "\n")
		if err != nil {
			fmt.Println("Error writing:", err)
			return
		}
	}

	fmt.Println("Buffered writing completed")
}
```

### 2. Buffered Reading
```go
func main() {
	// Open file
	file, err := os.Open("buffered_example.txt")
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer file.Close()

	// Create buffered reader
	reader := bufio.NewReader(file)

	// Read line by line
	fmt.Println("Reading file line by line:")
	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			fmt.Println("Error reading:", err)
			return
		}
		fmt.Print(line)
	}
}
```

### 3. Using Scanner for Line-by-Line Reading
```go
func main() {
	// Open file
	file, err := os.Open("buffered_example.txt")
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer file.Close()

	// Create scanner
	scanner := bufio.NewScanner(file)

	// Read line by line
	fmt.Println("Using scanner:")
	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		fmt.Println("Scanner error:", err)
	}
}
```

## Working with Different File Formats

### 1. JSON Files
```go
type Person struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	// Write JSON file
	people := []Person{
		{"Alice", 30},
		{"Bob", 25},
		{"Charlie", 35},
	}

	// Marshal to JSON
	jsonData, err := json.MarshalIndent(people, "", "  ")
	if err != nil {
		fmt.Println("Error marshaling JSON:", err)
		return
	}

	// Write to file
	err = os.WriteFile("people.json", jsonData, 0644)
	if err != nil {
		fmt.Println("Error writing JSON file:", err)
		return
	}

	// Read JSON file
	var readPeople []Person
	data, err := os.ReadFile("people.json")
	if err != nil {
		fmt.Println("Error reading JSON file:", err)
		return
	}

	err = json.Unmarshal(data, &readPeople)
	if err != nil {
		fmt.Println("Error unmarshaling JSON:", err)
		return
	}

	fmt.Println("Read from JSON file:")
	for _, person := range readPeople {
		fmt.Printf("%s is %d years old\n", person.Name, person.Age)
	}
}
```

### 2. CSV Files
```go
func main() {
	// Write CSV file
	file, err := os.Create("data.csv")
	if err != nil {
		fmt.Println("Error creating CSV file:", err)
		return
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	// Write header
	err = writer.Write([]string{"Name", "Age", "City"})
	if err != nil {
		fmt.Println("Error writing header:", err)
		return
	}

	// Write records
	records := [][]string{
		{"Alice", "30", "New York"},
		{"Bob", "25", "Los Angeles"},
		{"Charlie", "35", "Chicago"},
	}

	for _, record := range records {
		err = writer.Write(record)
		if err != nil {
			fmt.Println("Error writing record:", err)
			return
		}
	}

	// Read CSV file
	file, err = os.Open("data.csv")
	if err != nil {
		fmt.Println("Error opening CSV file:", err)
		return
	}
	defer file.Close()

	reader := csv.NewReader(file)
	records, err = reader.ReadAll()
	if err != nil {
		fmt.Println("Error reading CSV:", err)
		return
	}

	fmt.Println("\nRead from CSV file:")
	for i, record := range records {
		if i == 0 {
			fmt.Printf("Header: %v\n", record)
		} else {
			fmt.Printf("Record: %v\n", record)
		}
	}
}
```

## Directory Operations

### 1. Creating Directories
```go
func main() {
	// Create single directory
	err := os.Mkdir("testdir", 0755)
	if err != nil {
		fmt.Println("Error creating directory:", err)
	}

	// Create nested directories (MkdirAll)
	err = os.MkdirAll("testdir/nested1/nested2", 0755)
	if err != nil {
		fmt.Println("Error creating nested directories:", err)
	}

	fmt.Println("Directories created")
}
```

### 2. Reading Directory Contents
```go
func main() {
	// Open directory
	dir, err := os.Open(".")
	if err != nil {
		fmt.Println("Error opening directory:", err)
		return
	}
	defer dir.Close()

	// Read directory contents
	names, err := dir.Readdirnames(-1)
	if err != nil {
		fmt.Println("Error reading directory:", err)
		return
	}

	fmt.Println("Directory contents:")
	for _, name := range names {
		fmt.Println(name)
	}
}
```

### 3. Walking Directory Tree
```go
func main() {
	// Walk directory tree
	err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		fmt.Println(path)
		return nil
	})
	if err != nil {
		fmt.Println("Error walking directory:", err)
	}
}
```

## Temporary Files

### 1. Creating Temporary Files
```go
func main() {
	// Create temporary file
	tempFile, err := os.CreateTemp("", "example-*.txt")
	if err != nil {
		fmt.Println("Error creating temp file:", err)
		return
	}
	defer os.Remove(tempFile.Name()) // Clean up

	fmt.Println("Temporary file created:", tempFile.Name())

	// Write to temp file
	_, err = tempFile.WriteString("This is temporary content")
	if err != nil {
		fmt.Println("Error writing to temp file:", err)
		return
	}

	// Read from temp file
	content, err := os.ReadFile(tempFile.Name())
	if err != nil {
		fmt.Println("Error reading temp file:", err)
		return
	}

	fmt.Println("Temp file content:", string(content))
}
```

### 2. Temporary Directories
```go
func main() {
	// Create temporary directory
	tempDir, err := os.MkdirTemp("", "example-")
	if err != nil {
		fmt.Println("Error creating temp directory:", err)
		return
	}
	defer os.RemoveAll(tempDir) // Clean up

	fmt.Println("Temporary directory created:", tempDir)

	// Create a file in temp directory
	tempFile := filepath.Join(tempDir, "test.txt")
	err = os.WriteFile(tempFile, []byte("Hello from temp dir"), 0644)
	if err != nil {
		fmt.Println("Error creating file in temp dir:", err)
		return
	}

	// Read the file
	content, err := os.ReadFile(tempFile)
	if err != nil {
		fmt.Println("Error reading file in temp dir:", err)
		return
	}

	fmt.Println("File in temp dir content:", string(content))
}
```

## Error Handling in File Operations

### 1. Common File Errors
```go
func safeFileOperation(filename string) error {
	// Try to open file
	file, err := os.Open(filename)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("file does not exist: %w", err)
		}
		if os.IsPermission(err) {
			return fmt.Errorf("permission denied: %w", err)
		}
		return fmt.Errorf("error opening file: %w", err)
	}
	defer file.Close()

	// Read file content
	_, err = io.ReadAll(file)
	if err != nil {
		return fmt.Errorf("error reading file: %w", err)
	}

	return nil
}

func main() {
	err := safeFileOperation("nonexistent.txt")
	if err != nil {
		fmt.Println("File operation error:", err)
	}
}
```

### 2. Retry Mechanism for File Operations
```go
func retryFileOperation(operation func() error, maxRetries int) error {
	var err error
	for i := 0; i < maxRetries; i++ {
		err = operation()
		if err == nil {
			return nil
		}
		
		// Check if it's a retryable error
		if os.IsPermission(err) || os.IsExist(err) {
			time.Sleep(time.Second * time.Duration(i+1))
			continue
		}
		
		// Non-retryable error
		return err
	}
	
	return fmt.Errorf("operation failed after %d retries: %w", maxRetries, err)
}

func main() {
	// Example: Try to create a file that might be locked
	err := retryFileOperation(func() error {
		file, err := os.Create("locked_file.txt")
		if err != nil {
			return err
		}
		file.Close()
		return nil
	}, 3)
	
	if err != nil {
		fmt.Println("Error after retries:", err)
	}
}
```

## Real-World Example: Log Rotator

Let's build a simple log rotator that demonstrates various file operations:

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// LogRotator handles log file rotation
type LogRotator struct {
	basePath    string
	maxSize     int64
	maxBackups  int
	currentFile *os.File
	currentSize int64
}

// NewLogRotator creates a new log rotator
func NewLogRotator(basePath string, maxSize int64, maxBackups int) *LogRotator {
	return &LogRotator{
		basePath:   basePath,
		maxSize:    maxSize,
		maxBackups: maxBackups,
	}
}

// Open opens the current log file or creates a new one
func (lr *LogRotator) Open() error {
	// Try to open existing file
	file, err := os.OpenFile(lr.basePath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		return fmt.Errorf("failed to open log file: %w", err)
	}
	
	// Get current file size
	info, err := file.Stat()
	if err != nil {
		file.Close()
		return fmt.Errorf("failed to get file info: %w", err)
	}
	
	lr.currentFile = file
	lr.currentSize = info.Size()
	
	// Check if rotation is needed
	if lr.currentSize >= lr.maxSize {
		if err := lr.rotate(); err != nil {
			file.Close()
			return err
		}
	}
	
	return nil
}

// Write writes data to the log file
func (lr *LogRotator) Write(p []byte) (int, error) {
	if lr.currentFile == nil {
		if err := lr.Open(); err != nil {
			return 0, err
		}
	}
	
	// Check if rotation is needed
	if lr.currentSize+int64(len(p)) >= lr.maxSize {
		if err := lr.rotate(); err != nil {
			return 0, err
		}
	}
	
	n, err := lr.currentFile.Write(p)
	if err != nil {
		return n, err
	}
	
	lr.currentSize += int64(n)
	return n, nil
}

// Close closes the current log file
func (lr *LogRotator) Close() error {
	if lr.currentFile != nil {
		return lr.currentFile.Close()
	}
	return nil
}

// rotate performs log rotation
func (lr *LogRotator) rotate() error {
	// Close current file
	if lr.currentFile != nil {
		lr.currentFile.Close()
	}
	
	// Rotate existing backup files
	for i := lr.maxBackups - 1; i >= 0; i-- {
		oldPath := lr.backupPath(i)
		newPath := lr.backupPath(i + 1)
		
		if _, err := os.Stat(oldPath); err == nil {
			if i == lr.maxBackups-1 {
				// Remove the oldest backup
				os.Remove(oldPath)
			} else {
				// Rename the backup
				os.Rename(oldPath, newPath)
			}
		}
	}
	
	// Rename current file to backup
	if _, err := os.Stat(lr.basePath); err == nil {
		os.Rename(lr.basePath, lr.backupPath(0))
	}
	
	// Create new file
	file, err := os.OpenFile(lr.basePath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		return fmt.Errorf("failed to create new log file: %w", err)
	}
	
	lr.currentFile = file
	lr.currentSize = 0
	
	return nil
}

// backupPath returns the path for a backup file
func (lr *LogRotator) backupPath(index int) string {
	if index == 0 {
		return lr.basePath + ".1"
	}
	return fmt.Sprintf("%s.%d", lr.basePath, index+1)
}

// WriteString writes a string to the log file
func (lr *LogRotator) WriteString(s string) (int, error) {
	return lr.Write([]byte(s))
}

// WriteLine writes a line to the log file
func (lr *LogRotator) WriteLine(line string) error {
	_, err := lr.WriteString(line + "\n")
	return err
}

func main() {
	// Create log rotator
	rotator := NewLogRotator("app.log", 1024, 3) // 1KB max size, 3 backups
	
	// Open log file
	if err := rotator.Open(); err != nil {
		fmt.Println("Error opening log rotator:", err)
		return
	}
	defer rotator.Close()
	
	// Write log entries
	logEntries := []string{
		"INFO: Application started",
		"INFO: Processing request",
		"DEBUG: Processing data",
		"INFO: Request processed successfully",
		"WARNING: High memory usage detected",
		"ERROR: Database connection failed",
		"INFO: Retrying database connection",
		"INFO: Database connection restored",
		"INFO: Application shutting down",
	}
	
	for _, entry := range logEntries {
		timestamp := time.Now().Format("2006-01-02 15:04:05")
		logLine := fmt.Sprintf("[%s] %s", timestamp, entry)
		
		if err := rotator.WriteLine(logLine); err != nil {
			fmt.Println("Error writing log entry:", err)
			continue
		}
		
		fmt.Printf("Logged: %s\n", entry)
		
		// Small delay to simulate real logging
		time.Sleep(100 * time.Millisecond)
	}
	
	// List all log files
	fmt.Println("\nLog files created:")
	matches, err := filepath.Glob("app.log*")
	if err != nil {
		fmt.Println("Error listing log files:", err)
		return
	}
	
	for _, match := range matches {
		info, err := os.Stat(match)
		if err != nil {
			fmt.Println("Error getting file info:", err)
			continue
		}
		
		fmt.Printf("%s (%d bytes)\n", match, info.Size())
		
		// Show first few lines of each file
		file, err := os.Open(match)
		if err != nil {
			fmt.Println("Error opening file:", err)
			continue
		}
		
		scanner := bufio.NewScanner(file)
		lineCount := 0
		for scanner.Scan() && lineCount < 3 {
			fmt.Printf("  %s\n", scanner.Text())
			lineCount++
		}
		file.Close()
		
		if lineCount >= 3 {
			fmt.Println("  ...")
		}
	}
	
	// Clean up
	os.RemoveAll("app.log")
}
```

### How This Example Works:

1. **Log Rotation Logic**:
   - Monitors log file size and rotates when it exceeds the limit
   - Maintains a specified number of backup files
   - Renames existing backups to make room for new ones

2. **File Operations**:
   - Creates, opens, writes to, and closes files
   - Renames files for rotation
   - Handles file size tracking

3. **Error Handling**:
   - Gracefully handles file operation errors
   - Ensures files are properly closed
   - Provides meaningful error messages

4. **Directory Management**:
   - Works with file paths and backups
   - Lists and manages multiple log files
   - Demonstrates file system operations

### Real-World Applications:

1. **Logging Systems**:
   - Application logging with rotation
   - Log file management
   - Archive and cleanup

2. **Data Processing**:
   - Batch file processing
   - Data transformation
   - File format conversion

3. **Backup Systems**:
   - File backup and rotation
   - Version management
   - Storage optimization

## Best Practices

### 1. Always Close Files
```go
// Good: Use defer to ensure files are closed
func processFile(filename string) error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close() // Ensure file is closed
	
	// Process file...
	return nil
}

// Bad: Forgetting to close files
func processFileBad(filename string) error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	// No defer - file might not be closed if error occurs
	// Process file...
	return nil
}
```

### 2. Use Buffered I/O for Performance
```go
// Good: Use buffered I/O for frequent operations
func writeManyLines(filename string, lines []string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()
	
	writer := bufio.NewWriter(file)
	defer writer.Flush()
	
	for _, line := range lines {
		_, err := writer.WriteString(line + "\n")
		if err != nil {
			return err
		}
	}
	
	return nil
}

// Bad: Unbuffered writes for many operations
func writeManyLinesBad(filename string, lines []string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()
	
	for _, line := range lines {
		_, err := file.WriteString(line + "\n") // System call for each line
		if err != nil {
			return err
		}
	}
	
	return nil
}
```

### 3. Handle Errors Properly
```go
// Good: Handle specific errors
func readFile(filename string) ([]byte, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("file not found: %s", filename)
		}
		if os.IsPermission(err) {
			return nil, fmt.Errorf("permission denied: %s", filename)
		}
		return nil, fmt.Errorf("failed to read file: %w", err)
	}
	return data, nil
}

// Bad: Generic error handling
func readFileBad(filename string) ([]byte, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, err // No context about what went wrong
	}
	return data, nil
}
```

### 4. Use Appropriate File Permissions
```go
// Good: Use appropriate permissions
func createConfigFile() error {
	// 0600: Read/write for owner only
	return os.WriteFile("config.json", configData, 0600)
}

func createLogFile() error {
	// 0644: Read/write for owner, read for others
	return os.WriteFile("app.log", logData, 0644)
}

func createExecutable() error {
	// 0755: Read/write/execute for owner, read/execute for others
	return os.WriteFile("myapp", binaryData, 0755)
}
```

## Performance Considerations

### 1. Buffer Size Optimization
```go
// Adjust buffer size based on use case
func copyFileWithBufferSize(src, dst string, bufferSize int) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()
	
	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()
	
	// Use custom buffer size
	buf := make([]byte, bufferSize)
	_, err = io.CopyBuffer(dstFile, srcFile, buf)
	return err
}
```

### 2. Concurrent File Operations
```go
// Process multiple files concurrently
func processFilesConcurrently(filenames []string) error {
	var wg sync.WaitGroup
	errChan := make(chan error, len(filenames))
	
	for _, filename := range filenames {
		wg.Add(1)
		go func(fname string) {
			defer wg.Done()
			
			// Process file
			if err := processSingleFile(fname); err != nil {
				errChan <- err
			}
		}(filename)
	}
	
	// Wait for all goroutines to complete
	wg.Wait()
	close(errChan)
	
	// Check for errors
	for err := range errChan {
		if err != nil {
			return err
		}
	}
	
	return nil
}
```

## Conclusion

File I/O is a critical aspect of many Go applications. The `os`, `io`, and `bufio` packages provide comprehensive tools for:

1. **Basic File Operations**:
   - Creating, reading, writing, and closing files
   - Different file modes (read, write, append)
   - Error handling and resource management

2. **Buffered I/O**:
   - Improved performance with buffered readers and writers
   - Line-by-line processing with Scanner
   - Efficient handling of large files

3. **Advanced Operations**:
   - Working with different file formats (JSON, CSV)
   - Directory operations and file system traversal
   - Temporary files and directories

4. **Real-World Applications**:
   - Logging systems with rotation
   - Data processing pipelines
   - Configuration management
   - Backup and archival systems

The log rotator example demonstrates how to combine various file operations to build a practical application that handles file rotation, backup management, and error scenarios. By following best practices and understanding performance considerations, you can build robust and efficient file I/O operations in your Go applications.

Key takeaways:
1. **Always close files** using `defer` to prevent resource leaks
2. **Use buffered I/O** for better performance with frequent operations
3. **Handle errors appropriately** with specific error types and messages
4. **Use appropriate file permissions** based on the sensitivity of data
5. **Consider concurrency** for processing multiple files efficiently
6. **Implement proper cleanup** for temporary files and resources

File I/O might seem straightforward, but it's full of edge cases and performance considerations. With Go's excellent standard library and the patterns shown in this guide, you can build reliable and efficient file operations in your applications.