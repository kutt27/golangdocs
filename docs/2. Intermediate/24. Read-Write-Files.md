

{# File I/O in Go: Reading and Writing Files

!!! abstract "Overview"
    Master Go's file I/O capabilities using the os, io, and bufio packages. Learn to create, read, write, and manipulate files, handle different file modes, implement buffered operations, work with various file formats, and build robust file processing systems with proper error handling and resource management.

!!! tip "Key Points"
    - Use os package for basic file operations like Create, Open, ReadFile, and WriteFile
    - Implement buffered I/O with bufio package for better performance with frequent operations
    - Handle different file modes (read, write, append) with appropriate flags and permissions
    - Process files line-by-line using Scanner or ReadString for efficient memory usage
    - Work with various file formats like JSON and CSV using encoding packages
    - Always close files using defer to prevent resource leaks and handle errors gracefully

## Understanding File Operations in Go

File input/output (I/O) is a fundamental aspect of many applications. Go provides a rich set of packages for file operations, primarily through the `os`, `io`, and `bufio` packages. Understanding how to effectively work with files is essential for building robust applications that handle data persistence, configuration, logging, and more.

!!! info "File I/O Components"
    ```mermaid
    graph LR
        A[File I/O in Go] --> B[Basic Operations]
        A --> C[Buffered I/O]
        A --> D[File Formats]
        A --> E[Directory Operations]
        A --> F[Error Handling]
        B --> G[Create/Read/Write]
        C --> H[bufio.Reader/Writer]
        D --> I[JSON/CSV]
        E --> J[Mkdir/Readdir]
        F --> K[Resource Management]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Basic File Operations

### 1. Creating and Writing Files

!!! example "Creating and Writing Files"
    ```go title="create_write_file.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        // Create a new file
        file, err := os.Create("example.txt")
        if err != nil {
            fmt.Println("Error creating file:", err)
            return
        }
        defer file.Close() // Ensure file is closed when done

        // Write a string to the file
        _, err = file.WriteString("Hello, World!\n")
        if err != nil {
            fmt.Println("Error writing to file:", err)
            return
        }

        // Write bytes to the file
        _, err = file.Write([]byte("This is a byte slice.\n"))
        if err != nil {
            fmt.Println("Error writing bytes:", err)
            return
        }

        fmt.Println("File created and written successfully")
    }
    ```

### 2. Reading Files

!!! example "Reading Files"
    ```go title="read_file.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        // Open the file for reading
        file, err := os.Open("example.txt")
        if err != nil {
            fmt.Println("Error opening file:", err)
            return
        }
        defer file.Close()

        // Read the entire file content
        content, err := os.ReadFile("example.txt")
        if err != nil {
            fmt.Println("Error reading file:", err)
            return
        }

        fmt.Println("File content:")
        fmt.Println(string(content))
    }
    ```

## File Opening Modes

### 1. Different Open Flags

Go provides various flags for opening files with different modes:

!!! example "Different Open Flags"
    ```go title="open_flags.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        // Open file with different modes
        flags := []struct {
            name string
            flag int
            mode string
        }{
            {"Read Only", os.O_RDONLY, "r"},
            {"Write Only", os.O_WRONLY, "w"},
            {"Read Write", os.O_RDWR, "rw"},
            {"Append", os.O_APPEND, "a"},
            {"Create", os.O_CREATE, "create"},
            {"Truncate", os.O_TRUNC, "truncate"},
            {"Exclusive", os.O_EXCL, "exclusive"},
        }

        for _, f := range flags {
            fmt.Printf("%-12s: %d (%s)\n", f.name, f.flag, f.mode)
        }
    }
    ```

### 2. Using OpenFile with Flags

!!! example "Using OpenFile with Flags"
    ```go title="openfile_flags.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        // Open file in append mode
        file, err := os.OpenFile("example.txt", os.O_APPEND|os.O_WRONLY, 0644)
        if err != nil {
            fmt.Println("Error opening file:", err)
            return
        }
        defer file.Close()

        // Append content
        _, err = file.WriteString("Appended content.\n")
        if err != nil {
            fmt.Println("Error appending to file:", err)
            return
        }

        fmt.Println("Content appended successfully")
    }
    ```

## Buffered I/O with bufio

### 1. Buffered Writing

!!! example "Buffered Writing"
    ```go title="buffered_writing.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "bufio"
        "fmt"
        "os"
    )

    func main() {
        // Create file
        file, err := os.Create("buffered_example.txt")
        if err != nil {
            fmt.Println("Error creating file:", err)
            return
        }
        defer file.Close()

        // Create buffered writer
        writer := bufio.NewWriter(file)
        defer writer.Flush() // Ensure all buffered data is written

        // Write multiple lines
        lines := []string{
            "First line",
            "Second line",
            "Third line",
        }

        for _, line := range lines {
            _, err := writer.WriteString(line + "\n")
            if err != nil {
                fmt.Println("Error writing:", err)
                return
            }
        }

        fmt.Println("Buffered writing completed")
    }
    ```

### 2. Buffered Reading

!!! example "Buffered Reading"
    ```go title="buffered_reading.go" linenums="1" hl_lines="8-30"
    package main

    import (
        "bufio"
        "fmt"
        "io"
        "os"
    )

    func main() {
        // Open file
        file, err := os.Open("buffered_example.txt")
        if err != nil {
            fmt.Println("Error opening file:", err)
            return
        }
        defer file.Close()

        // Create buffered reader
        reader := bufio.NewReader(file)

        // Read line by line
        fmt.Println("Reading file line by line:")
        for {
            line, err := reader.ReadString('\n')
            if err != nil {
                if err == io.EOF {
                    break
                }
                fmt.Println("Error reading:", err)
                return
            }
            fmt.Print(line)
        }
    }
    ```

### 3. Using Scanner for Line-by-Line Reading

!!! example "Using Scanner"
    ```go title="using_scanner.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "bufio"
        "fmt"
        "os"
    )

    func main() {
        // Open file
        file, err := os.Open("buffered_example.txt")
        if err != nil {
            fmt.Println("Error opening file:", err)
            return
        }
        defer file.Close()

        // Create scanner
        scanner := bufio.NewScanner(file)

        // Read line by line
        fmt.Println("Using scanner:")
        for scanner.Scan() {
            fmt.Println(scanner.Text())
        }

        if err := scanner.Err(); err != nil {
            fmt.Println("Scanner error:", err)
        }
    }
    ```

## Working with Different File Formats

### 1. JSON Files

!!! example "JSON Files"
    ```go title="json_files.go" linenums="1" hl_lines="8-46"
    package main

    import (
        "encoding/json"
        "fmt"
        "os"
    )

    type Person struct {
        Name string `json:"name"`
        Age  int    `json:"age"`
    }

    func main() {
        // Write JSON file
        people := []Person{
            {"Alice", 30},
            {"Bob", 25},
            {"Charlie", 35},
        }

        // Marshal to JSON
        jsonData, err := json.MarshalIndent(people, "", "  ")
        if err != nil {
            fmt.Println("Error marshaling JSON:", err)
            return
        }

        // Write to file
        err = os.WriteFile("people.json", jsonData, 0644)
        if err != nil {
            fmt.Println("Error writing JSON file:", err)
            return
        }

        // Read JSON file
        var readPeople []Person
        data, err := os.ReadFile("people.json")
        if err != nil {
            fmt.Println("Error reading JSON file:", err)
            return
        }

        err = json.Unmarshal(data, &readPeople)
        if err != nil {
            fmt.Println("Error unmarshaling JSON:", err)
            return
        }

        fmt.Println("Read from JSON file:")
        for _, person := range readPeople {
            fmt.Printf("%s is %d years old\n", person.Name, person.Age)
        }
    }
    ```

### 2. CSV Files

!!! example "CSV Files"
    ```go title="csv_files.go" linenums="1" hl_lines="8-52"
    package main

    import (
        "encoding/csv"
        "fmt"
        "os"
    )

    func main() {
        // Write CSV file
        file, err := os.Create("data.csv")
        if err != nil {
            fmt.Println("Error creating CSV file:", err)
            return
        }
        defer file.Close()

        writer := csv.NewWriter(file)
        defer writer.Flush()

        // Write header
        err = writer.Write([]string{"Name", "Age", "City"})
        if err != nil {
            fmt.Println("Error writing header:", err)
            return
        }

        // Write records
        records := [][]string{
            {"Alice", "30", "New York"},
            {"Bob", "25", "Los Angeles"},
            {"Charlie", "35", "Chicago"},
        }

        for _, record := range records {
            err = writer.Write(record)
            if err != nil {
                fmt.Println("Error writing record:", err)
                return
            }
        }

        // Read CSV file
        file, err = os.Open("data.csv")
        if err != nil {
            fmt.Println("Error opening CSV file:", err)
            return
        }
        defer file.Close()

        reader := csv.NewReader(file)
        records, err = reader.ReadAll()
        if err != nil {
            fmt.Println("Error reading CSV:", err)
            return
        }

        fmt.Println("\nRead from CSV file:")
        for i, record := range records {
            if i == 0 {
                fmt.Printf("Header: %v\n", record)
            } else {
                fmt.Printf("Record: %v\n", record)
            }
        }
    }
    ```

## Directory Operations

### 1. Creating Directories

!!! example "Creating Directories"
    ```go title="creating_directories.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        // Create single directory
        err := os.Mkdir("testdir", 0755)
        if err != nil {
            fmt.Println("Error creating directory:", err)
        }

        // Create nested directories (MkdirAll)
        err = os.MkdirAll("testdir/nested1/nested2", 0755)
        if err != nil {
            fmt.Println("Error creating nested directories:", err)
        }

        fmt.Println("Directories created")
    }
    ```

### 2. Reading Directory Contents

!!! example "Reading Directory Contents"
    ```go title="reading_directory.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        // Open directory
        dir, err := os.Open(".")
        if err != nil {
            fmt.Println("Error opening directory:", err)
            return
        }
        defer dir.Close()

        // Read directory contents
        names, err := dir.Readdirnames(-1)
        if err != nil {
            fmt.Println("Error reading directory:", err)
            return
        }

        fmt.Println("Directory contents:")
        for _, name := range names {
            fmt.Println(name)
        }
    }
    ```

### 3. Walking Directory Tree

!!! example "Walking Directory Tree"
    ```go title="walking_directory.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "os"
        "path/filepath"
    )

    func main() {
        // Walk directory tree
        err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
            if err != nil {
                return err
            }
            fmt.Println(path)
            return nil
        })
        if err != nil {
            fmt.Println("Error walking directory:", err)
        }
    }
    ```

## Temporary Files

### 1. Creating Temporary Files

!!! example "Creating Temporary Files"
    ```go title="temporary_files.go" linenums="1" hl_lines="8-30"
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        // Create temporary file
        tempFile, err := os.CreateTemp("", "example-*.txt")
        if err != nil {
            fmt.Println("Error creating temp file:", err)
            return
        }
        defer os.Remove(tempFile.Name()) // Clean up

        fmt.Println("Temporary file created:", tempFile.Name())

        // Write to temp file
        _, err = tempFile.WriteString("This is temporary content")
        if err != nil {
            fmt.Println("Error writing to temp file:", err)
            return
        }

        // Read from temp file
        content, err := os.ReadFile(tempFile.Name())
        if err != nil {
            fmt.Println("Error reading temp file:", err)
            return
        }

        fmt.Println("Temp file content:", string(content))
    }
    ```

### 2. Temporary Directories

!!! example "Temporary Directories"
    ```go title="temporary_directories.go" linenums="1" hl_lines="8-34"
    package main

    import (
        "fmt"
        "os"
        "path/filepath"
    )

    func main() {
        // Create temporary directory
        tempDir, err := os.MkdirTemp("", "example-")
        if err != nil {
            fmt.Println("Error creating temp directory:", err)
            return
        }
        defer os.RemoveAll(tempDir) // Clean up

        fmt.Println("Temporary directory created:", tempDir)

        // Create a file in temp directory
        tempFile := filepath.Join(tempDir, "test.txt")
        err = os.WriteFile(tempFile, []byte("Hello from temp dir"), 0644)
        if err != nil {
            fmt.Println("Error creating file in temp dir:", err)
            return
        }

        // Read the file
        content, err := os.ReadFile(tempFile)
        if err != nil {
            fmt.Println("Error reading file in temp dir:", err)
            return
        }

        fmt.Println("File in temp dir content:", string(content))
    }
    ```

## Error Handling in File Operations

### 1. Common File Errors

!!! example "Common File Errors"
    ```go title="file_errors.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "fmt"
        "io"
        "os"
    )

    func safeFileOperation(filename string) error {
        // Try to open file
        file, err := os.Open(filename)
        if err != nil {
            if os.IsNotExist(err) {
                return fmt.Errorf("file does not exist: %w", err)
            }
            if os.IsPermission(err) {
                return fmt.Errorf("permission denied: %w", err)
            }
            return fmt.Errorf("error opening file: %w", err)
        }
        defer file.Close()

        // Read file content
        _, err = io.ReadAll(file)
        if err != nil {
            return fmt.Errorf("error reading file: %w", err)
        }

        return nil
    }

    func main() {
        err := safeFileOperation("nonexistent.txt")
        if err != nil {
            fmt.Println("File operation error:", err)
        }
    }
    ```

### 2. Retry Mechanism for File Operations

!!! example "Retry Mechanism"
    ```go title="retry_mechanism.go" linenums="1" hl_lines="8-38"
    package main

    import (
        "fmt"
        "os"
        "time"
    )

    func retryFileOperation(operation func() error, maxRetries int) error {
        var err error
        for i := 0; i < maxRetries; i++ {
            err = operation()
            if err == nil {
                return nil
            }
            
            // Check if it's a retryable error
            if os.IsPermission(err) || os.IsExist(err) {
                time.Sleep(time.Second * time.Duration(i+1))
                continue
            }
            
            // Non-retryable error
            return err
        }
        
        return fmt.Errorf("operation failed after %d retries: %w", maxRetries, err)
    }

    func main() {
        // Example: Try to create a file that might be locked
        err := retryFileOperation(func() error {
            file, err := os.Create("locked_file.txt")
            if err != nil {
                return err
            }
            file.Close()
            return nil
        }, 3)
        
        if err != nil {
            fmt.Println("Error after retries:", err)
        }
    }
    ```

## Real-World Example: Log Rotator

Let's build a simple log rotator that demonstrates various file operations:

!!! example "Log Rotator"
    ```go title="log_rotator.go" linenums="1" hl_lines="8-60"
    package main

    import (
        "bufio"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"
    )

    // LogRotator handles log file rotation
    type LogRotator struct {
        basePath    string
        maxSize     int64
        maxBackups  int
        currentFile *os.File
        currentSize int64
        mu          sync.Mutex
    }

    // NewLogRotator creates a new log rotator
    func NewLogRotator(basePath string, maxSize int64, maxBackups int) *LogRotator {
        return &LogRotator{
            basePath:   basePath,
            maxSize:    maxSize,
            maxBackups: maxBackups,
        }
    }

    // Open opens the current log file or creates a new one
    func (lr *LogRotator) Open() error {
        lr.mu.Lock()
        defer lr.mu.Unlock()
        
        // Try to open existing file
        file, err := os.OpenFile(lr.basePath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
        if err != nil {
            return fmt.Errorf("failed to open log file: %w", err)
        }
        
        // Get current file size
        info, err := file.Stat()
        if err != nil {
            file.Close()
            return fmt.Errorf("failed to get file info: %w", err)
        }
        
        lr.currentFile = file
        lr.currentSize = info.Size()
        
        // Check if rotation is needed
        if lr.currentSize >= lr.maxSize {
            if err := lr.rotate(); err != nil {
                file.Close()
                return err
            }
        }
        
        return nil
    }

    // Write writes data to the log file
    func (lr *LogRotator) Write(p []byte) (int, error) {
        lr.mu.Lock()
        defer lr.mu.Unlock()
        
        if lr.currentFile == nil {
            if err := lr.Open(); err != nil {
                return 0, err
            }
        }
        
        // Check if rotation is needed
        if lr.currentSize+int64(len(p)) >= lr.maxSize {
            if err := lr.rotate(); err != nil {
                return 0, err
            }
        }
        
        n, err := lr.currentFile.Write(p)
        if err != nil {
            return n, err
        }
        
        lr.currentSize += int64(n)
        return n, nil
    }

    // Close closes the current log file
    func (lr *LogRotator) Close() error {
        lr.mu.Lock()
        defer lr.mu.Unlock()
        
        if lr.currentFile != nil {
            return lr.currentFile.Close()
        }
        return nil
    }

    // rotate performs log rotation
    func (lr *LogRotator) rotate() error {
        // Close current file
        if lr.currentFile != nil {
            lr.currentFile.Close()
        }
        
        // Rotate existing backup files
        for i := lr.maxBackups - 1; i >= 0; i-- {
            oldPath := lr.backupPath(i)
            newPath := lr.backupPath(i + 1)
            
            if _, err := os.Stat(oldPath); err == nil {
                if i == lr.maxBackups-1 {
                    // Remove the oldest backup
                    os.Remove(oldPath)
                } else {
                    // Rename the backup
                    os.Rename(oldPath, newPath)
                }
            }
        }
        
        // Rename current file to backup
        if _, err := os.Stat(lr.basePath); err == nil {
            os.Rename(lr.basePath, lr.backupPath(0))
        }
        
        // Create new file
        file, err := os.OpenFile(lr.basePath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
        if err != nil {
            return fmt.Errorf("failed to create new log file: %w", err)
        }
        
        lr.currentFile = file
        lr.currentSize = 0
        
        return nil
    }

    // backupPath returns the path for a backup file
    func (lr *LogRotator) backupPath(index int) string {
        if index == 0 {
            return lr.basePath + ".1"
        }
        return fmt.Sprintf("%s.%d", lr.basePath, index+1)
    }

    // WriteString writes a string to the log file
    func (lr *LogRotator) WriteString(s string) (int, error) {
        return lr.Write([]byte(s))
    }

    // WriteLine writes a line to the log file
    func (lr *LogRotator) WriteLine(line string) error {
        _, err := lr.WriteString(line + "\n")
        return err
    }

    func main() {
        // Create log rotator
        rotator := NewLogRotator("app.log", 1024, 3) // 1KB max size, 3 backups
        
        // Open log file
        if err := rotator.Open(); err != nil {
            fmt.Println("Error opening log rotator:", err)
            return
        }
        defer rotator.Close()
        
        // Write log entries
        logEntries := []string{
            "INFO: Application started",
            "INFO: Processing request",
            "DEBUG: Processing data",
            "INFO: Request processed successfully",
            "WARNING: High memory usage detected",
            "ERROR: Database connection failed",
            "INFO: Retrying database connection",
            "INFO: Database connection restored",
            "INFO: Application shutting down",
        }
        
        for _, entry := range logEntries {
            timestamp := time.Now().Format("2006-01-02 15:04:05")
            logLine := fmt.Sprintf("[%s] %s", timestamp, entry)
            
            if err := rotator.WriteLine(logLine); err != nil {
                fmt.Println("Error writing log entry:", err)
                continue
            }
            
            fmt.Printf("Logged: %s\n", entry)
            
            // Small delay to simulate real logging
            time.Sleep(100 * time.Millisecond)
        }
        
        // List all log files
        fmt.Println("\nLog files created:")
        matches, err := filepath.Glob("app.log*")
        if err != nil {
            fmt.Println("Error listing log files:", err)
            return
        }
        
        for _, match := range matches {
            info, err := os.Stat(match)
            if err != nil {
                fmt.Println("Error getting file info:", err)
                continue
            }
            
            fmt.Printf("%s (%d bytes)\n", match, info.Size())
            
            // Show first few lines of each file
            file, err := os.Open(match)
            if err != nil {
                fmt.Println("Error opening file:", err)
                continue
            }
            
            scanner := bufio.NewScanner(file)
            lineCount := 0
            for scanner.Scan() && lineCount < 3 {
                fmt.Printf("  %s\n", scanner.Text())
                lineCount++
            }
            file.Close()
            
            if lineCount >= 3 {
                fmt.Println("  ...")
            }
        }
        
        // Clean up
        os.RemoveAll("app.log")
    }
    ```

### How This Example Works:

1. **Log Rotation Logic**:
   - Monitors log file size and rotates when it exceeds the limit
   - Maintains a specified number of backup files
   - Renames existing backups to make room for new ones

2. **File Operations**:
   - Creates, opens, writes to, and closes files
   - Renames files for rotation
   - Handles file size tracking

3. **Error Handling**:
   - Gracefully handles file operation errors
   - Ensures files are properly closed
   - Provides meaningful error messages

4. **Directory Management**:
   - Works with file paths and backups
   - Lists and manages multiple log files
   - Demonstrates file system operations

### Real-World Applications:

1. **Logging Systems**:
   - Application logging with rotation
   - Log file management
   - Archive and cleanup

2. **Data Processing**:
   - Batch file processing
   - Data transformation
   - File format conversion

3. **Backup Systems**:
   - File backup and rotation
   - Version management
   - Storage optimization

## Best Practices

!!! tip "Always Close Files"
    Use defer to ensure files are properly closed, even if errors occur.

!!! example "Always Close Files"
    ```go title="close_files.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "os"
    )

    // Good: Use defer to ensure files are closed
    func processFile(filename string) error {
        file, err := os.Open(filename)
        if err != nil {
            return err
        }
        defer file.Close() // Ensure file is closed
        
        // Process file...
        return nil
    }

    // Bad: Forgetting to close files
    func processFileBad(filename string) error {
        file, err := os.Open(filename)
        if err != nil {
            return err
        }
        // No defer - file might not be closed if error occurs
        // Process file...
        return nil
    }
    ```

!!! tip "Use Buffered I/O for Performance"
    Buffered operations significantly improve performance for frequent I/O operations.

!!! example "Buffered I/O for Performance"
    ```go title="buffered_io.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "bufio"
        "fmt"
        "os"
    )

    // Good: Use buffered I/O for frequent operations
    func writeManyLines(filename string, lines []string) error {
        file, err := os.Create(filename)
        if err != nil {
            return err
        }
        defer file.Close()
        
        writer := bufio.NewWriter(file)
        defer writer.Flush()
        
        for _, line := range lines {
            _, err := writer.WriteString(line + "\n")
            if err != nil {
                return err
            }
        }
        
        return nil
    }

    // Bad: Unbuffered writes for many operations
    func writeManyLinesBad(filename string, lines []string) error {
        file, err := os.Create(filename)
        if err != nil {
            return err
        }
        defer file.Close()
        
        for _, line := range lines {
            _, err := file.WriteString(line + "\n") // System call for each line
            if err != nil {
                return err
            }
        }
        
        return nil
    }
    ```

!!! tip "Handle Errors Properly"
    Provide specific error handling for different types of file operation errors.

!!! example "Handle Errors Properly"
    ```go title="error_handling.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "os"
    )

    // Good: Handle specific errors
    func readFile(filename string) ([]byte, error) {
        data, err := os.ReadFile(filename)
        if err != nil {
            if os.IsNotExist(err) {
                return nil, fmt.Errorf("file not found: %s", filename)
            }
            if os.IsPermission(err) {
                return nil, fmt.Errorf("permission denied: %s", filename)
            }
            return nil, fmt.Errorf("failed to read file: %w", err)
        }
        return data, nil
    }

    // Bad: Generic error handling
    func readFileBad(filename string) ([]byte, error) {
        data, err := os.ReadFile(filename)
        if err != nil {
            return nil, err // No context about what went wrong
        }
        return data, nil
    }
    ```

!!! tip "Use Appropriate File Permissions"
    Set appropriate file permissions based on the sensitivity and purpose of the file.

!!! example "Appropriate File Permissions"
    ```go title="file_permissions.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "os"
    )

    // Good: Use appropriate permissions
    func createConfigFile() error {
        // 0600: Read/write for owner only
        return os.WriteFile("config.json", configData, 0600)
    }

    func createLogFile() error {
        // 0644: Read/write for owner, read for others
        return os.WriteFile("app.log", logData, 0644)
    }

    func createExecutable() error {
        // 0755: Read/write/execute for owner, read/execute for others
        return os.WriteFile("myapp", binaryData, 0755)
    }
    ```

## Performance Considerations

!!! warning "Buffer Size Optimization"
    Adjust buffer size based on your specific use case for optimal performance.

!!! example "Buffer Size Optimization"
    ```go title="buffer_size.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "io"
        "os"
    )

    // Adjust buffer size based on use case
    func copyFileWithBufferSize(src, dst string, bufferSize int) error {
        srcFile, err := os.Open(src)
        if err != nil {
            return err
        }
        defer srcFile.Close()
        
        dstFile, err := os.Create(dst)
        if err != nil {
            return err
        }
        defer dstFile.Close()
        
        // Use custom buffer size
        buf := make([]byte, bufferSize)
        _, err = io.CopyBuffer(dstFile, srcFile, buf)
        return err
    }
    ```

!!! warning "Concurrent File Operations"
    Use goroutines for concurrent file processing when appropriate, but ensure proper synchronization.

!!! example "Concurrent File Operations"
    ```go title="concurrent_operations.go" linenums="1" hl_lines="8-34"
    package main

    import (
        "fmt"
        "os"
        "sync"
    )

    // Process multiple files concurrently    
    func processFilesConcurrently(filenames []string) error {
        var wg sync.WaitGroup
        errChan := make(chan error, len(filenames))
        
        for _, filename := range filenames {
            wg.Add(1)
            go func(fname string) {
                defer wg.Done()
                
                // Process file
                if err := processSingleFile(fname); err != nil {
                    errChan <- err
                }
            }(filename)
        }
        
        // Wait for all goroutines to complete
        wg.Wait()
        close(errChan)
        
        // Check for errors
        for err := range errChan {
            if err != nil {
                return err
            }
        }
        
        return nil
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Basic Operations**: Use `os.Create`, `os.Open`, `os.ReadFile`, and `os.WriteFile` for simple file operations
    - **File Modes**: Combine flags like `os.O_RDONLY`, `os.O_WRONLY`, `os.O_APPEND` with `os.OpenFile` for different access modes
    - **Buffered I/O**: Use `bufio.NewReader` and `bufio.NewWriter` for better performance with frequent operations
    - **Line Processing**: Use `bufio.Scanner` for convenient line-by-line reading
    - **File Formats**: Leverage `encoding/json` and `encoding/csv` for structured data
    - **Resource Management**: Always use `defer` to close files and handle errors appropriately

!!! quote "Remember"
    "File I/O is a critical aspect of many Go applications. The os, io, and bufio packages provide comprehensive tools for creating, reading, writing, and manipulating files. By following best practices like always closing files, using buffered I/O for performance, handling errors properly, and using appropriate file permissions, you can build robust and efficient file operations in your Go applications."