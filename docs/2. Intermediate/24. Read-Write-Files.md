# Go Reading and Writing Files

Go's standard library provides several ways to work with files. The most common packages used are `os`, `io`, and `bufio`.

### 1. Reading Files

#### Quick Read (Entire File)
Use `os.ReadFile` if the file is small enough to fit in memory.

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    data, err := os.ReadFile("example.txt")
    if err != nil {
        panic(err)
    }
    fmt.Print(string(data))
}
```

#### Line-by-Line Read
Use `bufio.Scanner` for large files or when you want to process text line by line.

```go
f, _ := os.Open("large.txt")
defer f.Close()

scanner := bufio.NewScanner(f)
for scanner.Scan() {
    fmt.Println(scanner.Text())
}
```

### 2. Writing Files

#### Quick Write (Overwrite)
Use `os.WriteFile` to create or overwrite a file with data.

```go
d1 := []byte("hello\ngo\n")
err := os.WriteFile("test.txt", d1, 0644)
```

#### Manual Write
Use `os.Create` and `WriteString` for more control.

```go
f, _ := os.Create("manual.txt")
defer f.Close()

f.WriteString("some data\n")
f.Sync() // Flush writes to stable storage
```

### 3. Appending to a File

To add data to the end of a file without overwriting it, use `os.OpenFile` with the `O_APPEND` flag.

```go
f, _ := os.OpenFile("log.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
defer f.Close()

f.WriteString("new log entry\n")
```

### Best Practices

1.  **Always use `defer f.Close()`**: This ensures the file is closed even if your program panics, preventing memory leaks.
2.  **Check Errors**: File operations (like opening or writing) are very likely to fail (e.g., file not found, permission denied).
3.  **Use `bufio` for Many Small Writes**: It's much faster because it groups writes into a single batch.