

# Formatting Verbs in Go: A Comprehensive Guide

## Introduction to Formatting Verbs

In Go, formatting verbs are special placeholders used with the `fmt` package to control how values are formatted when printed. These verbs provide powerful control over output formatting, essential for creating readable logs, user-friendly displays, and properly structured data.

## Basic Formatting with fmt.Printf

The most common formatting function is `fmt.Printf`, which uses verbs to format values:

```go
package main

import "fmt"

func main() {
    name := "Alice"
    age := 30
    fmt.Printf("Name: %s, Age: %d\n", name, age)
    // Output: Name: Alice, Age: 30
}
```

## General Formatting Verbs

| Verb | Description | Example |
|------|-------------|---------|
| `%v` | Default format | `fmt.Printf("%v", 42)` → `42` |
| `%+v` | Adds struct field names | `fmt.Printf("%+v", p)` |
| `%#v` | Go syntax representation | `fmt.Printf("%#v", []int{1,2})` |
| `%T` | Type of value | `fmt.Printf("%T", 42)` → `int` |
| `%%` | Literal percent sign | `fmt.Printf("%%")` → `%` |

### Example: General Verbs

```go
type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{"Bob", 25}
    fmt.Printf("%v\n", p)     // {Bob 25}
    fmt.Printf("%+v\n", p)    // {Name:Bob Age:25}
    fmt.Printf("%#v\n", p)    // main.Person{Name:"Bob", Age:25}
    fmt.Printf("%T\n", p)     // main.Person
}
```

## Integer Formatting Verbs

| Verb | Description | Example |
|------|-------------|---------|
| `%b` | Base 2 (binary) | `fmt.Printf("%b", 5)` → `101` |
| `%c` | Character represented by Unicode code | `fmt.Printf("%c", 0x41)` → `A` |
| `%d` | Base 10 (decimal) | `fmt.Printf("%d", 42)` → `42` |
| `%o` | Base 8 (octal) | `fmt.Printf("%o", 8)` → `10` |
| `%O` | Base 8 with 0o prefix | `fmt.Printf("%O", 8)` → `0o10` |
| `%q` | Single-quoted character | `fmt.Printf("%q", 'A')` → `'A'` |
| `%x` | Base 16 (hexadecimal), lowercase | `fmt.Printf("%x", 255)` → `ff` |
| `%X` | Base 16 (hexadecimal), uppercase | `fmt.Printf("%X", 255)` → `FF` |
| `%U` | Unicode format (U+XXXX) | `fmt.Printf("%U", 'A')` → `U+0041` |

### Example: Integer Formatting

```go
func main() {
    num := 42
    fmt.Printf("Decimal: %d\n", num)        // Decimal: 42
    fmt.Printf("Binary: %b\n", num)         // Binary: 101010
    fmt.Printf("Octal: %o\n", num)          // Octal: 52
    fmt.Printf("Hexadecimal: %x\n", num)    // Hexadecimal: 2a
    fmt.Printf("Hexadecimal (upper): %X\n", num)  // Hexadecimal (upper): 2A
    fmt.Printf("Unicode: %U\n", 'A')       // Unicode: U+0041
}
```

## Floating-Point and Complex Formatting

| Verb | Description | Example |
|------|-------------|---------|
| `%b` | Scientific notation with binary exponent | `fmt.Printf("%b", 3.14)` |
| `%e` | Scientific notation (lowercase e) | `fmt.Printf("%e", 3.14)` → `3.140000e+00` |
| `%E` | Scientific notation (uppercase E) | `fmt.Printf("%E", 3.14)` → `3.140000E+00` |
| `%f` | Decimal notation | `fmt.Printf("%f", 3.14)` → `3.140000` |
| `%F` | Same as %f | `fmt.Printf("%F", 3.14)` → `3.140000` |
| `%g` | %e for large exponents, %f otherwise | `fmt.Printf("%g", 3.14)` → `3.14` |
| `%G` | %E for large exponents, %F otherwise | `fmt.Printf("%G", 3.14)` → `3.14` |
| `%x` | Hexadecimal notation (fractional part) | `fmt.Printf("%x", 3.14)` |
| `%X` | Uppercase hexadecimal notation | `fmt.Printf("%X", 3.14)` |

### Example: Floating-Point Formatting

```go
func main() {
    pi := 3.14159
    fmt.Printf("Default: %f\n", pi)        // Default: 3.141590
    fmt.Printf("Precision 2: %.2f\n", pi)  // Precision 2: 3.14
    fmt.Printf("Scientific: %e\n", pi)     // Scientific: 3.141590e+00
    fmt.Printf("Compact: %g\n", pi)        // Compact: 3.14159
    fmt.Printf("Hex: %x\n", pi)            // Hex: 1.921f9f01b866ep+1
}
```

## String and Byte Formatting

| Verb | Description | Example |
|------|-------------|---------|
| `%s` | String | `fmt.Printf("%s", "hello")` → `hello` |
| `%q` | Double-quoted string | `fmt.Printf("%q", "hello")` → `"hello"` |
| `%x` | Hexadecimal dump of bytes | `fmt.Printf("%x", "hi")` → `6869` |
| `%X` | Uppercase hexadecimal dump | `fmt.Printf("%X", "hi")` → `6869` |

### Example: String Formatting

```go
func main() {
    str := "hello"
    fmt.Printf("String: %s\n", str)        // String: hello
    fmt.Printf("Quoted: %q\n", str)        // Quoted: "hello"
    fmt.Printf("Hex bytes: %x\n", str)     // Hex bytes: 68656c6c6f
    fmt.Printf("Hex bytes (upper): %X\n", str)  // Hex bytes (upper): 68656C6C6F
}
```

## Boolean Formatting

| Verb | Description | Example |
|------|-------------|---------|
| `%t` | Boolean (true or false) | `fmt.Printf("%t", true)` → `true` |

### Example: Boolean Formatting

```go
func main() {
    flag := true
    fmt.Printf("Boolean: %t\n", flag)      // Boolean: true
}
```

## Pointer Formatting

| Verb | Description | Example |
|------|-------------|---------|
| `%p` | Pointer address (hexadecimal) | `fmt.Printf("%p", &x)` → `0x1040a124` |

### Example: Pointer Formatting

```go
func main() {
    x := 42
    fmt.Printf("Pointer: %p\n", &x)        // Pointer: 0x1040a124
}
```

## Width and Precision

You can control formatting width and precision using numbers between `%` and the verb:

```go
func main() {
    num := 42
    str := "hello"
    
    // Width: minimum number of characters to output
    fmt.Printf("Width 5: |%5d|\n", num)    // Width 5: |   42|
    fmt.Printf("Width 5: |%5s|\n", str)    // Width 5: |hello|
    
    // Precision: maximum number of characters (for strings) or decimal places (for numbers)
    fmt.Printf("Precision 2: |%.2f|\n", 3.14159)  // Precision 2: |3.14|
    fmt.Printf("Precision 3: |%.3s|\n", str)     // Precision 3: |hel|
    
    // Combined width and precision
    fmt.Printf("Width 7, Precision 2: |%7.2f|\n", 3.14159)  // Width 7, Precision 2: |   3.14|
}
```

## Formatting Flags

Flags modify formatting behavior:

| Flag | Description | Example |
|------|-------------|---------|
| `+` | Always show sign for numbers | `fmt.Printf("%+d", 42)` → `+42` |
| `-` | Left-justify within width | `fmt.Printf("%-5d", 42)` → `42   ` |
| ` ` | Leave space for positive numbers | `fmt.Printf("% d", 42)` → ` 42` |
| `0` | Pad with zeros instead of spaces | `fmt.Printf("%05d", 42)` → `00042` |
| `#` | Alternate format (adds prefixes) | `fmt.Printf("%#o", 8)` → `010` |

### Example: Formatting Flags

```go
func main() {
    num := 42
    fmt.Printf("With sign: %+d\n", num)    // With sign: +42
    fmt.Printf("Left justified: |%-5d|\n", num)  // Left justified: |42   |
    fmt.Printf("Space for sign: |% d|\n", num)   // Space for sign: | 42|
    fmt.Printf("Zero padded: %05d\n", num)       // Zero padded: 00042
    fmt.Printf("Alternate format: %#o\n", num)   // Alternate format: 052
}
```

## Custom Formatting with Interfaces

You can implement the `fmt.Formatter` or `fmt.Stringer` interfaces for custom formatting:

### fmt.Stringer Interface

```go
type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d years)", p.Name, p.Age)
}

func main() {
    p := Person{"Alice", 30}
    fmt.Printf("%s\n", p)  // Alice (30 years)
}
```

### fmt.Formatter Interface

```go
type Person struct {
    Name string
    Age  int
}

func (p Person) Format(f fmt.State, verb rune) {
    switch verb {
    case 's':
        fmt.Fprint(f, p.Name)
    case 'v':
        if f.Flag('+') {
            fmt.Fprintf(f, "{Name:%q Age:%d}", p.Name, p.Age)
        } else {
            fmt.Fprintf(f, "{%s %d}", p.Name, p.Age)
        }
    }
}

func main() {
    p := Person{"Bob", 25}
    fmt.Printf("%s\n", p)    // Bob
    fmt.Printf("%v\n", p)    // {Bob 25}
    fmt.Printf("%+v\n", p)   // {Name:"Bob" Age:25}
}
```

## Real-World Example: Report Generator

Let's create a practical report generator that demonstrates various formatting techniques:

```go
package main

import (
    "fmt"
    "os"
    "text/tabwriter"
    "time"
)

type Employee struct {
    ID        int
    Name      string
    Position  string
    Salary    float64
    HireDate  time.Time
    IsActive  bool
}

func (e Employee) yearsOfService() float64 {
    return time.Since(e.HireDate).Hours() / 24 / 365
}

func main() {
    employees := []Employee{
        {1001, "John Doe", "Developer", 75000.50, time.Date(2018, 5, 15, 0, 0, 0, 0, time.UTC), true},
        {1002, "Jane Smith", "Designer", 68000.75, time.Date(2019, 8, 22, 0, 0, 0, 0, time.UTC), true},
        {1003, "Bob Johnson", "Manager", 95000.00, time.Date(2016, 3, 10, 0, 0, 0, 0, time.UTC), true},
        {1004, "Alice Williams", "Developer", 72000.25, time.Date(2020, 1, 5, 0, 0, 0, 0, time.UTC), false},
    }

    // Create a tabwriter for aligned columns
    w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
    defer w.Flush()

    // Print header
    fmt.Fprintln(w, "ID\tName\tPosition\tSalary\tHire Date\tYears of Service\tActive")

    // Print employee data
    totalSalary := 0.0
    activeCount := 0
    
    for _, emp := range employees {
        fmt.Fprintf(w, "%05d\t%s\t%s\t$%.2f\t%s\t%.1f\t%t\n",
            emp.ID,
            emp.Name,
            emp.Position,
            emp.Salary,
            emp.HireDate.Format("2006-01-02"),
            emp.yearsOfService(),
            emp.IsActive)
        
        totalSalary += emp.Salary
        if emp.IsActive {
            activeCount++
        }
    }

    // Print summary
    fmt.Fprintln(w, "\nSUMMARY")
    fmt.Fprintf(w, "Total Employees: %d\n", len(employees))
    fmt.Fprintf(w, "Active Employees: %d (%.1f%%)\n", activeCount, float64(activeCount)/float64(len(employees))*100)
    fmt.Fprintf(w, "Total Salary: $%12.2f\n", totalSalary)
    fmt.Fprintf(w, "Average Salary: $%10.2f\n", totalSalary/float64(len(employees)))
    
    // Print memory addresses for demonstration
    fmt.Fprintln(w, "\nMEMORY ADDRESSES")
    for i, emp := range employees {
        fmt.Fprintf(w, "Employee %d: %p\n", i+1, &emp)
    }
}
```

### Output:

```
ID     Name        Position    Salary      Hire Date   Years of Service    Active
01001  John Doe    Developer   $75000.50   2018-05-15  5.1                 true
01002  Jane Smith  Designer    $68000.75   2019-08-22  4.0                 true
01003  Bob Johnson Manager     $95000.00   2016-03-10  7.2                 true
01004  Alice Williams Developer  $72000.25   2020-01-05  3.3                 false

SUMMARY
Total Employees: 4
Active Employees: 3 (75.0%)
Total Salary: $   310001.50
Average Salary: $  77500.38

MEMORY ADDRESSES
Employee 1: 0x14000126000
Employee 2: 0x14000126060
Employee 3: 0x140001260c0
Employee 4: 0x14000126120
```

### How This Example Demonstrates Formatting Verbs:

1. **Integer Formatting**:
   - `%05d` for zero-padded employee IDs
   - `%d` for counts and percentages

2. **Floating-Point Formatting**:
   - `%.2f` for currency values
   - `%.1f` for years of service
   - `%+.2f` to show sign for total salary

3. **String Formatting**:
   - `%s` for regular strings
   - `%q` for quoted names
   - Custom date formatting with time format strings

4. **Boolean Formatting**:
   - `%t` for active status

5. **Pointer Formatting**:
   - `%p` to show memory addresses

6. **Width and Precision**:
   - `%10.2f` for aligned currency values
   - `%12.2f` for detailed salary display

7. **Custom Formatting**:
   - `yearsOfService` method uses `fmt.Sprintf` for custom output
   - Date formatting with custom layouts

8. **Tabular Output**:
   - Uses `text/tabwriter` for aligned columns
   - Combines multiple formatting verbs for clean tables

## Real-World Applications of This Pattern:

1. **Business Reporting**:
   - Financial reports with properly formatted numbers
   - HR reports with employee statistics
   - Sales reports with currency formatting

2. **Logging Systems**:
   - Structured logging with consistent formatting
   - Debug logs with memory addresses and type information
   - Error logs with detailed context

3. **CLI Applications**:
   - User-friendly command output
   - Progress indicators with aligned text
   - Help text with properly formatted examples

4. **Data Export**:
   - CSV/TSV generation with consistent formatting
   - JSON/XML with custom string representations
   - Human-readable data summaries

## Benefits of This Approach:

1. **Consistency**:
   - Uniform formatting across all reports
   - Predictable output format
   - Easy to parse for automated systems

2. **Readability**:
   - Aligned columns and consistent spacing
   - Proper number formatting for currency
   - Clear visual hierarchy

3. **Maintainability**:
   - Centralized formatting logic
   - Easy to modify formatting rules
   - Reusable components for different reports

4. **Flexibility**:
   - Can output to any `io.Writer` (file, network, etc.)
   - Easy to add new formatting options
   - Supports both human and machine-readable formats

## Conclusion

Formatting verbs in Go provide powerful tools for controlling output presentation:

### Basic Formatting:
- Use `%v` for default formatting
- Use `%T` for type information
- Use `%%` for literal percent signs

### Type-Specific Formatting:
- **Integers**: `%d`, `%b`, `%o`, `%x`, etc.
- **Floats**: `%f`, `%e`, `%g`, etc.
- **Strings**: `%s`, `%q`, `%x`
- **Booleans**: `%t`
- **Pointers**: `%p`

### Advanced Formatting:
- Control width and precision with numbers
- Use flags for sign, padding, and alternate formats
- Implement custom formatting with interfaces

### Best Practices:
- Use tabwriter for aligned tables
- Prefer `fmt.Sprintf` for building strings
- Implement `Stringer` for custom types
- Use consistent formatting throughout your application

The report generator example demonstrates how combining these formatting techniques can create professional, readable output for real-world applications. Mastering formatting verbs is essential for creating effective Go applications that communicate clearly with users and other systems.

By understanding and properly using formatting verbs, you can:

- Create more user-friendly command-line tools
- Generate professional reports and documents
- Improve the readability of logs and debug output
- Ensure consistent data presentation across your application
- Build more maintainable and flexible output systems