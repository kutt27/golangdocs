# Closures in Go

## Introduction to Closures
In Go, a closure is a special type of function that references variables from outside its own scope. It "closes over" these variables, maintaining access to them even after the outer function has finished executing. This powerful feature enables functions to maintain state between calls and create more flexible, modular code.

## How Closures Work in Go
A closure consists of:
1. A function (often anonymous)
2. A reference to an external variable from the enclosing scope
3. The environment that binds them together

When a closure is created, it captures references to variables in its surrounding scope. Unlike some other languages, Go closures capture variables by reference, not by value.

### Basic Closure Example
```go
func main() {
    x := 10
    increment := func() int {
        x++
        return x
    }
    
    fmt.Println(increment()) // 11
    fmt.Println(increment()) // 12
    fmt.Println(x)           // 12
}
```
Here, the anonymous function `increment` captures the variable `x` from the outer scope and modifies it.

## Key Characteristics of Go Closures

### 1. Variable Capture by Reference
Go closures capture variables by reference, meaning they share the same variable instance:

```go
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

func main() {
    c1 := counter()
    fmt.Println(c1()) // 1
    fmt.Println(c1()) // 2
    
    c2 := counter()
    fmt.Println(c2()) // 1 (new instance)
}
```

### 2. Lifetime Extension
Closures extend the lifetime of captured variables beyond their original scope:

```go
func getMultiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

func main() {
    times2 := getMultiplier(2)
    times3 := getMultiplier(3)
    
    fmt.Println(times2(5)) // 10
    fmt.Println(times3(5)) // 15
}
```

### 3. Shared State
Multiple closures can share the same captured variables:

```go
func generator() (func() int, func() int) {
    n := 0
    return func() int {
            n++
            return n
        }, func() int {
            n += 2
            return n
        }
}

func main() {
    next, skip := generator()
    fmt.Println(next()) // 1
    fmt.Println(next()) // 2
    fmt.Println(skip()) // 4
    fmt.Println(next()) // 5
}
```

## Common Use Cases for Closures

### 1. Function Factories
Creating specialized functions with pre-configured behavior:

```go
func getGreeter(greeting string) func(string) string {
    return func(name string) string {
        return fmt.Sprintf("%s, %s!", greeting, name)
    }
}

func main() {
    sayHello := getGreeter("Hello")
    sayHi := getGreeter("Hi")
    
    fmt.Println(sayHello("Alice"))  // "Hello, Alice!"
    fmt.Println(sayHi("Bob"))       // "Hi, Bob!"
}
```

### 2. Callbacks and Event Handlers
Passing behavior as a parameter:

```go
func processItems(items []int, callback func(int)) {
    for _, item := range items {
        callback(item)
    }
}

func main() {
    items := []int{1, 2, 3, 4, 5}
    
    processItems(items, func(n int) {
        if n%2 == 0 {
            fmt.Println(n, "is even")
        } else {
            fmt.Println(n, "is odd")
        }
    })
}
```

### 3. Middleware and Decorators
Adding functionality to existing functions:

```go
func logExecution(fn func()) func() {
    return func() {
        start := time.Now()
        fn()
        fmt.Printf("Function executed in %v\n", time.Since(start))
    }
}

func main() {
    task := logExecution(func() {
        time.Sleep(100 * time.Millisecond)
        fmt.Println("Task completed")
    })
    
    task()
}
```

## Real-World Example: HTTP Request Rate Limiter

One of the most practical applications of closures in Go is implementing a rate limiter for HTTP requests. This is crucial for protecting APIs from abuse and ensuring fair usage.

```go
package main

import (
	"fmt"
	"net/http"
	"sync"
	"time"
)

// RateLimiter creates a closure that limits the rate of function execution
func RateLimiter(limit int, window time.Duration) func(http.Handler) http.Handler {
	// Shared state maintained by the closure
	requests := make(map[string]int)
	mu := &sync.Mutex{}
	ticker := time.NewTicker(window)
	
	// Reset counters periodically
	go func() {
		for range ticker.C {
			mu.Lock()
			requests = make(map[string]int)
			mu.Unlock()
		}
	}()
	
	// Return the middleware function
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			ip := r.RemoteAddr
			
			mu.Lock()
			requests[ip]++
			count := requests[ip]
			mu.Unlock()
			
			if count > limit {
				http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
				return
			}
			
			next.ServeHTTP(w, r)
		})
	}
}

func main() {
	// Create a rate limiter: max 5 requests per minute per IP
	limiter := RateLimiter(5, time.Minute)
	
	// Sample HTTP handler
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Welcome to the protected resource!")
	})
	
	// Apply the rate limiter middleware
	protectedHandler := limiter(handler)
	
	// Start the server
	fmt.Println("Server starting on :8080...")
	http.ListenAndServe(":8080", protectedHandler)
}
```

### How This Works:

1. **State Management**: The closure maintains:
   - A map to track request counts per IP
   - A mutex for thread safety
   - A ticker to reset counters periodically

2. **Encapsulation**: All rate limiting logic is encapsulated within the closure. The outside world only sees the middleware function.

3. **Persistence**: The state persists across multiple HTTP requests, allowing the limiter to track request counts over time.

4. **Customization**: The rate limit and time window are configurable when creating the limiter.

5. **Middleware Pattern**: The closure implements the middleware pattern, wrapping an existing handler to add rate limiting functionality.

### Benefits of This Approach:

- **Reusability**: The same rate limiter can be applied to any HTTP handler
- **Isolation**: Each IP address has its own counter
- **Efficiency**: The shared state is managed efficiently with a mutex
- **Clean Implementation**: The closure keeps all related logic together

This pattern is commonly used in production Go applications to protect APIs, prevent abuse, and ensure fair resource allocation among clients.

## Conclusion

Closures are a fundamental feature in Go that enable powerful programming patterns by allowing functions to maintain state and reference variables from their enclosing scope. They are particularly valuable for:

1. Creating function factories and specialized functions
2. Implementing callbacks and event handlers
3. Building middleware and decorators
4. Managing state in a controlled, encapsulated way

Understanding closures is essential for writing idiomatic Go code, especially when working with concurrent operations, HTTP handlers, and functional programming patterns. The rate limiter example demonstrates how closures can solve real-world problems in an elegant and efficient manner.