# Go Closures: Functions with Captured Variables

!!! abstract "Overview"
    Master Go closures - functions that capture and maintain access to variables from their surrounding scope. This guide covers closure fundamentals, practical applications, and advanced patterns for building stateful functions and elegant solutions.

!!! tip "Key Points"
    - Closures capture variables by reference, not by value
    - Enable functions to maintain state between calls
    - Essential for functional programming patterns
    - Powerful tool for creating flexible, modular code
    - Common in goroutines and callback functions

## Understanding Closures

A closure is a function that references variables from outside its own scope. It "closes over" these variables, maintaining access to them even after the outer function has finished executing.

!!! info "Closure Components"
    ```mermaid
    graph LR
        A[Closure] --> B[Function Body]
        A --> C[Captured Variables]
        A --> D[Lexical Environment]
        B --> B1[Anonymous or Named]
        C --> C1[By Reference]
        D --> D1[Binding Context]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Basic Closure Mechanics

!!! example "Simple Closure"

    === "Variable Capture"
        ```go title="basic_closure.go" linenums="1" hl_lines="6-10"
        package main

        import "fmt"

        func main() {
            x := 10
            increment := func() int {
                x++
                return x
            }

            fmt.Println(increment()) // 11
            fmt.Println(increment()) // 12
            fmt.Println(x)           // 12 (original variable modified)
        }
        ```

    === "Multiple Variables"
        ```go title="multi_capture.go" linenums="1" hl_lines="7-12"
        package main

        import "fmt"

        func main() {
            name := "Counter"
            count := 0

            counter := func() string {
                count++
                return fmt.Sprintf("%s: %d", name, count)
            }

            fmt.Println(counter()) // Counter: 1
            fmt.Println(counter()) // Counter: 2
        }
        ```

    === "Closure Factory"
        ```go title="closure_factory.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func createCounter() func() int {
            count := 0
            return func() int {
                count++
                return count
            }
        }

        func main() {
            c1 := createCounter()
            c2 := createCounter()

            fmt.Println(c1()) // 1
            fmt.Println(c1()) // 2
            fmt.Println(c2()) // 1 (independent counter)
        }
        ```

## Key Characteristics of Closures

### Variable Capture by Reference

Go closures capture variables by reference, meaning they share the same variable instance across multiple calls.

!!! example "Reference Capture Behavior"

    === "Shared State"
        ```go title="shared_state.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func counter() func() int {
            count := 0
            return func() int {
                count++
                return count
            }
        }

        func main() {
            c1 := counter()
            fmt.Println(c1()) // 1
            fmt.Println(c1()) // 2

            c2 := counter()
            fmt.Println(c2()) // 1 (independent instance)
        }
        ```

    === "Loop Variable Capture"
        ```go title="loop_capture.go" linenums="1" hl_lines="8-12"
        package main

        import "fmt"

        func main() {
            var funcs []func()

            // Common pitfall: all closures capture same variable
            for i := 0; i < 3; i++ {
                funcs = append(funcs, func() {
                    fmt.Println("Wrong:", i) // Always prints 3
                })
            }

            // Correct approach: capture loop variable
            for i := 0; i < 3; i++ {
                i := i // Create new variable in loop scope
                funcs = append(funcs, func() {
                    fmt.Println("Correct:", i)
                })
            }
        }
        ```

    === "Modifying Captured Variables"
        ```go title="modify_captured.go" linenums="1" hl_lines="7-15"
        package main

        import "fmt"

        func main() {
            balance := 100.0

            deposit := func(amount float64) {
                balance += amount
                fmt.Printf("Deposited %.2f, Balance: %.2f\n", amount, balance)
            }

            withdraw := func(amount float64) bool {
                if balance >= amount {
                    balance -= amount
                    fmt.Printf("Withdrew %.2f, Balance: %.2f\n", amount, balance)
                    return true
                }
                fmt.Printf("Insufficient funds. Balance: %.2f\n", balance)
                return false
            }

            deposit(50.0)   // Deposited 50.00, Balance: 150.00
            withdraw(75.0)  // Withdrew 75.00, Balance: 75.00
        }
        ```

### Closure Scope and Lifetime

Variables captured by closures remain accessible as long as the closure exists, extending their lifetime beyond the original scope.

!!! example "Variable Lifetime"

    === "Extended Lifetime"
        ```go title="lifetime.go" linenums="1" hl_lines="6-10"
        package main

        import "fmt"

        func createMultiplier(factor int) func(int) int {
            // factor variable lifetime extended by closure
            return func(x int) int {
                return x * factor
            }
        }

        func main() {
            double := createMultiplier(2)
            triple := createMultiplier(3)

            // factor variables still accessible
            fmt.Println(double(5))  // 10
            fmt.Println(triple(4))  // 12
        }
        ```

    === "Shared State Pattern"
        ```go title="shared_state.go" linenums="1" hl_lines="6-15"
        package main

        import "fmt"

        func createCounter() (func() int, func() int, func() int) {
            count := 0

            increment := func() int {
                count++
                return count
            }

            decrement := func() int {
                count--
                return count
            }

            get := func() int {
                return count
            }

            return increment, decrement, get
        }

        func main() {
            inc, dec, get := createCounter()

            fmt.Println(inc()) // 1
            fmt.Println(inc()) // 2
            fmt.Println(dec()) // 1
            fmt.Println(get()) // 1
        }
        ```

### Closures with Goroutines

Closures are commonly used with goroutines, but variable capture requires careful attention.

!!! warning "Common Goroutine Pitfall"
    Loop variables are captured by reference, leading to unexpected behavior in concurrent code.

!!! example "Goroutine Patterns"

    === "Problem: Shared Variable"
        ```go title="goroutine_problem.go" linenums="1" hl_lines="8-12"
        package main

        import (
            "fmt"
            "time"
        )

        func main() {
            for i := 0; i < 3; i++ {
                go func() {
                    fmt.Println("Problem:", i) // Likely prints 3, 3, 3
                }()
            }
            time.Sleep(100 * time.Millisecond)
        }
        ```

    === "Solution 1: Parameter Passing"
        ```go title="goroutine_solution1.go" linenums="1" hl_lines="8-12"
        package main

        import (
            "fmt"
            "time"
        )

        func main() {
            for i := 0; i < 3; i++ {
                go func(val int) {
                    fmt.Println("Solution 1:", val) // Prints 0, 1, 2
                }(i)
            }
            time.Sleep(100 * time.Millisecond)
        }
        ```

    === "Solution 2: Variable Shadowing"
        ```go title="goroutine_solution2.go" linenums="1" hl_lines="8-13"
        package main

        import (
            "fmt"
            "time"
        )

        func main() {
            for i := 0; i < 3; i++ {
                i := i // Shadow the loop variable
                go func() {
                    fmt.Println("Solution 2:", i) // Prints 0, 1, 2
                }()
            }
            time.Sleep(100 * time.Millisecond)
        }
        ```

## Common Use Cases for Closures

### 1. Function Factories
Creating specialized functions with pre-configured behavior:

```go
func getGreeter(greeting string) func(string) string {
    return func(name string) string {
        return fmt.Sprintf("%s, %s!", greeting, name)
    }
}

func main() {
    sayHello := getGreeter("Hello")
    sayHi := getGreeter("Hi")
    
    fmt.Println(sayHello("Alice"))  // "Hello, Alice!"
    fmt.Println(sayHi("Bob"))       // "Hi, Bob!"
}
```

### 2. Callbacks and Event Handlers
Passing behavior as a parameter:

```go
func processItems(items []int, callback func(int)) {
    for _, item := range items {
        callback(item)
    }
}

func main() {
    items := []int{1, 2, 3, 4, 5}
    
    processItems(items, func(n int) {
        if n%2 == 0 {
            fmt.Println(n, "is even")
        } else {
            fmt.Println(n, "is odd")
        }
    })
}
```

### Middleware and Decorators

Closures enable elegant middleware patterns by wrapping existing functions with additional behavior.

!!! example "Decorator Patterns"

    === "Execution Timer"
        ```go title="execution_timer.go" linenums="1" hl_lines="8-14"
        package main

        import (
            "fmt"
            "time"
        )

        func logExecution(fn func()) func() {
            return func() {
                start := time.Now()
                fn()
                fmt.Printf("Function executed in %v\n", time.Since(start))
            }
        }

        func main() {
            task := logExecution(func() {
                time.Sleep(100 * time.Millisecond)
                fmt.Println("Task completed")
            })

            task() // Task completed, Function executed in ~100ms
        }
        ```

    === "Error Handler"
        ```go title="error_handler.go" linenums="1" hl_lines="6-16"
        package main

        import "fmt"

        func withErrorHandling(fn func() error) func() {
            return func() {
                if err := fn(); err != nil {
                    fmt.Printf("Error occurred: %v\n", err)
                } else {
                    fmt.Println("Operation completed successfully")
                }
            }
        }

        func main() {
            riskyOperation := withErrorHandling(func() error {
                // Simulate some operation that might fail
                return nil // or return errors.New("something went wrong")
            })

            riskyOperation()
        }
        ```

## Advanced Patterns

### Rate Limiting with Closures

Closures provide an elegant solution for implementing rate limiters and throttling mechanisms.

!!! example "Rate Limiter Implementation"

    === "Simple Rate Limiter"
        ```go title="rate_limiter.go" linenums="1" hl_lines="8-18"
        package main

        import (
            "fmt"
            "time"
        )

        func createRateLimiter(maxCalls int, duration time.Duration) func() bool {
            calls := 0
            resetTime := time.Now().Add(duration)

            return func() bool {
                now := time.Now()
                if now.After(resetTime) {
                    calls = 0
                    resetTime = now.Add(duration)
                }

                if calls < maxCalls {
                    calls++
                    return true
                }
                return false
            }
        }

        func main() {
            limiter := createRateLimiter(3, time.Second)

            for i := 0; i < 5; i++ {
                if limiter() {
                    fmt.Printf("Request %d: Allowed\n", i+1)
                } else {
                    fmt.Printf("Request %d: Rate limited\n", i+1)
                }
            }
        }
        ```

## Best Practices

### Memory Management

Closures keep references to captured variables, which can affect garbage collection.

!!! warning "Memory Considerations"
    Be mindful of what variables your closures capture to avoid memory leaks.

!!! example "Memory Best Practices"

    === "Potential Memory Issue"
        ```go title="memory_issue.go" linenums="1" hl_lines="7-12"
        package main

        import "fmt"

        func createProcessors() []func() {
            var processors []func()
            largeData := make([]byte, 1024*1024) // 1MB

            for i := 0; i < 100; i++ {
                processors = append(processors, func() {
                    // Captures entire largeData slice
                    fmt.Printf("Processing with data size: %d\n", len(largeData))
                })
            }
            return processors
        }
        ```

    === "Memory Optimized"
        ```go title="memory_optimized.go" linenums="1" hl_lines="7-12"
        package main

        import "fmt"

        func createProcessors() []func() {
            var processors []func()
            dataSize := 1024 * 1024 // Capture only what you need

            for i := 0; i < 100; i++ {
                processors = append(processors, func() {
                    // Only captures the integer, not the slice
                    fmt.Printf("Processing with data size: %d\n", dataSize)
                })
            }
            return processors
        }
        ```

### Loop Variable Capture

Always be careful when creating closures inside loops.

!!! example "Loop Variable Patterns"

    === "Common Mistake"
        ```go title="loop_mistake.go" linenums="1" hl_lines="6-10"
        package main

        func createFunctions() []func() {
            var funcs []func()
            for i := 0; i < 3; i++ {
                funcs = append(funcs, func() {
                    fmt.Println(i) // Will print 3, 3, 3
                })
            }
            return funcs
        }
        ```

    === "Correct Approach"
        ```go title="loop_correct.go" linenums="1" hl_lines="6-11"
        package main

        func createFunctions() []func() {
            var funcs []func()
            for i := 0; i < 3; i++ {
                i := i // Create new variable in loop scope
                funcs = append(funcs, func() {
                    fmt.Println(i) // Will print 0, 1, 2
                })
            }
            return funcs
        }
        ```

### Clean API Design

Use closures to create intuitive and flexible APIs.

!!! example "API Design Patterns"

    === "Configuration Options"
        ```go title="config_options.go" linenums="1" hl_lines="8-18"
        package main

        import (
            "net/http"
            "time"
        )

        func WithTimeout(timeout time.Duration) func(*http.Client) {
            return func(client *http.Client) {
                client.Timeout = timeout
            }
        }

        func WithRetries(retries int) func(*http.Client) {
            return func(client *http.Client) {
                // Configure retry logic
            }
        }

        func MakeRequest(url string, options ...func(*http.Client)) error {
            client := &http.Client{}
            for _, option := range options {
                option(client)
            }
            // Make request with configured client
            return nil
        }

        func main() {
            // Clean, readable API
            err := MakeRequest("https://api.example.com",
                WithTimeout(30*time.Second),
                WithRetries(3))
            _ = err
        }
        ```

## Quick Reference

!!! success "Key Takeaways"
    - **State Preservation**: Functions maintain state between calls
    - **Variable Capture**: By reference, not by value
    - **Memory Awareness**: Be mindful of what variables are captured
    - **Loop Variables**: Use variable shadowing to avoid common pitfalls
    - **Clean APIs**: Enable flexible configuration and option patterns
    - **Goroutine Safety**: Consider thread safety when sharing state

!!! quote "Remember"
    "Closures are particularly powerful in Go for creating stateful functions, middleware patterns, and elegant APIs. Use them wisely to write clean, maintainable code."