

{# Time and Epoch in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master Go's time handling capabilities using the time package. Learn time representation, formatting, epoch time, time operations, and time zones for building reliable applications that work correctly across different time zones and handle time-related operations efficiently.

!!! tip "Key Points"
    - Go's time package provides comprehensive functionality for measuring and displaying time
    - Use time.Time type for precise time representation with nanosecond precision
    - Convert between time and Unix timestamps with Unix(), UnixMilli(), UnixMicro(), UnixNano()
    - Format and parse times using reference time: Mon Jan 2 15:04:05 MST 2006
    - Handle time zones and locations for global applications
    - Essential for logging, scheduling, caching, and many other common programming tasks

## Understanding Time Handling

Go's `time` package provides comprehensive functionality for measuring and displaying time. Understanding how to work with time is crucial for logging, scheduling, caching, and many other common programming tasks. This guide covers time representation, formatting, epoch time, and time operations.

!!! info "Time Components"
    ```mermaid
    graph LR
        A[Time Handling] --> B[Time Representation]
        A --> C[Epoch Time]
        A --> D[Formatting/Parsing]
        A --> E[Time Operations]
        A --> F[Time Zones]
        B --> G[time.Time]
        C --> H[Unix Timestamps]
        D --> I[Reference Time]
        E --> J[Arithmetic]
        F --> K[Locations]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Basic Time Representation

### 1. The `time.Time` Type

The `time.Time` type represents an instant in time with nanosecond precision:

!!! example "Basic Time Representation"
    ```go title="time_representation.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        // Get current time
        now := time.Now()
        fmt.Printf("Current time: %v\n", now)
        fmt.Printf("Type: %T\n", now)
        
        // Create a specific time
        t := time.Date(2023, time.November, 15, 14, 30, 0, 0, time.UTC)
        fmt.Printf("Specific time: %v\n", t)
    }
    ```

### 2. Time Components

Access individual components of a time:

!!! example "Time Components"
    ```go title="time_components.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        t := time.Now()
        
        fmt.Printf("Year: %d\n", t.Year())
        fmt.Printf("Month: %d\n", t.Month())    // Month as int (1-12)
        fmt.Printf("Month: %s\n", t.Month().String()) // Month as string
        fmt.Printf("Day: %d\n", t.Day())
        fmt.Printf("Hour: %d\n", t.Hour())
        fmt.Printf("Minute: %d\n", t.Minute())
        fmt.Printf("Second: %d\n", t.Second())
        fmt.Printf("Nanosecond: %d\n", t.Nanosecond())
        fmt.Printf("Weekday: %s\n", t.Weekday())
        fmt.Printf("Year day: %d\n", t.YearDay())
    }
    ```

## Epoch Time (Unix Timestamp)

### 1. Converting to Unix Timestamp

Epoch time (Unix timestamp) represents seconds since January 1, 1970 UTC:

!!! example "Converting to Unix Timestamp"
    ```go title="unix_timestamp.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        now := time.Now()
        
        // Unix timestamp in seconds
        unixSec := now.Unix()
        fmt.Printf("Unix timestamp (seconds): %d\n", unixSec)
        
        // Unix timestamp in milliseconds
        unixMilli := now.UnixMilli()
        fmt.Printf("Unix timestamp (milliseconds): %d\n", unixMilli)
        
        // Unix timestamp in microseconds
        unixMicro := now.UnixMicro()
        fmt.Printf("Unix timestamp (microseconds): %d\n", unixMicro)
        
        // Unix timestamp in nanoseconds
        unixNano := now.UnixNano()
        fmt.Printf("Unix timestamp (nanoseconds): %d\n", unixNano)
    }
    ```

### 2. Creating Time from Unix Timestamp

!!! example "Creating Time from Unix Timestamp"
    ```go title="from_unix_timestamp.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        // From seconds
        t1 := time.Unix(1699999999, 0)
        fmt.Printf("From seconds: %v\n", t1)
        
        // From milliseconds
        t2 := time.Unix(0, 1699999999000000000)
        fmt.Printf("From nanoseconds: %v\n", t2)
        
        // Current timestamp and back
        now := time.Now()
        timestamp := now.Unix()
        reconstructed := time.Unix(timestamp, 0)
        fmt.Printf("Original: %v\n", now)
        fmt.Printf("Reconstructed: %v\n", reconstructed)
    }
    ```

## Time Formatting and Parsing

### 1. Formatting Time

Go uses a unique reference time for formatting: `Mon Jan 2 15:04:05 MST 2006`

!!! example "Formatting Time"
    ```go title="formatting_time.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        t := time.Now()
        
        // Predefined formats
        fmt.Println("RFC1123:", t.Format(time.RFC1123))
        fmt.Println("RFC3339:", t.Format(time.RFC3339))
        fmt.Println("Kitchen:", t.Format(time.Kitchen))
        
        // Custom formats
        fmt.Println("Custom:", t.Format("2006-01-02 15:04:05"))
        fmt.Println("Custom:", t.Format("Jan 2, 2006 at 3:04pm"))
        fmt.Println("Custom:", t.Format("02/01/2006")) // DD/MM/YYYY
    }
    ```

### 2. Parsing Time

Parse strings into time using the same reference format:

!!! example "Parsing Time"
    ```go title="parsing_time.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        // Parse with predefined layouts
        t1, err := time.Parse(time.RFC3339, "2023-11-15T14:30:00Z")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Println("Parsed RFC3339:", t1)
        
        // Parse with custom layout
        t2, err := time.Parse("2006-01-02", "2023-11-15")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Println("Parsed custom:", t2)
        
        // Parse with time zone
        t3, err := time.Parse("2006-01-02 15:04:05 -0700", "2023-11-15 14:30:00 -0500")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Println("Parsed with timezone:", t3)
    }
    ```

## Time Operations

### 1. Time Arithmetic

!!! example "Time Arithmetic"
    ```go title="time_arithmetic.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        now := time.Now()
        
        // Add duration
        later := now.Add(24 * time.Hour) // Add 24 hours
        fmt.Printf("24 hours later: %v\n", later)
        
        // Subtract duration
        earlier := now.Add(-7 * 24 * time.Hour) // Subtract 7 days
        fmt.Printf("7 days earlier: %v\n", earlier)
        
        // Add specific units
        nextYear := now.AddDate(1, 0, 0) // Add 1 year
        nextMonth := now.AddDate(0, 1, 0) // Add 1 month
        nextDay := now.AddDate(0, 0, 1)   // Add 1 day
        
        fmt.Printf("Next year: %v\n", nextYear)
        fmt.Printf("Next month: %v\n", nextMonth)
        fmt.Printf("Next day: %v\n", nextDay)
    }
    ```

### 2. Time Comparison

!!! example "Time Comparison"
    ```go title="time_comparison.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        t1 := time.Date(2023, time.November, 15, 12, 0, 0, 0, time.UTC)
        t2 := time.Date(2023, time.November, 15, 14, 0, 0, 0, time.UTC)
        t3 := time.Date(2023, time.November, 15, 12, 0, 0, 0, time.UTC)
        
        // Before and After
        fmt.Printf("t1 before t2: %v\n", t1.Before(t2)) // true
        fmt.Printf("t1 after t2: %v\n", t1.After(t2))   // false
        
        // Equal
        fmt.Printf("t1 equal t3: %v\n", t1.Equal(t3)) // true
        
        // Sub returns duration between times
        duration := t2.Sub(t1)
        fmt.Printf("Duration between t2 and t1: %v\n", duration)
        fmt.Printf("Duration in hours: %.2f\n", duration.Hours())
    }
    ```

### 3. Time Difference

!!! example "Time Difference"
    ```go title="time_difference.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        start := time.Now()
        
        // Simulate some work
        time.Sleep(100 * time.Millisecond)
        
        end := time.Now()
        
        elapsed := end.Sub(start)
        fmt.Printf("Elapsed time: %v\n", elapsed)
        fmt.Printf("Elapsed milliseconds: %d\n", elapsed.Milliseconds())
        fmt.Printf("Elapsed microseconds: %d\n", elapsed.Microseconds())
        fmt.Printf("Elapsed nanoseconds: %d\n", elapsed.Nanoseconds())
    }
    ```

## Duration

### 1. Working with Durations

`time.Duration` represents the elapsed time between two instants:

!!! example "Working with Durations"
    ```go title="durations.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        // Creating durations
        d1 := 2 * time.Hour
        d2 := 30 * time.Minute
        d3 := 1000 * time.Millisecond
        d4 := 500 * time.Microsecond
        d5 := 200 * time.Nanosecond
        
        fmt.Printf("2 hours: %v\n", d1)
        fmt.Printf("30 minutes: %v\n", d2)
        fmt.Printf("1000 milliseconds: %v\n", d3)
        fmt.Printf("500 microseconds: %v\n", d4)
        fmt.Printf("200 nanoseconds: %v\n", d5)
        
        // Duration arithmetic
        total := d1 + d2
        fmt.Printf("2 hours + 30 minutes: %v\n", total)
        
        // Duration conversion
        fmt.Printf("2 hours in minutes: %.0f\n", d1.Minutes())
        fmt.Printf("2 hours in seconds: %.0f\n", d1.Seconds())
        fmt.Printf("1000ms in seconds: %.3f\n", d3.Seconds())
    }
    ```

### 2. Parsing Durations

!!! example "Parsing Durations"
    ```go title="parsing_durations.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        // Parse duration from string
        d1, err := time.ParseDuration("1h30m")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Parsed duration: %v\n", d1)
        
        d2, err := time.ParseDuration("100ms")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Parsed duration: %v\n", d2)
        
        // Valid duration units: ns, us, ms, s, m, h
        durations := []string{
            "1ns", "1us", "1ms", "1s", "1m", "1h",
            "1h30m", "1.5h", "90m", "3600s",
        }
        
        for _, dStr := range durations {
            d, err := time.ParseDuration(dStr)
            if err != nil {
                fmt.Printf("Error parsing %q: %v\n", dStr, err)
            } else {
                fmt.Printf("%q = %v\n", dStr, d)
            }
        }
    }
    ```

## Time Zones and Locations

### 1. Working with Time Zones

!!! example "Working with Time Zones"
    ```go title="time_zones.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        // Get current time in different time zones
        now := time.Now()
        
        // UTC
        utc := now.UTC()
        fmt.Printf("UTC: %v\n", utc)
        
        // Local time zone
        local := now.Local()
        fmt.Printf("Local: %v\n", local)
        
        // Specific time zones
        locations := []string{
            "America/New_York",
            "Europe/London",
            "Asia/Tokyo",
            "Australia/Sydney",
        }
        
        for _, locName := range locations {
            loc, err := time.LoadLocation(locName)
            if err != nil {
                fmt.Printf("Error loading location %s: %v\n", locName, err)
                continue
            }
            
            t := now.In(loc)
            fmt.Printf("%s: %v\n", locName, t)
        }
    }
    ```

### 2. Creating Time with Time Zones

!!! example "Creating Time with Time Zones"
    ```go title="creating_time_with_zones.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        // Create time in specific time zone
        loc, err := time.LoadLocation("America/New_York")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        
        // Create time in New York
        nyTime := time.Date(2023, time.November, 15, 14, 30, 0, 0, loc)
        fmt.Printf("New York time: %v\n", nyTime)
        
        // Convert to UTC
        utcTime := nyTime.UTC()
        fmt.Printf("UTC time: %v\n", utcTime)
        
        // Convert to another time zone
        tokyoLoc, _ := time.LoadLocation("Asia/Tokyo")
        tokyoTime := nyTime.In(tokyoLoc)
        fmt.Printf("Tokyo time: %v\n", tokyoTime)
    }
    ```

## Real-World Example: Event Scheduler

Let's build a comprehensive event scheduler that demonstrates various time operations:

!!! example "Event Scheduler"
    ```go title="event_scheduler.go" linenums="1" hl_lines="8-60"
    package main

    import (
        "fmt"
        "sort"
        "time"
    )

    // Event represents a scheduled event
    type Event struct {
        ID          string
        Title       string
        Description string
        StartTime   time.Time
        EndTime     time.Time
        Location    string
        TimeZone    *time.Location
    }

    // EventScheduler manages events
    type EventScheduler struct {
        events []Event
    }

    func NewEventScheduler() *EventScheduler {
        return &EventScheduler{
            events: make([]Event, 0),
        }
    }

    func (es *EventScheduler) AddEvent(event Event) error {
        // Validate event times
        if event.EndTime.Before(event.StartTime) {
            return fmt.Errorf("end time cannot be before start time")
        }
        
        es.events = append(es.events, event)
        return nil
    }

    func (es *EventScheduler) GetUpcomingEvents(limit int) []Event {
        now := time.Now()
        var upcoming []Event
        
        for _, event := range es.events {
            if event.StartTime.After(now) {
                upcoming = append(upcoming, event)
            }
        }
        
        // Sort by start time
        sort.Slice(upcoming, func(i, j int) bool {
            return upcoming[i].StartTime.Before(upcoming[j].StartTime)
        })
        
        if len(upcoming) > limit {
            upcoming = upcoming[:limit]
        }
        
        return upcoming
    }

    func (es *EventScheduler) GetEventsInDateRange(start, end time.Time) []Event {
        var eventsInRange []Event
        
        for _, event := range es.events {
            if (event.StartTime.Equal(start) || event.StartTime.After(start)) &&
                (event.StartTime.Equal(end) || event.StartTime.Before(end)) {
                eventsInRange = append(eventsInRange, event)
            }
        }
        
        return eventsInRange
    }

    func (es *EventScheduler) GetEventsByLocation(location string) []Event {
        var eventsByLocation []Event
        
        for _, event := range es.events {
            if event.Location == location {
                eventsByLocation = append(eventsByLocation, event)
            }
        }
        
        return eventsByLocation
    }

    func (es *EventScheduler) GetEventDuration(eventID string) (time.Duration, error) {
        for _, event := range es.events {
            if event.ID == eventID {
                return event.EndTime.Sub(event.StartTime), nil
            }
        }
        return 0, fmt.Errorf("event not found")
    }

    func (es *EventScheduler) RescheduleEvent(eventID string, newStart, newEnd time.Time) error {
        for i, event := range es.events {
            if event.ID == eventID {
                if newEnd.Before(newStart) {
                    return fmt.Errorf("end time cannot be before start time")
                }
                
                es.events[i].StartTime = newStart
                es.events[i].EndTime = newEnd
                return nil
            }
        }
        return fmt.Errorf("event not found")
    }

    func (es *EventScheduler) ConvertEventTimezone(eventID string, newLoc *time.Location) (*Event, error) {
        for _, event := range es.events {
            if event.ID == eventID {
                // Create a copy of the event
                newEvent := event
                newEvent.StartTime = event.StartTime.In(newLoc)
                newEvent.EndTime = event.EndTime.In(newLoc)
                newEvent.TimeZone = newLoc
                return &newEvent, nil
            }
        }
        return nil, fmt.Errorf("event not found")
    }

    func (es *EventScheduler) PrintEvents() {
        fmt.Println("\n=== All Events ===")
        for _, event := range es.events {
            fmt.Printf("\nID: %s\n", event.ID)
            fmt.Printf("Title: %s\n", event.Title)
            fmt.Printf("Description: %s\n", event.Description)
            fmt.Printf("Start: %v\n", event.StartTime)
            fmt.Printf("End: %v\n", event.EndTime)
            fmt.Printf("Duration: %v\n", event.EndTime.Sub(event.StartTime))
            fmt.Printf("Location: %s\n", event.Location)
            if event.TimeZone != nil {
                fmt.Printf("Time Zone: %s\n", event.TimeZone)
            }
        }
    }

    func main() {
        // Create scheduler
        scheduler := NewEventScheduler()
        
        // Load time zones
        nyLoc, _ := time.LoadLocation("America/New_York")
        tokyoLoc, _ := time.LoadLocation("Asia/Tokyo")
        
        // Create events
        events := []Event{
            {
                ID:          "1",
                Title:       "Team Meeting",
                Description: "Weekly team sync",
                StartTime:   time.Date(2023, time.November, 20, 10, 0, 0, 0, nyLoc),
                EndTime:     time.Date(2023, time.November, 20, 11, 0, 0, 0, nyLoc),
                Location:    "Conference Room A",
                TimeZone:    nyLoc,
            },
            {
                ID:          "2",
                Title:       "Lunch with Client",
                Description: "Discuss project requirements",
                StartTime:   time.Date(2023, time.November, 20, 12, 30, 0, 0, nyLoc),
                EndTime:     time.Date(2023, time.November, 20, 14, 0, 0, 0, nyLoc),
                Location:    "Restaurant Downtown",
                TimeZone:    nyLoc,
            },
            {
                ID:          "3",
                Title:       "Project Deadline",
                Description: "Submit final deliverables",
                StartTime:   time.Date(2023, time.November, 25, 17, 0, 0, 0, nyLoc),
                EndTime:     time.Date(2023, time.November, 25, 18, 0, 0, 0, nyLoc),
                Location:    "Office",
                TimeZone:    nyLoc,
            },
        }
        
        // Add events
        for _, event := range events {
            if err := scheduler.AddEvent(event); err != nil {
                fmt.Printf("Error adding event: %v\n", err)
            }
        }
        
        // Print all events
        scheduler.PrintEvents()
        
        // Get upcoming events
        fmt.Println("\n=== Upcoming Events ===")
        upcoming := scheduler.GetUpcomingEvents(5)
        for _, event := range upcoming {
            fmt.Printf("- %s at %v\n", event.Title, event.StartTime)
        }
        
        // Get events in date range
        fmt.Println("\n=== Events in Date Range ===")
        start := time.Date(2023, time.November, 20, 0, 0, 0, 0, time.UTC)
        end := time.Date(2023, time.November, 21, 0, 0, 0, 0, time.UTC)
        eventsInRange := scheduler.GetEventsInDateRange(start, end)
        for _, event := range eventsInRange {
            fmt.Printf("- %s on %v\n", event.Title, event.StartTime)
        }
        
        // Get event duration
        fmt.Println("\n=== Event Durations ===")
        duration, err := scheduler.GetEventDuration("1")
        if err != nil {
            fmt.Printf("Error: %v\n", err)
        } else {
            fmt.Printf("Team meeting duration: %v\n", duration)
        }
        
        // Convert event timezone
        fmt.Println("\n=== Timezone Conversion ===")
        convertedEvent, err := scheduler.ConvertEventTimezone("1", tokyoLoc)
        if err != nil {
            fmt.Printf("Error: %v\n", err)
        } else {
            fmt.Printf("Team meeting in Tokyo time:\n")
            fmt.Printf("Start: %v\n", convertedEvent.StartTime)
            fmt.Printf("End: %v\n", convertedEvent.EndTime)
        }
        
        // Reschedule event
        fmt.Println("\n=== Rescheduling Event ===")
        newStart := time.Date(2023, time.November, 20, 9, 0, 0, 0, nyLoc)
        newEnd := time.Date(2023, time.November, 20, 10, 30, 0, 0, nyLoc)
        err = scheduler.RescheduleEvent("1", newStart, newEnd)
        if err != nil {
            fmt.Printf("Error: %v\n", err)
        } else {
            fmt.Println("Event rescheduled successfully")
            scheduler.PrintEvents()
        }
    }
    ```

### How This Example Works:

1. **Event Management**:
   - Create, store, and manage events with time zones
   - Validate event times (end after start)
   - Support multiple time zones

2. **Query Operations**:
   - Get upcoming events sorted by time
   - Filter events by date range
   - Find events by location

3. **Time Operations**:
   - Calculate event durations
   - Convert between time zones
   - Reschedule events

4. **Time Zone Handling**:
   - Store events with specific time zones
   - Convert times between zones
   - Display times in local format

### Real-World Applications:

1. **Calendar Applications**:
   - Personal or shared calendars
   - Meeting scheduling
   - Reminder systems

2. **Booking Systems**:
   - Hotel reservations
   - Flight bookings
   - Appointment scheduling

3. **Monitoring Systems**:
   - Scheduled maintenance
   - Alert timing
   - Report generation

4. **Distributed Systems**:
   - Coordinating events across time zones
   - Logging with timestamps
   - Expiring cache entries

## Best Practices for Time Handling

!!! tip "UTC Storage"
    Always use UTC for internal storage and convert to local time for display.

!!! example "UTC Storage"
    ```go title="utc_storage.go" linenums="1" hl_lines="8-16"
    package main

    import "time"

    // Good: Store times in UTC
    func SaveToDatabase(t time.Time) {
        utcTime := t.UTC()
        // Save utcTime to database
    }

    // Bad: Store local time
    func SaveToDatabaseBad(t time.Time) {
        // Save t directly - might cause issues with time zones
    }
    ```

!!! tip "Explicit Time Zones"
    Be explicit about time zones to avoid ambiguity.

!!! example "Explicit Time Zones"
    ```go title="explicit_time_zones.go" linenums="1" hl_lines="8-14"
    package main

    import "time"

    func main() {
        // Good: Specify time zone
        t := time.Date(2023, time.November, 15, 12, 0, 0, 0, time.UTC)
        
        // Bad: Assume local time zone
        // t := time.Date(2023, time.November, 15, 12, 0, 0, 0, time.Local)
    }
    ```

!!! tip "Duration Usage"
    Use Duration for time intervals instead of magic numbers.

!!! example "Duration Usage"
    ```go title="duration_usage.go" linenums="1" hl_lines="8-14"
    package main

    import "time"

    func main() {
        // Good: Use duration
        timeout := 30 * time.Second
        
        // Bad: Use magic numbers
        // timeout := 30000000000 // 30 seconds in nanoseconds
    }
    ```

!!! tip "Error Handling"
    Handle time parsing errors gracefully.

!!! example "Error Handling"
    ```go title="time_error_handling.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "time"
    )

    func parseTime(layout, value string) (time.Time, error) {
        t, err := time.Parse(layout, value)
        if err != nil {
            return time.Time{}, fmt.Errorf("invalid time format: %w", err)
        }
        return t, nil
    }
    ```

!!! tip "Consistent Formats"
    Use consistent time formats throughout your application.

!!! example "Consistent Formats"
    ```go title="consistent_formats.go" linenums="1" hl_lines="8-14"
    package main

    const (
        APILayout     = "2006-01-02T15:04:05Z"
        DatabaseLayout = "2006-01-02 15:04:05.999999999-07:00"
        DisplayLayout  = "Jan 2, 2006 at 3:04pm"
    )
    ```

## Performance Considerations

!!! warning "Time Zone Loading"
    Avoid repeated time zone loading for better performance.

!!! example "Time Zone Loading"
    ```go title="timezone_loading.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "time"
    )

    // Good: Load time zone once
    var nyLoc *time.Location

    func init() {
        nyLoc, _ = time.LoadLocation("America/New_York")
    }

    func getNYTime() time.Time {
        return time.Now().In(nyLoc)
    }

    // Bad: Load time zone on every call
    func getNYTimeBad() time.Time {
        nyLoc, _ := time.LoadLocation("America/New_York")
        return time.Now().In(nyLoc)
    }
    ```

!!! warning "Time-based Operations"
    Use time.After for delays instead of time.Sleep in goroutines.

!!! example "Time-based Operations"
    ```go title="time_operations.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        // Good: Use time.After
        select {
        case <-time.After(5 * time.Second):
            fmt.Println("Timeout")
        case result := <-ch:
            fmt.Println("Received:", result)
        }
        
        // Bad: Use time.Sleep in goroutine
        // go func() {
        //     time.Sleep(5 * time.Second)
        //     fmt.Println("Timeout")
        // }()
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Time Representation**: Use `time.Time` for precise time representation with nanosecond precision
    - **Epoch Time**: Convert between time and Unix timestamps with `Unix()`, `UnixMilli()`, `UnixMicro()`, `UnixNano()`
    - **Formatting/Parsing**: Use reference time `Mon Jan 2 15:04:05 MST 2006` for formatting and parsing
    - **Time Operations**: Perform arithmetic with `Add()`, `Sub()`, and `AddDate()`
    - **Time Zones**: Handle time zones with `LoadLocation()` and `In()` methods
    - **Best Practices**: Store times in UTC, be explicit about time zones, use durations for intervals

!!! quote "Remember"
    "Time handling is a critical aspect of many Go applications. The time package provides comprehensive tools for representing time, working with epoch time, formatting, parsing, and handling time zones. By mastering Go's time package, you can build reliable applications that work correctly across different time zones and handle time-related operations efficiently."}