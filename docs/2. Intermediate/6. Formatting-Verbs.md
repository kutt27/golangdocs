# Formatting Verbs in Go: A Comprehensive Guide

## Introduction to Formatting Verbs
In Go, formatting verbs are special placeholders used with the `fmt` package to control how values are formatted when printed. These verbs provide powerful control over output formatting, essential for creating readable logs, user-friendly displays, and properly structured data.

## Basic Formatting with `fmt.Printf`
The most common formatting function is `fmt.Printf`, which uses verbs to format values:

```go
package main

import "fmt"

func main() {
    name := "Alice"
    age := 30
    fmt.Printf("Name: %s, Age: %d\n", name, age)
    // Output: Name: Alice, Age: 30
}
```

## General Formatting Verbs

| Verb | Description                              | Example                          |
|------|------------------------------------------|----------------------------------|
| `%v` | Default format                           | `fmt.Printf("%v", 42)` → `42`    |
| `%+v` | Adds struct field names                  | `fmt.Printf("%+v", p)`           |
| `%#v` | Go syntax representation                | `fmt.Printf("%#v", []int{1,2})`  |
| `%T`  | Type of value                            | `fmt.Printf("%T", 42)` → `int`   |
| `%%`  | Literal percent sign                     | `fmt.Printf("%%") → `%`          |

### Example: General Verbs
```go
type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{"Bob", 25}
    fmt.Printf("%v\n", p)     // {Bob 25}
    fmt.Printf("%+v\n", p)    // {Name:Bob Age:25}
    fmt.Printf("%#v\n", p)    // main.Person{Name:"Bob", Age:25}
    fmt.Printf("%T\n", p)     // main.Person
}
```

## Integer Formatting Verbs

| Verb | Description                              | Example                          |
|------|------------------------------------------|----------------------------------|
| `%b` | Base 2 (binary)                          | `fmt.Printf("%b", 5)` → `101`    |
| `%c` | Character represented by Unicode code    | `fmt.Printf("%c", 0x41)` → `A`   |
| `%d` | Base 10 (decimal)                        | `fmt.Printf("%d", 42)` → `42`    |
| `%o` | Base 8 (octal)                           | `fmt.Printf("%o", 8)` → `10`     |
| `%O` | Base 8 with 0o prefix                    | `fmt.Printf("%O", 8)` → `0o10`   |
| `%q` | Single-quoted character                  | `fmt.Printf("%q", 'A') → `'A'`   |
| `%x` | Base 16 (hexadecimal), lowercase         | `fmt.Printf("%x", 255)` → `ff`   |
| `%X` | Base 16 (hexadecimal), uppercase         | `fmt.Printf("%X", 255)` → `FF`   |
| `%U` | Unicode format (U+XXXX)                  | `fmt.Printf("%U", 'A') → `U+0041` |

### Example: Integer Formatting
```go
func main() {
    num := 42
    fmt.Printf("Decimal: %d\n", num)      // 42
    fmt.Printf("Binary: %b\n", num)       // 101010
    fmt.Printf("Octal: %o\n", num)        // 52
    fmt.Printf("Hex: %x\n", num)          // 2a
    fmt.Printf("Hex (upper): %X\n", num)  // 2A
    fmt.Printf("Unicode: %U\n", num)      // U+002A
}
```

## Floating-Point and Complex Formatting

| Verb | Description                              | Example                          |
|------|------------------------------------------|----------------------------------|
| `%b` | Scientific notation with binary exponent | `fmt.Printf("%b", 3.14)`         |
| `%e` | Scientific notation (lowercase e)        | `fmt.Printf("%e", 3.14)` → `3.140000e+00` |
| `%E` | Scientific notation (uppercase E)        | `fmt.Printf("%E", 3.14)` → `3.140000E+00` |
| `%f` | Decimal notation                         | `fmt.Printf("%f", 3.14)` → `3.140000` |
| `%F` | Same as %f                               | `fmt.Printf("%F", 3.14)` → `3.140000` |
| `%g` | %e for large exponents, %f otherwise     | `fmt.Printf("%g", 3.14)` → `3.14` |
| `%G` | %E for large exponents, %F otherwise     | `fmt.Printf("%G", 3.14)` → `3.14` |
| `%x` | Hexadecimal notation (fractional part)   | `fmt.Printf("%x", 3.14)`        |
| `%X` | Uppercase hexadecimal notation           | `fmt.Printf("%X", 3.14)`        |

### Example: Floating-Point Formatting
```go
func main() {
    pi := 3.1415926535
    fmt.Printf("Default: %v\n", pi)      // 3.1415926535
    fmt.Printf("Decimal: %f\n", pi)      // 3.141593
    fmt.Printf("Scientific: %e\n", pi)   // 3.141593e+00
    fmt.Printf("Shortest: %g\n", pi)     // 3.1415926535
    fmt.Printf("Hex: %x\n", pi)          // 1.921fb54442d18p+1
}
```

## String and Byte Formatting

| Verb | Description                              | Example                          |
|------|------------------------------------------|----------------------------------|
| `%s` | String                                   | `fmt.Printf("%s", "hello")` → `hello` |
| `%q` | Double-quoted string                     | `fmt.Printf("%q", "hello")` → `"hello"` |
| `%x` | Hexadecimal dump of bytes                | `fmt.Printf("%x", "hi")` → `6869` |
| `%X` | Uppercase hexadecimal dump               | `fmt.Printf("%X", "hi")` → `6869` |

### Example: String Formatting
```go
func main() {
    str := "Hello, 世界"
    fmt.Printf("String: %s\n", str)      // Hello, 世界
    fmt.Printf("Quoted: %q\n", str)      // "Hello, 世界"
    fmt.Printf("Hex bytes: %x\n", str)   // 48656c6c6f2c20e4b896e7958c
}
```

## Boolean Formatting

| Verb | Description                              | Example                          |
|------|------------------------------------------|----------------------------------|
| `%t` | Boolean (true or false)                  | `fmt.Printf("%t", true)` → `true` |

### Example: Boolean Formatting
```go
func main() {
    flag := true
    fmt.Printf("Flag: %t\n", flag)       // true
}
```

## Pointer Formatting

| Verb | Description                              | Example                          |
|------|------------------------------------------|----------------------------------|
| `%p` | Pointer address (hexadecimal)            | `fmt.Printf("%p", &x)` → `0x1040a124` |

### Example: Pointer Formatting
```go
func main() {
    x := 42
    fmt.Printf("Address: %p\n", &x)     // 0x1040a124 (example address)
}
```

## Width and Precision
You can control formatting width and precision using numbers between `%` and the verb:

```go
func main() {
    // Width: minimum number of characters
    fmt.Printf("|%10d|\n", 42)      // |        42|
    fmt.Printf("|%-10d|\n", 42)     // |42        |
    
    // Precision: number of decimal places
    fmt.Printf("|%.2f|\n", 3.14159) // |3.14|
    
    // Combined width and precision
    fmt.Printf("|%10.2f|\n", 3.14159) // |      3.14|
    fmt.Printf("|%-10.2f|\n", 3.14159) // |3.14      |
}
```

## Formatting Flags
Flags modify formatting behavior:

| Flag | Description                              | Example                          |
|------|------------------------------------------|----------------------------------|
| `+`  | Always show sign for numbers             | `fmt.Printf("%+d", 42)` → `+42`  |
| `-`  | Left-justify within width                | `fmt.Printf("%-5d", 42)` → `42   ` |
| ` `  | Leave space for positive numbers         | `fmt.Printf("% d", 42)` → ` 42`  |
| `0`  | Pad with zeros instead of spaces         | `fmt.Printf("%05d", 42)` → `00042` |
| `#`  | Alternate format (adds prefixes)         | `fmt.Printf("%#o", 8)` → `010`   |

### Example: Formatting Flags
```go
func main() {
    // Sign flag
    fmt.Printf("With sign: %+d\n", 42)     // +42
    fmt.Printf("With sign: %+d\n", -42)    // -42
    
    // Space flag
    fmt.Printf("Space: % d\n", 42)         //  42
    fmt.Printf("Space: % d\n", -42)        // -42
    
    // Zero padding
    fmt.Printf("Zero pad: %05d\n", 42)     // 00042
    
    // Alternate format
    fmt.Printf("Alternate: %#o\n", 8)      // 010
    fmt.Printf("Alternate: %#x\n", 255)    // 0xff
}
```

## Custom Formatting with Interfaces
You can implement the `fmt.Formatter` or `fmt.Stringer` interfaces for custom formatting:

### `fmt.Stringer` Interface
```go
type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d years)", p.Name, p.Age)
}

func main() {
    p := Person{"Charlie", 35}
    fmt.Printf("%s\n", p)  // Charlie (35 years)
}
```

### `fmt.Formatter` Interface
```go
type Temperature float64

func (t Temperature) Format(f fmt.State, verb rune) {
    switch verb {
    case 'f':
        fmt.Fprintf(f, "%.1f°C", float64(t))
    case 'F':
        fmt.Fprintf(f, "%.1f°F", float64(t)*9/5+32)
    default:
        fmt.Fprintf(f, "%v", t)
    }
}

func main() {
    temp := Temperature(37.5)
    fmt.Printf("Celsius: %f\n", temp)  // 37.5°C
    fmt.Printf("Fahrenheit: %F\n", temp) // 99.5°F
}
```

## Real-World Example: Report Generator
Let's create a practical report generator that demonstrates various formatting techniques:

```go
package main

import (
    "fmt"
    "io"
    "os"
    "text/tabwriter"
    "time"
)

type Employee struct {
    ID        int
    Name      string
    Position  string
    Salary    float64
    HireDate  time.Time
    IsActive  bool
}

type ReportGenerator struct {
    output io.Writer
}

func NewReportGenerator(w io.Writer) *ReportGenerator {
    return &ReportGenerator{output: w}
}

func (rg *ReportGenerator) GenerateHeader(title string) {
    fmt.Fprintf(rg.output, "\n%s\n", title)
    fmt.Fprintf(rg.output, "%s\n", "========================================")
}

func (rg *ReportGenerator) GenerateSummary(employees []Employee) {
    total := len(employees)
    active := 0
    totalSalary := 0.0
    
    for _, emp := range employees {
        if emp.IsActive {
            active++
            totalSalary += emp.Salary
        }
    }
    
    avgSalary := 0.0
    if active > 0 {
        avgSalary = totalSalary / float64(active)
    }
    
    fmt.Fprintf(rg.output, "Summary:\n")
    fmt.Fprintf(rg.output, "  Total Employees: %d\n", total)
    fmt.Fprintf(rg.output, "  Active Employees: %d (%.1f%%)\n", active, float64(active)/float64(total)*100)
    fmt.Fprintf(rg.output, "  Total Salary: $%+.2f\n", totalSalary)
    fmt.Fprintf(rg.output, "  Average Salary: $%.2f\n", avgSalary)
    fmt.Fprintf(rg.output, "  Report Generated: %s\n", time.Now().Format("2006-01-02 15:04:05"))
}

func (rg *ReportGenerator) GenerateEmployeeTable(employees []Employee) {
    w := tabwriter.NewWriter(rg.output, 0, 0, 2, ' ', 0)
    defer w.Flush()
    
    // Table header
    fmt.Fprintln(w, "ID\tName\tPosition\tSalary\tHire Date\tStatus")
    fmt.Fprintln(w, "--\t----\t--------\t------\t----------\t------")
    
    // Table rows
    for _, emp := range employees {
        status := "Active"
        if !emp.IsActive {
            status = "Inactive"
        }
        
        fmt.Fprintf(w, "%05d\t%s\t%s\t$%10.2f\t%s\t%s\n",
            emp.ID,
            emp.Name,
            emp.Position,
            emp.Salary,
            emp.HireDate.Format("2006-01-02"),
            status)
    }
}

func (rg *ReportGenerator) GenerateDetails(employees []Employee) {
    fmt.Fprintf(rg.output, "\nEmployee Details:\n")
    fmt.Fprintf(rg.output, "%s\n", "----------------------------------------")
    
    for _, emp := range employees {
        fmt.Fprintf(rg.output, "\nEmployee ID: #%05d\n", emp.ID)
        fmt.Fprintf(rg.output, "  Name: %q\n", emp.Name)
        fmt.Fprintf(rg.output, "  Position: %s\n", emp.Position)
        fmt.Fprintf(rg.output, "  Salary: $%12.2f\n", emp.Salary)
        fmt.Fprintf(rg.output, "  Hire Date: %s (%s)\n", 
            emp.HireDate.Format("January 2, 2006"),
            rg.yearsOfService(emp.HireDate))
        fmt.Fprintf(rg.output, "  Status: %t\n", emp.IsActive)
        fmt.Fprintf(rg.output, "  Memory Address: %p\n", &emp)
    }
}

func (rg *ReportGenerator) yearsOfService(hireDate time.Time) string {
    years := time.Since(hireDate).Hours() / 24 / 365
    return fmt.Sprintf("%.1f years", years)
}

func main() {
    // Sample data
    employees := []Employee{
        {101, "Alice Johnson", "Software Engineer", 95000.50, time.Date(2020, 5, 15, 0, 0, 0, 0, time.UTC), true},
        {102, "Bob Smith", "Project Manager", 105000.00, time.Date(2018, 8, 22, 0, 0, 0, 0, time.UTC), true},
        {103, "Charlie Brown", "QA Engineer", 75000.75, time.Date(2021, 3, 10, 0, 0, 0, 0, time.UTC), true},
        {104, "Diana Prince", "DevOps Engineer", 110000.25, time.Date(2019, 11, 5, 0, 0, 0, 0, time.UTC), false},
    }
    
    // Generate report to stdout
    generator := NewReportGenerator(os.Stdout)
    
    generator.GenerateHeader("Employee Report")
    generator.GenerateSummary(employees)
    generator.GenerateEmployeeTable(employees)
    generator.GenerateDetails(employees)
}
```

### Output:
```
Employee Report
========================================
Summary:
  Total Employees: 4
  Active Employees: 3 (75.0%)
  Total Salary: $+275001.25
  Average Salary: $91667.08
  Report Generated: 2023-11-15 14:30:45

ID    Name    Position      Salary      Hire Date    Status
--    ----    --------      ------      ----------    ------
00101 Alice Johnson  Software Engineer  $  95000.50  2020-05-15  Active
00102 Bob Smith      Project Manager    $ 105000.00  2018-08-22  Active
00103 Charlie Brown  QA Engineer        $  75000.75  2021-03-10  Active
00104 Diana Prince   DevOps Engineer    $ 110000.25  2019-11-05  Inactive

Employee Details:
----------------------------------------

Employee ID: #00101
  Name: "Alice Johnson"
  Position: Software Engineer
  Salary: $    95000.50
  Hire Date: May 15, 2020 (3.5 years)
  Status: true
  Memory Address: 0x14000126000

Employee ID: #00102
  Name: "Bob Smith"
  Position: Project Manager
  Salary: $   105000.00
  Hire Date: August 22, 2018 (5.2 years)
  Status: true
  Memory Address: 0x14000126060

Employee ID: #00103
  Name: "Charlie Brown"
  Position: QA Engineer
  Salary: $    75000.75
  Hire Date: March 10, 2021 (2.7 years)
  Status: true
  Memory Address: 0x140001260c0

Employee ID: #00104
  Name: "Diana Prince"
  Position: DevOps Engineer
  Salary: $   110000.25
  Hire Date: November 5, 2019 (4.0 years)
  Status: false
  Memory Address: 0x14000126120
```

### How This Example Demonstrates Formatting Verbs:

1. **Integer Formatting**:
   - `%05d` for zero-padded employee IDs
   - `%d` for counts and percentages

2. **Floating-Point Formatting**:
   - `%.2f` for currency values
   - `%.1f` for years of service
   - `%+.2f` to show sign for total salary

3. **String Formatting**:
   - `%s` for regular strings
   - `%q` for quoted names
   - Custom date formatting with time format strings

4. **Boolean Formatting**:
   - `%t` for active status

5. **Pointer Formatting**:
   - `%p` to show memory addresses

6. **Width and Precision**:
   - `%10.2f` for aligned currency values
   - `%12.2f` for detailed salary display

7. **Custom Formatting**:
   - `yearsOfService` method uses `fmt.Sprintf` for custom output
   - Date formatting with custom layouts

8. **Tabular Output**:
   - Uses `text/tabwriter` for aligned columns
   - Combines multiple formatting verbs for clean tables

### Real-World Applications of This Pattern:

1. **Business Reporting**:
   - Financial reports with properly formatted numbers
   - HR reports with employee statistics
   - Sales reports with currency formatting

2. **Logging Systems**:
   - Structured logging with consistent formatting
   - Debug logs with memory addresses and type information
   - Error logs with detailed context

3. **CLI Applications**:
   - User-friendly command output
   - Progress indicators with aligned text
   - Help text with properly formatted examples

4. **Data Export**:
   - CSV/TSV generation with consistent formatting
   - JSON/XML with custom string representations
   - Human-readable data summaries

### Benefits of This Approach:

1. **Consistency**:
   - Uniform formatting across all reports
   - Predictable output format
   - Easy to parse for automated systems

2. **Readability**:
   - Aligned columns and consistent spacing
   - Proper number formatting for currency
   - Clear visual hierarchy

3. **Maintainability**:
   - Centralized formatting logic
   - Easy to modify formatting rules
   - Reusable components for different reports

4. **Flexibility**:
   - Can output to any io.Writer (file, network, etc.)
   - Easy to add new formatting options
   - Supports both human and machine-readable formats

## Conclusion

Formatting verbs in Go provide powerful tools for controlling output presentation:

1. **Basic Formatting**:
   - Use `%v` for default formatting
   - Use `%T` for type information
   - Use `%%` for literal percent signs

2. **Type-Specific Formatting**:
   - Integers: `%d`, `%b`, `%o`, `%x`, etc.
   - Floats: `%f`, `%e`, `%g`, etc.
   - Strings: `%s`, `%q`, `%x`
   - Booleans: `%t`
   - Pointers: `%p`

3. **Advanced Formatting**:
   - Control width and precision with numbers
   - Use flags for sign, padding, and alternate formats
   - Implement custom formatting with interfaces

4. **Best Practices**:
   - Use `tabwriter` for aligned tables
   - Prefer `fmt.Sprintf` for building strings
   - Implement `Stringer` for custom types
   - Use consistent formatting throughout your application

The report generator example demonstrates how combining these formatting techniques can create professional, readable output for real-world applications. Mastering formatting verbs is essential for creating effective Go applications that communicate clearly with users and other systems.

By understanding and properly using formatting verbs, you can:
- Create more user-friendly command-line tools
- Generate professional reports and documents
- Improve the readability of logs and debug output
- Ensure consistent data presentation across your application
- Build more maintainable and flexible output systems