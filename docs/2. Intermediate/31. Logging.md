

# Logging in Go: A Comprehensive Guide

## Introduction to Logging

Logging is a critical aspect of software development that provides visibility into application behavior, helps with debugging, and enables monitoring and troubleshooting. In Go, logging can range from simple output using the standard library to sophisticated structured logging with third-party packages.

## The Standard Log Package

Go's standard `log` package provides basic logging functionality. It's simple and built-in, making it suitable for small applications or quick prototyping.

### Basic Usage

```go
package main

import (
    "log"
    "os"
)

func main() {
    // Basic logging
    log.Println("This is a standard log message")
    
    // Logging with formatting
    name := "Alice"
    age := 30
    log.Printf("User: %s, Age: %d", name, age)
    
    // Fatal logging (terminates the program)
    log.Fatal("This message will be logged and the program will exit")
    
    // Panic logging (causes a panic)
    log.Panic("This message will be logged and then panic")
}
```

### Log Flags

The `log` package allows you to customize the output format using flags:

```go
package main

import (
    "log"
    "os"
)

func main() {
    // Set log flags to include date, time, and file name
    log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
    
    log.Println("This log includes date, time, and file name")
    
    // Set a custom prefix
    log.SetPrefix("APP: ")
    log.Println("This log has a custom prefix")
    
    // Set output to a file
    file, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        log.Fatal("Failed to open log file:", err)
    }
    defer file.Close()
    
    log.SetOutput(file)
    log.Println("This message will be written to app.log")
}
```

### Available Log Flags

| Flag | Description |
|------|-------------|
| `log.Ldate` | Date in the local time zone: 2009/01/23 |
| `log.Ltime` | Time in the local time zone: 01:23:23 |
| `log.Lmicroseconds` | Microsecond resolution: 01:23:23.123123 |
| `log.Llongfile` | Full file name and line number: /a/b/c/d.go:23 |
| `log.Lshortfile` | Final file name element and line number: d.go:23 |
| `log.LUTC` | Use UTC rather than the local time zone |
| `log.Lmsgprefix` | Move the prefix to the beginning of the message |
| `log.LstdFlags` | Standard flags: Ldate | Ltime |

## Third-Party Logging Libraries

While the standard `log` package is sufficient for simple use cases, many applications benefit from more advanced features provided by third-party logging libraries.

### Logrus

Logrus is a structured logger for Go, compatible with the standard library logger.

```go
package main

import (
    "os"
    
    "github.com/sirupsen/logrus"
)

func main() {
    // Create a new logger
    logger := logrus.New()
    
    // Set log level
    logger.SetLevel(logrus.DebugLevel)
    
    // Set formatter
    logger.SetFormatter(&logrus.JSONFormatter{})
    
    // Set output to stdout
    logger.SetOutput(os.Stdout)
    
    // Log with different levels
    logger.Debug("Debug message")
    logger.Info("Info message")
    logger.Warn("Warning message")
    logger.Error("Error message")
    
    // Log with fields
    logger.WithFields(logrus.Fields{
        "event": "test",
        "topic": "logging",
    }).Info("Message with fields")
    
    // Fatal and panic
    // logger.Fatal("Fatal message")  // This would terminate the program
    // logger.Panic("Panic message")  // This would cause a panic
}
```

### Zap

Zap is a high-performance, structured logging library from Uber.

```go
package main

import (
    "go.uber.org/zap"
)

func main() {
    // Create a logger
    logger, err := zap.NewProduction()
    if err != nil {
        panic(err)
    }
    defer logger.Sync()
    
    // Basic logging
    logger.Info("Info message",
        zap.String("service", "example"),
        zap.Int("attempt", 3),
    )
    
    // Debug logging (disabled in production by default)
    logger.Debug("Debug message")
    
    // Error logging
    logger.Error("Error message",
        zap.Error(fmt.Errorf("something went wrong")),
    )
    
    // For development, you can use a different configuration
    devLogger, err := zap.NewDevelopment()
    if err != nil {
        panic(err)
    }
    defer devLogger.Sync()
    
    devLogger.Debug("This debug message will be visible in development mode")
}
```

### Zerolog

Zerolog is a zero-allocation JSON logger designed for performance.

```go
package main

import (
    "github.com/rs/zerolog"
    "github.com/rs/zerolog/log"
)

func main() {
    // Set global log level
    zerolog.SetGlobalLevel(zerolog.InfoLevel)
    
    // Basic logging
    log.Info().Msg("Info message")
    log.Debug().Msg("Debug message")  // This won't be printed
    
    // Structured logging
    log.Info().
        Str("service", "example").
        Int("attempt", 3).
        Msg("Message with fields")
    
    // Error logging
    log.Error().
        Err(fmt.Errorf("something went wrong")).
        Msg("Error message")
    
    // Create a child logger with context
    subLogger := log.With().Str("component", "auth").Logger()
    subLogger.Info().Msg("Message from auth component")
}
```

## Structured Logging

Structured logging uses key-value pairs to make logs more machine-readable and searchable. This is particularly valuable in production environments where logs might be processed by automated systems.

### Benefits of Structured Logging

1. **Machine-Readable**: Logs can be easily parsed by log management systems
2. **Consistent Format**: All logs follow the same structure
3. **Rich Context**: Additional metadata can be attached to log messages
4. **Better Filtering**: Logs can be filtered based on specific fields

### Example with Logrus

```go
package main

import (
    "os"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    logger.SetFormatter(&logrus.JSONFormatter{})
    
    // Log with context
    logger.WithFields(logrus.Fields{
        "event":     "user_login",
        "user_id":   "123",
        "ip":        "192.168.1.1",
        "user_agent": "Mozilla/5.0",
    }).Info("User logged in")
    
    // Nested fields
    requestLogger := logger.WithFields(logrus.Fields{
        "request_id": "abc123",
        "method":     "GET",
        "path":       "/api/users",
    })
    
    requestLogger.Info("Request received")
    requestLogger.WithFields(logrus.Fields{
        "status": 200,
        "duration": "120ms",
    }).Info("Request completed")
}
```

### Example with Zap

```go
package main

import (
    "go.uber.org/zap"
)

func main() {
    logger, _ := zap.NewProduction()
    defer logger.Sync()
    
    // Log with context
    logger.Info("User logged in",
        zap.String("event", "user_login"),
        zap.String("user_id", "123"),
        zap.String("ip", "192.168.1.1"),
        zap.String("user_agent", "Mozilla/5.0"),
    )
    
    // Create a child logger with context
    requestLogger := logger.With(
        zap.String("request_id", "abc123"),
        zap.String("method", "GET"),
        zap.String("path", "/api/users"),
    )
    
    requestLogger.Info("Request received")
    requestLogger.Info("Request completed",
        zap.Int("status", 200),
        zap.String("duration", "120ms"),
    )
}
```

## Log Levels

Log levels help categorize messages by severity, allowing developers to control verbosity and focus on relevant information.

### Common Log Levels

| Level | Description | Typical Use |
|-------|-------------|-------------|
| Trace | Very detailed information, typically for debugging | Detailed execution flow |
| Debug | Diagnostic information for developers | Variable values, state information |
| Info | General information about application execution | Application startup, configuration |
| Warn | Potentially harmful situations | Deprecated API usage, unexpected but recoverable errors |
| Error | Error events that might still allow the application to continue | Failed operations, exceptions |
| Fatal | Severe errors that will cause the application to terminate | Critical system failures |
| Panic | Similar to Fatal, but with a stack trace | Unrecoverable errors |

### Setting Log Levels

```go
package main

import (
    "github.com/sirupsen/logrus"
    "go.uber.org/zap"
    "github.com/rs/zerolog"
    "github.com/rs/zerolog/log"
)

func main() {
    // Logrus
    logrusLogger := logrus.New()
    logrusLogger.SetLevel(logrus.WarnLevel)  // Only show Warn, Error, Fatal, Panic
    
    logrusLogger.Debug("This won't be visible")
    logrusLogger.Info("This won't be visible")
    logrusLogger.Warn("This will be visible")
    
    // Zap
    zapLogger, _ := zap.NewProduction()
    defer zapLogger.Sync()
    
    zapLogger.Debug("This won't be visible in production")
    zapLogger.Info("This will be visible")
    
    // Zerolog
    zerolog.SetGlobalLevel(zerolog.InfoLevel)
    
    log.Debug().Msg("This won't be visible")
    log.Info().Msg("This will be visible")
}
```

## Log Formatting

Log formatting determines how log messages are presented. Different formats are suitable for different environments.

### Text Format

Human-readable format suitable for development:

```go
package main

import (
    "os"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    // Text formatter
    logger.SetFormatter(&logrus.TextFormatter{
        FullTimestamp: true,
        ForceColors:   true,
    })
    
    logger.WithFields(logrus.Fields{
        "event": "test",
        "topic": "logging",
    }).Info("Message with fields")
}
```

### JSON Format

Machine-readable format suitable for production:

```go
package main

import (
    "os"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    // JSON formatter
    logger.SetFormatter(&logrus.JSONFormatter{})
    
    logger.WithFields(logrus.Fields{
        "event": "test",
        "topic": "logging",
    }).Info("Message with fields")
}
```

### Custom Formatters

You can create custom formatters for specific needs:

```go
package main

import (
    "bytes"
    "fmt"
    "os"
    "time"
    
    "github.com/sirupsen/logrus"
)

type CustomFormatter struct{}

func (f *CustomFormatter) Format(entry *logrus.Entry) ([]byte, error) {
    timestamp := time.Now().Format("2006-01-02 15:04:05")
    var b *bytes.Buffer
    if entry.Buffer != nil {
        b = entry.Buffer
    } else {
        b = &bytes.Buffer{}
    }
    
    fmt.Fprintf(b, "[%s] %s: %s", timestamp, entry.Level, entry.Message)
    for k, v := range entry.Data {
        fmt.Fprintf(b, " %s=%v", k, v)
    }
    b.WriteByte('\n')
    return b.Bytes(), nil
}

func main() {
    logger := logrus.New()
    logger.SetFormatter(&CustomFormatter{})
    
    logger.WithFields(logrus.Fields{
        "event": "test",
        "topic": "logging",
    }).Info("Message with fields")
}
```

## Log Destinations

Logs can be directed to different outputs depending on the environment and requirements.

### Standard Output

```go
package main

import (
    "os"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    // Output to stdout
    logger.SetOutput(os.Stdout)
    logger.Info("This message goes to stdout")
    
    // Output to stderr
    logger.SetOutput(os.Stderr)
    logger.Info("This message goes to stderr")
}
```

### File Output

```go
package main

import (
    "os"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    // Open a file for logging
    file, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        logger.Fatal("Failed to open log file:", err)
    }
    defer file.Close()
    
    logger.SetOutput(file)
    logger.Info("This message goes to app.log")
}
```

### Multiple Outputs

```go
package main

import (
    "io"
    "os"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    // Create a multi-writer to write to both stdout and a file
    file, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        logger.Fatal("Failed to open log file:", err)
    }
    defer file.Close()
    
    multiWriter := io.MultiWriter(os.Stdout, file)
    logger.SetOutput(multiWriter)
    
    logger.Info("This message goes to both stdout and app.log")
}
```

### Log Rotation

For long-running applications, log rotation is essential to prevent log files from consuming too much disk space:

```go
package main

import (
    "github.com/sirupsen/logrus"
    "gopkg.in/natefinch/lumberjack.v2"
)

func main() {
    logger := logrus.New()
    
    // Set up log rotation
    logger.SetOutput(&lumberjack.Logger{
        Filename:   "app.log",
        MaxSize:    100, // megabytes
        MaxBackups: 3,
        MaxAge:     28, // days
        Compress:   true,
    })
    
    logger.Info("This message goes to a rotating log file")
}
```

## Contextual Logging

Contextual logging adds relevant context to log messages, making them more informative and easier to debug.

### Request Context in Web Applications

```go
package main

import (
    "net/http"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        // Create a logger with request context
        requestLogger := logger.WithFields(logrus.Fields{
            "method": r.Method,
            "path":   r.URL.Path,
            "remote": r.RemoteAddr,
        })
        
        requestLogger.Info("Request received")
        
        // Process request...
        
        requestLogger.WithFields(logrus.Fields{
            "status": 200,
            "size":   1024,
        }).Info("Request completed")
    })
    
    http.ListenAndServe(":8080", nil)
}
```

### Correlation IDs

Correlation IDs help track requests across multiple services:

```go
package main

import (
    "net/http"
    
    "github.com/google/uuid"
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        // Get or create correlation ID
        correlationID := r.Header.Get("X-Correlation-ID")
        if correlationID == "" {
            correlationID = uuid.New().String()
        }
        
        // Add correlation ID to response header
        w.Header().Set("X-Correlation-ID", correlationID)
        
        // Create logger with correlation ID
        requestLogger := logger.WithField("correlation_id", correlationID)
        
        requestLogger.Info("Request received")
        
        // Process request...
        
        requestLogger.Info("Request completed")
    })
    
    http.ListenAndServe(":8080", nil)
}
```

## Performance Considerations

Logging can impact application performance, especially in high-throughput systems. Here are some considerations:

### Asynchronous Logging

Asynchronous logging can reduce the impact on application performance:

```go
package main

import (
    "github.com/sirupsen/logrus"
    "gopkg.in/natefinch/lumberjack.v2"
)

func main() {
    logger := logrus.New()
    
    // Set up log rotation
    logger.SetOutput(&lumberjack.Logger{
        Filename:   "app.log",
        MaxSize:    100,
        MaxBackups: 3,
        MaxAge:     28,
        Compress:   true,
    })
    
    // For production, consider using a hook for asynchronous logging
    // This is a simplified example - in production, use a proper async hook
    logger.SetFormatter(&logrus.JSONFormatter{})
    
    // In a real application, you might use a library like logrus-async-hook
    // or implement a buffered channel for log messages
    
    logger.Info("This message is logged synchronously")
}
```

### Conditional Logging

Avoid expensive operations if the log level won't be used:

```go
package main

import (
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    logger.SetLevel(logrus.InfoLevel)
    
    // Bad: The expensive operation is always performed
    logger.Debug("Result of expensive operation: ", expensiveOperation())
    
    // Good: The expensive operation is only performed if needed
    if logger.IsLevelEnabled(logrus.DebugLevel) {
        logger.Debug("Result of expensive operation: ", expensiveOperation())
    }
}

func expensiveOperation() string {
    // Simulate an expensive operation
    return "result"
}
```

### High-Performance Logging with Zap

Zap is designed for high performance with minimal allocations:

```go
package main

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

func main() {
    // Create a high-performance logger
    config := zap.NewProductionConfig()
    config.OutputPaths = []string{"stdout"}
    config.ErrorOutputPaths = []string{"stderr"}
    
    logger, err := config.Build()
    if err != nil {
        panic(err)
    }
    defer logger.Sync()
    
    // Sugared logger is more flexible but slightly slower
    sugar := logger.Sugar()
    
    // For high-performance scenarios, use the non-sugared logger
    logger.Info("High-performance logging",
        zap.String("service", "example"),
        zap.Int("attempt", 3),
    )
    
    // For convenience, use the sugared logger
    sugar.Infow("Convenient logging",
        "service", "example",
        "attempt", 3,
    )
}
```

## Best Practices

### 1. Use Appropriate Log Levels

```go
package main

import (
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    // Use appropriate log levels
    logger.Debug("Detailed information for debugging")  // Development only
    logger.Info("General information about application state")
    logger.Warn("Something unexpected but not critical")
    logger.Error("An error occurred but the application can continue")
    // logger.Fatal("A critical error that terminates the application")
    // logger.Panic("A critical error that terminates with a stack trace")
}
```

### 2. Include Relevant Context

```go
package main

import (
    "net/http"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        // Include relevant context
        logger.WithFields(logrus.Fields{
            "method": r.Method,
            "path":   r.URL.Path,
            "remote": r.RemoteAddr,
        }).Info("Request received")
        
        // Process request...
    })
    
    http.ListenAndServe(":8080", nil)
}
```

### 3. Log Errors with Stack Traces

```go
package main

import (
    "errors"
    "runtime/debug"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    // Log errors with stack traces
    err := errors.New("something went wrong")
    logger.WithFields(logrus.Fields{
        "error": err,
        "stack": string(debug.Stack()),
    }).Error("An error occurred")
}
```

### 4. Avoid Logging Sensitive Information

```go
package main

import (
    "github.com/sirupsen/logrus"
)

type User struct {
    ID       string
    Username string
    Password string // Sensitive
}

func main() {
    logger := logrus.New()
    
    user := User{
        ID:       "123",
        Username: "alice",
        Password: "secret",
    }
    
    // Bad: Logs sensitive information
    logger.Infof("User logged in: %+v", user)
    
    // Good: Excludes sensitive information
    logger.WithFields(logrus.Fields{
        "user_id":  user.ID,
        "username": user.Username,
    }).Info("User logged in")
}
```

### 5. Use Structured Logging in Production

```go
package main

import (
    "os"
    
    "github.com/sirupsen/logrus"
)

func main() {
    logger := logrus.New()
    
    // Use structured logging in production
    if os.Getenv("ENVIRONMENT") == "production" {
        logger.SetFormatter(&logrus.JSONFormatter{})
        logger.SetOutput(os.Stdout)
    } else {
        // Use human-readable format in development
        logger.SetFormatter(&logrus.TextFormatter{
            FullTimestamp: true,
            ForceColors:   true,
        })
    }
    
    logger.Info("Application started")
}
```

## Real-World Example: Web Application Logging

Let's create a comprehensive example of logging in a web application:

```go
package main

import (
    "encoding/json"
    "net/http"
    "os"
    "time"
    
    "github.com/google/uuid"
    "github.com/gorilla/mux"
    "github.com/sirupsen/logrus"
    "gopkg.in/natefinch/lumberjack.v2"
)

type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

var users = []User{
    {ID: "1", Name: "Alice", Email: "alice@example.com"},
    {ID: "2", Name: "Bob", Email: "bob@example.com"},
}

func main() {
    // Set up logger
    logger := logrus.New()
    
    // Configure based on environment
    if os.Getenv("ENVIRONMENT") == "production" {
        logger.SetFormatter(&logrus.JSONFormatter{})
        logger.SetOutput(&lumberjack.Logger{
            Filename:   "app.log",
            MaxSize:    100,
            MaxBackups: 5,
            MaxAge:     30,
            Compress:   true,
        })
        logger.SetLevel(logrus.InfoLevel)
    } else {
        logger.SetFormatter(&logrus.TextFormatter{
            FullTimestamp: true,
            ForceColors:   true,
        })
        logger.SetLevel(logrus.DebugLevel)
    }
    
    // Create router
    r := mux.NewRouter()
    
    // Add logging middleware
    r.Use(loggingMiddleware(logger))
    
    // Define routes
    r.HandleFunc("/users", getUsers(logger)).Methods("GET")
    r.HandleFunc("/users/{id}", getUser(logger)).Methods("GET")
    
    // Start server
    server := &http.Server{
        Addr:         ":8080",
        Handler:      r,
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
    }
    
    logger.Info("Starting server on :8080")
    if err := server.ListenAndServe(); err != nil {
        logger.Fatal("Server error: ", err)
    }
}

func loggingMiddleware(logger *logrus.Logger) mux.MiddlewareFunc {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // Get or create correlation ID
            correlationID := r.Header.Get("X-Correlation-ID")
            if correlationID == "" {
                correlationID = uuid.New().String()
            }
            
            // Add correlation ID to response header
            w.Header().Set("X-Correlation-ID", correlationID)
            
            // Create logger with request context
            requestLogger := logger.WithFields(logrus.Fields{
                "correlation_id": correlationID,
                "method":         r.Method,
                "path":           r.URL.Path,
                "remote_addr":    r.RemoteAddr,
                "user_agent":     r.UserAgent(),
            })
            
            // Log request
            requestLogger.Info("Request received")
            
            // Create response recorder to capture status code
            recorder := &responseRecorder{w, http.StatusOK}
            
            // Call next handler
            next.ServeHTTP(recorder, r)
            
            // Calculate request duration
            duration := time.Since(start)
            
            // Log response
            requestLogger.WithFields(logrus.Fields{
                "status":   recorder.statusCode,
                "duration": duration,
            }).Info("Request completed")
        })
    }
}

type responseRecorder struct {
    http.ResponseWriter
    statusCode int
}

func (r *responseRecorder) WriteHeader(statusCode int) {
    r.statusCode = statusCode
    r.ResponseWriter.WriteHeader(statusCode)
}

func getUsers(logger *logrus.Logger) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        requestLogger := logger.WithField("endpoint", "getUsers")
        
        requestLogger.Debug("Retrieving all users")
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(users)
        
        requestLogger.Info("Retrieved all users")
    }
}

func getUser(logger *logrus.Logger) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        vars := mux.Vars(r)
        id := vars["id"]
        
        requestLogger := logger.WithFields(logrus.Fields{
            "endpoint": "getUser",
            "user_id":  id,
        })
        
        requestLogger.Debug("Retrieving user")
        
        for _, user := range users {
            if user.ID == id {
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(user)
                
                requestLogger.Info("Retrieved user")
                return
            }
        }
        
        requestLogger.WithField("status", "not_found").Warn("User not found")
        http.NotFound(w, r)
    }
}
```

### How This Example Demonstrates Logging Concepts:

1. **Environment-Based Configuration**:
   - Different logging formats for development and production
   - Log rotation in production
   - Different log levels for different environments

2. **Middleware for Request Logging**:
   - Logs incoming requests with relevant context
   - Includes correlation IDs for request tracking
   - Captures response status and duration

3. **Contextual Logging**:
   - Adds context to log messages (endpoint, user ID, etc.)
   - Uses child loggers for specific operations

4. **Structured Logging**:
   - Uses key-value pairs for machine-readable logs
   - Consistent format across all log messages

5. **Error Handling**:
   - Appropriate log levels for different situations
   - Includes relevant context for debugging

## Conclusion

Logging is a critical aspect of application development in Go:

### Key Takeaways:
1. **Standard Library**:
   - The `log` package is simple and built-in
   - Suitable for small applications or quick prototyping
   - Limited in features compared to third-party libraries

2. **Third-Party Libraries**:
   - Logrus provides structured logging with a familiar API
   - Zap offers high performance with minimal allocations
   - Zerolog is designed for zero-allocation logging

3. **Structured Logging**:
   - Makes logs machine-readable and searchable
   - Enables better filtering and analysis
   - Essential for production environments

4. **Best Practices**:
   - Use appropriate log levels
   - Include relevant context
   - Avoid logging sensitive information
   - Use structured logging in production
   - Implement log rotation for long-running applications

5. **Performance Considerations**:
   - Be mindful of the performance impact of logging
   - Use asynchronous logging for high-throughput applications
   - Consider conditional logging to avoid expensive operations

By implementing effective logging practices, you can create more maintainable, debuggable, and monitorable Go applications. Whether you're building a simple CLI tool or a complex web service, proper logging will help you understand and troubleshoot your application's behavior.