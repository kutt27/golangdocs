

{# Number Parsing in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master Go's number parsing capabilities using the strconv package. Learn to convert string representations of numbers into their corresponding numeric types, handle various number formats, implement proper error handling, and build robust parsing systems for configuration, user input, and data processing.

!!! tip "Key Points"
    - Use strconv package for parsing numbers from strings with proper error handling
    - ParseInt and ParseUint for integers with different bases and bit sizes
    - ParseFloat for floating-point numbers including scientific notation
    - Atoi and Itoa for simple base-10 integer conversions
    - ParseBool for boolean values with multiple accepted formats
    - Essential for configuration parsing, user input validation, and data processing

## Understanding Number Parsing

Number parsing is the process of converting string representations of numbers into their corresponding numeric types. In Go, this is a common operation when dealing with user input, configuration files, network protocols, and data interchange formats. Go provides robust built-in functions for parsing numbers with proper error handling.

!!! info "Number Parsing Components"
    ```mermaid
    graph LR
        A[Number Parsing] --> B[Integer Parsing]
        A --> C[Floating-Point Parsing]
        A --> D[Boolean Parsing]
        A --> E[Error Handling]
        B --> F[ParseInt/ParseUint]
        C --> G[ParseFloat]
        D --> H[ParseBool]
        E --> I[Validation]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Basic Integer Parsing

### 1. Parsing Integers

The `strconv` package provides functions for parsing integers from strings:

!!! example "Parsing Integers"
    ```go title="integer_parsing.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // ParseInt with base 10
        i, err := strconv.ParseInt("123", 10, 64)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Parsed int64: %d, type: %T\n", i, i)

        // ParseInt with different bases
        bases := []int{2, 8, 10, 16}
        numbers := []string{"1010", "755", "123", "FF"}
        
        for i := range bases {
            n, err := strconv.ParseInt(numbers[i], bases[i], 64)
            if err != nil {
                fmt.Printf("Error parsing %s in base %d: %v\n", numbers[i], bases[i], err)
                continue
            }
            fmt.Printf("%s (base %d) = %d (decimal)\n", numbers[i], bases[i], n)
        }
    }
    ```

### 2. Parsing with Specific Bit Sizes

!!! example "Parsing with Specific Bit Sizes"
    ```go title="bit_sizes.go" linenums="1" hl_lines="8-30"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // Parse to int8
        i8, err := strconv.ParseInt("127", 10, 8)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("int8: %d\n", int8(i8))
        }

        // Parse to int16
        i16, err := strconv.ParseInt("32767", 10, 16)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("int16: %d\n", int16(i16))
        }

        // Parse to int32
        i32, err := strconv.ParseInt("2147483647", 10, 32)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("int32: %d\n", int32(i32))
        }

        // Parse to int64
        i64, err := strconv.ParseInt("9223372036854775807", 10, 64)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("int64: %d\n", i64)
        }
    }
    ```

### 3. Parsing Unsigned Integers

!!! example "Parsing Unsigned Integers"
    ```go title="unsigned_integers.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // ParseUint
        u, err := strconv.ParseUint("4294967295", 10, 64)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Parsed uint64: %d, type: %T\n", u, u)

        // Parse to uint8
        u8, err := strconv.ParseUint("255", 10, 8)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("uint8: %d\n", uint8(u8))
        }

        // Parse to uint16
        u16, err := strconv.ParseUint("65535", 10, 16)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("uint16: %d\n", uint16(u16))
        }
    }
    ```

## Floating-Point Parsing

### 1. Parsing Floats

!!! example "Parsing Floats"
    ```go title="float_parsing.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // ParseFloat to float64
        f64, err := strconv.ParseFloat("3.14159", 64)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Parsed float64: %f, type: %T\n", f64, f64)

        // ParseFloat to float32
        f32, err := strconv.ParseFloat("3.14159", 32)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("Parsed float32: %f, type: %T\n", float32(f32), f32)
        }

        // Scientific notation
        sci, err := strconv.ParseFloat("1.23e-4", 64)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("Scientific notation: %g\n", sci)
        }
    }
    ```

### 2. Special Floating-Point Values

!!! example "Special Floating-Point Values"
    ```go title="special_floats.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // Parse special values
        specialValues := []string{"inf", "+Inf", "-Inf", "NaN"}
        
        for _, val := range specialValues {
            f, err := strconv.ParseFloat(val, 64)
            if err != nil {
                fmt.Printf("Error parsing %s: %v\n", val, err)
                continue
            }
            fmt.Printf("%s -> %f\n", val, f)
        }
    }
    ```

## Convenience Functions

### 1. Atoi and Itoa

For simple base-10 integer conversion:

!!! example "Atoi and Itoa"
    ```go title="atoi_itoa.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // Atoi (ASCII to integer)
        i, err := strconv.Atoi("123")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Atoi result: %d, type: %T\n", i, i)

        // Itoa (integer to ASCII)
        s := strconv.Itoa(456)
        fmt.Printf("Itoa result: %s, type: %T\n", s, s)
    }
    ```

### 2. ParseBool

!!! example "ParseBool"
    ```go title="parse_bool.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // Parse boolean values
        boolStrings := []string{"true", "false", "1", "0", "t", "f", "TRUE", "FALSE"}
        
        for _, s := range boolStrings {
            b, err := strconv.ParseBool(s)
            if err != nil {
                fmt.Printf("Error parsing %q: %v\n", s, err)
                continue
            }
            fmt.Printf("%q -> %t\n", s, b)
        }
    }
    ```

## Advanced Parsing Techniques

### 1. Parsing with Custom Formats

!!! example "Parsing with Custom Formats"
    ```go title="custom_formats.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
        "strconv"
        "strings"
    )

    func main() {
        // Parse number with commas
        numWithCommas := "1,234,567"
        
        // Remove commas before parsing
        cleaned := strings.ReplaceAll(numWithCommas, ",", "")
        num, err := strconv.ParseInt(cleaned, 10, 64)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Number with commas: %d\n", num)

        // Parse currency
        currency := "$1,234.56"
        cleaned = strings.ReplaceAll(currency, "$", "")
        cleaned = strings.ReplaceAll(cleaned, ",", "")
        f, err := strconv.ParseFloat(cleaned, 64)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Currency: %.2f\n", f)
    }
    ```

### 2. Parsing Number Ranges

!!! example "Parsing Number Ranges"
    ```go title="number_ranges.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "fmt"
        "strconv"
        "strings"
    )

    func parseRange(s string) (min, max int, err error) {
        parts := strings.Split(s, "-")
        if len(parts) != 2 {
            return 0, 0, fmt.Errorf("invalid range format")
        }
        
        min, err = strconv.Atoi(strings.TrimSpace(parts[0]))
        if err != nil {
            return 0, 0, fmt.Errorf("invalid min value: %w", err)
        }
        
        max, err = strconv.Atoi(strings.TrimSpace(parts[1]))
        if err != nil {
            return 0, 0, fmt.Errorf("invalid max value: %w", err)
        }
        
        if min > max {
            return 0, 0, fmt.Errorf("min cannot be greater than max")
        }
        
        return min, max, nil
    }

    func main() {
        ranges := []string{"1-10", "100-200", "50-25"}
        
        for _, r := range ranges {
            min, max, err := parseRange(r)
            if err != nil {
                fmt.Printf("Error parsing %q: %v\n", r, err)
                continue
            }
            fmt.Printf("Range %q: %d to %d\n", r, min, max)
        }
    }
    ```

### 3. Parsing Multiple Numbers from a String

!!! example "Parsing Multiple Numbers"
    ```go title="multiple_numbers.go" linenums="1" hl_lines="8-36"
    package main

    import (
        "fmt"
        "strconv"
        "strings"
    )

    func parseNumbers(s string) ([]int, error) {
        fields := strings.Fields(s)
        numbers := make([]int, 0, len(fields))
        
        for _, field := range fields {
            num, err := strconv.Atoi(field)
            if err != nil {
                return nil, fmt.Errorf("invalid number %q: %w", field, err)
            }
            numbers = append(numbers, num)
        }
        
        return numbers, nil
    }

    func main() {
        data := "10 20 30 40 50"
        numbers, err := parseNumbers(data)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        
        fmt.Printf("Parsed numbers: %v\n", numbers)
        fmt.Printf("Sum: %d\n", sum(numbers))
    }

    func sum(numbers []int) int {
        total := 0
        for _, num := range numbers {
            total += num
        }
        return total
    }
    ```

## Error Handling

### 1. Common Parsing Errors

!!! example "Common Parsing Errors"
    ```go title="parsing_errors.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // Invalid number format
        _, err := strconv.ParseInt("abc", 10, 64)
        fmt.Printf("ParseInt error: %v\n", err) // strconv.ParseInt: parsing "abc": invalid syntax

        // Out of range
        _, err = strconv.ParseInt("999999999999999999999999999999", 10, 64)
        fmt.Printf("ParseInt error: %v\n", err) // strconv.ParseInt: parsing "999999999999999999999999999999": value out of range

        // Invalid base
        _, err = strconv.ParseInt("123", 37, 64) // Base must be between 2 and 36
        fmt.Printf("ParseInt error: %v\n", err)

        // Empty string
        _, err = strconv.ParseInt("", 10, 64)
        fmt.Printf("ParseInt error: %v\n", err)
    }
    ```

### 2. Safe Parsing with Defaults

!!! example "Safe Parsing with Defaults"
    ```go title="safe_parsing.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "strconv"
    )

    func safeParseInt(s string, defaultValue int64) int64 {
        if s == "" {
            return defaultValue
        }
        
        i, err := strconv.ParseInt(s, 10, 64)
        if err != nil {
            return defaultValue
        }
        
        return i
    }

    func main() {
        values := []string{"123", "abc", "", "999999999999999999999999999999"}
        defaultValue := int64(0)
        
        for _, val := range values {
            result := safeParseInt(val, defaultValue)
            fmt.Printf("safeParseInt(%q, %d) = %d\n", val, defaultValue, result)
        }
    }
    ```

### 3. Parsing with Validation

!!! example "Parsing with Validation"
    ```go title="parsing_validation.go" linenums="1" hl_lines="8-40"
    package main

    import (
        "fmt"
        "strconv"
    )

    func parsePositiveInt(s string) (int, error) {
        i, err := strconv.Atoi(s)
        if err != nil {
            return 0, fmt.Errorf("invalid integer: %w", err)
        }
        
        if i <= 0 {
            return 0, fmt.Errorf("value must be positive")
        }
        
        return i, nil
    }

    func parsePercentage(s string) (float64, error) {
        f, err := strconv.ParseFloat(s, 64)
        if err != nil {
            return 0, fmt.Errorf("invalid percentage: %w", err)
        }
        
        if f < 0 || f > 100 {
            return 0, fmt.Errorf("percentage must be between 0 and 100")
        }
        
        return f, nil
    }

    func main() {
        // Test positive integer parsing
        intTests := []string{"10", "-5", "0", "abc"}
        for _, test := range intTests {
            result, err := parsePositiveInt(test)
            if err != nil {
                fmt.Printf("parsePositiveInt(%q): %v\n", test, err)
            } else {
                fmt.Printf("parsePositiveInt(%q): %d\n", test, result)
            }
        }

        // Test percentage parsing
        percentTests := []string{"50", "150", "-10", "abc"}
        for _, test := range percentTests {
            result, err := parsePercentage(test)
            if err != nil {
                fmt.Printf("parsePercentage(%q): %v\n", test, err)
            } else {
                fmt.Printf("parsePercentage(%q): %.1f%%\n", test, result)
            }
        }
    }
    ```

## Real-World Example: Configuration Parser

Let's build a comprehensive configuration parser that handles various number formats:

!!! example "Configuration Parser"
    ```go title="config_parser.go" linenums="1" hl_lines="8-60"
    package main

    import (
        "fmt"
        "strconv"
        "strings"
        "time"
    )

    // Config represents application configuration
    type Config struct {
        ServerPort     int
        MaxConnections int
        Timeout        time.Duration
        CacheSize      int64
        DebugMode      bool
        Threshold      float64
        RetryCount     int
    }

    // ConfigParser handles parsing configuration values
    type ConfigParser struct {
        values map[string]string
    }

    func NewConfigParser(values map[string]string) *ConfigParser {
        return &ConfigParser{
            values: values,
        }
    }

    func (cp *ConfigParser) Parse() (*Config, error) {
        config := &Config{}
        
        // Parse server port
        port, err := cp.parseInt("server_port", 8080, 1, 65535)
        if err != nil {
            return nil, fmt.Errorf("invalid server_port: %w", err)
        }
        config.ServerPort = port
        
        // Parse max connections
        maxConn, err := cp.parseInt("max_connections", 100, 1, 10000)
        if err != nil {
            return nil, fmt.Errorf("invalid max_connections: %w", err)
        }
        config.MaxConnections = maxConn
        
        // Parse timeout (supports duration strings)
        timeout, err := cp.parseDuration("timeout", 30*time.Second)
        if err != nil {
            return nil, fmt.Errorf("invalid timeout: %w", err)
        }
        config.Timeout = timeout
        
        // Parse cache size (supports K, M, G suffixes)
        cacheSize, err := cp.parseSize("cache_size", 1024*1024) // Default 1MB
        if err != nil {
            return nil, fmt.Errorf("invalid cache_size: %w", err)
        }
        config.CacheSize = cacheSize
        
        // Parse debug mode
        debug, err := cp.parseBool("debug_mode", false)
        if err != nil {
            return nil, fmt.Errorf("invalid debug_mode: %w", err)
        }
        config.DebugMode = debug
        
        // Parse threshold
        threshold, err := cp.parseFloat("threshold", 0.5, 0.0, 1.0)
        if err != nil {
            return nil, fmt.Errorf("invalid threshold: %w", err)
        }
        config.Threshold = threshold
        
        // Parse retry count
        retryCount, err := cp.parseInt("retry_count", 3, 0, 10)
        if err != nil {
            return nil, fmt.Errorf("invalid retry_count: %w", err)
        }
        config.RetryCount = retryCount
        
        return config, nil
    }

    func (cp *ConfigParser) parseInt(key string, defaultValue, min, max int) (int, error) {
        value, exists := cp.values[key]
        if !exists || value == "" {
            return defaultValue, nil
        }
        
        i, err := strconv.Atoi(value)
        if err != nil {
            return 0, fmt.Errorf("invalid integer: %w", err)
        }
        
        if i < min || i > max {
            return 0, fmt.Errorf("value %d is out of range [%d, %d]", i, min, max)
        }
        
        return i, nil
    }

    func (cp *ConfigParser) parseFloat(key string, defaultValue, min, max float64) (float64, error) {
        value, exists := cp.values[key]
        if !exists || value == "" {
            return defaultValue, nil
        }
        
        f, err := strconv.ParseFloat(value, 64)
        if err != nil {
            return 0, fmt.Errorf("invalid float: %w", err)
        }
        
        if f < min || f > max {
            return 0, fmt.Errorf("value %f is out of range [%f, %f]", f, min, max)
        }
        
        return f, nil
    }

    func (cp *ConfigParser) parseBool(key string, defaultValue bool) (bool, error) {
        value, exists := cp.values[key]
        if !exists || value == "" {
            return defaultValue, nil
        }
        
        b, err := strconv.ParseBool(value)
        if err != nil {
            return false, fmt.Errorf("invalid boolean: %w", err)
        }
        
        return b, nil
    }

    func (cp *ConfigParser) parseDuration(key string, defaultValue time.Duration) (time.Duration, error) {
        value, exists := cp.values[key]
        if !exists || value == "" {
            return defaultValue, nil
        }
        
        // Try to parse as duration string first
        duration, err := time.ParseDuration(value)
        if err == nil {
            return duration, nil
        }
        
        // If that fails, try to parse as seconds
        seconds, err := strconv.ParseFloat(value, 64)
        if err != nil {
            return 0, fmt.Errorf("invalid duration: %w", err)
        }
        
        return time.Duration(seconds * float64(time.Second)), nil
    }

    func (cp *ConfigParser) parseSize(key string, defaultValue int64) (int64, error) {
        value, exists := cp.values[key]
        if !exists || value == "" {
            return defaultValue, nil
        }
        
        // Check for size suffixes
        suffixes := map[string]int64{
            "K": 1024,
            "M": 1024 * 1024,
            "G": 1024 * 1024 * 1024,
            "T": 1024 * 1024 * 1024 * 1024,
        }
        
        for suffix, multiplier := range suffixes {
            if strings.HasSuffix(value, suffix) {
                numStr := strings.TrimSuffix(value, suffix)
                num, err := strconv.ParseInt(numStr, 10, 64)
                if err != nil {
                    return 0, fmt.Errorf("invalid size: %w", err)
                }
                return num * multiplier, nil
            }
        }
        
        // No suffix, parse as bytes
        return strconv.ParseInt(value, 10, 64)
    }

    func main() {
        // Sample configuration values
        configValues := map[string]string{
            "server_port":     "8080",
            "max_connections": "100",
            "timeout":        "30s",
            "cache_size":     "2M",
            "debug_mode":     "true",
            "threshold":      "0.75",
            "retry_count":    "3",
        }
        
        // Parse configuration
        parser := NewConfigParser(configValues)
        config, err := parser.Parse()
        if err != nil {
            fmt.Printf("Error parsing configuration: %v\n", err)
            return
        }
        
        // Print parsed configuration
        fmt.Println("=== Parsed Configuration ===")
        fmt.Printf("Server Port: %d\n", config.ServerPort)
        fmt.Printf("Max Connections: %d\n", config.MaxConnections)
        fmt.Printf("Timeout: %v\n", config.Timeout)
        fmt.Printf("Cache Size: %d bytes\n", config.CacheSize)
        fmt.Printf("Debug Mode: %t\n", config.DebugMode)
        fmt.Printf("Threshold: %.2f\n", config.Threshold)
        fmt.Printf("Retry Count: %d\n", config.RetryCount)
        
        // Test error cases
        fmt.Println("\n=== Testing Error Cases ===")
        errorConfigs := []map[string]string{
            {"server_port": "99999"}, // Out of range
            {"timeout": "invalid"},    // Invalid duration
            {"cache_size": "2X"},     // Invalid suffix
            {"debug_mode": "maybe"},   // Invalid boolean
        }
        
        for i, values := range errorConfigs {
            fmt.Printf("\nTest case %d:\n", i+1)
            parser := NewConfigParser(values)
            _, err := parser.Parse()
            if err != nil {
                fmt.Printf("Expected error: %v\n", err)
            } else {
                fmt.Println("Unexpected success")
            }
        }
    }
    ```

### How This Example Works:

1. **Configuration Structure**:
   - Defines a `Config` struct with various numeric and boolean fields
   - Supports different data types (int, float64, bool, duration, size)

2. **Parser Implementation**:
   - `ConfigParser` handles parsing of configuration values
   - Provides type-specific parsing methods with validation
   - Supports default values and range checking

3. **Advanced Parsing Features**:
   - Duration parsing (supports "30s", "1h", etc.)
   - Size parsing with suffixes (K, M, G, T)
   - Boolean parsing with multiple formats
   - Range validation for all numeric values

4. **Error Handling**:
   - Comprehensive error messages
   - Graceful handling of missing values
   - Type-specific validation

### Real-World Applications:

1. **Application Configuration**:
   - Environment variable parsing
   - Configuration file parsing
   - Command-line argument processing

2. **Data Validation**:
   - User input validation
   - API parameter parsing
   - Form data processing

3. **Protocol Handling**:
   - Network protocol parsing
   - File format parsing
   - Database result processing

## Best Practices

!!! tip "Error Checking"
    Always check errors when parsing numbers to handle invalid input gracefully.

!!! example "Error Checking"
    ```go title="error_checking.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "strconv"
    )

    // Good: Check errors
    func parseNumber(s string) (int, error) {
        i, err := strconv.Atoi(s)
        if err != nil {
            return 0, err
        }
        return i, nil
    }

    // Bad: Ignore errors
    func parseNumberBad(s string) int {
        i, _ := strconv.Atoi(s) // Might panic on invalid input
        return i
    }
    ```

!!! tip "Input Validation"
    Validate input ranges to ensure parsed values are within acceptable bounds.

!!! example "Input Validation"
    ```go title="input_validation.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "strconv"
    )

    // Good: Validate range
    func parsePort(s string) (int, error) {
        port, err := strconv.Atoi(s)
        if err != nil {
            return 0, err
        }
        if port < 1 || port > 65535 {
            return 0, fmt.Errorf("port must be between 1 and 65535")
        }
        return port, nil
    }

    // Bad: No validation
    func parsePortBad(s string) (int, error) {
        return strconv.Atoi(s)
    }
    ```

!!! tip "Default Values"
    Provide sensible default values for missing or invalid input.

!!! example "Default Values"
    ```go title="default_values.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "strconv"
    )

    // Good: Provide defaults
    func parseIntWithDefault(s string, defaultValue int) int {
        if s == "" {
            return defaultValue
        }
        i, err := strconv.Atoi(s)
        if err != nil {
            return defaultValue
        }
        return i
    }

    // Bad: No default handling
    func parseIntBad(s string) int {
        i, _ := strconv.Atoi(s)
        return i
    }
    ```

!!! tip "Appropriate Types"
    Use appropriate numeric types for your data to optimize memory usage.

!!! example "Appropriate Types"
    ```go title="appropriate_types.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "strconv"
    )

    // Good: Use appropriate bit size
    func parseUserID(s string) (int32, error) {
        i, err := strconv.ParseInt(s, 10, 32)
        if err != nil {
            return 0, err
        }
        return int32(i), nil
    }

    // Bad: Always use int64
    func parseUserIDBad(s string) (int64, error) {
        return strconv.ParseInt(s, 10, 64)
    }
    ```

## Performance Considerations

!!! warning "Reuse Parsers"
    Reuse scanners and parsers when processing multiple values to improve performance.

!!! example "Reuse Parsers"
    ```go title="reuse_parsers.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "bufio"
        "fmt"
        "strconv"
        "strings"
    )

    // Good: Reuse scanner
    func parseNumbers(data string) ([]int, error) {
        scanner := bufio.NewScanner(strings.NewReader(data))
        var numbers []int
        
        for scanner.Scan() {
            num, err := strconv.Atoi(scanner.Text())
            if err != nil {
                return nil, err
            }
            numbers = append(numbers, num)
        }
        
        return numbers, nil
    }

    // Bad: Create new scanner for each number
    func parseNumbersBad(data string) ([]int, error) {
        fields := strings.Fields(data)
        var numbers []int
        for _, field := range fields {
            num, err := strconv.Atoi(field)
            if err != nil {
                return nil, err
            }
            numbers = append(numbers, num)
        }
        return numbers, nil
    }
    ```

!!! warning "Batch Processing"
    Process numbers in batches when possible to reduce memory allocations.

!!! example "Batch Processing"
    ```go title="batch_processing.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "strconv"
    )

    // Good: Process in batches
    func parseNumbersBatch(data []string) ([]int, error) {
        numbers := make([]int, len(data))
        for i, s := range data {
            num, err := strconv.Atoi(s)
            if err != nil {
                return nil, err
            }
            numbers[i] = num
        }
        return numbers, nil
    }

    // Bad: Process one by one with append
    func parseNumbersBad(data []string) ([]int, error) {
        var numbers []int
        for _, s := range data {
            num, err := strconv.Atoi(s)
            if err != nil {
                return nil, err
            }
            numbers = append(numbers, num)
        }
        return numbers, nil
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Basic Functions**: Use `strconv.ParseInt`, `strconv.ParseUint`, `strconv.ParseFloat` for number parsing
    - **Convenience Functions**: Use `strconv.Atoi`, `strconv.Itoa` for simple base-10 conversions
    - **Boolean Parsing**: Use `strconv.ParseBool` for converting strings to boolean values
    - **Error Handling**: Always check errors and validate input ranges
    - **Custom Formats**: Preprocess strings for custom formats like currency or numbers with commas
    - **Performance**: Reuse parsers and process in batches for better performance

!!! quote "Remember"
    "Number parsing is a fundamental operation in Go programming. The strconv package provides comprehensive functions for converting strings to numeric types with proper error handling. By mastering these functions and following best practices, you can build reliable and maintainable code for parsing numbers in your Go applications."