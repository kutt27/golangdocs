

# String Formatting in Go: A Comprehensive Guide

## Introduction to String Formatting
String formatting is the process of creating formatted strings by combining literal text with formatted values. In Go, the `fmt` package provides powerful formatting capabilities that allow you to control how values are represented as strings. This is essential for creating user-friendly output, logs, reports, and any application that needs to present data in a structured way.

## Basic Formatting Functions

### 1. `fmt.Sprintf` - Format to String
The most commonly used formatting function, which returns a formatted string:

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// Basic formatting
	name := "Alice"
	age := 30
	formatted := fmt.Sprintf("Name: %s, Age: %d", name, age)
	fmt.Println(formatted) // "Name: Alice, Age: 30"
	
	// Multiple values
	item := "Laptop"
	price := 999.99
	inStock := true
	formatted = fmt.Sprintf("Item: %s, Price: $%.2f, In Stock: %t", item, price, inStock)
	fmt.Println(formatted) // "Item: Laptop, Price: $999.99, In Stock: true"
	
	// Date formatting
	now := time.Now()
	formatted = fmt.Sprintf("Current time: %s", now.Format("2006-01-02 15:04:05"))
	fmt.Println(formatted) // "Current time: 2023-11-15 14:30:45"
}
```

### 2. `fmt.Printf` - Format and Print
Prints formatted text to standard output:

```go
func main() {
	// Direct printing
	fmt.Printf("Hello, %s!\n", "World") // "Hello, World!"
	
	// Multiple arguments
	fmt.Printf("%s has %d apples\n", "Bob", 5) // "Bob has 5 apples"
	
	// Without newline
	fmt.Printf("Processing...") // No newline
	fmt.Printf("Done!\n")      // "Processing...Done!"
}
```

### 3. `fmt.Fprintf` - Format to Writer
Writes formatted text to any `io.Writer`:

```go
import (
	"bytes"
	"os"
)

func main() {
	// Write to buffer
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "Error: %s occurred at %v", "timeout", time.Now())
	fmt.Println(buf.String())
	
	// Write to file
	file, err := os.Create("log.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()
	
	fmt.Fprintf(file, "Log entry: %s\n", time.Now().Format(time.RFC3339))
}
```

## Formatting Verbs Reference

### General Verbs
| Verb | Description | Example |
|------|-------------|---------|
| `%v` | Default format | `fmt.Printf("%v", 42)` → `42` |
| `%+v` | Adds struct field names | `fmt.Printf("%+v", p)` |
| `%#v` | Go syntax representation | `fmt.Printf("%#v", []int{1,2})` |
| `%T` | Type of value | `fmt.Printf("%T", 42)` → `int` |
| `%%` | Literal percent sign | `fmt.Printf("%%") → `%` |

### Integer Verbs
| Verb | Description | Example |
|------|-------------|---------|
| `%b` | Binary | `fmt.Printf("%b", 5)` → `101` |
| `%c` | Character | `fmt.Printf("%c", 65)` → `A` |
| `%d` | Decimal | `fmt.Printf("%d", 42)` → `42` |
| `%o` | Octal | `fmt.Printf("%o", 8)` → `10` |
| `%O` | Octal with 0o prefix | `fmt.Printf("%O", 8)` → `0o10` |
| `%q` | Single-quoted character | `fmt.Printf("%q", 'A')` → `'A'` |
| `%x` | Hexadecimal (lowercase) | `fmt.Printf("%x", 255)` → `ff` |
| `%X` | Hexadecimal (uppercase) | `fmt.Printf("%X", 255)` → `FF` |
| `%U` | Unicode format | `fmt.Printf("%U", 'A')` → `U+0041` |

### Floating-Point Verbs
| Verb | Description | Example |
|------|-------------|---------|
| `%b` | Scientific notation (binary exponent) | `fmt.Printf("%b", 3.14)` |
| `%e` | Scientific notation (lowercase e) | `fmt.Printf("%e", 3.14)` → `3.140000e+00` |
| `%E` | Scientific notation (uppercase E) | `fmt.Printf("%E", 3.14)` → `3.140000E+00` |
| `%f` | Decimal notation | `fmt.Printf("%f", 3.14)` → `3.140000` |
| `%F` | Same as %f | `fmt.Printf("%F", 3.14)` → `3.140000` |
| `%g` | %e for large exponents, %f otherwise | `fmt.Printf("%g", 3.14)` → `3.14` |
| `%G` | %E for large exponents, %F otherwise | `fmt.Printf("%G", 3.14)` → `3.14` |
| `%x` | Hexadecimal notation | `fmt.Printf("%x", 3.14)` |

### String and Byte Verbs
| Verb | Description | Example |
|------|-------------|---------|
| `%s` | String | `fmt.Printf("%s", "hello")` → `hello` |
| `%q` | Double-quoted string | `fmt.Printf("%q", "hello")` → `"hello"` |
| `%x` | Hexadecimal dump of bytes | `fmt.Printf("%x", "hi")` → `6869` |
| `%X` | Uppercase hexadecimal dump | `fmt.Printf("%X", "hi")` → `6869` |

### Boolean and Pointer Verbs
| Verb | Description | Example |
|------|-------------|---------|
| `%t` | Boolean | `fmt.Printf("%t", true)` → `true` |
| `%p` | Pointer address | `fmt.Printf("%p", &x)` → `0x1040a124` |

## Width, Precision, and Flags

### 1. Width Specification
Controls the minimum width of the formatted value:

```go
func main() {
	// Integer width
	fmt.Printf("|%5d|\n", 42)      // "|   42|"
	fmt.Printf("|%-5d|\n", 42)     // "|42   |"
	
	// String width
	fmt.Printf("|%10s|\n", "hi")   // "|        hi|"
	fmt.Printf("|%-10s|\n", "hi")  // "|hi        |"
}
```

### 2. Precision Specification
Controls the number of decimal places for floats or maximum characters for strings:

```go
func main() {
	// Float precision
	fmt.Printf("|%.2f|\n", 3.14159) // "|3.14|"
	fmt.Printf("|%.4f|\n", 3.14159) // "|3.1416|"
	
	// String precision
	fmt.Printf("|%.3s|\n", "hello") // "|hel|"
	fmt.Printf("|%.10s|\n", "hi")  // "|hi        |" (padded to width 10)
}
```

### 3. Combined Width and Precision
```go
func main() {
	// Float with width and precision
	fmt.Printf("|%10.2f|\n", 3.14159) // "|      3.14|"
	fmt.Printf("|%-10.2f|\n", 3.14159) // "|3.14      |"
	
	// String with width and precision
	fmt.Printf("|%10.3s|\n", "hello") // "|       hel|"
	fmt.Printf("|%-10.3s|\n", "hello") // "|hel       |"
}
```

### 4. Formatting Flags
| Flag | Description | Example |
|------|-------------|---------|
| `+` | Always show sign for numbers | `fmt.Printf("%+d", 42)` → `+42` |
| `-` | Left-justify within width | `fmt.Printf("%-5d", 42)` → `42   ` |
| ` ` | Leave space for positive numbers | `fmt.Printf("% d", 42)` → ` 42` |
| `0` | Pad with zeros instead of spaces | `fmt.Printf("%05d", 42)` → `00042` |
| `#` | Alternate format | `fmt.Printf("%#o", 8)` → `010` |

```go
func main() {
	// Sign flag
	fmt.Printf("With sign: %+d\n", 42)     // "+42"
	fmt.Printf("With sign: %+d\n", -42)    // "-42"
	
	// Space flag
	fmt.Printf("Space: % d\n", 42)         // " 42"
	fmt.Printf("Space: % d\n", -42)        // "-42"
	
	// Zero padding
	fmt.Printf("Zero pad: %05d\n", 42)     // "00042"
	
	// Alternate format
	fmt.Printf("Alternate: %#o\n", 8)      // "010"
	fmt.Printf("Alternate: %#x\n", 255)    // "0xff"
}
```

## Custom Formatting

### 1. Implementing `Stringer` Interface
For custom string representation:

```go
type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf("%s (%d years)", p.Name, p.Age)
}

func main() {
	p := Person{"Alice", 30}
	fmt.Println(p) // Automatically calls String() method
	fmt.Printf("%v\n", p) // Also uses String()
}
```

### 2. Implementing `Formatter` Interface
For more complex formatting control:

```go
type Money float64

func (m Money) Format(f fmt.State, verb rune) {
	switch verb {
	case 'f':
		fmt.Fprintf(f, "$%.2f", float64(m))
	case 'F':
		fmt.Fprintf(f, "$%.2f", float64(m))
	case 'v':
		if f.Flag('+') {
			fmt.Fprintf(f, "Money(%v)", float64(m))
		} else {
			fmt.Fprintf(f, "$%.2f", float64(m))
		}
	default:
		fmt.Fprintf(f, "%v", float64(m))
	}
}

func main() {
	price := Money(19.99)
	fmt.Printf("Price: %f\n", price)  // "$19.99"
	fmt.Printf("Price: %+v\n", price) // "Money(19.99)"
}
```

## Common Formatting Patterns

### 1. Table Formatting
Creating aligned columns:

```go
func main() {
	// Header
	fmt.Printf("%-15s %10s %10s\n", "Name", "Age", "Score")
	fmt.Println(strings.Repeat("-", 35))
	
	// Data rows
	fmt.Printf("%-15s %10d %10.1f\n", "Alice", 30, 95.5)
	fmt.Printf("%-15s %10d %10.1f\n", "Bob", 25, 87.2)
	fmt.Printf("%-15s %10d %10.1f\n", "Charlie", 35, 92.8)
}
```

Output:
```
Name            Age       Score
-----------------------------------
Alice            30       95.5
Bob              25       87.2
Charlie          35       92.8
```

### 2. Number Formatting
Adding commas to large numbers:

```go
func formatNumber(n int) string {
	s := fmt.Sprintf("%d", n)
	
	// Add commas every 3 digits from the right
	for i := len(s) - 3; i > 0; i -= 3 {
		s = s[:i] + "," + s[i:]
	}
	
	return s
}

func main() {
	fmt.Println(formatNumber(1000))      // "1,000"
	fmt.Println(formatNumber(1234567))   // "1,234,567"
	fmt.Println(formatNumber(987654321)) // "987,654,321"
}
```

### 3. Progress Bars
Creating simple progress indicators:

```go
func printProgress(current, total int) {
	percent := float64(current) / float64(total) * 100
	barWidth := 50
	filled := int(percent / 100 * float64(barWidth))
	
	bar := strings.Repeat("=", filled) + strings.Repeat(" ", barWidth-filled)
	fmt.Printf("\r[%s] %.1f%% (%d/%d)", bar, percent, current, total)
}

func main() {
	total := 100
	for i := 0; i <= total; i++ {
		printProgress(i, total)
		time.Sleep(50 * time.Millisecond)
	}
	fmt.Println() // Newline after progress completes
}
```

### 4. Logging with Context
Structured log messages:

```go
type Logger struct {
	prefix string
}

func NewLogger(prefix string) *Logger {
	return &Logger{prefix: prefix}
}

func (l *Logger) Log(format string, args ...interface{}) {
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	message := fmt.Sprintf(format, args...)
	fmt.Printf("[%s] %s: %s\n", timestamp, l.prefix, message)
}

func main() {
	logger := NewLogger("APP")
	logger.Log("Starting application")
	logger.Log("Processing %d items", 42)
	logger.Log("Error: %s", "connection timeout")
}
```

## Real-World Example: Report Generator

Let's build a comprehensive report generator that demonstrates various formatting techniques:

```go
package main

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"time"
)

// ReportData represents the data for our report
type ReportData struct {
	Title       string
	GeneratedAt time.Time
	Summary     SummaryStats
	Sections    []ReportSection
}

type SummaryStats struct {
	TotalRecords int
	SuccessCount int
	ErrorCount   int
	AverageValue float64
}

type ReportSection struct {
	Title   string
	Entries []ReportEntry
}

type ReportEntry struct {
	ID       string
	Name     string
	Value    float64
	Status   string
	Category string
}

// ReportGenerator handles report generation
type ReportGenerator struct {
	output io.Writer
}

func NewReportGenerator(w io.Writer) *ReportGenerator {
	return &ReportGenerator{output: w}
}

func (rg *ReportGenerator) GenerateReport(data ReportData) error {
	rg.generateHeader(data)
	rg.generateSummary(data.Summary)
	rg.generateSections(data.Sections)
	rg.generateFooter()
	return nil
}

func (rg *ReportGenerator) generateHeader(data ReportData) {
	// Title with underline
	rg.writeln(data.Title)
	rg.writeln(strings.Repeat("=", len(data.Title)))
	rg.writeln("")
	
	// Metadata
	rg.writeln(fmt.Sprintf("Generated: %s", data.GeneratedAt.Format("2006-01-02 15:04:05")))
	rg.writeln("")
}

func (rg *ReportGenerator) generateSummary(summary SummaryStats) {
	rg.writeln("Summary")
	rg.writeln(strings.Repeat("-", 7))
	rg.writeln("")
	
	// Summary statistics
	rg.writeln(fmt.Sprintf("Total Records: %s", rg.formatNumber(summary.TotalRecords)))
	rg.writeln(fmt.Sprintf("Successful: %s (%.1f%%)", 
		rg.formatNumber(summary.SuccessCount), 
		float64(summary.SuccessCount)/float64(summary.TotalRecords)*100))
	rg.writeln(fmt.Sprintf("Errors: %s (%.1f%%)", 
		rg.formatNumber(summary.ErrorCount), 
		float64(summary.ErrorCount)/float64(summary.TotalRecords)*100))
	rg.writeln(fmt.Sprintf("Average Value: %s", rg.formatCurrency(summary.AverageValue)))
	rg.writeln("")
}

func (rg *ReportGenerator) generateSections(sections []ReportSection) {
	for _, section := range sections {
		rg.generateSection(section)
	}
}

func (rg *ReportGenerator) generateSection(section ReportSection) {
	// Section title
	rg.writeln(section.Title)
	rg.writeln(strings.Repeat("-", len(section.Title)))
	rg.writeln("")
	
	// Table header
	rg.writeln(fmt.Sprintf("%-10s %-20s %15s %-10s %s", 
		"ID", "Name", "Value", "Status", "Category"))
	rg.writeln(strings.Repeat("-", 70))
	
	// Sort entries by value (descending)
	entries := make([]ReportEntry, len(section.Entries))
	copy(entries, section.Entries)
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].Value > entries[j].Value
	})
	
	// Table rows
	for _, entry := range entries {
		statusColor := ""
		if entry.Status == "Success" {
			statusColor = "\033[32m" // Green
		} else if entry.Status == "Error" {
			statusColor = "\033[31m" // Red
		}
		resetColor := "\033[0m"
		
		rg.writeln(fmt.Sprintf("%-10s %-20s %15s %s%-10s%s %s", 
			entry.ID,
			entry.Name,
			rg.formatCurrency(entry.Value),
			statusColor,
			entry.Status,
			resetColor,
			entry.Category))
	}
	
	rg.writeln("")
}

func (rg *ReportGenerator) generateFooter() {
	rg.writeln(strings.Repeat("=", 50))
	rg.writeln("End of Report")
}

func (rg *ReportGenerator) write(s string) {
	fmt.Fprint(rg.output, s)
}

func (rg *ReportGenerator) writeln(s string) {
	fmt.Fprintln(rg.output, s)
}

func (rg *ReportGenerator) formatNumber(n int) string {
	s := fmt.Sprintf("%d", n)
	for i := len(s) - 3; i > 0; i -= 3 {
		s = s[:i] + "," + s[i:]
	}
	return s
}

func (rg *ReportGenerator) formatCurrency(amount float64) string {
	return fmt.Sprintf("$%s%.2f", rg.formatNumber(int(amount)), amount-float64(int(amount)))
}

func main() {
	// Sample data
	data := ReportData{
		Title:       "Quarterly Sales Report",
		GeneratedAt: time.Now(),
		Summary: SummaryStats{
			TotalRecords: 1250,
			SuccessCount: 1187,
			ErrorCount:   63,
			AverageValue: 2475.50,
		},
		Sections: []ReportSection{
			{
				Title: "Top Performers",
				Entries: []ReportEntry{
					{"001", "Product A", 5000.00, "Success", "Electronics"},
					{"002", "Product B", 4500.00, "Success", "Electronics"},
					{"003", "Product C", 3200.00, "Success", "Clothing"},
					{"004", "Product D", 2800.00, "Error", "Electronics"},
					{"005", "Product E", 2100.00, "Success", "Clothing"},
				},
			},
			{
				Title: "New Products",
				Entries: []ReportEntry{
					{"006", "Product F", 1500.00, "Success", "Home"},
					{"007", "Product G", 1200.00, "Error", "Home"},
					{"008", "Product H", 900.00, "Success", "Garden"},
				},
			},
		},
	}
	
	// Generate report to stdout
	generator := NewReportGenerator(os.Stdout)
	if err := generator.GenerateReport(data); err != nil {
		fmt.Printf("Error generating report: %v\n", err)
		os.Exit(1)
	}
	
	// Also generate to file
	file, err := os.Create("report.txt")
	if err != nil {
		fmt.Printf("Error creating file: %v\n", err)
		return
	}
	defer file.Close()
	
	fileGenerator := NewReportGenerator(file)
	if err := fileGenerator.GenerateReport(data); err != nil {
		fmt.Printf("Error generating file report: %v\n", err)
	}
	
	fmt.Println("\nReport generated successfully!")
}
```

### How This Example Demonstrates String Formatting:

1. **Structured Output**:
   - Uses `fmt.Sprintf` for building formatted strings
   - Implements consistent formatting patterns
   - Creates aligned tables with precise spacing

2. **Custom Formatting Functions**:
   - `formatNumber` adds commas to large numbers
   - `formatCurrency` properly formats monetary values
   - Color codes status indicators

3. **Layout Control**:
   - Uses width specifications for column alignment
   - Implements headers and footers with consistent styling
   - Creates visual separators with repeated characters

4. **Data Presentation**:
   - Formats percentages with decimal precision
   - Handles different data types appropriately
   - Sorts and presents data in a readable format

### Real-World Applications:

1. **Business Reporting**:
   - Financial reports with formatted numbers
   - Sales summaries with percentages
   - Performance metrics with visual indicators

2. **Logging Systems**:
   - Structured log messages with timestamps
   - Contextual information formatting
   - Error reporting with consistent format

3. **User Interfaces**:
   - Command-line table displays
   - Progress indicators
   - Formatted data presentation

4. **Data Export**:
   - CSV/TSV generation with proper formatting
   - Report generation for printing
   - Email notifications with formatted content

## Best Practices for String Formatting

### 1. Choose the Right Function
- Use `fmt.Sprintf` when you need a string
- Use `fmt.Printf` for direct output
- Use `fmt.Fprintf` for writing to files or other writers

### 2. Be Consistent
- Establish formatting standards for your project
- Use consistent date/time formats
- Maintain alignment in table outputs

### 3. Handle Internationalization
- Be careful with hardcoded formats
- Consider using localization packages for multi-language apps
- Avoid assumptions about number/date formats

### 4. Performance Considerations
- Pre-allocate strings when possible
- Use `strings.Builder` for complex string building
- Avoid excessive formatting in tight loops

### 5. Error Handling
- Always check errors from formatting functions
- Provide meaningful error messages
- Handle edge cases gracefully

## Performance Tips

### 1. Avoid Repeated Formatting
```go
// Bad - formats on each iteration
for i := 0; i < 1000; i++ {
    msg := fmt.Sprintf("Processing item %d", i)
    // ...
}

// Good - reuse format string
format := "Processing item %d"
for i := 0; i < 1000; i++ {
    msg := fmt.Sprintf(format, i)
    // ...
}
```

### 2. Use strings.Builder for Complex Building
```go
// Bad - creates many temporary strings
var result string
for _, item := range items {
    result += fmt.Sprintf("%s: %v\n", item.Name, item.Value)
}

// Good - efficient with Builder
var builder strings.Builder
for _, item := range items {
    fmt.Fprintf(&builder, "%s: %v\n", item.Name, item.Value)
}
result := builder.String()
```

### 3. Cache Format Strings
```go
// Cache commonly used format strings
var (
    logFormat    = "[%s] %s: %s"
    errorFormat  = "ERROR: %s (code: %d)"
    tableFormat  = "%-20s %10s %15s"
)
```

## Conclusion

String formatting is a fundamental skill in Go that enables you to:

1. **Create Professional Output**:
   - Well-formatted reports and tables
   - User-friendly command-line interfaces
   - Consistent log messages

2. **Present Data Effectively**:
   - Format numbers with appropriate precision
   - Display dates and times consistently
   - Create aligned and readable output

3. **Build Robust Applications**:
   - Handle different data types gracefully
   - Implement custom formatting for complex types
   - Create maintainable and consistent output

The report generator example demonstrates how combining various formatting techniques can create professional, readable output for real-world applications. By mastering Go's string formatting capabilities, you can build applications that communicate clearly with users and present data in the most effective way.

Key takeaways:
1. **Use the right formatting function** for each use case
2. **Leverage width, precision, and flags** for control
3. **Implement custom formatting** for complex types
4. **Follow consistent patterns** throughout your application
5. **Consider performance** for formatting-intensive operations

String formatting is more than just concatenating values—it's about presenting information in a way that's clear, consistent, and professional. Mastering these skills will significantly improve the quality and usability of your Go applications.