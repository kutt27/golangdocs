

{# Type Conversions in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master Go's type conversion capabilities to transform data between different types safely and efficiently. Learn to handle numeric conversions, string and byte transformations, type assertions, and custom type conversions. Understand potential pitfalls like overflow, precision loss, and how to implement proper error handling in your Go applications.

!!! tip "Key Points"
    - Go requires explicit type conversions between different types, preventing implicit conversion bugs
    - Use strconv package for string to numeric conversions and vice versa
    - Implement safe type assertions with comma-ok idiom or type switches
    - Be aware of overflow, underflow, and precision loss when converting between numeric types
    - Create conversion methods for custom types to improve code readability and maintainability
    - Always handle conversion errors properly to prevent runtime panics

## Understanding Type Conversions

Type conversions in Go are explicit operations that change the type of a value. Unlike some languages that allow implicit conversions, Go requires explicit conversions between different types. This strict approach helps prevent bugs and makes code more predictable.

!!! info "Type Conversion Categories"
    ```mermaid
    graph LR
        A[Type Conversions] --> B[Numeric Conversions]
        A --> C[String and Byte Conversions]
        A --> D[Boolean Conversions]
        A --> E[Type Assertions]
        A --> F[Custom Type Conversions]
        B --> G[Integer to Integer]
        B --> H[Floating-point to Floating-point]
        B --> I[Integer to Floating-point]
        B --> J[Floating-point to Integer]
        C --> K[String to Byte Slice]
        C --> L[Byte Slice to String]
        C --> M[Rune to String]
        C --> N[String to Rune Slice]
        E --> O[Basic Type Assertions]
        E --> P[Type Switches]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Basic Type Conversions

### 1. Numeric Conversions

Go provides explicit conversions between numeric types. When converting between types of different sizes or signedness, you must be aware of potential data loss or overflow.

!!! example "Numeric Conversions"
    ```go title="numeric_conversions.go" linenums="1" hl_lines="8-42"
    package main

    import (
        "fmt"
        "math"
    )

    func main() {
        // Integer to integer
        var i int = 42
        var i8 int8 = int8(i)
        var i16 int16 = int16(i)
        var i32 int32 = int32(i)
        var i64 int64 = int64(i)
        var u uint = uint(i)
        var u8 uint8 = uint8(i)
        var u16 uint16 = uint16(i)
        var u32 uint32 = uint32(i)
        var u64 uint64 = uint64(i)
        
        fmt.Printf("Original: %d (type: %T)\n", i, i)
        fmt.Printf("int8: %d (type: %T)\n", i8, i8)
        fmt.Printf("uint: %d (type: %T)\n", u, u)
        
        // Floating-point to floating-point
        var f32 float32 = 3.14
        var f64 float64 = float64(f32)
        fmt.Printf("float32: %f (type: %T)\n", f32, f32)
        fmt.Printf("float64: %f (type: %T)\n", f64, f64)
        
        // Integer to floating-point
        var x int = 10
        var y float64 = float64(x)
        fmt.Printf("int to float64: %f (type: %T)\n", y, y)
        
        // Floating-point to integer (truncates decimal part)
        var z float64 = 3.9
        var w int = int(z)
        fmt.Printf("float64 to int: %d (type: %T)\n", w, w)
        
        // Handling overflow
        var bigInt int64 = math.MaxInt64
        var smallInt int8 = int8(bigInt) // This will overflow
        fmt.Printf("Overflow example: %d (type: %T)\n", smallInt, smallInt)
    }
    ```

### 2. String and Byte Conversions

Converting between strings and byte slices is a common operation in Go:

!!! example "String and Byte Conversions"
    ```go title="string_byte_conversions.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
    )

    func main() {
        // String to byte slice
        s := "Hello, World!"
        b := []byte(s)
        fmt.Printf("String: %s (type: %T)\n", s, s)
        fmt.Printf("Byte slice: %v (type: %T)\n", b, b)
        
        // Byte slice to string
        s2 := string(b)
        fmt.Printf("Back to string: %s (type: %T)\n", s2, s2)
        
        // Rune to string
        r := 'G'
        s3 := string(r)
        fmt.Printf("Rune: %c (type: %T)\n", r, r)
        fmt.Printf("Rune to string: %s (type: %T)\n", s3, s3)
        
        // String to rune slice
        s4 := "Hello"
        runes := []rune(s4)
        fmt.Printf("String: %s (type: %T)\n", s4, s4)
        fmt.Printf("Rune slice: %v (type: %T)\n", runes, runes)
    }
    ```

### 3. Boolean Conversions

There are no direct conversions between booleans and other types in Go. You must use conditional expressions:

!!! example "Boolean Conversions"
    ```go title="boolean_conversions.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // Boolean to string
        b := true
        s := strconv.FormatBool(b)
        fmt.Printf("Boolean: %t (type: %T)\n", b, b)
        fmt.Printf("Boolean to string: %s (type: %T)\n", s, s)
        
        // String to boolean
        s2 := "true"
        b2, err := strconv.ParseBool(s2)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("String: %s (type: %T)\n", s2, s2)
            fmt.Printf("String to boolean: %t (type: %T)\n", b2, b2)
        }
        
        // Numeric to boolean (no direct conversion)
        i := 1
        b3 := i != 0
        fmt.Printf("Numeric: %d (type: %T)\n", i, i)
        fmt.Printf("Numeric to boolean: %t (type: %T)\n", b3, b3)
    }
    ```

## Type Assertions

Type assertions are used to extract the concrete value from an interface variable.

### 1. Basic Type Assertions

!!! example "Basic Type Assertions"
    ```go title="type_assertions.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
    )

    func main() {
        var i interface{} = "Hello, World!"
        
        // Type assertion
        s, ok := i.(string)
        if ok {
            fmt.Printf("i is a string: %s\n", s)
        } else {
            fmt.Println("i is not a string")
        }
        
        // Type assertion with panic if wrong type
        s2 := i.(string)
        fmt.Printf("i is definitely a string: %s\n", s2)
        
        // This would panic:
        // n := i.(int)
        // fmt.Println(n)
        
        // Safe type assertion
        if n, ok := i.(int); ok {
            fmt.Printf("i is an int: %d\n", n)
        } else {
            fmt.Println("i is not an int")
        }
    }
    ```

### 2. Type Switches

Type switches are a convenient way to handle multiple possible types:

!!! example "Type Switches"
    ```go title="type_switches.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "fmt"
    )

    func processValue(i interface{}) {
        switch v := i.(type) {
        case int:
            fmt.Printf("Integer: %d\n", v)
        case float64:
            fmt.Printf("Float: %f\n", v)
        case string:
            fmt.Printf("String: %s\n", v)
        case bool:
            fmt.Printf("Boolean: %t\n", v)
        default:
            fmt.Printf("Unknown type: %T\n", v)
        }
    }

    func main() {
        processValue(42)
        processValue(3.14)
        processValue("Hello")
        processValue(true)
        processValue([]int{1, 2, 3})
    }
    ```

## Custom Type Conversions

You can define methods on your types to enable conversions between custom types.

### 1. Creating Conversion Methods

!!! example "Creating Conversion Methods"
    ```go title="custom_conversion_methods.go" linenums="1" hl_lines="8-54"
    package main

    import (
        "fmt"
        "strconv"
    )

    type Celsius float64
    type Fahrenheit float64

    func (c Celsius) String() string {
        return fmt.Sprintf("%.2f째C", c)
    }

    func (f Fahrenheit) String() string {
        return fmt.Sprintf("%.2f째F", f)
    }

    // Conversion methods
    func (c Celsius) Fahrenheit() Fahrenheit {
        return Fahrenheit(c*9/5 + 32)
    }

    func (f Fahrenheit) Celsius() Celsius {
        return Celsius((f - 32) * 5 / 9)
    }

    type Money float64

    func (m Money) String() string {
        return fmt.Sprintf("$%.2f", m)
    }

    func (m Money) Dollars() int {
        return int(m)
    }

    func (m Money) Cents() int {
        return int(m*100) % 100
    }

    func Dollars(d int, c int) Money {
        return Money(float64(d) + float64(c)/100)
    }

    func main() {
        // Temperature conversions
        c := Celsius(100)
        f := c.Fahrenheit()
        fmt.Printf("%s is %s\n", c, f)
        
        f2 := Fahrenheit(32)
        c2 := f2.Celsius()
        fmt.Printf("%s is %s\n", f2, c2)
        
        // Money conversions
        m := Money(12.49)
        fmt.Printf("%s is %d dollars and %d cents\n", m, m.Dollars(), m.Cents())
        
        m2 := Dollars(5, 99)
        fmt.Printf("Dollars and cents: %s\n", m2)
    }
    ```

### 2. Converting to and from Strings

!!! example "Converting to and from Strings"
    ```go title="string_conversions.go" linenums="1" hl_lines="8-44"
    package main

    import (
        "fmt"
        "strconv"
        "time"
    )

    type Date struct {
        Year  int
        Month time.Month
        Day   int
    }

    func (d Date) String() string {
        return fmt.Sprintf("%04d-%02d-%02d", d.Year, d.Month, d.Day)
    }

    func ParseDate(s string) (Date, error) {
        parts := []string{s[0:4], s[5:7], s[8:10]}
        
        year, err := strconv.Atoi(parts[0])
        if err != nil {
            return Date{}, err
        }
        
        month, err := strconv.Atoi(parts[1])
        if err != nil {
            return Date{}, err
        }
        
        day, err := strconv.Atoi(parts[2])
        if err != nil {
            return Date{}, err
        }
        
        return Date{
            Year:  year,
            Month: time.Month(month),
            Day:   day,
        }, nil
    }

    func main() {
        // Date to string
        d := Date{2023, 10, 15}
        s := d.String()
        fmt.Printf("Date: %s (type: %T)\n", d, d)
        fmt.Printf("String: %s (type: %T)\n", s, s)
        
        // String to date
        s2 := "2023-11-20"
        d2, err := ParseDate(s2)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Printf("String: %s (type: %T)\n", s2, s2)
            fmt.Printf("Date: %s (type: %T)\n", d2, d2)
        }
    }
    ```

## Common Pitfalls and Best Practices

### 1. Overflow and Underflow

!!! warning "Overflow and Underflow"
    Be aware of potential overflow and underflow when converting between numeric types of different sizes.

!!! example "Overflow and Underflow"
    ```go title="overflow_underflow.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "fmt"
        "math"
    )

    func main() {
        // Integer overflow
        var bigInt int64 = math.MaxInt64
        var smallInt int8 = int8(bigInt) // This will overflow
        fmt.Printf("Max int64: %d\n", bigInt)
        fmt.Printf("Converted to int8: %d\n", smallInt)
        
        // Floating-point precision loss
        var bigFloat float64 = 1.23456789012345
        var smallFloat float32 = float32(bigFloat)
        fmt.Printf("Original float64: %.15f\n", bigFloat)
        fmt.Printf("Converted to float32: %.15f\n", smallFloat)
        
        // Safe conversion with checking
        var x int32 = 1000
        var y int8
        
        if x < math.MinInt8 || x > math.MaxInt8 {
            fmt.Println("Conversion would overflow")
        } else {
            y = int8(x)
            fmt.Printf("Safe conversion: %d\n", y)
        }
    }
    ```

### 2. Loss of Precision

!!! warning "Loss of Precision"
    Converting between types can result in loss of precision, especially when converting from floating-point to integer or between floating-point types of different sizes.

!!! example "Loss of Precision"
    ```go title="precision_loss.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "fmt"
        "math"
    )

    func main() {
        // Floating-point to integer
        f := 3.9
        i := int(f) // Truncates, doesn't round
        fmt.Printf("Original float: %f\n", f)
        fmt.Printf("Converted to int: %d\n", i)
        
        // For rounding, use math.Round
        i2 := int(math.Round(f))
        fmt.Printf("Rounded to int: %d\n", i2)
        
        // Large integers to floating-point
        bigInt := int64(9007199254740993) // 2^53 + 1
        bigFloat := float64(bigInt)
        backToInt := int64(bigFloat)
        fmt.Printf("Original int64: %d\n", bigInt)
        fmt.Printf("Converted to float64: %f\n", bigFloat)
        fmt.Printf("Back to int64: %d\n", backToInt)
        fmt.Printf("Values equal? %t\n", bigInt == backToInt) // May be false due to precision loss
    }
    ```

### 3. Type Assertion Safety

!!! warning "Type Assertion Safety"
    Always use safe type assertions to prevent panics in your code.

!!! example "Type Assertion Safety"
    ```go title="type_assertion_safety.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
    )

    func main() {
        var i interface{} = "Hello"
        
        // Safe type assertion
        if s, ok := i.(string); ok {
            fmt.Printf("i is a string: %s\n", s)
        } else {
            fmt.Println("i is not a string")
        }
        
        // Unsafe type assertion (would panic)
        // n := i.(int)
        // fmt.Println(n)
        
        // Using type switches for safety
        switch v := i.(type) {
        case string:
            fmt.Printf("i is a string: %s\n", v)
        case int:
            fmt.Printf("i is an int: %d\n", v)
        default:
            fmt.Printf("i is of type %T\n", v)
        }
    }
    ```

### 4. String Conversion Efficiency

!!! tip "String Conversion Efficiency"
    Use efficient methods for string operations to avoid unnecessary memory allocations.

!!! example "String Conversion Efficiency"
    ```go title="string_efficiency.go" linenums="1" hl_lines="8-36"
    package main

    import (
        "fmt"
        "strconv"
        "strings"
    )

    func main() {
        // Inefficient string concatenation in loops
        var s1 string
        for i := 0; i < 1000; i++ {
            s1 += strconv.Itoa(i) // Creates a new string each time
        }
        fmt.Printf("Length of inefficient concatenation: %d\n", len(s1))
        
        // Efficient string building
        var builder strings.Builder
        for i := 0; i < 1000; i++ {
            builder.WriteString(strconv.Itoa(i))
        }
        s2 := builder.String()
        fmt.Printf("Length of efficient concatenation: %d\n", len(s2))
        
        // Byte slice to string conversion
        b := []byte{'H', 'e', 'l', 'l', 'o'}
        s3 := string(b) // Creates a new string
        fmt.Printf("Byte slice to string: %s\n", s3)
        
        // String to byte slice conversion
        s4 := "World"
        b2 := []byte(s4) // Creates a new byte slice
        fmt.Printf("String to byte slice: %v\n", b2)
    }
    ```

## Real-World Example: Data Processing Pipeline

Let's create a comprehensive example that demonstrates various type conversions in a data processing context:

!!! example "Data Processing Pipeline"
    ```go title="data_processing.go" linenums="1" hl_lines="8-152"
    package main

    import (
        "encoding/csv"
        "encoding/json"
        "fmt"
        "log"
        "math"
        "os"
        "strconv"
        "strings"
        "time"
    )

    type Person struct {
        ID        int       `json:"id"`
        Name      string    `json:"name"`
        Age       int       `json:"age"`
        Salary    float64   `json:"salary"`
        HireDate  time.Time `json:"hire_date"`
        IsActive  bool      `json:"is_active"`
    }

    type PersonCSV struct {
        ID        string `csv:"id"`
        Name      string `csv:"name"`
        Age       string `csv:"age"`
        Salary    string `csv:"salary"`
        HireDate  string `csv:"hire_date"`
        IsActive  string `csv:"is_active"`
    }

    func main() {
        // Read CSV file
        file, err := os.Open("people.csv")
        if err != nil {
            log.Fatal(err)
        }
        defer file.Close()
        
        reader := csv.NewReader(file)
        records, err := reader.ReadAll()
        if err != nil {
            log.Fatal(err)
        }
        
        // Skip header
        var people []Person
        for i, record := range records {
            if i == 0 {
                continue // Skip header
            }
            
            // Parse CSV record
            csvPerson := PersonCSV{
                ID:       record[0],
                Name:     record[1],
                Age:      record[2],
                Salary:   record[3],
                HireDate: record[4],
                IsActive: record[5],
            }
            
            // Convert CSV to Person
            person, err := csvToPerson(csvPerson)
            if err != nil {
                log.Printf("Error converting record %d: %v", i, err)
                continue
            }
            
            people = append(people, person)
        }
        
        // Process people
        var totalSalary float64
        var activeCount int
        var ageSum int
        
        for _, person := range people {
            totalSalary += person.Salary
            if person.IsActive {
                activeCount++
            }
            ageSum += person.Age
        }
        
        // Calculate statistics
        avgSalary := totalSalary / float64(len(people))
        avgAge := float64(ageSum) / float64(len(people))
        activePercentage := float64(activeCount) / float64(len(people)) * 100
        
        // Create statistics
        stats := map[string]interface{}{
            "total_people":      len(people),
            "total_salary":      totalSalary,
            "average_salary":    avgSalary,
            "average_age":       avgAge,
            "active_count":      activeCount,
            "active_percentage": activePercentage,
        }
        
        // Print statistics
        fmt.Println("Statistics:")
        for key, value := range stats {
            switch v := value.(type) {
            case int:
                fmt.Printf("%s: %d\n", key, v)
            case float64:
                fmt.Printf("%s: %.2f\n", key, v)
            default:
                fmt.Printf("%s: %v\n", key, v)
            }
        }
        
        // Convert to JSON
        jsonData, err := json.MarshalIndent(people, "", "  ")
        if err != nil {
            log.Fatal(err)
        }
        
        // Write JSON file
        jsonFile, err := os.Create("people.json")
        if err != nil {
            log.Fatal(err)
        }
        defer jsonFile.Close()
        
        _, err = jsonFile.Write(jsonData)
        if err != nil {
            log.Fatal(err)
        }
        
        fmt.Println("Data processed and saved to people.json")
    }

    func csvToPerson(csvPerson PersonCSV) (Person, error) {
        var person Person
        var err error
        
        // Convert ID
        person.ID, err = strconv.Atoi(csvPerson.ID)
        if err != nil {
            return Person{}, fmt.Errorf("invalid ID: %v", err)
        }
        
        // Convert Name
        person.Name = strings.TrimSpace(csvPerson.Name)
        if person.Name == "" {
            return Person{}, fmt.Errorf("name is empty")
        }
        
        // Convert Age
        person.Age, err = strconv.Atoi(csvPerson.Age)
        if err != nil {
            return Person{}, fmt.Errorf("invalid age: %v", err)
        }
        if person.Age < 0 || person.Age > 120 {
            return Person{}, fmt.Errorf("age out of range: %d", person.Age)
        }
        
        // Convert Salary
        person.Salary, err = strconv.ParseFloat(csvPerson.Salary, 64)
        if err != nil {
            return Person{}, fmt.Errorf("invalid salary: %v", err)
        }
        if person.Salary < 0 {
            return Person{}, fmt.Errorf("salary cannot be negative: %f", person.Salary)
        }
        
        // Convert HireDate
        person.HireDate, err = time.Parse("2006-01-02", csvPerson.HireDate)
        if err != nil {
            return Person{}, fmt.Errorf("invalid hire date: %v", err)
        }
        
        // Convert IsActive
        person.IsActive, err = strconv.ParseBool(csvPerson.IsActive)
        if err != nil {
            return Person{}, fmt.Errorf("invalid active status: %v", err)
        }
        
        return person, nil
    }
    ```

### How This Example Demonstrates Type Conversions:

1. **String to Numeric Conversions**:
   - `strconv.Atoi` for string to int
   - `strconv.ParseFloat` for string to float64
   - `strconv.ParseBool` for string to bool

2. **Date Parsing**:
   - `time.Parse` for string to time.Time

3. **Custom Type Conversions**:
   - `csvToPerson` function converts from CSV struct to Person struct
   - Includes validation and error handling

4. **Interface Type Handling**:
   - Type switch in statistics printing to handle different types
   - JSON marshaling uses interface{} for flexible data representation

5. **Error Handling**:
   - Proper error handling for all conversions
   - Meaningful error messages

## Best Practices for Type Conversions

!!! tip "Always Check for Errors"
    Handle conversion errors properly to prevent runtime panics.

!!! example "Error Handling"
    ```go title="error_handling.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // Good
        s := "123"
        i, err := strconv.Atoi(s)
        if err != nil {
            // Handle error
            fmt.Println("Error:", err)
        } else {
            fmt.Println("Converted value:", i)
        }
    }
    ```

!!! tip "Use Safe Type Assertions"
    Always use the comma-ok idiom or type switches for type assertions to prevent panics.

!!! example "Safe Type Assertions"
    ```go title="safe_type_assertions.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
    )

    func main() {
        var i interface{} = "Hello"
        
        // Good
        if s, ok := i.(string); ok {
            fmt.Println("String value:", s)
        } else {
            fmt.Println("Not a string")
        }
    }
    ```

!!! tip "Be Aware of Precision Loss"
    Check for potential overflow or precision loss when converting between numeric types.

!!! example "Precision Loss Prevention"
    ```go title="precision_prevention.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "math"
    )

    func main() {
        // Good - check for overflow
        var x int32 = 1000
        var y int8
        
        if x < math.MinInt8 || x > math.MaxInt8 {
            fmt.Println("Conversion would overflow")
        } else {
            y = int8(x)
            fmt.Printf("Safe conversion: %d\n", y)
        }
    }
    ```

!!! tip "Use Appropriate Conversion Functions"
    Use the right conversion functions for the task, especially for string conversions.

!!! example "Appropriate Conversion Functions"
    ```go title="appropriate_conversions.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        // Good - use strconv for string conversions
        s := "3.14"
        f, err := strconv.ParseFloat(s, 64)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Println("Converted float:", f)
        }
    }
    ```

!!! tip "Create Conversion Methods for Custom Types"
    Implement conversion methods for custom types to improve code readability and maintainability.

!!! example "Custom Type Conversion Methods"
    ```go title="custom_type_methods.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
    )

    type Celsius float64
    type Fahrenheit float64

    func (c Celsius) Fahrenheit() Fahrenheit {
        return Fahrenheit(c*9/5 + 32)
    }

    func main() {
        // Usage
        c := Celsius(100)
        f := c.Fahrenheit()
        fmt.Printf("%.2f째C is %.2f째F\n", c, f)
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Explicit Conversions**: Go requires explicit conversions between different types, preventing implicit conversion bugs
    - **Numeric Conversions**: Be aware of overflow, underflow, and precision loss when converting between numeric types
    - **String Conversions**: Use `strconv` package for string to numeric conversions and `strings.Builder` for efficient string building
    - **Type Assertions**: Use safe assertions with the comma-ok idiom or type switches to prevent panics
    - **Custom Conversions**: Create conversion methods for custom types to improve code readability and maintainability
    - **Error Handling**: Always handle conversion errors properly to prevent runtime panics

!!! quote "Remember"
    "Type conversions are a fundamental aspect of Go programming. By understanding and properly using type conversions, you can write more robust, predictable, and maintainable Go code. Type safety is one of Go's strengths, and mastering type conversions will help you leverage this safety effectively."