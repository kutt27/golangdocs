

# Type Conversions in Go: A Comprehensive Guide

## Introduction to Type Conversions

In Go, type conversions (also called type casting) are explicit operations that change the type of a value. Unlike some languages that allow implicit conversions, Go requires explicit conversions between different types. This strict approach helps prevent bugs and makes code more predictable.

## Basic Type Conversions

### Numeric Conversions

Go provides explicit conversions between numeric types. When converting between types of different sizes or signedness, you must be aware of potential data loss or overflow.

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Integer to integer
    var i int = 42
    var i8 int8 = int8(i)
    var i16 int16 = int16(i)
    var i32 int32 = int32(i)
    var i64 int64 = int64(i)
    var u uint = uint(i)
    var u8 uint8 = uint8(i)
    var u16 uint16 = uint16(i)
    var u32 uint32 = uint32(i)
    var u64 uint64 = uint64(i)
    
    fmt.Printf("Original: %d (type: %T)\n", i, i)
    fmt.Printf("int8: %d (type: %T)\n", i8, i8)
    fmt.Printf("uint: %d (type: %T)\n", u, u)
    
    // Floating-point to floating-point
    var f32 float32 = 3.14
    var f64 float64 = float64(f32)
    fmt.Printf("float32: %f (type: %T)\n", f32, f32)
    fmt.Printf("float64: %f (type: %T)\n", f64, f64)
    
    // Integer to floating-point
    var x int = 10
    var y float64 = float64(x)
    fmt.Printf("int to float64: %f (type: %T)\n", y, y)
    
    // Floating-point to integer (truncates decimal part)
    var z float64 = 3.9
    var w int = int(z)
    fmt.Printf("float64 to int: %d (type: %T)\n", w, w)
    
    // Handling overflow
    var bigInt int64 = math.MaxInt64
    var smallInt int8 = int8(bigInt) // This will overflow
    fmt.Printf("Overflow example: %d (type: %T)\n", smallInt, smallInt)
}
```

### String and Byte Conversions

Converting between strings and byte slices is a common operation in Go:

```go
package main

import (
    "fmt"
)

func main() {
    // String to byte slice
    s := "Hello, World!"
    b := []byte(s)
    fmt.Printf("String: %s (type: %T)\n", s, s)
    fmt.Printf("Byte slice: %v (type: %T)\n", b, b)
    
    // Byte slice to string
    s2 := string(b)
    fmt.Printf("Back to string: %s (type: %T)\n", s2, s2)
    
    // Rune to string
    r := 'G'
    s3 := string(r)
    fmt.Printf("Rune: %c (type: %T)\n", r, r)
    fmt.Printf("Rune to string: %s (type: %T)\n", s3, s3)
    
    // String to rune slice
    s4 := "Hello"
    runes := []rune(s4)
    fmt.Printf("String: %s (type: %T)\n", s4, s4)
    fmt.Printf("Rune slice: %v (type: %T)\n", runes, runes)
}
```

### Boolean Conversions

There are no direct conversions between booleans and other types in Go. You must use conditional expressions:

```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
    // Boolean to string
    b := true
    s := strconv.FormatBool(b)
    fmt.Printf("Boolean: %t (type: %T)\n", b, b)
    fmt.Printf("Boolean to string: %s (type: %T)\n", s, s)
    
    // String to boolean
    s2 := "true"
    b2, err := strconv.ParseBool(s2)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Printf("String: %s (type: %T)\n", s2, s2)
        fmt.Printf("String to boolean: %t (type: %T)\n", b2, b2)
    }
    
    // Numeric to boolean (no direct conversion)
    i := 1
    b3 := i != 0
    fmt.Printf("Numeric: %d (type: %T)\n", i, i)
    fmt.Printf("Numeric to boolean: %t (type: %T)\n", b3, b3)
}
```

## Type Assertions

Type assertions are used to extract the concrete value from an interface variable.

### Basic Type Assertions

```go
package main

import (
    "fmt"
)

func main() {
    var i interface{} = "Hello, World!"
    
    // Type assertion
    s, ok := i.(string)
    if ok {
        fmt.Printf("i is a string: %s\n", s)
    } else {
        fmt.Println("i is not a string")
    }
    
    // Type assertion with panic if wrong type
    s2 := i.(string)
    fmt.Printf("i is definitely a string: %s\n", s2)
    
    // This would panic:
    // n := i.(int)
    // fmt.Println(n)
    
    // Safe type assertion
    if n, ok := i.(int); ok {
        fmt.Printf("i is an int: %d\n", n)
    } else {
        fmt.Println("i is not an int")
    }
}
```

### Type Switches

Type switches are a convenient way to handle multiple possible types:

```go
package main

import (
    "fmt"
)

func processValue(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case float64:
        fmt.Printf("Float: %f\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case bool:
        fmt.Printf("Boolean: %t\n", v)
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}

func main() {
    processValue(42)
    processValue(3.14)
    processValue("Hello")
    processValue(true)
    processValue([]int{1, 2, 3})
}
```

## Custom Type Conversions

You can define methods on your types to enable conversions between custom types.

### Creating Conversion Methods

```go
package main

import (
    "fmt"
    "strconv"
)

type Celsius float64
type Fahrenheit float64

func (c Celsius) String() string {
    return fmt.Sprintf("%.2f°C", c)
}

func (f Fahrenheit) String() string {
    return fmt.Sprintf("%.2f°F", f)
}

// Conversion methods
func (c Celsius) Fahrenheit() Fahrenheit {
    return Fahrenheit(c*9/5 + 32)
}

func (f Fahrenheit) Celsius() Celsius {
    return Celsius((f - 32) * 5 / 9)
}

type Money float64

func (m Money) String() string {
    return fmt.Sprintf("$%.2f", m)
}

func (m Money) Dollars() int {
    return int(m)
}

func (m Money) Cents() int {
    return int(m*100) % 100
}

func Dollars(d int, c int) Money {
    return Money(float64(d) + float64(c)/100)
}

func main() {
    // Temperature conversions
    c := Celsius(100)
    f := c.Fahrenheit()
    fmt.Printf("%s is %s\n", c, f)
    
    f2 := Fahrenheit(32)
    c2 := f2.Celsius()
    fmt.Printf("%s is %s\n", f2, c2)
    
    // Money conversions
    m := Money(12.49)
    fmt.Printf("%s is %d dollars and %d cents\n", m, m.Dollars(), m.Cents())
    
    m2 := Dollars(5, 99)
    fmt.Printf("Dollars and cents: %s\n", m2)
}
```

### Converting to and from Strings

```go
package main

import (
    "fmt"
    "strconv"
    "time"
)

type Date struct {
    Year  int
    Month time.Month
    Day   int
}

func (d Date) String() string {
    return fmt.Sprintf("%04d-%02d-%02d", d.Year, d.Month, d.Day)
}

func ParseDate(s string) (Date, error) {
    parts := []string{s[0:4], s[5:7], s[8:10]}
    
    year, err := strconv.Atoi(parts[0])
    if err != nil {
        return Date{}, err
    }
    
    month, err := strconv.Atoi(parts[1])
    if err != nil {
        return Date{}, err
    }
    
    day, err := strconv.Atoi(parts[2])
    if err != nil {
        return Date{}, err
    }
    
    return Date{
        Year:  year,
        Month: time.Month(month),
        Day:   day,
    }, nil
}

func main() {
    // Date to string
    d := Date{2023, 10, 15}
    s := d.String()
    fmt.Printf("Date: %s (type: %T)\n", d, d)
    fmt.Printf("String: %s (type: %T)\n", s, s)
    
    // String to date
    s2 := "2023-11-20"
    d2, err := ParseDate(s2)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Printf("String: %s (type: %T)\n", s2, s2)
        fmt.Printf("Date: %s (type: %T)\n", d2, d2)
    }
}
```

## Common Pitfalls and Best Practices

### 1. Overflow and Underflow

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Integer overflow
    var bigInt int64 = math.MaxInt64
    var smallInt int8 = int8(bigInt) // This will overflow
    fmt.Printf("Max int64: %d\n", bigInt)
    fmt.Printf("Converted to int8: %d\n", smallInt)
    
    // Floating-point precision loss
    var bigFloat float64 = 1.23456789012345
    var smallFloat float32 = float32(bigFloat)
    fmt.Printf("Original float64: %.15f\n", bigFloat)
    fmt.Printf("Converted to float32: %.15f\n", smallFloat)
    
    // Safe conversion with checking
    var x int32 = 1000
    var y int8
    
    if x < math.MinInt8 || x > math.MaxInt8 {
        fmt.Println("Conversion would overflow")
    } else {
        y = int8(x)
        fmt.Printf("Safe conversion: %d\n", y)
    }
}
```

### 2. Loss of Precision

```go
package main

import (
    "fmt"
)

func main() {
    // Floating-point to integer
    f := 3.9
    i := int(f) // Truncates, doesn't round
    fmt.Printf("Original float: %f\n", f)
    fmt.Printf("Converted to int: %d\n", i)
    
    // For rounding, use math.Round
    import "math"
    i2 := int(math.Round(f))
    fmt.Printf("Rounded to int: %d\n", i2)
    
    // Large integers to floating-point
    bigInt := int64(9007199254740993) // 2^53 + 1
    bigFloat := float64(bigInt)
    backToInt := int64(bigFloat)
    fmt.Printf("Original int64: %d\n", bigInt)
    fmt.Printf("Converted to float64: %f\n", bigFloat)
    fmt.Printf("Back to int64: %d\n", backToInt)
    fmt.Printf("Values equal? %t\n", bigInt == backToInt) // May be false due to precision loss
}
```

### 3. Type Assertion Safety

```go
package main

import (
    "fmt"
)

func main() {
    var i interface{} = "Hello"
    
    // Safe type assertion
    if s, ok := i.(string); ok {
        fmt.Printf("i is a string: %s\n", s)
    } else {
        fmt.Println("i is not a string")
    }
    
    // Unsafe type assertion (would panic)
    // n := i.(int)
    // fmt.Println(n)
    
    // Using type switches for safety
    switch v := i.(type) {
    case string:
        fmt.Printf("i is a string: %s\n", v)
    case int:
        fmt.Printf("i is an int: %d\n", v)
    default:
        fmt.Printf("i is of type %T\n", v)
    }
}
```

### 4. String Conversion Efficiency

```go
package main

import (
    "fmt"
    "strconv"
    "strings"
)

func main() {
    // Inefficient string concatenation in loops
    var s1 string
    for i := 0; i < 1000; i++ {
        s1 += strconv.Itoa(i) // Creates a new string each time
    }
    fmt.Printf("Length of inefficient concatenation: %d\n", len(s1))
    
    // Efficient string building
    var builder strings.Builder
    for i := 0; i < 1000; i++ {
        builder.WriteString(strconv.Itoa(i))
    }
    s2 := builder.String()
    fmt.Printf("Length of efficient concatenation: %d\n", len(s2))
    
    // Byte slice to string conversion
    b := []byte{'H', 'e', 'l', 'l', 'o'}
    s3 := string(b) // Creates a new string
    fmt.Printf("Byte slice to string: %s\n", s3)
    
    // String to byte slice conversion
    s4 := "World"
    b2 := []byte(s4) // Creates a new byte slice
    fmt.Printf("String to byte slice: %v\n", b2)
}
```

## Real-World Example: Data Processing Pipeline

Let's create a comprehensive example that demonstrates various type conversions in a data processing context:

```go
package main

import (
    "encoding/csv"
    "encoding/json"
    "fmt"
    "log"
    "math"
    "os"
    "strconv"
    "strings"
    "time"
)

type Person struct {
    ID        int       `json:"id"`
    Name      string    `json:"name"`
    Age       int       `json:"age"`
    Salary    float64   `json:"salary"`
    HireDate  time.Time `json:"hire_date"`
    IsActive  bool      `json:"is_active"`
}

type PersonCSV struct {
    ID        string `csv:"id"`
    Name      string `csv:"name"`
    Age       string `csv:"age"`
    Salary    string `csv:"salary"`
    HireDate  string `csv:"hire_date"`
    IsActive  string `csv:"is_active"`
}

func main() {
    // Read CSV file
    file, err := os.Open("people.csv")
    if err != nil {
        log.Fatal(err)
    }
    defer file.Close()
    
    reader := csv.NewReader(file)
    records, err := reader.ReadAll()
    if err != nil {
        log.Fatal(err)
    }
    
    // Skip header
    var people []Person
    for i, record := range records {
        if i == 0 {
            continue // Skip header
        }
        
        // Parse CSV record
        csvPerson := PersonCSV{
            ID:       record[0],
            Name:     record[1],
            Age:      record[2],
            Salary:   record[3],
            HireDate: record[4],
            IsActive: record[5],
        }
        
        // Convert CSV to Person
        person, err := csvToPerson(csvPerson)
        if err != nil {
            log.Printf("Error converting record %d: %v", i, err)
            continue
        }
        
        people = append(people, person)
    }
    
    // Process people
    var totalSalary float64
    var activeCount int
    var ageSum int
    
    for _, person := range people {
        totalSalary += person.Salary
        if person.IsActive {
            activeCount++
        }
        ageSum += person.Age
    }
    
    // Calculate statistics
    avgSalary := totalSalary / float64(len(people))
    avgAge := float64(ageSum) / float64(len(people))
    activePercentage := float64(activeCount) / float64(len(people)) * 100
    
    // Create statistics
    stats := map[string]interface{}{
        "total_people":      len(people),
        "total_salary":      totalSalary,
        "average_salary":    avgSalary,
        "average_age":       avgAge,
        "active_count":      activeCount,
        "active_percentage": activePercentage,
    }
    
    // Print statistics
    fmt.Println("Statistics:")
    for key, value := range stats {
        switch v := value.(type) {
        case int:
            fmt.Printf("%s: %d\n", key, v)
        case float64:
            fmt.Printf("%s: %.2f\n", key, v)
        default:
            fmt.Printf("%s: %v\n", key, v)
        }
    }
    
    // Convert to JSON
    jsonData, err := json.MarshalIndent(people, "", "  ")
    if err != nil {
        log.Fatal(err)
    }
    
    // Write JSON file
    jsonFile, err := os.Create("people.json")
    if err != nil {
        log.Fatal(err)
    }
    defer jsonFile.Close()
    
    _, err = jsonFile.Write(jsonData)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("Data processed and saved to people.json")
}

func csvToPerson(csvPerson PersonCSV) (Person, error) {
    var person Person
    var err error
    
    // Convert ID
    person.ID, err = strconv.Atoi(csvPerson.ID)
    if err != nil {
        return Person{}, fmt.Errorf("invalid ID: %v", err)
    }
    
    // Convert Name
    person.Name = strings.TrimSpace(csvPerson.Name)
    if person.Name == "" {
        return Person{}, fmt.Errorf("name is empty")
    }
    
    // Convert Age
    person.Age, err = strconv.Atoi(csvPerson.Age)
    if err != nil {
        return Person{}, fmt.Errorf("invalid age: %v", err)
    }
    if person.Age < 0 || person.Age > 120 {
        return Person{}, fmt.Errorf("age out of range: %d", person.Age)
    }
    
    // Convert Salary
    person.Salary, err = strconv.ParseFloat(csvPerson.Salary, 64)
    if err != nil {
        return Person{}, fmt.Errorf("invalid salary: %v", err)
    }
    if person.Salary < 0 {
        return Person{}, fmt.Errorf("salary cannot be negative: %f", person.Salary)
    }
    
    // Convert HireDate
    person.HireDate, err = time.Parse("2006-01-02", csvPerson.HireDate)
    if err != nil {
        return Person{}, fmt.Errorf("invalid hire date: %v", err)
    }
    
    // Convert IsActive
    person.IsActive, err = strconv.ParseBool(csvPerson.IsActive)
    if err != nil {
        return Person{}, fmt.Errorf("invalid active status: %v", err)
    }
    
    return person, nil
}
```

### How This Example Demonstrates Type Conversions:

1. **String to Numeric Conversions**:
   - `strconv.Atoi` for string to int
   - `strconv.ParseFloat` for string to float64
   - `strconv.ParseBool` for string to bool

2. **Date Parsing**:
   - `time.Parse` for string to time.Time

3. **Custom Type Conversions**:
   - `csvToPerson` function converts from CSV struct to Person struct
   - Includes validation and error handling

4. **Interface Type Handling**:
   - Type switch in statistics printing to handle different types
   - JSON marshaling uses interface{} for flexible data representation

5. **Error Handling**:
   - Proper error handling for all conversions
   - Meaningful error messages

## Best Practices for Type Conversions

### 1. Always Check for Errors

```go
// Good
s := "123"
i, err := strconv.Atoi(s)
if err != nil {
    // Handle error
}

// Bad (panics on invalid input)
i := int(s.(int))
```

### 2. Use Safe Type Assertions

```go
// Good
if s, ok := i.(string); ok {
    // Use s
}

// Bad (panics if wrong type)
s := i.(string)
```

### 3. Be Aware of Precision Loss

```go
// Good - check for overflow
var x int32 = 1000
var y int8

if x < math.MinInt8 || x > math.MaxInt8 {
    // Handle overflow
} else {
    y = int8(x)
}

// Bad - potential overflow
y = int8(x)
```

### 4. Use Appropriate Conversion Functions

```go
// Good - use strconv for string conversions
s := "3.14"
f, err := strconv.ParseFloat(s, 64)

// Bad - potential precision loss
f := float64(int(s))
```

### 5. Create Conversion Methods for Custom Types

```go
// Good
type Celsius float64
type Fahrenheit float64

func (c Celsius) Fahrenheit() Fahrenheit {
    return Fahrenheit(c*9/5 + 32)
}

// Usage
c := Celsius(100)
f := c.Fahrenheit()
```

## Conclusion

Type conversions are a fundamental aspect of Go programming:

### Key Takeaways:
1. **Explicit Conversions**:
   - Go requires explicit conversions between different types
   - This prevents implicit conversion bugs

2. **Numeric Conversions**:
   - Be aware of overflow and underflow
   - Check bounds when converting between types of different sizes

3. **String Conversions**:
   - Use `strconv` package for string to numeric conversions
   - Be efficient with string concatenation using `strings.Builder`

4. **Type Assertions**:
   - Use safe assertions with the comma-ok idiom
   - Use type switches for handling multiple possible types

5. **Custom Conversions**:
   - Create conversion methods for custom types
   - Include validation and error handling

6. **Best Practices**:
   - Always check for errors
   - Be aware of precision loss
   - Use appropriate conversion functions
   - Create meaningful conversion methods

By understanding and properly using type conversions, you can write more robust, predictable, and maintainable Go code. Type safety is one of Go's strengths, and mastering type conversions will help you leverage this safety effectively.