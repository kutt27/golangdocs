

# Go Methods: Behavior for Custom Types

!!! abstract "Overview"
    Master Go methods - functions with receiver arguments that define behavior for custom types. Learn value vs pointer receivers, method sets, and patterns for building expressive, object-oriented Go code.

!!! tip "Key Points"
    - Methods are functions with receiver arguments
    - Choose value or pointer receivers based on needs
    - Method sets determine interface satisfaction
    - Can be defined on any custom type
    - Enable object-oriented programming patterns

## Understanding Methods

Methods in Go are functions with a special receiver argument that defines behavior for custom types.

!!! info "Method Structure"
    ```mermaid
    graph LR
        A[Method] --> B[Receiver]
        A --> C[Name]
        A --> D[Parameters]
        A --> E[Return Values]
        B --> F[Value Receiver]
        B --> G[Pointer Receiver]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Method Basics

### Defining Methods

!!! example "Method Definition"
    ```go title="method_definition.go" linenums="1" hl_lines="8-15"
    package main

    import "fmt"

    type Rectangle struct {
        Width, Height float64
    }

    // Method with value receiver
    func (r Rectangle) Area() float64 {
        return r.Width * r.Height
    }

    // Method with pointer receiver
    func (r *Rectangle) Scale(factor float64) {
        r.Width *= factor
        r.Height *= factor
    }

    func main() {
        rect := Rectangle{Width: 10, Height: 5}
        fmt.Println("Area:", rect.Area()) // 50
        
        rect.Scale(2)
        fmt.Printf("Scaled: %+v\n", rect) // {Width:20 Height:10}
    }
    ```

### Value Receivers vs. Pointer Receivers

!!! example "Receiver Types"
    ```go title="receiver_types.go" linenums="1" hl_lines="8-20"
    package main

    import "fmt"

    type Rectangle struct {
        Width, Height float64
    }

    // Value receiver - operates on a copy
    func (r Rectangle) Perimeter() float64 {
        return 2 * (r.Width + r.Height)
    }

    // Pointer receiver - operates on the original
    func (r *Rectangle) SetDimensions(width, height float64) {
        r.Width = width
        r.Height = height
    }

    func main() {
        rect := Rectangle{Width: 10, Height: 5}
        fmt.Println("Perimeter:", rect.Perimeter()) // 30
        
        rect.SetDimensions(20, 10)
        fmt.Printf("Updated: %+v\n", rect) // {Width:20 Height:10}
    }
    ```

#### When to Use Each:
- **Value Receivers**: When method doesn't need to modify receiver, receiver is small, or for consistency
- **Pointer Receivers**: When method needs to modify receiver, receiver is large, or contains fields that shouldn't be copied

### Method Invocation

!!! example "Method Invocation"
    ```go title="method_invocation.go" linenums="1" hl_lines="8-20"
    package main

    import "fmt"

    type Rectangle struct {
        Width, Height float64
    }

    func (r Rectangle) Area() float64 {
        return r.Width * r.Height
    }

    func (r *Rectangle) Scale(factor float64) {
        r.Width *= factor
        r.Height *= factor
    }

    func main() {
        rect := Rectangle{Width: 10, Height: 5}
        
        // Value receiver method
        fmt.Println("Area:", rect.Area()) // 50
        
        // Pointer receiver method (Go automatically takes address)
        rect.Scale(2)
        fmt.Printf("Scaled: %+v\n", rect) // {Width:20 Height:10}
        
        // Calling with pointer
        pRect := &Rectangle{Width: 5, Height: 3}
        fmt.Println("Area:", pRect.Area()) // 15 (Go automatically dereferences)
    }
    ```

## Method Sets and Interface Satisfaction

### Method Sets

!!! info "Method Set Rules"
    ```mermaid
    graph LR
        A[Type T] --> B[Methods with receiver T]
        C[Type *T] --> D[Methods with receiver *T]
        C --> B
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
        style C fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

!!! example "Method Sets"
    ```go title="method_sets.go" linenums="1" hl_lines="8-20"
    package main

    import "fmt"

    type Shaper interface {
        Area() float64
        Perimeter() float64
    }

    type Rectangle struct {
        Width, Height float64
    }

    // Rectangle implements Shaper with value receiver methods
    func (r Rectangle) Area() float64 {
        return r.Width * r.Height
    }

    func (r Rectangle) Perimeter() float64 {
        return 2 * (r.Width + r.Height)
    }

    func main() {
        var s Shaper
        s = Rectangle{Width: 10, Height: 5} // OK: Rectangle has required methods
        s = &Rectangle{Width: 10, Height: 5} // Also OK: *Rectangle has all methods of Rectangle
        
        fmt.Printf("Area: %.2f\n", s.Area())
    }
    ```

### Interface Satisfaction Rules

!!! warning "Interface Satisfaction"
    If an interface has methods with pointer receivers, only `*T` (not `T`) can satisfy it.

!!! example "Interface Satisfaction"
    ```go title="interface_satisfaction.go" linenums="1" hl_lines="8-18"
    package main

    import "fmt"

    type Scaler interface {
        Scale(float64)
    }

    type Rectangle struct {
        Width, Height float64
    }

    // Scale has a pointer receiver
    func (r *Rectangle) Scale(factor float64) {
        r.Width *= factor
        r.Height *= factor
    }

    func main() {
        var s Scaler
        s = &Rectangle{Width: 10, Height: 5} // OK
        fmt.Printf("Before scaling: %+v\n", s)
        s.Scale(2)
        fmt.Printf("After scaling: %+v\n", s)
        
        // s = Rectangle{Width: 10, Height: 5} // Compile error: Rectangle does not implement Scaler
    }
    ```

## Method Expressions and Values

### Method Expressions

!!! example "Method Expressions"
    ```go title="method_expressions.go" linenums="1" hl_lines="8-19"
    package main

    import "fmt"

    type Calculator struct{}

    func (c Calculator) Add(a, b int) int {
        return a + b
    }

    func main() {
        // Method expression
        addFunc := Calculator.Add
        result := addFunc(Calculator{}, 2, 3) // Pass receiver as first argument
        fmt.Println(result) // 5
        
        // With pointer receiver
        calc := &Calculator{}
        addFunc2 := (*Calculator).Add
        result2 := addFunc2(calc, 5, 7)
        fmt.Println(result2) // 12
    }
    ```

### Method Values

!!! example "Method Values"
    ```go title="method_values.go" linenums="1" hl_lines="8-18"
    package main

    import "fmt"

    type Rectangle struct {
        Width, Height float64
    }

    func (r Rectangle) Area() float64 {
        return r.Width * r.Height
    }

    func (r *Rectangle) Scale(factor float64) {
        r.Width *= factor
        r.Height *= factor
    }

    func main() {
        rect := Rectangle{Width: 10, Height: 5}
        
        // Method value
        areaFunc := rect.Area
        fmt.Println(areaFunc()) // 50
        
        // Works with pointers too
        pRect := &Rectangle{Width: 5, Height: 3}
        scaleFunc := pRect.Scale
        scaleFunc(2)
        fmt.Printf("%+v\n", pRect) // {Width:10 Height:6}
    }
    ```

## Embedded Types and Method Promotion

### Method Promotion

!!! example "Method Promotion"
    ```go title="method_promotion.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "math"
    )

    type Point struct {
        X, Y int
    }

    func (p Point) Distance() float64 {
        return math.Sqrt(float64(p.X*p.X + p.Y*p.Y))
    }

    type Circle struct {
        Point  // Embedded type
        Radius int
    }

    func main() {
        c := Circle{
            Point:  Point{X: 3, Y: 4},
            Radius: 5,
        }
        
        // Promoted method
        fmt.Println("Distance from origin:", c.Distance()) // 5
        
        // Still accessible via embedded type
        fmt.Println("Distance via Point:", c.Point.Distance()) // 5
    }
    ```

### Method Overriding

!!! example "Method Overriding"
    ```go title="method_overriding.go" linenums="1" hl_lines="14-22"
    package main

    import (
        "fmt"
        "math"
    )

    type Point struct {
        X, Y int
    }

    func (p Point) Distance() float64 {
        return math.Sqrt(float64(p.X*p.X + p.Y*p.Y))
    }

    type Circle struct {
        Point  // Embedded type
        Radius int
    }

    func (c Circle) Distance() float64 {
        centerDist := c.Point.Distance()
        return math.Abs(float64(c.Radius) - centerDist)
    }

    func main() {
        c := Circle{
            Point:  Point{X: 3, Y: 4},
            Radius: 5,
        }
        
        fmt.Println("Circle distance:", c.Distance()) // 0 (5 - 5)
        fmt.Println("Point distance:", c.Point.Distance()) // 5
    }
    ```

## Best Practices and Common Patterns

### 1. Choosing Between Value and Pointer Receivers

!!! example "Receiver Selection"
    ```go title="receiver_selection.go" linenums="1" hl_lines="8-20"
    package main

    import "fmt"

    type User struct {
        Name  string
        Email string
    }

    // Use pointer receiver when:
    func (u *User) Save() {
        // Modifies user (e.g., updates database)
        fmt.Printf("Saving user %s to database\n", u.Name)
    }

    // Use value receiver when:
    func (u User) Validate() bool {
        // Only reads user data
        return u.Email != "" && u.Name != ""
    }

    func main() {
        user := User{Name: "Alice", Email: "alice@example.com"}
        
        if user.Validate() {
            user.Save()
        }
    }
    ```

### 2. Method Chaining

!!! example "Method Chaining"
    ```go title="method_chaining.go" linenums="1" hl_lines="8-22"
    package main

    import "fmt"

    type Builder struct {
    name string
    age  int
    }

    func (b *Builder) SetName(name string) *Builder {
        b.name = name
        return b
    }

    func (b *Builder) SetAge(age int) *Builder {
        b.age = age
        return b
    }

    func (b *Builder) Build() User {
        return User{Name: b.name, Age: b.age}
    }

    type User struct {
        Name string
        Age  int
    }

    func main() {
        builder := &Builder{}
        user := builder.SetName("Alice").SetAge(30).Build()
        fmt.Printf("%+v\n", user)
    }
    ```

### 3. Fluent Interfaces

!!! example "Fluent Interface"
    ```go title="fluent_interface.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "strings"
    )

    type Query struct {
    table string
    where []string
    }

    func (q *Query) From(table string) *Query {
        q.table = table
        return q
    }

    func (q *Query) Where(condition string) *Query {
        q.where = append(q.where, condition)
        return q
    }

    func (q *Query) String() string {
        return fmt.Sprintf("SELECT * FROM %s WHERE %s", q.table, strings.Join(q.where, " AND "))
    }

    func main() {
        query := &Query{}
        sql := query.From("users").Where("age > 18").Where("active = true").String()
        fmt.Println(sql)
    }
    ```

### 4. Interface Segregation

!!! example "Interface Segregation"
    ```go title="interface_segregation.go" linenums="1" hl_lines="6-18"
    package main

    import "fmt"

    type Reader interface {
        Read([]byte) (int, error)
    }

    type Writer interface {
        Write([]byte) (int, error)
    }

    type ReadWriter interface {
        Reader
        Writer
    }

    type Buffer struct {
        data []byte
    }

    func (b *Buffer) Read(p []byte) (int, error) {
        // Implementation
        return 0, nil
    }

    func (b *Buffer) Write(p []byte) (int, error) {
        // Implementation
        return 0, nil
    }

    func main() {
        var rw ReadWriter = &Buffer{}
        fmt.Printf("Buffer implements ReadWriter: %v\n", rw != nil)
    }
    ```

## Real-World Example: CRUD Service with Methods

Let's build a complete CRUD (Create, Read, Update, Delete) service for a User entity, demonstrating various method patterns:

!!! example "CRUD Service"
    ```go title="crud_service.go" linenums="1" hl_lines="8-50"
    package main

    import (
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "net/http"
        "sync"
        "time"
    )

    // User represents a user in our system
    type User struct {
        ID        int       `json:"id"`
        Name      string    `json:"name" validate:"required"`
        Email     string    `json:"email" validate:"required,email"`
        Age       int       `json:"age" validate:"gte=18"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
    }

    // UserRepository handles data operations
    type UserRepository struct {
        users map[int]*User
        mu    sync.RWMutex
        nextID int
    }

    func NewUserRepository() *UserRepository {
        return &UserRepository{
            users:  make(map[int]*User),
            nextID: 1,
        }
    }

    // Create adds a new user to the repository
    func (r *UserRepository) Create(user *User) error {
        r.mu.Lock()
        defer r.mu.Unlock()
        
        // Check for duplicate email
        for _, u := range r.users {
            if u.Email == user.Email {
                return errors.New("email already exists")
            }
        }
        
        user.ID = r.nextID
        user.CreatedAt = time.Now()
        user.UpdatedAt = time.Now()
        r.users[user.ID] = user
        r.nextID++
        
        return nil
    }

    // Get retrieves a user by ID
    func (r *UserRepository) Get(id int) (*User, error) {
        r.mu.RLock()
        defer r.mu.RUnlock()
        
        user, exists := r.users[id]
        if !exists {
            return nil, errors.New("user not found")
        }
        
        // Return a copy to avoid external modifications
        copy := *user
        return &copy, nil
    }

    // UserService provides business logic on top of the repository
    type UserService struct {
        repo *UserRepository
    }

    func NewUserService(repo *UserRepository) *UserService {
        return &UserService{repo: repo}
    }

    // CreateUser handles user creation with business rules
    func (s *UserService) CreateUser(name, email string, age int) (*User, error) {
        if age < 18 {
            return nil, errors.New("user must be at least 18 years old")
        }
        
        user := &User{
            Name:  name,
            Email: email,
            Age:   age,
        }
        
        if err := s.repo.Create(user); err != nil {
            return nil, fmt.Errorf("failed to create user: %w", err)
        }
        
        return user, nil
    }

    // HTTP Handlers
    type UserHandler struct {
        service *UserService
    }

    func NewUserHandler(service *UserService) *UserHandler {
        return &UserHandler{service: service}
    }

    func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
        var req struct {
            Name  string `json:"name"`
            Email string `json:"email"`
            Age   int    `json:"age"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            http.Error(w, "Invalid request", http.StatusBadRequest)
            return
        }
        
        user, err := h.service.CreateUser(req.Name, req.Email, req.Age)
        if err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)
    }

    func main() {
        // Setup dependencies
        repo := NewUserRepository()
        service := NewUserService(repo)
        handler := NewUserHandler(service)
        
        // Add sample data
        repo.Create(&User{Name: "Alice", Email: "alice@example.com", Age: 30})
        
        // Setup routes
        http.HandleFunc("/users", handler.CreateUser)
        
        fmt.Println("Server starting on port 8080...")
        log.Fatal(http.ListenAndServe(":8080", nil))
    }
    ```

### How This Example Demonstrates Method Concepts:

1. **Repository Pattern**:
   - `UserRepository` methods encapsulate data access
   - Pointer receivers for modifying data
   - Value receivers for read operations
   - Thread-safe operations with mutex

2. **Service Layer**:
   - `UserService` methods implement business logic
   - Composition with repository
   - Error handling and validation

3. **HTTP Handlers**:
   - Methods handle HTTP requests
   - Dependency injection
   - Separation of concerns

## Advanced Method Techniques

### 1. Method Values as Closures

!!! example "Method Closures"
    ```go title="method_closures.go" linenums="1" hl_lines="8-22"
    package main

    import "fmt"

    type User struct {
        Name  string
        Email string
    }

    func (u *User) GetValidator() func(string) bool {
        return func(field string) bool {
            switch field {
            case "name":
                return u.Name != ""
            case "email":
                return u.Email != ""
            default:
                return false
            }
        }
    }

    func main() {
        user := &User{Name: "Alice", Email: "alice@example.com"}
        validate := user.GetValidator()
        fmt.Println("Name valid:", validate("name")) // true
        fmt.Println("Email valid:", validate("email")) // true
    }
    ```

### 2. Method Sets for Polymorphism

!!! example "Polymorphism"
    ```go title="polymorphism.go" linenums="1" hl_lines="8-28"
    package main

    import "fmt"

    type Animal interface {
        Speak() string
        Move() string
    }

    type Dog struct{}

    func (d Dog) Speak() string { return "Woof!" }
    func (d Dog) Move() string  { return "Runs" }

    type Bird struct{}

    func (b Bird) Speak() string { return "Chirp!" }
    func (b Bird) Move() string  { return "Flies" }

    func PerformActions(a Animal) {
        fmt.Println(a.Speak())
        fmt.Println(a.Move())
    }

    func main() {
        PerformActions(Dog{})
    PerformActions(Bird{})
    }
    ```

### 3. Embedded Interfaces

!!! example "Embedded Interfaces"
    ```go title="embedded_interfaces.go" linenums="1" hl_lines="6-22"
    package main

    import "fmt"

    type Reader interface {
        Read([]byte) (int, error)
    }

    type Writer interface {
        Write([]byte) (int, error)
    }

    type ReadWriter interface {
        Reader
        Writer
    }

    type Buffer struct {
        data []byte
    }

    func (b *Buffer) Read(p []byte) (int, error) {
        // Implementation
        return 0, nil
    }

    func (b *Buffer) Write(p []byte) (int, error) {
        // Implementation
        return 0, nil
    }

    func main() {
        var rw ReadWriter = &Buffer{}
        fmt.Printf("Buffer implements ReadWriter: %v\n", rw != nil)
    }
    ```

## Best Practices

!!! warning "Common Pitfalls"
    - Inconsistent use of value and pointer receivers
    - Modifying value receivers (changes won't persist)
    - Forgetting that nil pointers can call methods
    - Creating large method sets that violate interface segregation

!!! example "Best Practice Patterns"
    ```go title="best_practices.go" linenums="1" hl_lines="8-25"
    package main

    import "fmt"

    // Good: Clear receiver choice
    type User struct {
        Name string
    }

    // Pointer receiver for modification
    func (u *User) SetName(name string) {
        u.Name = name
    }

    // Value receiver for read-only operations
    func (u User) GetName() string {
        return u.Name
    }

    // Good: Method consistency
    type Service struct {
        config *Config
    }

    // All methods use pointer receivers for consistency
    func (s *Service) Start() error {
        // Implementation
        return nil
    }

    func (s *Service) Stop() error {
        // Implementation
        return nil
    }

    type Config struct{}

    func main() {
        user := &User{Name: "Alice"}
        user.SetName("Bob")
        fmt.Println("Name:", user.GetName())
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Method Definition**: `func (receiver Type) MethodName(params) return_type`
    - **Value Receivers**: Use for read-only operations, small types, or consistency
    - **Pointer Receivers**: Use for modification, large types, or fields that shouldn't be copied
    - **Method Sets**: Determine interface satisfaction
    - **Method Promotion**: Embedded type methods become available on containing type
    - **Method Chaining**: Return receiver to enable fluent interfaces
    - **Interface Segregation**: Keep interfaces small and focused

!!! quote "Remember"
    "Methods in Go provide a way to associate behavior with data. Unlike traditional OOP languages, Go uses composition over inheritance, with methods playing a key role in this approach. Choose your receiver types carefully and design methods that work together to create expressive, maintainable APIs."