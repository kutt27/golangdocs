
# Go Methods: Behavior for Custom Types

!!! abstract "Overview"
    Master Go methods - functions with receiver arguments that define behavior for custom types. Learn value vs pointer receivers, method sets, and patterns for building expressive, object-oriented Go code.

!!! tip "Key Points"
    - Methods are functions with receiver arguments
    - Choose value or pointer receivers based on needs
    - Method sets determine interface satisfaction
    - Can be defined on any custom type
    - Enable object-oriented programming patterns

## Understanding Methods

Methods in Go are functions with a special receiver argument that defines behavior for custom types.

## Method Basics

### Defining Methods
A method is defined with a receiver parameter between the `func` keyword and the method name:

```go
type Rectangle struct {
    Width, Height float64
}

// Method with value receiver
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Method with pointer receiver
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}
```

### Value Receivers vs. Pointer Receivers

#### Value Receivers
- Operate on a copy of the receiver
- Cannot modify the original value
- Used when:
  - The method doesn't need to modify the receiver
  - The receiver is small (to avoid copying overhead)
  - Consistency is needed (if some methods use value receivers)

```go
func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}
```

#### Pointer Receivers
- Operate on the original value
- Can modify the receiver
- Used when:
  - The method needs to modify the receiver
  - The receiver is large (to avoid copying)
  - The receiver contains fields that shouldn't be copied (like sync.Mutex)

```go
func (r *Rectangle) SetDimensions(width, height float64) {
    r.Width = width
    r.Height = height
}
```

### Method Invocation
Go automatically handles the conversion between values and pointers when calling methods:

```go
func main() {
    rect := Rectangle{Width: 10, Height: 5}
    
    // Value receiver method
    fmt.Println("Area:", rect.Area()) // 50
    
    // Pointer receiver method (Go automatically takes address)
    rect.Scale(2)
    fmt.Printf("Scaled: %+v\n", rect) // {Width:20 Height:10}
    
    // Calling with pointer
    pRect := &Rectangle{Width: 5, Height: 3}
    fmt.Println("Area:", pRect.Area()) // 15 (Go automatically dereferences)
}
```

## Method Sets and Interface Satisfaction

### Method Sets
The method set of a type determines which interfaces it can implement:
- For a type `T`, its method set includes all methods with receiver `T`
- For a type `*T`, its method set includes all methods with receiver `*T` or `T`

```go
type Shaper interface {
    Area() float64
    Perimeter() float64
}

// Rectangle implements Shaper with value receiver methods
func (r Rectangle) Area() float64 { /* ... */ }
func (r Rectangle) Perimeter() float64 { /* ... */ }

func main() {
    var s Shaper
    s = Rectangle{Width: 10, Height: 5} // OK: Rectangle has required methods
    s = &Rectangle{Width: 10, Height: 5} // Also OK: *Rectangle has all methods of Rectangle
}
```

### Interface Satisfaction Rules
- A type `T` satisfies an interface if its method set includes all methods of the interface
- A type `*T` satisfies an interface if its method set includes all methods of the interface
- If an interface has methods with pointer receivers, only `*T` (not `T`) can satisfy it

```go
type Scaler interface {
    Scale(float64)
}

// Only *Rectangle satisfies Scaler because Scale has a pointer receiver
func main() {
    var s Scaler
    s = &Rectangle{Width: 10, Height: 5} // OK
    // s = Rectangle{Width: 10, Height: 5} // Compile error: Rectangle does not implement Scaler
}
```

## Method Expressions and Values

### Method Expressions
Method expressions allow you to treat methods as functions, with the receiver as the first parameter:

```go
type Calculator struct{}

func (c Calculator) Add(a, b int) int {
    return a + b
}

func main() {
    // Method expression
    addFunc := Calculator.Add
    result := addFunc(Calculator{}, 2, 3) // Pass receiver as first argument
    fmt.Println(result) // 5
    
    // With pointer receiver
    calc := &Calculator{}
    addFunc2 := (*Calculator).Add
    result2 := addFunc2(calc, 5, 7)
    fmt.Println(result2) // 12
}
```

### Method Values
Method values are like closures that capture the receiver:

```go
func main() {
    rect := Rectangle{Width: 10, Height: 5}
    
    // Method value
    areaFunc := rect.Area
    fmt.Println(areaFunc()) // 50
    
    // Works with pointers too
    pRect := &Rectangle{Width: 5, Height: 3}
    scaleFunc := pRect.Scale
    scaleFunc(2)
    fmt.Printf("%+v\n", pRect) // {Width:10 Height:6}
}
```

## Embedded Types and Method Promotion

When a struct embeds another type, methods of the embedded type are promoted to the containing struct:

```go
type Point struct {
    X, Y int
}

func (p Point) Distance() float64 {
    return math.Sqrt(float64(p.X*p.X + p.Y*p.Y))
}

type Circle struct {
    Point  // Embedded type
    Radius int
}

func main() {
    c := Circle{
        Point:  Point{X: 3, Y: 4},
        Radius: 5,
    }
    
    // Promoted method
    fmt.Println("Distance from origin:", c.Distance()) // 5
    
    // Still accessible via embedded type
    fmt.Println("Distance via Point:", c.Point.Distance()) // 5
}
```

### Method Overriding
A containing type can override methods of an embedded type:

```go
func (c Circle) Distance() float64 {
    centerDist := c.Point.Distance()
    return math.Abs(float64(c.Radius) - centerDist)
}

func main() {
    c := Circle{
        Point:  Point{X: 3, Y: 4},
        Radius: 5,
    }
    
    fmt.Println("Circle distance:", c.Distance()) // 0 (5 - 5)
    fmt.Println("Point distance:", c.Point.Distance()) // 5
}
```

## Best Practices and Common Patterns

### 1. Choosing Between Value and Pointer Receivers
```go
// Use pointer receiver when:
func (u *User) Save() {
    // Modifies user (e.g., updates database)
}

// Use value receiver when:
func (u User) Validate() bool {
    // Only reads user data
    return u.Email != "" && u.Name != ""
}
```

### 2. Method Chaining
Return the receiver to enable method chaining:

```go
func (b *Builder) SetName(name string) *Builder {
    b.name = name
    return b
}

func (b *Builder) SetAge(age int) *Builder {
    b.age = age
    return b
}

func main() {
    builder := &Builder{}
    user := builder.SetName("Alice").SetAge(30).Build()
}
```

### 3. Fluent Interfaces
Design methods that work well together:

```go
type Query struct {
    table string
    where []string
}

func (q *Query) From(table string) *Query {
    q.table = table
    return q
}

func (q *Query) Where(condition string) *Query {
    q.where = append(q.where, condition)
    return q
}

func (q *Query) String() string {
    return fmt.Sprintf("SELECT * FROM %s WHERE %s", q.table, strings.Join(q.where, " AND "))
}

func main() {
    query := &Query{}
    sql := query.From("users").Where("age > 18").Where("active = true").String()
    fmt.Println(sql)
}
```

### 4. Interface Segregation
Define small, focused interfaces that methods can implement:

```go
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type ReadWriter interface {
    Reader
    Writer
}
```

## Real-World Example: CRUD Service with Methods

Let's build a complete CRUD (Create, Read, Update, Delete) service for a User entity, demonstrating various method patterns:

```go
package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"
)

// User represents a user in our system
type User struct {
	ID        int       `json:"id"`
	Name      string    `json:"name" validate:"required"`
	Email     string    `json:"email" validate:"required,email"`
	Age       int       `json:"age" validate:"gte=18"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// UserRepository handles data operations
type UserRepository struct {
	users map[int]*User
	mu    sync.RWMutex
	nextID int
}

func NewUserRepository() *UserRepository {
	return &UserRepository{
		users:  make(map[int]*User),
		nextID: 1,
	}
}

// Create adds a new user to the repository
func (r *UserRepository) Create(user *User) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	
	// Check for duplicate email
	for _, u := range r.users {
		if u.Email == user.Email {
			return errors.New("email already exists")
		}
	}
	
	user.ID = r.nextID
	user.CreatedAt = time.Now()
	user.UpdatedAt = time.Now()
	r.users[user.ID] = user
	r.nextID++
	
	return nil
}

// Get retrieves a user by ID
func (r *UserRepository) Get(id int) (*User, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	user, exists := r.users[id]
	if !exists {
		return nil, errors.New("user not found")
	}
	
	// Return a copy to avoid external modifications
	copy := *user
	return &copy, nil
}

// Update modifies an existing user
func (r *UserRepository) Update(user *User) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	
	existing, exists := r.users[user.ID]
	if !exists {
		return errors.New("user not found")
	}
	
	// Check for duplicate email (excluding current user)
	for id, u := range r.users {
		if id != user.ID && u.Email == user.Email {
			return errors.New("email already exists")
		}
	}
	
	existing.Name = user.Name
	existing.Email = user.Email
	existing.Age = user.Age
	existing.UpdatedAt = time.Now()
	
	return nil
}

// Delete removes a user by ID
func (r *UserRepository) Delete(id int) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	
	if _, exists := r.users[id]; !exists {
		return errors.New("user not found")
	}
	
	delete(r.users, id)
	return nil
}

// List returns all users
func (r *UserRepository) List() []*User {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	users := make([]*User, 0, len(r.users))
	for _, user := range r.users {
		// Return copies to avoid external modifications
		copy := *user
		users = append(users, &copy)
	}
	
	return users
}

// UserService provides business logic on top of the repository
type UserService struct {
	repo *UserRepository
}

func NewUserService(repo *UserRepository) *UserService {
	return &UserService{repo: repo}
}

// CreateUser handles user creation with business rules
func (s *UserService) CreateUser(name, email string, age int) (*User, error) {
	if age < 18 {
		return nil, errors.New("user must be at least 18 years old")
	}
	
	user := &User{
		Name:  name,
		Email: email,
		Age:   age,
	}
	
	if err := s.repo.Create(user); err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}
	
	return user, nil
}

// GetUserProfile returns extended user information
func (s *UserService) GetUserProfile(id int) (map[string]interface{}, error) {
	user, err := s.repo.Get(id)
	if err != nil {
		return nil, err
	}
	
	profile := map[string]interface{}{
		"id":         user.ID,
		"name":       user.Name,
		"email":      user.Email,
		"age":        user.Age,
		"member_for": time.Since(user.CreatedAt).String(),
		"is_adult":   user.Age >= 18,
	}
	
	return profile, nil
}

// UpdateUserEmail handles email updates with validation
func (s *UserService) UpdateUserEmail(id int, newEmail string) error {
	user, err := s.repo.Get(id)
	if err != nil {
		return err
	}
	
	// Additional business logic
	if user.Email == newEmail {
		return errors.New("new email is the same as current email")
	}
	
	user.Email = newEmail
	return s.repo.Update(user)
}

// HTTP Handlers
type UserHandler struct {
	service *UserService
}

func NewUserHandler(service *UserService) *UserHandler {
	return &UserHandler{service: service}
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
	var req struct {
		Name  string `json:"name"`
		Email string `json:"email"`
		Age   int    `json:"age"`
	}
	
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}
	
	user, err := h.service.CreateUser(req.Name, req.Email, req.Age)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
	// In a real app, get ID from URL params
	id := 1
	
	profile, err := h.service.GetUserProfile(id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusNotFound)
		return
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(profile)
}

func main() {
	// Setup dependencies
	repo := NewUserRepository()
	service := NewUserService(repo)
	handler := NewUserHandler(service)
	
	// Add sample data
	repo.Create(&User{Name: "Alice", Email: "alice@example.com", Age: 30})
	repo.Create(&User{Name: "Bob", Email: "bob@example.com", Age: 25})
	
	// Setup routes
	http.HandleFunc("/users", handler.CreateUser)
	http.HandleFunc("/user", handler.GetUser)
	
	fmt.Println("Server starting on port 8080...")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### How This Example Demonstrates Method Concepts:

1. **Repository Pattern**:
   - `UserRepository` methods encapsulate data access
   - Pointer receivers for modifying data
   - Value receivers for read operations
   - Thread-safe operations with mutex

2. **Service Layer**:
   - `UserService` methods implement business logic
   - Composition with repository
   - Error handling and validation

3. **HTTP Handlers**:
   - Methods handle HTTP requests
   - Dependency injection
   - Separation of concerns

4. **Method Types**:
   - Value receivers for read-only operations
   - Pointer receivers for modifications
   - Method chaining potential
   - Interface implementation readiness

### Real-World Applications of This Pattern:

1. **Web Applications**:
   - RESTful API services
   - Microservices architecture
   - Domain-driven design

2. **Data Access Layers**:
   - Database repositories
   - Cache management
   - External API clients

3. **Business Logic**:
   - Domain services
   - Application services
   - Workflow orchestration

4. **Testing Infrastructure**:
   - Mock implementations
   - Test fixtures
   - Benchmark helpers

### Benefits of This Approach:

1. **Encapsulation**:
   - Data and behavior are bundled together
   - Clear boundaries between layers
   - Controlled access to data

2. **Testability**:
   - Easy to mock dependencies
   - Isolated unit testing
   - Clear contracts between components

3. **Maintainability**:
   - Single responsibility principle
   - Clear separation of concerns
   - Easy to extend and modify

4. **Concurrency Safety**:
   - Thread-safe operations
   - Proper locking mechanisms
   - Immutable data where possible

## Advanced Method Techniques

### 1. Method Values as Closures
```go
func (u *User) GetValidator() func(string) bool {
    return func(field string) bool {
        switch field {
        case "name":
            return u.Name != ""
        case "email":
            return u.Email != ""
        default:
            return false
        }
    }
}

func main() {
    user := &User{Name: "Alice", Email: "alice@example.com"}
    validate := user.GetValidator()
    fmt.Println("Name valid:", validate("name")) // true
    fmt.Println("Email valid:", validate("email")) // true
}
```

### 2. Method Sets for Polymorphism
```go
type Animal interface {
    Speak() string
    Move() string
}

type Dog struct{}

func (d Dog) Speak() string { return "Woof!" }
func (d Dog) Move() string  { return "Runs" }

type Bird struct{}

func (b Bird) Speak() string { return "Chirp!" }
func (b Bird) Move() string  { return "Flies" }

func PerformActions(a Animal) {
    fmt.Println(a.Speak())
    fmt.Println(a.Move())
}

func main() {
    PerformActions(Dog{})
    PerformActions(Bird{})
}
```

### 3. Embedded Interfaces
```go
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type ReadWriter interface {
    Reader
    Writer
}

type Buffer struct {
    data []byte
}

func (b *Buffer) Read(p []byte) (int, error) {
    // Implementation
    return 0, nil
}

func (b *Buffer) Write(p []byte) (int, error) {
    // Implementation
    return 0, nil
}

func main() {
    var rw ReadWriter = &Buffer{}
    // Can use both Read and Write methods
}
```

## Conclusion

Methods are a fundamental feature in Go that enable:

1. **Behavior Association**:
   - Attach functions to types
   - Implement object-oriented patterns
   - Create expressive APIs

2. **Interface Implementation**:
   - Satisfy interface contracts
   - Enable polymorphism
   - Support dependency injection

3. **Code Organization**:
   - Group related functionality
   - Implement design patterns
   - Create reusable components

4. **Encapsulation**:
   - Control access to data
   - Implement business rules
   - Maintain invariants

The CRUD service example demonstrates how methods form the backbone of well-structured Go applications, providing clear separation of concerns, testability, and maintainability. Mastering methods is essential for building robust, idiomatic Go software.

By understanding and effectively using methods, you can:
- Create more organized and maintainable code
- Implement complex business logic in a structured way
- Build flexible and extensible systems
- Leverage Go's type system effectively
- Write code that's both efficient and expressive

Methods, combined with interfaces and structs, provide Go's unique approach to object-oriented programming, emphasizing composition, simplicity, and clarity over inheritance and complexity.