

# String Functions in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master Go's strings package - a comprehensive toolkit for text processing, manipulation, and analysis. Learn essential string functions for searching, replacing, splitting, joining, and transforming text data efficiently.

!!! tip "Key Points"
    - Go's strings package provides rich text manipulation capabilities
    - Functions handle Unicode correctly with rune-based operations
    - Use strings.Builder for efficient string concatenation
    - Regular expressions enable advanced pattern matching
    - Be mindful of performance with large text processing

## Understanding String Functions

Go's `strings` package provides a rich set of functions for string manipulation, essential for text processing, input validation, and data transformation.

!!! info "String Processing Categories"
    ```mermaid
    graph LR
        A[String Functions] --> B[Searching]
        A --> C[Replacing]
        A --> D[Splitting/Joining]
        A --> E[Case Conversion]
        A --> F[Trimming]
        A --> G[Comparison]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Basic String Manipulation

### 1. Searching Within Strings

!!! example "String Searching Functions"
    ```go title="string_searching.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        s := "Hello, World! Welcome to Go programming."
        
        // Contains - checks if substring exists
        fmt.Println(strings.Contains(s, "World"))    // true
        fmt.Println(strings.Contains(s, "Python"))  // false
        
        // ContainsAny - checks if any character in the set exists
        fmt.Println(strings.ContainsAny(s, "abc"))   // true (because of 'a' in "Welcome")
        fmt.Println(strings.ContainsAny(s, "xyz"))   // false
        
        // HasPrefix - checks if string starts with prefix
        fmt.Println(strings.HasPrefix(s, "Hello"))   // true
        fmt.Println(strings.HasPrefix(s, "World"))   // false
        
        // HasSuffix - checks if string ends with suffix
        fmt.Println(strings.HasSuffix(s, "programming.")) // true
        fmt.Println(strings.HasSuffix(s, "Go"))       // false
        
        // Index - returns first index of substring
        fmt.Println(strings.Index(s, "World"))       // 7
        fmt.Println(strings.Index(s, "Python"))      // -1 (not found)
        
        // LastIndex - returns last index of substring
        fmt.Println(strings.LastIndex(s, "o"))      // 29 (in "programming")
        
        // IndexAny - returns index of any character in the set
        fmt.Println(strings.IndexAny(s, "aeiou"))   // 1 (first 'e')
    }
    ```

### 2. Replacing Content

!!! example "String Replacement Functions"
    ```go title="string_replacement.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        s := "I like apples, apples are tasty."
        
        // Replace - replaces n occurrences
        fmt.Println(strings.Replace(s, "apples", "oranges", 1)) // "I like oranges, apples are tasty."
        fmt.Println(strings.Replace(s, "apples", "oranges", 2)) // "I like oranges, oranges are tasty."
        fmt.Println(strings.Replace(s, "apples", "oranges", -1)) // Replace all
        
        // ReplaceAll - replaces all occurrences (Go 1.12+)
        fmt.Println(strings.ReplaceAll(s, "apples", "oranges")) // "I like oranges, oranges are tasty."
        
        // Map - applies a function to each character
        rot13 := func(r rune) rune {
            switch {
            case r >= 'A' && r <= 'Z':
                return 'A' + (r-'A'+13)%26
            case r >= 'a' && r <= 'z':
                return 'a' + (r-'a'+13)%26
            default:
                return r
            }
        }
        fmt.Println(strings.Map(rot13, "Hello, World!")) // "Uryyb, Jbeyq!"
    }
    ```

### 3. Splitting and Joining

!!! example "String Splitting and Joining"
    ```go title="string_splitting_joining.go" linenums="1" hl_lines="8-25"
    package main

    import (
        "fmt"
        "strings"
        "unicode"
    )

    func main() {
        // Split - splits string by separator
        s := "a,b,c,d"
        parts := strings.Split(s, ",")
        fmt.Println(parts) // [a b c d]
        
        // SplitN - splits into at most n parts
        parts = strings.SplitN(s, ",", 3)
        fmt.Println(parts) // [a b c,d]
        
        // SplitAfter - includes separator in parts
        parts = strings.SplitAfter(s, ",")
        fmt.Println(parts) // [a, b, c, d]
        
        // Fields - splits by whitespace
        s2 := "  Go   is  awesome  "
        fields := strings.Fields(s2)
        fmt.Println(fields) // [Go is awesome]
        
        // FieldsFunc - splits using custom function
        // Split on any non-alphanumeric character
        fieldsFunc := strings.FieldsFunc(s2, func(r rune) bool {
            return !unicode.IsLetter(r) && !unicode.IsNumber(r)
        })
        fmt.Println(fieldsFunc) // [Go is awesome]
        
        // Join - concatenates slice with separator
        joined := strings.Join([]string{"Go", "is", "awesome"}, " ")
        fmt.Println(joined) // "Go is awesome"
    }
    ```

## Case Conversion

!!! example "Case Conversion Functions"
    ```go title="case_conversion.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "strings"
        "unicode"
    )

    func main() {
        s := "Hello, World! 123"
        
        // ToLower - converts to lowercase
        fmt.Println(strings.ToLower(s)) // "hello, world! 123"
        
        // ToUpper - converts to uppercase
        fmt.Println(strings.ToUpper(s)) // "HELLO, WORLD! 123"
        
        // ToTitle - converts to title case (each word starts with uppercase)
        fmt.Println(strings.ToTitle("hello world")) // "HELLO WORLD"
        
        // Title - converts to title case (first letter of each word uppercase)
        fmt.Println(strings.Title("hello world")) // "Hello World"
        
        // ToLowerSpecial - handles special cases (e.g., Turkish)
        fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, "İ")) // "i"
        
        // ToUpperSpecial - handles special cases
        fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, "i")) // "İ"
    }
    ```

## Trimming Strings

### 1. Removing Characters from Edges

!!! example "String Trimming Functions"
    ```go title="string_trimming.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "strings"
        "unicode"
    )

    func main() {
        s := "!!!Hello, World!!!"
        
        // Trim - removes characters from both ends
        fmt.Println(strings.Trim(s, "!")) // "Hello, World"
        
        // TrimLeft - removes characters from left
        fmt.Println(strings.TrimLeft(s, "!")) // "Hello, World!!!"
        
        // TrimRight - removes characters from right
        fmt.Println(strings.TrimRight(s, "!")) // "!!!Hello, World"
        
        // TrimSpace - removes whitespace from both ends
        s2 := "  Hello, World  "
        fmt.Println(strings.TrimSpace(s2)) // "Hello, World"
        
        // TrimPrefix - removes specific prefix
        fmt.Println(strings.TrimPrefix("Hello, World", "Hello")) // ", World"
        
        // TrimSuffix - removes specific suffix
        fmt.Println(strings.TrimSuffix("Hello, World", "World")) // "Hello, "
        
        // TrimFunc - removes characters that satisfy a function
        // Remove all non-alphanumeric characters from edges
        trimmed := strings.TrimFunc("!!Hello, World!!", func(r rune) bool {
            return !unicode.IsLetter(r) && !unicode.IsNumber(r)
        })
        fmt.Println(trimmed) // "Hello, World"
    }
    ```

## Comparison Functions

!!! example "String Comparison Functions"
    ```go title="string_comparison.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        // Compare - compares two strings lexicographically
        fmt.Println(strings.Compare("a", "b"))  // -1 (a < b)
        fmt.Println(strings.Compare("b", "a"))  // 1 (b > a)
        fmt.Println(strings.Compare("a", "a"))  // 0 (equal)
        
        // EqualFold - case-insensitive comparison
        fmt.Println(strings.EqualFold("Go", "go")) // true
        fmt.Println(strings.EqualFold("Go", "Java")) // false
        
        // Basic comparison operators (more idiomatic in Go)
        fmt.Println("Go" == "go")   // false (case-sensitive)
        fmt.Println("Go" == "Go")   // true
    }
    ```

## Substring Functions

!!! example "Substring Functions"
    ```go title="substring_functions.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        s := "Hello, World!"
        
        // Slice - extracts substring (using byte indices)
        // Note: Be careful with multi-byte characters!
        sub := s[0:5]
        fmt.Println(sub) // "Hello"
        
        // For safe substring extraction with runes, convert to []rune first
        runes := []rune(s)
        subRunes := string(runes[7:12])
        fmt.Println(subRunes) // "World"
        
        // Clone - creates a copy of the string (Go 1.18+)
        clone := strings.Clone(s)
        fmt.Println(clone == s) // true (but different underlying memory)
    }
    ```

## Counting and Repeating

!!! example "Counting and Repeating Functions"
    ```go title="counting_repeating.go" linums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        s := "banana"
        
        // Count - counts non-overlapping occurrences
        fmt.Println(strings.Count(s, "a"))  // 3
        fmt.Println(strings.Count(s, "na")) // 2
        fmt.Println(strings.Count(s, "x"))  // 0
        
        // Repeat - repeats string n times
        fmt.Println(strings.Repeat("Go", 3)) // "GoGoGo"
    }
    ```

## Efficient String Building

!!! warning "String Concatenation Performance"
    Avoid using `+` operator for repeated string concatenation in loops. Use `strings.Builder` for better performance.

!!! example "String Builder"
    ```go title="string_builder.go" linums="1" hl_lines="8-30"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        // Inefficient concatenation with +
        s1 := "Hello"
        s2 := "World"
        result := s1 + ", " + s2 + "!"
        fmt.Println(result) // "Hello, World!"
        
        // Efficient concatenation with strings.Builder
        var builder strings.Builder
        
        // WriteString - appends string
        builder.WriteString("Hello")
        builder.WriteString(", ")
        builder.WriteString("World")
        builder.WriteString("!")
        
        fmt.Println(builder.String()) // "Hello, World!"
        
        // Write - appends byte slice
        builder.Reset() // Clear the builder
        builder.Write([]byte{72, 101, 108, 108, 111}) // "Hello"
        fmt.Println(builder.String())
        
        // WriteByte - appends single byte
        builder.WriteByte(32) // space
        builder.WriteByte(87)  // 'W'
        fmt.Println(builder.String()) // "Hello W"
        
        // Grow - pre-allocates space
        builder.Grow(100) // Ensure capacity for 100 more bytes
        fmt.Printf("Builder length: %d, capacity: %d\n", builder.Len(), builder.Cap())
    }
    ```

## Real-World Example: Text Processing Utility

Let's build a comprehensive text processing utility that demonstrates various string functions:

!!! example "Text Processing Utility"
    ```go title="text_processor.go" linums="1" hl_lines="8-80"
    package main

    import (
        "bufio"
        "fmt"
        "os"
        "regexp"
        "sort"
        "strings"
        "unicode"
    )

    // TextProcessor provides various text processing functions
    type TextProcessor struct {
        input string
    }

    func NewTextProcessor(input string) *TextProcessor {
        return &TextProcessor{input: input}
    }

    // WordCount returns the number of words in the text
    func (tp *TextProcessor) WordCount() int {
        return len(strings.Fields(tp.input))
    }

    // CharacterCount returns the number of characters (runes)
    func (tp *TextProcessor) CharacterCount() int {
        return len([]rune(tp.input))
    }

    // LineCount returns the number of lines
    func (tp *TextProcessor) LineCount() int {
        return len(strings.Split(tp.input, "\n"))
    }

    // UniqueWords returns a sorted slice of unique words
    func (tp *TextProcessor) UniqueWords() []string {
        words := strings.Fields(tp.input)
        wordMap := make(map[string]bool)
        
        for _, word := range words {
            // Normalize word (lowercase, remove punctuation)
            normalized := strings.ToLower(word)
            normalized = strings.TrimFunc(normalized, func(r rune) bool {
                return !unicode.IsLetter(r) && !unicode.IsNumber(r)
            })
            if normalized != "" {
                wordMap[normalized] = true
            }
        }
        
        unique := make([]string, 0, len(wordMap))
        for word := range wordMap {
            unique = append(unique, word)
        }
        
        sort.Strings(unique)
        return unique
    }

    // FindSentences splits text into sentences
    func (tp *TextProcessor) FindSentences() []string {
        // Simple sentence splitting on .!?
        re := regexp.MustCompile(`[.!?]+[\s]*`)
        sentences := re.Split(tp.input, -1)
        
        var result []string
        for _, sentence := range sentences {
            sentence = strings.TrimSpace(sentence)
            if sentence != "" {
                result = append(result, sentence)
            }
        }
        
        return result
    }

    // ReplaceWords replaces all occurrences of oldWord with newWord
    func (tp *TextProcessor) ReplaceWords(oldWord, newWord string) string {
        return strings.ReplaceAll(tp.input, oldWord, newWord)
    }

    // ToTitleCase converts text to title case
    func (tp *TextProcessor) ToTitleCase() string {
        words := strings.Fields(tp.input)
        for i, word := range words {
            if len(word) > 0 {
                words[i] = strings.ToUpper(string(word[0])) + strings.ToLower(word[1:])
            }
        }
        return strings.Join(words, " ")
    }

    // RemoveExtraWhitespace normalizes whitespace
    func (tp *TextProcessor) RemoveExtraWhitespace() string {
        // Replace multiple spaces with single space
        re := regexp.MustCompile(`\s+`)
        result := re.ReplaceAllString(tp.input, " ")
        
        // Trim leading/trailing whitespace
        return strings.TrimSpace(result)
    }

    // FindEmailAddresses extracts all email addresses
    func (tp *TextProcessor) FindEmailAddresses() []string {
        // Simple email regex (not production-quality)
        re := regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`)
        return re.FindAllString(tp.input, -1)
    }

    // GenerateSummary creates a summary of the first n words
    func (tp *TextProcessor) GenerateSummary(wordCount int) string {
        words := strings.Fields(tp.input)
        if len(words) <= wordCount {
            return tp.input
        }
        
        summary := strings.Join(words[:wordCount], " ")
        return summary + "..."
    }

    func main() {
        // Sample text
        sampleText := `Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
Go is amazing! I love working with Go. It's fast and efficient.
The Go community is great. For more information, visit golang.org or contact us at info@golang.org.`

        processor := NewTextProcessor(sampleText)

        // Basic statistics
        fmt.Println("=== Text Analysis ===")
        fmt.Printf("Word count: %d\n", processor.WordCount())
        fmt.Printf("Character count: %d\n", processor.CharacterCount())
        fmt.Printf("Line count: %d\n", processor.LineCount())

        // Unique words
        fmt.Println("\n=== Unique Words ===")
        uniqueWords := processor.UniqueWords()
        fmt.Printf("Found %d unique words\n", len(uniqueWords))

        // Sentences
        fmt.Println("\n=== Sentences ===")
        sentences := processor.FindSentences()
        for i, sentence := range sentences {
            fmt.Printf("%d. %s\n", i+1, sentence)
        }

        // Email addresses
        fmt.Println("\n=== Email Addresses ===")
        emails := processor.FindEmailAddresses()
        for _, email := range emails {
            fmt.Printf("- %s\n", email)
        }

        // Text transformations
        fmt.Println("\n=== Text Transformations ===")
        fmt.Println("Title Case:", processor.ToTitleCase())
        fmt.Println("Normalized Whitespace:", processor.RemoveExtraWhitespace())
    }
    ```

### How This Example Demonstrates String Functions:

1. **Basic String Operations**:
   - `strings.Fields()` for word splitting
   - `strings.ToLower()` for case normalization
   - `strings.TrimFunc()` for punctuation removal
   - `strings.ReplaceAll()` for word replacement

2. **Advanced Processing**:
   - Regular expressions for pattern matching
   - `strings.TrimSpace()` for whitespace normalization
   - `strings.Join()` for string concatenation
   - `strings.Count()` for word frequency analysis

3. **Text Analysis**:
   - Sentence splitting with custom logic
   - Email extraction with regex
   - Summary generation

4. **Efficient Processing**:
   - Using maps for unique word tracking
   - Sorting results for consistent output
   - Handling Unicode characters properly

## Best Practices

!!! tip "Function Selection"
    Choose the right function for each task to ensure readability and performance.

!!! example "Function Selection"
    ```go title="function_selection.go" linums="1" hl_lines="8-14"
    package main

    import (
        "strings"
    )

    func main() {
        // Good - use Contains for simple checks
        email := "user@example.com"
        if strings.Contains(email, "@") {
            // Valid email format
        }

        // Bad - using Index for simple existence check
        if strings.Index(email, "@") != -1 {
            // Less readable
        }
    }
    ```

!!! warning "Unicode Handling"
    Be careful with Unicode characters when using byte-based operations.

!!! example "Unicode Safety"
    ```go title="unicode_safety.go" linums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
    )

    func main() {
        // Bad - byte-based slicing can break multi-byte characters
        s := "Hello, 世界"
        sub := s[7:10] // Might break the Chinese character

        // Good - use rune-based slicing
        runes := []rune(s)
        sub = string(runes[7:9]) // Safe
        fmt.Println(sub)
    }
    ```

!!! tip "Efficient Concatenation"
    Use `strings.Builder` for efficient string concatenation, especially in loops.

!!! example "Efficient Concatenation"
    ```go title="efficient_concatenation.go" linums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        // Bad - creates many temporary strings
        var result string
        for i := 0; i < 1000; i++ {
            result += "x" // Allocates new string each time
        }

        // Good - efficient with Builder
        var builder strings.Builder
        for i := 0; i < 1000; i++ {
            builder.WriteByte('x')
        }
        result = builder.String()
        fmt.Printf("Length: %d\n", len(result))
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Searching**: Use `Contains`, `HasPrefix`, `HasSuffix`, `Index` for finding text
    - **Replacing**: Use `Replace`, `ReplaceAll`, `Map` for text substitution
    - **Splitting/Joining**: Use `Split`, `Fields`, `Join` for text segmentation
    - **Case Conversion**: Use `ToLower`, `ToUpper`, `Title` for changing case
    - **Trimming**: Use `Trim`, `TrimSpace`, `TrimFunc` for edge processing
    - **Building**: Use `strings.Builder` for efficient concatenation
    - **Unicode**: Always consider rune-based operations for multi-byte characters
    - **Performance**: Pre-compile regexes and use builders for large operations

!!! quote "Remember"
    "Go's strings package provides a comprehensive set of functions for text processing. By understanding which function to use for each task and being mindful of Unicode handling and performance, you can write efficient, readable code that handles text processing tasks correctly. Always prefer the specialized string functions over manual byte manipulation for better safety and clarity."