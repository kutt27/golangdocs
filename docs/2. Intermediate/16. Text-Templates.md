

# Text Templates in Go: A Comprehensive Guide

## Introduction to Text Templates
Go's `text/template` package provides a powerful templating system for generating textual output. Templates allow you to define reusable text patterns with placeholders that get filled in with data at runtime. This is particularly useful for generating HTML, configuration files, emails, code, and any other text-based output.

### Why Use Templates?
- **Separation of Concerns**: Keep presentation logic separate from business logic
- **Reusability**: Define templates once and use them with different data
- **Maintainability**: Easier to update presentation without changing code
- **Safety**: Automatic escaping and structured data handling

## Basic Template Syntax

### 1. Actions
Templates use double curly braces `{{` and `}}` to delimit actions:

```go
package main

import (
	"os"
	"text/template"
)

func main() {
	// Simple template with a variable
	tmpl := `Hello, {{.Name}}!`
	
	// Data to populate the template
	data := struct {
		Name string
	}{
		Name: "Alice",
	}
	
	// Parse and execute the template
	t := template.Must(template.New("greeting").Parse(tmpl))
	t.Execute(os.Stdout, data) // Output: Hello, Alice!
}
```

### 2. Variables and Pipelines
- `{{.}}` refers to the current data object
- `{{.Field}}` accesses a field of a struct
- `{{.Method}}` calls a method
- Pipelines use `|` to chain operations

```go
func main() {
	tmpl := `{{.Name}} is {{.Age}} years old. In 5 years: {{add .Age 5}}`
	
	data := struct {
		Name string
		Age  int
	}{
		Name: "Bob",
		Age:  30,
	}
	
	// Create a template with a custom function
	funcMap := template.FuncMap{
		"add": func(a, b int) int { return a + b },
	}
	
	t := template.Must(template.New("age").Funcs(funcMap).Parse(tmpl))
	t.Execute(os.Stdout, data)
	// Output: Bob is 30 years old. In 5 years: 35
}
```

## Template Creation and Execution

### 1. Parsing Templates
```go
// Parse a single template
t1, err := template.New("template1").Parse("Hello, {{.}}")
if err != nil {
    panic(err)
}

// Parse multiple templates
t2, err := template.ParseFiles("header.tmpl", "footer.tmpl")
if err != nil {
    panic(err)
}

// Parse from string
t3 := template.Must(template.New("inline").Parse("Value: {{.Value}}"))
```

### 2. Executing Templates
```go
// Execute to io.Writer
err := t.Execute(os.Stdout, data)
if err != nil {
    panic(err)
}

// Execute to string
var buf bytes.Buffer
err = t.Execute(&buf, data)
result := buf.String()

// Execute with specific template name (for multiple templates)
err = t.ExecuteTemplate(os.Stdout, "header", data)
```

## Data Structures for Templates

### 1. Using Structs
```go
type User struct {
    Name    string
    Age     int
    Email   string
    Active  bool
}

func main() {
    tmpl := `
User: {{.Name}}
Age: {{.Age}}
Email: {{.Email}}
Status: {{if .Active}}Active{{else}}Inactive{{end}}
`
    
    user := User{
        Name:   "Charlie",
        Age:    25,
        Email:  "charlie@example.com",
        Active: true,
    }
    
    t := template.Must(template.New("user").Parse(tmpl))
    t.Execute(os.Stdout, user)
}
```

### 2. Using Maps
```go
func main() {
    tmpl := `{{.name}} lives in {{.city}}`
    
    data := map[string]string{
        "name": "Diana",
        "city": "New York",
    }
    
    t := template.Must(template.New("location").Parse(tmpl))
    t.Execute(os.Stdout, data) // Diana lives in New York
}
```

### 3. Using Slices
```go
func main() {
    tmpl := `{{range .}}{{.}} {{end}}`
    
    items := []string{"apple", "banana", "cherry"}
    
    t := template.Must(template.New("list").Parse(tmpl))
    t.Execute(os.Stdout, items) // apple banana cherry 
}
```

## Control Structures

### 1. Conditionals
```go
func main() {
    tmpl := `
{{if .Admin}}
    Welcome, Administrator!
{{else if .User}}
    Welcome, {{.User}}!
{{else}}
    Please log in.
{{end}}
`
    
    data := map[string]interface{}{
        "Admin": false,
        "User":  "Alice",
    }
    
    t := template.Must(template.New("auth").Parse(tmpl))
    t.Execute(os.Stdout, data)
    // Output:
    // Welcome, Alice!
}
```

### 2. Loops with `range`
```go
func main() {
    tmpl := `
Users:
{{range .}}
    - {{.Name}} ({{.Age}})
{{end}}
`
    
    type User struct {
        Name string
        Age  int
    }
    
    users := []User{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
    }
    
    t := template.Must(template.New("users").Parse(tmpl))
    t.Execute(os.Stdout, users)
}
```

### 3. `with` for Context
```go
func main() {
    tmpl := `
{{with .User}}
    Name: {{.Name}}
    Email: {{.Email}}
{{end}}
`
    
    data := struct {
        User *struct {
            Name  string
            Email string
        }
    }{
        User: &struct {
            Name  string
            Email string
        }{
            Name:  "David",
            Email: "david@example.com",
        },
    }
    
    t := template.Must(template.New("with").Parse(tmpl))
    t.Execute(os.Stdout, data)
}
```

## Template Functions

### 1. Built-in Functions
```go
func main() {
    tmpl := `
String: {{.Text | upper}}
Length: {{.Text | len}}
Word count: {{.Text | wordCount}}
HTML escaped: {{.HTML | html}}
URL escaped: {{.URL | urlquery}}
`
    
    funcMap := template.FuncMap{
        "upper":     strings.ToUpper,
        "wordCount": func(s string) int { return len(strings.Fields(s)) },
    }
    
    data := struct {
        Text string
        HTML string
        URL  string
    }{
        Text: "hello world",
        HTML: "<script>alert('xss')</script>",
        URL:  "search?q=go templates",
    }
    
    t := template.Must(template.New("funcs").Funcs(funcMap).Parse(tmpl))
    t.Execute(os.Stdout, data)
}
```

### 2. Custom Functions
```go
// Define custom functions
func formatPrice(price float64) string {
    return fmt.Sprintf("$%.2f", price)
}

func formatDate(t time.Time) string {
    return t.Format("2006-01-02")
}

func main() {
    funcMap := template.FuncMap{
        "formatPrice": formatPrice,
        "formatDate":  formatDate,
    }
    
    tmpl := `
Product: {{.Name}}
Price: {{.Price | formatPrice}}
Created: {{.Created | formatDate}}
`
    
    data := struct {
        Name    string
        Price   float64
        Created time.Time
    }{
        Name:    "Laptop",
        Price:   999.99,
        Created: time.Now(),
    }
    
    t := template.Must(template.New("product").Funcs(funcMap).Parse(tmpl))
    t.Execute(os.Stdout, data)
}
```

## Template Composition

### 1. Template Inheritance with `block` and `define`
```go
// base.tmpl
{{define "base"}}<!DOCTYPE html>
<html>
<head>
    <title>{{block "title" .}}Default Title{{end}}</title>
</head>
<body>
    {{block "content" .}}{{end}}
</body>
</html>
{{end}}

// page.tmpl
{{define "title"}}Home Page{{end}}
{{define "content"}}<h1>Welcome!</h1>{{end}}
```

### 2. Template Composition in Code
```go
func main() {
    // Parse base template
    base := `{{define "base"}}Base: {{block "content" .}}Default{{end}}{{end}}`
    t := template.Must(template.New("base").Parse(base))
    
    // Add child template
    child := `{{define "content"}}Child Content{{end}}`
    t = template.Must(t.Parse(child))
    
    // Execute base template
    t.ExecuteTemplate(os.Stdout, "base", nil)
    // Output: Base: Child Content
}
```

## Error Handling

### 1. Common Template Errors
```go
func main() {
    // Missing field in template
    tmpl := `Hello, {{.NonExistentField}}!`
    t, err := template.New("error").Parse(tmpl)
    if err != nil {
        fmt.Println("Parse error:", err)
        return
    }
    
    // This will execute without error but output "Hello, <no value>!"
    err = t.Execute(os.Stdout, struct{}{})
    if err != nil {
        fmt.Println("Execute error:", err)
    }
}
```

### 2. Safe Template Execution
```go
func safeExecute(tmplStr string, data interface{}) error {
    t, err := template.New("safe").Parse(tmplStr)
    if err != nil {
        return fmt.Errorf("template parse error: %w", err)
    }
    
    if err := t.Execute(os.Stdout, data); err != nil {
        return fmt.Errorf("template execute error: %w", err)
    }
    
    return nil
}

func main() {
    err := safeExecute("Hello, {{.Name}}!", map[string]string{"Name": "Eve"})
    if err != nil {
        fmt.Println("Error:", err)
    }
}
```

## Real-World Example: HTML Report Generator

Let's build a comprehensive HTML report generator using templates:

```go
package main

import (
	"html/template"
	"os"
	"time"
)

// Data structures
type Report struct {
	Title       string
	GeneratedAt time.Time
	Summary     Summary
	Sections    []Section
}

type Summary struct {
	TotalItems   int
	SuccessCount int
	ErrorCount   int
}

type Section struct {
	Title   string
	Items   []Item
}

type Item struct {
	ID          string
	Name        string
	Value       float64
	Status      string
	Description string
}

// Template definitions
const baseTemplate = `<!DOCTYPE html>
<html>
<head>
    <title>{{.Title}} - Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { border-bottom: 2px solid #333; padding-bottom: 10px; }
        .summary { background: #f5f5f5; padding: 15px; margin: 20px 0; }
        .section { margin: 30px 0; }
        .section h2 { color: #333; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f2f2f2; }
        .success { color: green; }
        .error { color: red; }
        .footer { margin-top: 40px; font-size: 0.8em; color: #666; }
    </style>
</head>
<body>
    {{template "content" .}}
    <div class="footer">
        Generated on {{.GeneratedAt.Format "2006-01-02 15:04:05"}}
    </div>
</body>
</html>`

const contentTemplate = `{{define "content"}}
<div class="header">
    <h1>{{.Title}}</h1>
</div>

<div class="summary">
    <h2>Summary</h2>
    <p>Total Items: {{.Summary.TotalItems}}</p>
    <p>Successful: <span class="success">{{.Summary.SuccessCount}}</span></p>
    <p>Errors: <span class="error">{{.Summary.ErrorCount}}</span></p>
</div>

{{range .Sections}}
<div class="section">
    <h2>{{.Title}}</h2>
    <table>
        <thead>
            <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Value</th>
                <th>Status</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            {{range .Items}}
            <tr>
                <td>{{.ID}}</td>
                <td>{{.Name}}</td>
                <td>${{formatCurrency .Value}}</td>
                <td class="{{if eq .Status "Success"}}success{{else}}error{{end}}">
                    {{.Status}}
                </td>
                <td>{{.Description}}</td>
            </tr>
            {{end}}
        </tbody>
    </table>
</div>
{{end}}
{{end}}`

// Custom functions
var funcMap = template.FuncMap{
	"formatCurrency": func(value float64) string {
		return fmt.Sprintf("%.2f", value)
	},
	"eq": func(a, b interface{}) bool {
		return a == b
	},
}

func main() {
	// Create template
	t := template.Must(template.New("base").Funcs(funcMap).Parse(baseTemplate))
	t = template.Must(t.Parse(contentTemplate))
	
	// Sample data
	report := Report{
		Title:       "Monthly Sales Report",
		GeneratedAt: time.Now(),
		Summary: Summary{
			TotalItems:   10,
			SuccessCount: 8,
			ErrorCount:   2,
		},
		Sections: []Section{
			{
				Title: "Electronics",
				Items: []Item{
					{"E001", "Laptop", 999.99, "Success", "High-performance laptop"},
					{"E002", "Mouse", 25.50, "Success", "Wireless mouse"},
					{"E003", "Keyboard", 45.00, "Error", "Out of stock"},
				},
			},
			{
				Title: "Clothing",
				Items: []Item{
					{"C001", "T-Shirt", 19.99, "Success", "Cotton t-shirt"},
					{"C002", "Jeans", 49.99, "Success", "Denim jeans"},
					{"C003", "Jacket", 89.99, "Error", "Size not available"},
				},
			},
		},
	}
	
	// Execute template
	file, err := os.Create("report.html")
	if err != nil {
		panic(err)
	}
	defer file.Close()
	
	err = t.Execute(file, report)
	if err != nil {
		panic(err)
	}
	
	println("Report generated successfully: report.html")
}
```

### How This Example Works:

1. **Template Structure**:
   - Base template with HTML structure and CSS
   - Content template with report-specific markup
   - Template inheritance using `define` and `template`

2. **Data Organization**:
   - Structured data with nested types
   - Clear separation between different report sections
   - Consistent data model for all items

3. **Custom Functions**:
   - `formatCurrency` for monetary values
   - `eq` for equality comparison in templates

4. **Styling and Presentation**:
   - Embedded CSS for consistent styling
   - Conditional coloring based on status
   - Responsive table layout

### Real-World Applications:

1. **Web Applications**:
   - Dynamic HTML generation
   - Email templates
   - PDF report generation

2. **Configuration Management**:
   - Generate config files from templates
   - Environment-specific configurations
   - Infrastructure as Code templates

3. **Code Generation**:
   - Boilerplate code generation
   - API client generation
   - Database model generation

4. **Documentation**:
   - API documentation
   - User guides
   - Release notes

## Best Practices

### 1. Template Organization
- Keep templates separate from application logic
- Use a consistent naming convention
- Organize templates in a directory structure

### 2. Data Design
- Use simple, flat data structures when possible
- Avoid complex logic in templates
- Prepare data before passing to templates

### 3. Security
- Always use automatic escaping for HTML
- Validate data before template execution
- Be careful with user-generated content

### 4. Performance
- Parse templates once, execute many times
- Cache compiled templates
- Avoid heavy computation in template functions

### 5. Error Handling
- Check template parsing errors
- Handle execution errors gracefully
- Provide meaningful error messages

## Advanced Techniques

### 1. Template Reuse with Partial Templates
```go
// Define a partial template
const partial = `{{define "userCard"}}
<div class="user-card">
    <h3>{{.Name}}</h3>
    <p>{{.Email}}</p>
</div>
{{end}}`

// Use in multiple templates
const page1 = `{{template "userCard" .User}}`
const page2 = `Users: {{range .Users}}{{template "userCard" .}}{{end}}`
```

### 2. Dynamic Template Loading
```go
func loadTemplates(pattern string) (*template.Template, error) {
    tmpl := template.New("main").Funcs(funcMap)
    
    files, err := filepath.Glob(pattern)
    if err != nil {
        return nil, err
    }
    
    for _, file := range files {
        content, err := os.ReadFile(file)
        if err != nil {
            return nil, err
        }
        
        name := filepath.Base(file)
        _, err = tmpl.New(name).Parse(string(content))
        if err != nil {
            return nil, err
        }
    }
    
    return tmpl, nil
}
```

### 3. Template Testing
```go
func TestTemplate(t *testing.T) {
    tmpl := `Hello, {{.Name}}!`
    data := struct{ Name string }{Name: "Test"}
    
    result, err := executeTemplate(tmpl, data)
    if err != nil {
        t.Fatal(err)
    }
    
    expected := "Hello, Test!"
    if result != expected {
        t.Errorf("Expected %q, got %q", expected, result)
    }
}

func executeTemplate(tmplStr string, data interface{}) (string, error) {
    t := template.Must(template.New("test").Parse(tmplStr))
    var buf bytes.Buffer
    err := t.Execute(&buf, data)
    return buf.String(), err
}
```

## Conclusion

Go's `text/template` package provides a powerful and flexible system for generating textual output. By mastering templates, you can:

1. **Separate Concerns**:
   - Keep presentation logic separate from business logic
   - Maintain clean, organized code
   - Make applications easier to maintain

2. **Create Reusable Components**:
   - Define templates once, use everywhere
   - Build template libraries for common patterns
   - Share templates across projects

3. **Generate Dynamic Content**:
   - Create personalized emails
   - Generate configuration files
   - Build dynamic web pages

4. **Ensure Consistency**:
   - Maintain consistent formatting
   - Apply branding automatically
   - Reduce human error in output generation

The HTML report generator example demonstrates how templates can be used to create complex, professional-looking documents with minimal code. By combining templates with Go's strong typing and performance characteristics, you can build robust applications that generate high-quality textual output efficiently.

Key takeaways:
1. **Start simple** with basic templates and gradually add complexity
2. **Organize templates** logically for maintainability
3. **Use custom functions** to extend template capabilities
4. **Handle errors** properly at both parse and execute time
5. **Test templates** to ensure they work as expected

Templates are a fundamental tool in the Go ecosystem, essential for any application that needs to generate text-based output. Mastering them will significantly improve your ability to build flexible, maintainable Go applications.