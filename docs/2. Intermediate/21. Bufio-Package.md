

{# The `bufio` Package in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master Go's bufio package for efficient buffered I/O operations. Learn to create buffered readers and writers, use Scanner for tokenization, implement custom split functions, and build high-performance file processing applications that minimize system calls and optimize I/O operations.

!!! tip "Key Points"
    - bufio implements buffered I/O by wrapping io.Reader and io.Writer objects
    - Use bufio.Reader for efficient reading with methods like ReadString and ReadLine
    - bufio.Scanner provides convenient tokenization with built-in split functions
    - bufio.Writer improves write performance by buffering operations
    - Always flush buffered writers to ensure data is written
    - Essential for processing large files, logs, and data streams efficiently

## Understanding Buffered I/O

The `bufio` package in Go implements buffered I/O, wrapping `io.Reader` and `io.Writer` objects to create buffered readers and writers. Buffering reduces the number of system calls and improves performance, especially when dealing with small, frequent I/O operations.

!!! info "Buffered I/O Components"
    ```mermaid
    graph LR
        A[Buffered I/O] --> B[bufio.Reader]
        A --> C[bufio.Scanner]
        A --> D[bufio.Writer]
        B --> E[ReadString]
        B --> F[ReadLine]
        B --> G[ReadBytes]
        C --> H[ScanLines]
        C --> I[ScanWords]
        C --> J[Custom Split]
        D --> K[WriteString]
        D --> L[WriteBytes]
        D --> M[Flush]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Why Use Buffered I/O?
- **Performance**: Reduces system call overhead by reading/writing in chunks
- **Convenience**: Provides helpful methods for common operations like reading lines
- **Efficiency**: Minimizes disk/network I/O operations
- **Flexibility**: Works with any `io.Reader` or `io.Writer`

## Buffered Readers (`bufio.Reader`)

### 1. Creating a Buffered Reader

!!! example "Creating a Buffered Reader"
    ```go title="buffered_reader.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "bufio"
        "fmt"
        "io"
        "os"
        "strings"
    )

    func main() {
        // Create a buffered reader from a string
        reader := bufio.NewReader(strings.NewReader("Hello, World!\nThis is a test.\n"))
        
        // Read the entire content
        content, err := io.ReadAll(reader)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Println("Content:", string(content))
    }
    ```

### 2. Reading by Lines

!!! example "Reading by Lines"
    ```go title="reading_lines.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "bufio"
        "fmt"
        "io"
        "strings"
    )

    func main() {
        data := "First line\nSecond line\nThird line\n"
        reader := bufio.NewReader(strings.NewReader(data))
        
        for {
            line, err := reader.ReadString('\n')
            if err != nil {
                if err == io.EOF {
                    break
                }
                fmt.Println("Error:", err)
                return
            }
            fmt.Printf("Line: %q\n", strings.TrimSpace(line))
        }
    }
    ```

### 3. Reading Bytes

!!! example "Reading Bytes"
    ```go title="reading_bytes.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "bufio"
        "fmt"
        "strings"
    )

    func main() {
        data := "Hello, World!"
        reader := bufio.NewReader(strings.NewReader(data))
        
        // Read first 5 bytes
        buf := make([]byte, 5)
        n, err := reader.Read(buf)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Read %d bytes: %q\n", n, buf)
        
        // Peek at next bytes without advancing
        peeked, err := reader.Peek(3)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Peeked: %q\n", peeked)
    }
    ```

### 4. Using `ReadLine` (Deprecated but Still Used)

!!! example "Using ReadLine"
    ```go title="readline_example.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "bufio"
        "fmt"
        "io"
        "strings"
    )

    func main() {
        data := "Line 1\nLine 2\nLine 3\n"
        reader := bufio.NewReader(strings.NewReader(data))
        
        for {
            line, isPrefix, err := reader.ReadLine()
            if err != nil {
                if err == io.EOF {
                    break
                }
                fmt.Println("Error:", err)
                return
            }
            
            fmt.Printf("Line: %q (isPrefix: %v)\n", line, isPrefix)
        }
    }
    ```

## The `bufio.Scanner` Type

### 1. Basic Scanning

!!! example "Basic Scanning"
    ```go title="basic_scanning.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "bufio"
        "fmt"
        "strings"
    )

    func main() {
        data := "word1 word2 word3\nline2 word4"
        scanner := bufio.NewScanner(strings.NewReader(data))
        
        // Scan line by line (default)
        for scanner.Scan() {
            fmt.Println("Line:", scanner.Text())
        }
        
        if err := scanner.Err(); err != nil {
            fmt.Println("Error:", err)
        }
    }
    ```

### 2. Custom Split Functions

!!! example "Custom Split Functions"
    ```go title="custom_split.go" linenums="1" hl_lines="8-40"
    package main

    import (
        "bufio"
        "fmt"
        "strings"
    )

    func main() {
        data := "apple,banana,cherry,date"
        scanner := bufio.NewScanner(strings.NewReader(data))
        
        // Split by commas
        scanner.Split(bufio.ScanWords) // Default is ScanLines
        
        // Custom split function
        splitFunc := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
            // Skip leading spaces
            start := 0
            for ; start < len(data); start++ {
                if data[start] != ',' {
                    break
                }
            }
            
            // Scan until comma or EOF
            for i := start; i < len(data); i++ {
                if data[i] == ',' {
                    return i + 1, data[start:i], nil
                }
            }
            
            // If we're at EOF, we have a final, non-terminated line
            if atEOF && len(data) > start {
                return len(data), data[start:], nil
            }
            
            // Request more data
            return start, nil, nil
        }
        
        scanner.Split(splitFunc)
        
        for scanner.Scan() {
            fmt.Println("Token:", scanner.Text())
        }
    }
    ```

### 3. Built-in Split Functions

!!! example "Built-in Split Functions"
    ```go title="builtin_splits.go" linenums="1" hl_lines="8-42"
    package main

    import (
        "bufio"
        "fmt"
        "strings"
    )

    func main() {
        data := "word1 word2\nword3 word4"
        
        // ScanLines (default)
        fmt.Println("ScanLines:")
        scanner := bufio.NewScanner(strings.NewReader(data))
        scanner.Split(bufio.ScanLines)
        for scanner.Scan() {
            fmt.Println(scanner.Text())
        }
        
        // ScanWords
        fmt.Println("\nScanWords:")
        scanner = bufio.NewScanner(strings.NewReader(data))
        scanner.Split(bufio.ScanWords)
        for scanner.Scan() {
            fmt.Println(scanner.Text())
        }
        
        // ScanBytes
        fmt.Println("\nScanBytes:")
        scanner = bufio.NewScanner(strings.NewReader(data))
        scanner.Split(bufio.ScanBytes)
        for scanner.Scan() {
            fmt.Printf("%q ", scanner.Text())
        }
        fmt.Println()
        
        // ScanRunes
        fmt.Println("\nScanRunes:")
        scanner = bufio.NewScanner(strings.NewReader(data))
        scanner.Split(bufio.ScanRunes)
        for scanner.Scan() {
            fmt.Printf("%q ", scanner.Text())
        }
        fmt.Println()
    }
    ```

## Buffered Writers (`bufio.Writer`)

### 1. Creating a Buffered Writer

!!! example "Creating a Buffered Writer"
    ```go title="buffered_writer.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "bufio"
        "fmt"
        "os"
    )

    func main() {
        // Create a buffered writer that writes to os.Stdout
        writer := bufio.NewWriter(os.Stdout)
        
        // Write data
        _, err := writer.WriteString("Hello, Buffered World!\n")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        
        // Remember to flush!
        err = writer.Flush()
        if err != nil {
            fmt.Println("Error flushing:", err)
        }
    }
    ```

### 2. Writing with Buffering

!!! example "Writing with Buffering"
    ```go title="buffered_writing.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "bufio"
        "bytes"
        "fmt"
    )

    func main() {
        var buf bytes.Buffer
        writer := bufio.NewWriter(&buf)
        
        // Write multiple times
        for i := 0; i < 5; i++ {
            _, err := writer.WriteString(fmt.Sprintf("Line %d\n", i+1))
            if err != nil {
                fmt.Println("Error:", err)
                return
            }
            // Data is buffered, not yet written to buf
        }
        
        // Flush to write all buffered data
        err := writer.Flush()
        if err != nil {
            fmt.Println("Error flushing:", err)
            return
        }
        
        fmt.Println("Buffer content:")
        fmt.Print(buf.String())
    }
    ```

### 3. Available and Size

!!! example "Available and Size"
    ```go title="available_size.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "bufio"
        "fmt"
        "os"
    )

    func main() {
        writer := bufio.NewWriterSize(os.Stdout, 32) // 32-byte buffer
        
        // Check available buffer space
        fmt.Printf("Available: %d bytes\n", writer.Available())
        
        // Write some data
        writer.WriteString("Hello")
        fmt.Printf("Available after write: %d bytes\n", writer.Available())
        
        // Check buffer size
        fmt.Printf("Buffer size: %d bytes\n", writer.Size())
        
        // Flush
        writer.Flush()
    }
    ```

## Real-World Example: Log File Processor

Let's build a comprehensive log file processor that demonstrates various `bufio` features:

!!! example "Log File Processor"
    ```go title="log_processor.go" linenums="1" hl_lines="8-60"
    package main

    import (
        "bufio"
        "fmt"
        "io"
        "os"
        "regexp"
        "strings"
        "time"
    )

    // LogEntry represents a parsed log entry
    type LogEntry struct {
        Timestamp time.Time
        Level     string
        Message   string
        Source    string
    }

    // LogProcessor handles log file processing
    type LogProcessor struct {
        inputFile  string
        outputFile string
        filter     *regexp.Regexp
        stats      struct {
            TotalLines   int
            ErrorLines   int
            WarningLines int
            InfoLines    int
        }
    }

    func NewLogProcessor(input, output string, filterPattern string) (*LogProcessor, error) {
        lp := &LogProcessor{
            inputFile:  input,
            outputFile: output,
        }
        
        if filterPattern != "" {
            var err error
            lp.filter, err = regexp.Compile(filterPattern)
            if err != nil {
                return nil, fmt.Errorf("invalid filter pattern: %w", err)
            }
        }
        
        return lp, nil
    }

    // ProcessFile reads the input log file, processes it, and writes to output
    func (lp *LogProcessor) ProcessFile() error {
        // Open input file
        inputFile, err := os.Open(lp.inputFile)
        if err != nil {
            return fmt.Errorf("failed to open input file: %w", err)
        }
        defer inputFile.Close()
        
        // Create output file
        outputFile, err := os.Create(lp.outputFile)
        if err != nil {
            return fmt.Errorf("failed to create output file: %w", err)
        }
        defer outputFile.Close()
        
        // Create buffered reader and writer
        reader := bufio.NewReader(inputFile)
        writer := bufio.NewWriter(outputFile)
        defer writer.Flush()
        
        // Process line by line
        lineNumber := 0
        for {
            lineNumber++
            line, err := reader.ReadString('\n')
            if err != nil {
                if err == io.EOF {
                    break
                }
                return fmt.Errorf("error reading line %d: %w", lineNumber, err)
            }
            
            // Parse log entry
            entry, err := lp.parseLogEntry(line, lineNumber)
            if err != nil {
                fmt.Fprintf(os.Stderr, "Error parsing line %d: %v\n", lineNumber, err)
                continue
            }
            
            // Apply filter if specified
            if lp.filter != nil && !lp.filter.MatchString(entry.Message) {
                continue
            }
            
            // Update statistics
            lp.updateStats(entry)
            
            // Write processed entry
            if err := lp.writeLogEntry(writer, entry); err != nil {
                return fmt.Errorf("error writing line %d: %w", lineNumber, err)
            }
        }
        
        // Write summary statistics
        if err := lp.writeSummary(writer); err != nil {
            return fmt.Errorf("error writing summary: %w", err)
        }
        
        fmt.Printf("Processing complete. Processed %d lines.\n", lp.stats.TotalLines)
        return nil
    }

    // parseLogEntry parses a single log line
    func (lp *LogProcessor) parseLogEntry(line string, lineNumber int) (*LogEntry, error) {
        line = strings.TrimSpace(line)
        if line == "" {
            return nil, fmt.Errorf("empty line")
        }
        
        // Simple log format: [timestamp] [level] [source] message
        // Example: [2023-11-15T14:30:45Z] [ERROR] [server] Database connection failed
        
        parts := strings.SplitN(line, "]", 3)
        if len(parts) < 3 {
            return nil, fmt.Errorf("invalid log format")
        }
        
        // Parse timestamp
        timestampStr := strings.Trim(parts[0], "[ ")
        timestamp, err := time.Parse(time.RFC3339, timestampStr)
        if err != nil {
            return nil, fmt.Errorf("invalid timestamp: %w", err)
        }
        
        // Parse level
        levelStr := strings.Trim(parts[1], "[ ")
        level := strings.ToUpper(levelStr)
        
        // Parse source and message
        rest := strings.TrimSpace(parts[2])
        sourceEnd := strings.Index(rest, "]")
        if sourceEnd == -1 {
            return nil, fmt.Errorf("invalid source format")
        }
        
        source := strings.Trim(rest[:sourceEnd], "[ ")
        message := strings.TrimSpace(rest[sourceEnd+1:])
        
        return &LogEntry{
            Timestamp: timestamp,
            Level:     level,
            Message:   message,
            Source:    source,
        }, nil
    }

    // writeLogEntry writes a formatted log entry
    func (lp *LogProcessor) writeLogEntry(writer *bufio.Writer, entry *LogEntry) error {
        // Format: [timestamp] LEVEL source: message
        formatted := fmt.Sprintf("[%s] %s %s: %s\n",
            entry.Timestamp.Format(time.RFC3339),
            entry.Level,
            entry.Source,
            entry.Message)
        
        _, err := writer.WriteString(formatted)
        return err
    }

    // updateStats updates processing statistics
    func (lp *LogProcessor) updateStats(entry *LogEntry) {
        lp.stats.TotalLines++
        
        switch entry.Level {
        case "ERROR":
            lp.stats.ErrorLines++
        case "WARNING", "WARN":
            lp.stats.WarningLines++
        case "INFO":
            lp.stats.InfoLines++
        }
    }

    // writeSummary writes processing summary
    func (lp *LogProcessor) writeSummary(writer *bufio.Writer) error {
        summary := fmt.Sprintf(`
=== Processing Summary ===
Total lines processed: %d
Error lines: %d
Warning lines: %d
Info lines: %d
========================
`, lp.stats.TotalLines, lp.stats.ErrorLines, lp.stats.WarningLines, lp.stats.InfoLines)
        
        _, err := writer.WriteString(summary)
        return err
    }

    // generateSampleLog creates a sample log file for testing
    func generateSampleLog(filename string) error {
        file, err := os.Create(filename)
        if err != nil {
            return err
        }
        defer file.Close()
        
        writer := bufio.NewWriter(file)
        defer writer.Flush()
        
        logEntries := []string{
            "[2023-11-15T14:30:45Z] [INFO] [server] Server started",
            "[2023-11-15T14:31:00Z] [INFO] [database] Connected to database",
            "[2023-11-15T14:31:15Z] [WARNING] [auth] Failed login attempt",
            "[2023-11-15T14:31:30Z] [ERROR] [database] Connection timeout",
            "[2023-11-15T14:31:45Z] [INFO] [server] Request processed",
            "[2023-11-15T14:32:00Z] [ERROR] [server] Internal server error",
        }
        
        for _, entry := range logEntries {
            if _, err := writer.WriteString(entry + "\n"); err != nil {
                return err
            }
        }
        
        return nil
    }

    func main() {
        // Generate sample log file
        inputFile := "sample.log"
        outputFile := "processed.log"
        
        if err := generateSampleLog(inputFile); err != nil {
            fmt.Printf("Error generating sample log: %v\n", err)
            return
        }
        fmt.Println("Generated sample log file:", inputFile)
        
        // Create log processor
        processor, err := NewLogProcessor(inputFile, outputFile, "server|database")
        if err != nil {
            fmt.Printf("Error creating log processor: %v\n", err)
            return
        }
        
        // Process the log file
        if err := processor.ProcessFile(); err != nil {
            fmt.Printf("Error processing log file: %v\n", err)
            return
        }
        
        fmt.Println("Log processing complete. Output written to:", outputFile)
        
        // Display the processed file
        fmt.Println("\n=== Processed Log Content ===")
        content, err := os.ReadFile(outputFile)
        if err != nil {
            fmt.Printf("Error reading output file: %v\n", err)
            return
        }
        fmt.Print(string(content))
    }
    ```

### How This Example Works:

1. **Log Processing Pipeline**:
   - Reads log file line by line using `bufio.Reader`
   - Parses each log entry into structured data
   - Applies filtering based on regex patterns
   - Writes processed entries using `bufio.Writer`

2. **Buffered I/O Operations**:
   - Uses `bufio.NewReader` for efficient line reading
   - Uses `bufio.NewWriter` for efficient writing
   - Demonstrates proper resource management with `defer`

3. **Error Handling**:
   - Handles I/O errors gracefully
   - Provides detailed error messages with line numbers
   - Continues processing after non-critical errors

4. **Statistics Tracking**:
   - Counts different log levels
   - Generates summary reports
   - Writes statistics to output file

### Real-World Applications:

1. **Log Analysis**:
   - Process application logs
   - Filter and categorize log entries
   - Generate summary reports

2. **Data Transformation**:
   - Convert between data formats
   - Clean and normalize data
   - Apply business rules

3. **File Processing**:
   - Process large files efficiently
   - Handle different line endings
   - Memory-efficient processing

## Best Practices

!!! tip "Flushing Buffered Writers"
    Always flush buffered writers to ensure data is written to the underlying resource.

!!! example "Flushing Buffered Writers"
    ```go title="flushing_writers.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "bufio"
        "fmt"
        "os"
    )

    // Good: Explicit flush
    func writeWithFlush(file *os.File, data string) error {
        writer := bufio.NewWriter(file)
        _, err := writer.WriteString(data)
        if err != nil {
            return err
        }
        err = writer.Flush() // Important!
        if err != nil {
            return err
        }
        return nil
    }

    // Bad: Forgetting to flush
    func writeWithoutFlush(file *os.File, data string) error {
        writer := bufio.NewWriter(file)
        _, err := writer.WriteString(data) // Data might not be written!
        return err
    }
    ```

!!! tip "Handling Scanner Errors"
    Always check scanner errors to catch I/O problems during scanning.

!!! example "Handling Scanner Errors"
    ```go title="scanner_errors.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "bufio"
        "fmt"
        "os"
    )

    // Good: Check scanner errors
    func processFile(filename string) error {
        file, err := os.Open(filename)
        if err != nil {
            return err
        }
        defer file.Close()
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            // Process line
            fmt.Println(scanner.Text())
        }
        
        if err := scanner.Err(); err != nil {
            return fmt.Errorf("scanner error: %w", err)
        }
        return nil
    }
    ```

!!! tip "Appropriate Buffer Sizes"
    Choose appropriate buffer sizes based on your use case for optimal performance.

!!! example "Appropriate Buffer Sizes"
    ```go title="buffer_sizes.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "bufio"
        "os"
    )

    func main() {
        // For small files or frequent operations
        reader := bufio.NewReader(os.Stdin) // Default buffer size (4096 bytes)
        
        // For large files or performance-critical code
        reader = bufio.NewReaderSize(os.Stdin, 64*1024) // 64KB buffer
        
        // For network operations with high latency
        reader = bufio.NewReaderSize(os.Stdin, 128*1024) // 128KB buffer
    }
    ```

!!! tip "Resource Management"
    Use defer for proper resource cleanup to prevent resource leaks.

!!! example "Resource Management"
    ```go title="resource_management.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "bufio"
        "fmt"
        "os"
    )

    // Good: Use defer for cleanup
    func processFile(filename string) error {
        file, err := os.Open(filename)
        if err != nil {
            return err
        }
        defer file.Close() // Ensure file is closed
        
        reader := bufio.NewReader(file)
        // Process file...
        return nil
    }
    ```

## Performance Considerations

!!! warning "Buffer Size Impact"
    Buffer size can significantly impact performance. Choose sizes based on your specific use case.

!!! example "Buffer Size Impact"
    ```go title="buffer_size_impact.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "bufio"
        "io"
        "os"
        "time"
    )

    // Benchmark different buffer sizes
    func benchmarkBufferSize(filename string, bufferSize int) time.Duration {
        file, _ := os.Open(filename)
        defer file.Close()
        
        start := time.Now()
        reader := bufio.NewReaderSize(file, bufferSize)
        
        // Read entire file
        _, _ = io.Copy(io.Discard, reader)
        
        return time.Since(start)
    }

    func main() {
        // Test with different buffer sizes
        sizes := []int{4096, 8192, 16384, 32768, 65536}
        for _, size := range sizes {
            duration := benchmarkBufferSize("largefile.txt", size)
            fmt.Printf("Buffer size %d: %v\n", size, duration)
        }
    }
    ```

!!! warning "Scanner vs Manual Reading"
    Scanner is convenient but slightly slower than manual reading for performance-critical code.

!!! example "Scanner vs Manual Reading"
    ```go title="scanner_vs_manual.go" linenums="1" hl_lines="8-40"
    package main

    import (
        "bufio"
        "fmt"
        "io"
        "os"
    )

    // Scanner is convenient but slightly slower
    func countLinesScanner(filename string) (int, error) {
        file, err := os.Open(filename)
        if err != nil {
            return 0, err
        }
        defer file.Close()
        
        scanner := bufio.NewScanner(file)
        count := 0
        for scanner.Scan() {
            count++
        }
        return count, scanner.Err()
    }

    // Manual reading is faster but more code
    func countLinesManual(filename string) (int, error) {
        file, err := os.Open(filename)
        if err != nil {
            return 0, err
        }
        defer file.Close()
        
        reader := bufio.NewReader(file)
        count := 0
        for {
            _, err := reader.ReadString('\n')
            if err != nil {
                if err == io.EOF {
                    break
                }
                return 0, err
            }
            count++
        }
        return count, nil
    }
    ```

## Common Patterns

!!! tip "Line-by-Line Processing"
    Create reusable functions for common line processing patterns.

!!! example "Line-by-Line Processing"
    ```go title="line_processing.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "bufio"
        "fmt"
        "os"
    )

    // Process a file line by line with a custom function
    func processFile(filename string, processFunc func(string) error) error {
        file, err := os.Open(filename)
        if err != nil {
            return err
        }
        defer file.Close()
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            if err := processFunc(scanner.Text()); err != nil {
                return err
            }
        }
        return scanner.Err()
    }

    // Example usage
    func main() {
        err := processFile("example.txt", func(line string) error {
            fmt.Println("Processing:", line)
            return nil
        })
        if err != nil {
            fmt.Println("Error:", err)
        }
    }
    ```

!!! tip "Buffered Writing with Auto-Flush"
    Implement auto-flushing for writers that need periodic flushing.

!!! example "Buffered Writing with Auto-Flush"
    ```go title="autoflush_writer.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "bufio"
        "io"
        "time"
    )

    // AutoFlushWriter automatically flushes at intervals
    type AutoFlushWriter struct {
        *bufio.Writer
        flushInterval time.Duration
        lastFlush    time.Time
    }

    func NewAutoFlushWriter(w io.Writer, size int, interval time.Duration) *AutoFlushWriter {
        return &AutoFlushWriter{
            Writer:        bufio.NewWriterSize(w, size),
            flushInterval: interval,
            lastFlush:    time.Now(),
        }
    }

    func (w *AutoFlushWriter) Write(p []byte) (int, error) {
        n, err := w.Writer.Write(p)
        if err != nil {
            return n, err
        }
        
        // Auto-flush if interval has passed
        if time.Since(w.lastFlush) > w.flushInterval {
            w.Flush()
            w.lastFlush = time.Now()
        }
        
        return n, nil
    }
    ```

!!! tip "Custom Split Functions"
    Create custom split functions for specialized tokenization needs.

!!! example "Custom Split Functions"
    ```go title="custom_split_functions.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "bufio"
    )

    // Split by multiple delimiters
    func scanAnyDelimiter(data []byte, atEOF bool) (advance int, token []byte, err error) {
        // Skip leading delimiters
        start := 0
        for ; start < len(data); start++ {
            if data[start] != ' ' && data[start] != '\t' && data[start] != ',' {
                break
            }
        }
        
        // Scan until delimiter or EOF
        for i := start; i < len(data); i++ {
            if data[i] == ' ' || data[i] == '\t' || data[i] == ',' {
                return i + 1, data[start:i], nil
            }
        }
        
        // If we're at EOF, we have a final token
        if atEOF && len(data) > start {
            return len(data), data[start:], nil
        }
        
        // Request more data
        return start, nil, nil
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Buffered Reading**: Use `bufio.Reader` for efficient reading with methods like `ReadString` and `ReadLine`
    - **Scanner**: Use `bufio.Scanner` for convenient tokenization with built-in split functions
    - **Buffered Writing**: Use `bufio.Writer` for efficient writing, but always remember to flush
    - **Custom Splitting**: Implement custom split functions for specialized tokenization needs
    - **Performance**: Choose appropriate buffer sizes based on your use case
    - **Resource Management**: Use defer for proper cleanup of resources

!!! quote "Remember"
    "The bufio package is essential for efficient I/O operations in Go. It provides buffered readers and writers that reduce system call overhead and improve performance. By following best practices like always flushing writers, handling scanner errors, and choosing appropriate buffer sizes, you can build fast and reliable applications that handle I/O operations effectively."