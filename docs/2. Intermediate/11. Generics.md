# Go Generics: Type-Safe Generic Programming

!!! abstract "Overview"
    Master Go generics introduced in Go 1.18 - write type-safe, reusable code that works with multiple types. Learn type parameters, constraints, generic functions, and data structures for building flexible, maintainable applications.

!!! tip "Key Points"
    - Generics enable type-safe code reuse across multiple types
    - Type parameters use square bracket syntax `[T any]`
    - Constraints define what operations are allowed on type parameters
    - Generic functions and types reduce code duplication
    - Compile-time type checking ensures safety and performance

## Understanding Generics

Generics allow you to write functions and data structures that work with multiple types while maintaining compile-time type safety and performance.

!!! info "Generic Programming Concept"
    ```mermaid
    graph LR
        A[Generic Code] --> B[Type Parameters]
        A --> B --> C[Type Constraints]
        A --> B --> C --> D[Concrete Types]
        D --> E[Type-Safe Operations]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
        style E fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Why Use Generics?

1. **Type Safety**: Catch type errors at compile time
2. **Code Reusability**: Write once, use with multiple types
3. **Performance**: Avoid runtime type assertions and conversions
4. **Readability**: Clearer intent than interface-based solutions
5. **Reduced Boilerplate**: Eliminate repetitive code for different types

## Generic Functions

### Basic Syntax

!!! example "Basic Generic Function"
    ```go title="basic_generic.go" linenums="1" hl_lines="3-9"
    package main

    import "fmt"

    // PrintSlice prints elements of any slice
    func PrintSlice[T any](s []T) {
        for _, v := range s {
            fmt.Print(v, " ")
        }
        fmt.Println()
    }

    func main() {
        PrintSlice([]int{1, 2, 3})      // Works with int
        PrintSlice([]string{"a", "b"}) // Works with string
    }
    ```

### Type Parameters

- Declared in square brackets `[]` before function parameters
- Can have multiple type parameters: `[T, U any]`
- Conventionally use single capital letters (T, U, V, etc.)

### Type Constraints

!!! example "Type Constraints"
    ```go title="type_constraints.go" linenums="1" hl_lines="8-16"
    package main

    import "fmt"

    // Using built-in constraints
    func SumNumbers[T int | float64](nums []T) T {
        var sum T
        for _, n := range nums {
            sum += n
        }
        return sum
    }

    func main() {
        fmt.Println(SumNumbers([]int{1, 2, 3}))     // 6
        fmt.Println(SumNumbers([]float64{1.1, 2.2})) // 3.3
    }
    ```

## Built-in Constraints

### `any`

Equivalent to `interface{}`, allows any type:

!!! example "Any Constraint"
    ```go title="any_constraint.go" linenums="1" hl_lines="6-10"
    package main

    import "fmt"

    // Identity function that works with any type
    func Identity[T any](x T) T {
        return x
    }

    func main() {
        fmt.Println(Identity(42))        // 42
        fmt.Println(Identity("hello"))   // hello
        fmt.Println(Identity(true))      // true
    }
    ```

### `comparable`

Types that support `==` and `!=` operators:

!!! example "Comparable Constraint"
    ```go title="comparable_constraint.go" linenums="1" hl_lines="8-18"
    package main

    import "fmt"

    // FindIndex finds the index of a target in a slice
    func FindIndex[T comparable](s []T, target T) int {
        for i, v := range s {
            if v == target {
                return i
            }
        }
        return -1
    }

    func main() {
        fmt.Println(FindIndex([]int{1, 2, 3}, 2))     // 1
        fmt.Println(FindIndex([]string{"a", "b"}, "b")) // 1
        fmt.Println(FindIndex([]int{1, 2, 3}, 4))     // -1
    }
    ```

## Custom Type Constraints

### Using Interfaces

!!! example "Interface Constraints"
    ```go title="interface_constraints.go" linenums="1" hl_lines="8-24"
    package main

    import "fmt"

    // Stringer interface defines the String() method
    type Stringer interface {
        String() string
    }

    // PrintStringers prints elements that implement Stringer
    func PrintStringers[T Stringer](s []T) {
        for _, v := range s {
            fmt.Println(v.String())
        }
    }

    type Person struct {
        Name string
    }

    func (p Person) String() string {
        return p.Name
    }

    func main() {
        people := []Person{{"Alice"}, {"Bob"}}
        PrintStringers(people) // Alice\nBob
    }
    ```

### Approximating Constraints

Use `~` to include types whose underlying type matches:

!!! example "Approximating Constraints"
    ```go title="approximating_constraints.go" linenums="1" hl_lines="6-20"
    package main

    import "fmt"

    // Number constraint includes all numeric types
    type Number interface {
        int | int8 | int16 | int32 | int64 | 
        float32 | float64
    }

    // Max returns the larger of two numbers
    func Max[T Number](a, b T) T {
        if a > b {
            return a
        }
        return b
    }

    // MyInt is a custom type based on int
    type MyInt int

    func main() {
        fmt.Println(Max(10, 20))           // 20
        fmt.Println(Max(MyInt(10), MyInt(20))) // 20
    }
    ```

## Generic Types

### Generic Structs

!!! example "Generic Stack"
    ```go title="generic_stack.go" linenums="1" hl_lines="8-30"
    package main

    import "fmt"

    // Stack is a LIFO data structure that can hold any type
    type Stack[T any] struct {
        items []T
    }

    // Push adds an item to the top of the stack
    func (s *Stack[T]) Push(item T) {
        s.items = append(s.items, item)
    }

    // Pop removes and returns the top item from the stack
    func (s *Stack[T]) Pop() (T, bool) {
        if len(s.items) == 0 {
            var zero T
            return zero, false
        }
        item := s.items[len(s.items)-1]
        s.items = s.items[:len(s.items)-1]
        return item, true
    }

    func main() {
        intStack := &Stack[int]{}
        intStack.Push(1)
        intStack.Push(2)
        fmt.Println(intStack.Pop()) // 2, true

        stringStack := &Stack[string]{}
        stringStack.Push("a")
        stringStack.Push("b")
        fmt.Println(stringStack.Pop()) // "b", true
    }
    ```

### Generic Slices and Maps

!!! example "Generic Collections"
    ```go title="generic_collections.go" linenums="1" hl_lines="8-35"
    package main

    import "fmt"

    // Vector is a generic slice type with additional methods
    type Vector[T any] []T

    // Push adds an item to the vector
    func (v *Vector[T]) Push(item T) {
        *v = append(*v, item)
    }

    // Cache is a generic map type with thread-safe operations
    type Cache[K comparable, V any] struct {
        items map[K]V
    }

    // Set adds a key-value pair to the cache
    func (c *Cache[K, V]) Set(key K, value V) {
        if c.items == nil {
            c.items = make(map[K]V)
        }
        c.items[key] = value
    }

    // Get retrieves a value by key from the cache
    func (c *Cache[K, V]) Get(key K) (V, bool) {
        value, exists := c.items[key]
        return value, exists
    }

    func main() {
        vec := Vector[int]{1, 2, 3}
        vec.Push(4)
        fmt.Println(vec) // [1 2 3 4]

        cache := Cache[string, int]{}
        cache.Set("age", 30)
        if age, ok := cache.Get("age"); ok {
            fmt.Println(age) // 30
        }
    }
    ```

## Advanced Generic Patterns

### Generic Methods

!!! example "Generic Methods"
    ```go title="generic_methods.go" linenums="1" hl_lines="8-24"
    package main

    import "fmt"

    // Container holds a value of any type
    type Container[T any] struct {
        value T
    }

    // Get returns the container's value
    func (c Container[T]) Get() T {
        return c.value
    }

    // Set updates the container's value
    func (c *Container[T]) Set(value T) {
        c.value = value
    }

    func main() {
        intContainer := Container[int]{value: 42}
        fmt.Println(intContainer.Get()) // 42

        stringContainer := &Container[string]{}
        stringContainer.Set("hello")
        fmt.Println(stringContainer.Get()) // "hello"
    }
    ```

### Type Sets

!!! example "Type Sets"
    ```go title="type_sets.go" linenums="1" hl_lines="8-25"
    package main

    import (
        "fmt"
        "sort"
    )

    // Ordered constraint includes types that can be compared
    type Ordered interface {
        int | int8 | int16 | int32 | int64 |
        uint | uint8 | uint16 | uint32 | uint64 |
        float32 | float64 |
        ~string
    }

    // Sort sorts a slice of ordered values
    func Sort[T Ordered](s []T) {
        sort.Slice(s, func(i, j int) bool {
            return s[i] < s[j]
        })
    }

    func main() {
        ints := []int{3, 1, 2}
        Sort(ints)
        fmt.Println(ints) // [1 2 3]

        floats := []float64{3.3, 1.1, 2.2}
        Sort(floats)
        fmt.Println(floats) // [1.1 2.2 3.3]
    }
    ```

### Generic Channels

!!! example "Generic Channels"
    ```go title="generic_channels.go" linenums="1" hl_lines="8-25"
    package main

    import "fmt"

    // Process reads from input channel, applies function, writes to output channel
    func Process[T any](in <-chan T, out chan<- T, process func(T) T) {
        for item := range in {
            out <- process(item)
        }
        close(out)
    }

    func main() {
        in := make(chan int, 3)
        out := make(chan int, 3)

        // Process doubles each number
        go Process(in, out, func(x int) int {
            return x * 2
        })

        in <- 1
        in <- 2
        in <- 3
        close(in)

        for result := range out {
            fmt.Println(result) // 2, 4, 6
        }
    }
    ```

## Real-World Example: Generic Repository Pattern

Let's build a complete CRUD repository pattern using generics:

!!! example "Generic Repository"
    ```go title="generic_repository.go" linenums="1" hl_lines="8-80"
    package main

    import (
        "errors"
        "fmt"
        "sync"
    )

    // Entity interface defines the basic contract for all entities
    type Entity interface {
        GetID() string
        SetID(string)
    }

    // Repository interface defines the contract for repositories
    type Repository[T Entity] interface {
        Create(entity T) error
        GetByID(id string) (T, error)
        Update(entity T) error
        Delete(id string) error
        List() ([]T, error)
    }

    // InMemoryRepository implements Repository using in-memory storage
    type InMemoryRepository[T Entity] struct {
        items map[string]T
        mu    sync.RWMutex
    }

    func NewInMemoryRepository[T Entity]() *InMemoryRepository[T] {
        return &InMemoryRepository[T]{
            items: make(map[string]T),
        }
    }

    func (r *InMemoryRepository[T]) Create(entity T) error {
        r.mu.Lock()
        defer r.mu.Unlock()

        id := entity.GetID()
        if id == "" {
            return errors.New("entity must have an ID")
        }

        if _, exists := r.items[id]; exists {
            return fmt.Errorf("entity with ID %s already exists", id)
        }

        r.items[id] = entity
        return nil
    }

    func (r *InMemoryRepository[T]) GetByID(id string) (T, error) {
        r.mu.RLock()
        defer r.mu.RUnlock()

        entity, exists := r.items[id]
        if !exists {
            var zero T
            return zero, fmt.Errorf("entity with ID %s not found", id)
        }

        return entity, nil
    }

    func (r *InMemoryRepository[T]) Update(entity T) error {
        r.mu.Lock()
        defer r.mu.Unlock()

        id := entity.GetID()
        if _, exists := r.items[id]; !exists {
            return fmt.Errorf("entity with ID %s not found", id)
        }

        r.items[id] = entity
        return nil
    }

    func (r *InMemoryRepository[T]) Delete(id string) error {
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.items[id]; !exists {
            return fmt.Errorf("entity with ID %s not found", id)
        }

        delete(r.items, id)
        return nil
    }

    func (r *InMemoryRepository[T]) List() ([]T, error) {
        r.mu.RLock()
        defer r.mu.RUnlock()

        items := make([]T, 0, len(r.items))
        for _, item := range r.items {
            items = append(items, item)
        }

        return items, nil
    }

    // Example entity implementations
    type User struct {
        ID    string
        Name  string
        Email string
        Age   int
    }

    func (u User) GetID() string {
        return u.ID
    }

    func (u *User) SetID(id string) {
        u.ID = id
    }

    type Product struct {
        ID          string
        Name        string
        Description string
        Price       float64
    }

    func (p Product) GetID() string {
        return p.ID
    }

    func (p *Product) SetID(id string) {
        p.ID = id
    }

    func main() {
        // User repository
        userRepo := NewInMemoryRepository[User]()
        
        // Create users
        users := []User{
            {ID: "1", Name: "Alice", Email: "alice@example.com", Age: 30},
            {ID: "2", Name: "Bob", Email: "bob@example.com", Age: 25},
        }

        for _, user := range users {
            if err := userRepo.Create(user); err != nil {
                fmt.Printf("Error creating user: %v\n", err)
            }
        }

        // List users
        userList, err := userRepo.List()
        if err != nil {
            fmt.Printf("Error listing users: %v\n", err)
        } else {
            fmt.Println("Users:")
            for _, user := range userList {
                fmt.Printf("- %s (%s, %d years)\n", user.Name, user.Email, user.Age)
            }
        }

        // Product repository
        productRepo := NewInMemoryRepository[Product]()
        
        // Create products
        products := []Product{
            {ID: "p1", Name: "Laptop", Description: "High-performance laptop", Price: 999.99},
            {ID: "p2", Name: "Mouse", Description: "Wireless mouse", Price: 29.99},
        }

        for _, product := range products {
            if err := productRepo.Create(product); err != nil {
                fmt.Printf("Error creating product: %v\n", err)
            }
        }

        // List products
        productList, err := productRepo.List()
        if err != nil {
            fmt.Printf("Error listing products: %v\n", err)
        } else {
            fmt.Println("\nProducts:")
            for _, product := range productList {
                fmt.Printf("- %s: $%.2f\n", product.Name, product.Price)
            }
        }
    }
    ```

### How This Example Demonstrates Generics:

1. **Generic Repository Interface**:
   - `Repository[T Entity]` defines CRUD operations for any entity type
   - Type parameter `T` is constrained to implement `Entity`

2. **Generic Implementation**:
   - `InMemoryRepository[T Entity]` implements the repository interface
   - Works with any type that satisfies the `Entity` constraint

3. **Multiple Entity Types**:
   - `User` and `Product` both implement `Entity`
   - Same repository code works for both

## Best Practices

### 1. When to Use Generics

!!! tip "Generics Usage"
    - **Use generics** when you need to work with multiple types in the same way
    - **Avoid generics** when you're only working with one specific type

!!! example "When to Use Generics"
    ```go title="when_to_use.go" linums="1" hl_lines="8-20"
    package main

    import "fmt"

    // Good: Generic function for multiple types
    func Max[T int | float64](a, b T) T {
        if a > b {
            return a
        }
        return b
    }

    // Bad: Non-generic function for one type
    func MaxInt(a, b int) int {
        if a > b {
            return a
        }
        return b
    }

    func main() {
        fmt.Println(Max(10, 20))        // 20
        fmt.Println(Max(10.5, 20.5))   // 20.5
        fmt.Println(MaxInt(10, 20))    // 20
    }
    ```

### 2. Naming Conventions

!!! tip "Naming Conventions"
    Use single capital letters for type parameters (T, U, V) or descriptive names when the meaning isn't obvious.

!!! example "Naming Conventions"
    ```go title="naming_conventions.go" linums="1" hl_lines="8-16"
    package main

    import "fmt"

    // Good: Descriptive type parameter names
    func Map[Element, Result any](elements []Element, mapper func(Element) Result) []Result {
        results := make([]Result, len(elements))
        for i, element := range elements {
            results[i] = mapper(element)
        }
        return results
    }

    func main() {
        numbers := []int{1, 2, 3}
        strings := Map(numbers, func(n int) string {
            return fmt.Sprintf("Number: %d", n)
        })
        fmt.Println(strings)
    }
    ```

### 3. Constraint Design

!!! warning "Constraint Design"
    Keep constraints as small as possible and prefer `~` for underlying types when appropriate.

!!! example "Constraint Design"
    ```go title="constraint_design.go" linums="1" hl_lines="6-20"
    package main

    import "fmt"

    // Good: Minimal constraint
    type Addable interface {
        int | float64 | ~string
    }

    func Add[T Addable](a, b T) T {
        return a + b
    }

    type MyString string

    func main() {
        fmt.Println(Add(10, 20))           // 30
        fmt.Println(Add(MyString("a"), "b")) // ab
    }
    ```

## Common Patterns with Generics

### 1. Functional Utilities

!!! example "Functional Utilities"
    ```go title="functional_utils.go" linums="1" hl_lines="8-30"
    package main

    import "fmt"

    // Map applies a function to each element of a slice
    func Map[T, U any](s []T, f func(T) U) []U {
        result := make([]U, len(s))
        for i, v := range s {
            result[i] = f(v)
        }
        return result
    }

    // Filter returns elements that satisfy the predicate
    func Filter[T any](s []T, f func(T) bool) []T {
        result := make([]T, 0)
        for _, v := range s {
            if f(v) {
                result = append(result, v)
            }
        }
        return result
    }

    // Reduce reduces a slice to a single value
    func Reduce[T, U any](s []T, init U, f func(U, T) U) U {
        result := init
        for _, v := range s {
            result = f(result, v)
        }
        return result
    }

    func main() {
        numbers := []int{1, 2, 3, 4, 5}
        
        // Map: square each number
        squared := Map(numbers, func(x int) int { return x * x })
        fmt.Println(squared) // [1 4 9 16 25]
        
        // Filter: keep even numbers
        evens := Filter(numbers, func(x int) bool { return x%2 == 0 })
        fmt.Println(evens) // [2 4]
        
        // Reduce: sum all numbers
        sum := Reduce(numbers, 0, func(acc, x int) int { return acc + x })
        fmt.Println(sum) // 15
    }
    ```

### 2. Generic Data Structures

!!! example "Binary Search Tree"
    ```go title="binary_search_tree.go" linums="1" hl_lines="8-35"
    package main

    import "fmt"

    // TreeNode represents a node in a binary search tree
    type TreeNode[T comparable] struct {
        Value T
        Left  *TreeNode[T]
        Right *TreeNode[T]
    }

    // Insert adds a value to the tree
    func (n *TreeNode[T]) Insert(value T) {
        if value < n.Value {
            if n.Left == nil {
                n.Left = &TreeNode[T]{Value: value}
            } else {
                n.Left.Insert(value)
            }
        } else {
            if n.Right == nil {
                n.Right = &TreeNode[T]{Value: value}
            } else {
                n.Right.Insert(value)
            }
        }
    }

    // InOrder returns values in ascending order
    func (n *TreeNode[T]) InOrder() []T {
        var result []T
        if n.Left != nil {
            result = append(result, n.Left.InOrder()...)
        }
        result = append(result, n.Value)
        if n.Right != nil {
            result = append(result, n.Right.InOrder()...)
        }
        return result
    }

    func main() {
        root := &TreeNode[int]{Value: 5}
        root.Insert(3)
        root.Insert(7)
        root.Insert(1)
        root.Insert(9)
        
        fmt.Println(root.InOrder()) // [1 3 5 7 9]
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Type Parameters**: Use `[T any]` syntax to define generic types
    - **Constraints**: Limit which types can be used with `|` and `~`
    - **Built-in Constraints**: `any` for any type, `comparable` for types supporting `==`
    - **Generic Functions**: Define functions that work with multiple types
    - **Generic Types**: Create structs, slices, and maps that work with any type
    - **Repository Pattern**: Use generics for reusable data access layers
    - **Functional Utilities**: Implement map, filter, and reduce with generics

!!! quote "Remember"
    "Generics in Go provide a powerful way to write flexible, reusable, and type-safe code. They eliminate the need for code duplication while maintaining compile-time type safety. By carefully designing constraints and following naming conventions, you can create elegant abstractions that make your code more maintainable and expressive."