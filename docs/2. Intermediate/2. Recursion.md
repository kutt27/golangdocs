

# Go Recursion: Functions That Call Themselves

!!! abstract "Overview"
    Master recursion in Go - a powerful programming technique where functions call themselves to solve complex problems by breaking them into smaller, similar subproblems. Learn when to use recursion, common patterns, and Go-specific considerations.

!!! tip "Key Points"
    - Recursion requires base cases to prevent infinite loops
    - Go doesn't optimize tail calls, making deep recursion expensive
    - Best suited for naturally recursive problems like tree traversal
    - Consider iterative alternatives for performance-critical code
    - Stack usage grows with recursion depth

## Understanding Recursion

Recursion is a programming technique where a function calls itself to solve a problem by breaking it down into smaller, similar subproblems.

!!! info "Recursion Components"
    ```mermaid
    graph TD
        A[Recursive Function] --> B[Base Case]
        A --> C[Recursive Case]
        B --> B1[Stops Recursion]
        B --> B2[Returns Simple Value]
        C --> C1[Calls Itself]
        C --> C2[Modified Parameters]
        C --> C3[Progress Toward Base]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Essential Components

Every recursive function must have:

1. **Base Case**: Condition that stops the recursion
2. **Recursive Case**: Function calls itself with modified arguments
3. **Progress**: Each call moves closer to the base case

!!! example "Basic Recursion Pattern"

    === "Factorial Function"
        ```go title="factorial.go" linenums="1" hl_lines="6-10"
        package main

        import "fmt"

        func factorial(n int) int {
            if n <= 1 { // Base case
                return 1
            }
            return n * factorial(n-1) // Recursive case
        }

        func main() {
            fmt.Println(factorial(5)) // 120 (5*4*3*2*1)
            fmt.Println(factorial(0)) // 1
            fmt.Println(factorial(1)) // 1
        }
        ```

    === "Fibonacci Sequence"
        ```go title="fibonacci.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func fibonacci(n int) int {
            if n <= 1 { // Base cases
                return n
            }
            return fibonacci(n-1) + fibonacci(n-2) // Recursive case
        }

        func main() {
            for i := 0; i < 10; i++ {
                fmt.Printf("fib(%d) = %d\n", i, fibonacci(i))
            }
        }
        ```

    === "Sum of Array"
        ```go title="array_sum.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func sumArray(arr []int) int {
            if len(arr) == 0 { // Base case
                return 0
            }
            return arr[0] + sumArray(arr[1:]) // Recursive case
        }

        func main() {
            numbers := []int{1, 2, 3, 4, 5}
            fmt.Println(sumArray(numbers)) // 15
        }
        ```

## Go-Specific Considerations

### Stack Management

Go uses growable stacks, but recursion still has important limitations.

!!! warning "Stack Limitations"
    Go doesn't perform tail call optimization, making deep recursion memory-intensive.

!!! example "Stack Behavior"

    === "Stack Growth"
        ```go title="stack_growth.go" linenums="1" hl_lines="8-14"
        package main

        import (
            "fmt"
            "runtime"
        )

        func deepRecursion(n int) int {
            if n == 0 {
                var m runtime.MemStats
                runtime.ReadMemStats(&m)
                fmt.Printf("Stack size at depth 0: %d KB\n", m.StackInuse/1024)
                return 0
            }
            return 1 + deepRecursion(n-1)
        }

        func main() {
            result := deepRecursion(1000)
            fmt.Printf("Result: %d\n", result)
        }
        ```

    === "Stack Overflow Risk"
        ```go title="stack_overflow.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func riskyRecursion(n int) int {
            if n == 0 {
                return 0
            }
            // This could cause stack overflow with large n
            return 1 + riskyRecursion(n-1)
        }

        func main() {
            // Be careful with large values
            fmt.Println(riskyRecursion(10000)) // May cause issues
        }
        ```

### When to Use Recursion

Recursion is most appropriate for naturally recursive problems.

!!! example "Good Use Cases"

    === "Tree Traversal"
        ```go title="tree_traversal.go" linenums="1" hl_lines="11-17"
        package main

        import "fmt"

        type TreeNode struct {
            Value int
            Left  *TreeNode
            Right *TreeNode
        }

        func (t *TreeNode) InorderTraversal() {
            if t == nil { // Base case
                return
            }
            t.Left.InorderTraversal()  // Recursive case
            fmt.Printf("%d ", t.Value)
            t.Right.InorderTraversal() // Recursive case
        }

        func main() {
            root := &TreeNode{
                Value: 4,
                Left:  &TreeNode{Value: 2, Left: &TreeNode{Value: 1}, Right: &TreeNode{Value: 3}},
                Right: &TreeNode{Value: 6, Left: &TreeNode{Value: 5}, Right: &TreeNode{Value: 7}},
            }
            root.InorderTraversal() // 1 2 3 4 5 6 7
        }
        ```

## Common Recursive Patterns

### Linear Recursion

Processing elements sequentially, one at a time.

!!! example "Linear Patterns"

    === "Array Sum"
        ```go title="array_sum.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func sum(arr []int) int {
            if len(arr) == 0 { // Base case
                return 0
            }
            return arr[0] + sum(arr[1:]) // Recursive case
        }

        func main() {
            numbers := []int{1, 2, 3, 4, 5}
            fmt.Println(sum(numbers)) // 15
        }
        ```

    === "String Reversal"
        ```go title="string_reverse.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func reverseString(s string) string {
            if len(s) <= 1 { // Base case
                return s
            }
            return reverseString(s[1:]) + string(s[0]) // Recursive case
        }

        func main() {
            fmt.Println(reverseString("hello")) // "olleh"
        }
        ```

### Binary Recursion

Making two recursive calls, often for divide-and-conquer algorithms.

!!! example "Binary Patterns"

    === "Binary Search"
        ```go title="binary_search.go" linenums="1" hl_lines="6-16"
        package main

        import "fmt"

        func binarySearch(arr []int, target, low, high int) int {
            if low > high { // Base case
                return -1
            }

            mid := (low + high) / 2
            if arr[mid] == target {
                return mid
            } else if arr[mid] > target {
                return binarySearch(arr, target, low, mid-1) // Left half
            } else {
                return binarySearch(arr, target, mid+1, high) // Right half
            }
        }

        func main() {
            arr := []int{1, 3, 5, 7, 9, 11, 13, 15}
            result := binarySearch(arr, 7, 0, len(arr)-1)
            fmt.Printf("Element found at index: %d\n", result)
        }
        ```

### Backtracking

Exploring all possible solutions and backtracking when needed.

!!! example "Backtracking Pattern"

    === "Generate Permutations"
        ```go title="permutations.go" linenums="1" hl_lines="8-20"
        package main

        import "fmt"

        func generatePermutations(arr []string) [][]string {
            var result [][]string

            var backtrack func(start int)
            backtrack = func(start int) {
                if start == len(arr) { // Base case
                    temp := make([]string, len(arr))
                    copy(temp, arr)
                    result = append(result, temp)
                    return
                }

                for i := start; i < len(arr); i++ {
                    arr[start], arr[i] = arr[i], arr[start] // Swap
                    backtrack(start + 1)                    // Recurse
                    arr[start], arr[i] = arr[i], arr[start] // Backtrack
                }
            }

            backtrack(0)
            return result
        }

        func main() {
            perms := generatePermutations([]string{"A", "B", "C"})
            for _, perm := range perms {
                fmt.Println(perm)
            }
        }
        ```

## Performance Considerations

### Recursion vs Iteration

Understanding when to choose recursion over iteration is crucial in Go.

!!! info "Comparison Table"
    | Aspect           | Recursion                          | Iteration                     |
    |------------------|------------------------------------|-------------------------------|
    | Performance      | Slower (function call overhead)    | Faster (direct execution)     |
    | Memory Usage     | Higher (stack frames)              | Lower (constant space)        |
    | Readability      | Better for recursive problems      | Better for linear processes   |
    | Stack Limit      | Risk of stack overflow             | No stack limit                |
    | Tail Optimization| Not available in Go                | N/A                           |

### Optimization Techniques

!!! example "Performance Optimization"

    === "Memoization"
        ```go title="memoized_fibonacci.go" linenums="1" hl_lines="6-14"
        package main

        import "fmt"

        func fibonacci(n int, memo map[int]int) int {
            if n <= 1 { // Base case
                return n
            }
            if val, ok := memo[n]; ok { // Check cache
                return val
            }
            memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
            return memo[n]
        }

        func main() {
            memo := make(map[int]int)
            fmt.Println(fibonacci(50, memo)) // 12586269025
        }
        ```

    === "Iterative Alternative"
        ```go title="iterative_fibonacci.go" linenums="1" hl_lines="6-14"
        package main

        import "fmt"

        func fibonacciIterative(n int) int {
            if n <= 1 {
                return n
            }

            a, b := 0, 1
            for i := 2; i <= n; i++ {
                a, b = b, a+b
            }
            return b
        }

        func main() {
            fmt.Println(fibonacciIterative(50)) // 12586269025
        }
        ```

    === "Tail Recursion (Not Optimized)"
        ```go title="tail_recursion.go" linenums="1" hl_lines="6-12"
        package main

        import "fmt"

        func fibonacciTail(n, a, b int) int {
            if n == 0 { // Base case
                return a
            }
            return fibonacciTail(n-1, b, a+b) // Tail call (not optimized in Go)
        }

        func fibonacci(n int) int {
            return fibonacciTail(n, 0, 1)
        }

        func main() {
            fmt.Println(fibonacci(50)) // Still uses stack frames
        }
        ```

## Best Practices

### Essential Guidelines

Follow these practices for effective recursion in Go.

!!! warning "Critical Rules"
    - Always define a base case to prevent infinite recursion
    - Ensure each recursive call progresses toward the base case
    - Consider depth limitations for unknown/unbounded problems

!!! example "Best Practice Patterns"

    === "Proper Base Case"
        ```go title="proper_base_case.go" linenums="1" hl_lines="6-9"
        package main

        import "fmt"

        func countdown(n int) {
            if n <= 0 { // Clear base case
                fmt.Println("Done!")
                return
            }
            fmt.Println(n)
            countdown(n - 1) // Progress toward base case
        }

        func main() {
            countdown(5)
        }
        ```

    === "Input Validation"
        ```go title="input_validation.go" linenums="1" hl_lines="6-10"
        package main

        import "fmt"

        func factorial(n int) int {
            if n < 0 { // Handle invalid input
                return -1 // or panic/error
            }
            if n <= 1 { // Base case
                return 1
            }
            return n * factorial(n-1)
        }

        func main() {
            fmt.Println(factorial(5))  // 120
            fmt.Println(factorial(-1)) // -1 (error case)
        }
        ```

    === "Depth Limiting"
        ```go title="depth_limiting.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func limitedRecursion(n, maxDepth int) int {
            if maxDepth <= 0 { // Depth limit reached
                fmt.Println("Max depth reached")
                return 0
            }
            if n <= 1 { // Base case
                return 1
            }
            return n + limitedRecursion(n-1, maxDepth-1)
        }

        func main() {
            result := limitedRecursion(10, 5)
            fmt.Println(result)
        }
        ```

## Real-World Application

### File System Analysis

A practical example demonstrating recursion for directory traversal and analysis.

!!! example "Directory Analyzer"

    === "Core Implementation"
        ```go title="directory_analyzer.go" linenums="1" hl_lines="10-25"
        package main

        import (
            "fmt"
            "os"
            "path/filepath"
        )

        type FileStats struct {
            TotalFiles int64
            TotalSize  int64
            FileTypes  map[string]int
        }

        func analyzeDirectory(dir string, stats *FileStats) error {
            entries, err := os.ReadDir(dir)
            if err != nil {
                return err
            }

            for _, entry := range entries {
                fullPath := filepath.Join(dir, entry.Name())

                if entry.IsDir() {
                    // Recursive call for subdirectories
                    if err := analyzeDirectory(fullPath, stats); err != nil {
                        return err
                    }
                } else {
                    // Process file
                    info, err := entry.Info()
                    if err != nil {
                        continue
                    }

                    stats.TotalFiles++
                    stats.TotalSize += info.Size()

                    ext := filepath.Ext(entry.Name())
                    if ext == "" {
                        ext = "no_extension"
                    }
                    stats.FileTypes[ext]++
                }
            }
            return nil
        }

        func main() {
            if len(os.Args) < 2 {
                fmt.Println("Usage: go run analyzer.go <directory>")
                return
            }

            stats := &FileStats{
                FileTypes: make(map[string]int),
            }

            if err := analyzeDirectory(os.Args[1], stats); err != nil {
                fmt.Printf("Error: %v\n", err)
                return
            }

            fmt.Printf("Total files: %d\n", stats.TotalFiles)
            fmt.Printf("Total size: %.2f MB\n", float64(stats.TotalSize)/1024/1024)
            fmt.Println("File types:")
            for ext, count := range stats.FileTypes {
                fmt.Printf("  %s: %d files\n", ext, count)
            }
        }
        ```

### Applications and Benefits

Recursion is particularly valuable for specific types of problems.

!!! info "Common Applications"
    - **File System Operations**: Directory traversal, file search
    - **Data Structure Manipulation**: Tree/graph operations
    - **Algorithm Implementation**: Divide-and-conquer, backtracking
    - **Mathematical Computations**: Factorial, Fibonacci, combinatorics

!!! success "Benefits of Recursive Approach"
    - **Natural Fit**: Directory structures are inherently recursive
    - **Code Clarity**: More intuitive than manual stack management
    - **Maintainability**: Easier to understand and modify
    - **Flexibility**: Simple to add features like filtering or depth limits

### Performance Considerations

!!! warning "Limitations in Go"
    - **No Tail Call Optimization**: All recursive calls use stack frames
    - **Stack Depth**: Very deep recursion can cause stack overflow
    - **Memory Usage**: Each call consumes stack memory

!!! tip "Optimization Strategies"
    - Use memoization for overlapping subproblems
    - Consider iterative alternatives for deep recursion
    - Implement depth limits for unknown input sizes
    - Use channels and goroutines for concurrent processing

## Quick Reference

!!! success "Key Takeaways"
    - **Base Cases**: Always define conditions to stop recursion
    - **Progress**: Each call must move closer to the base case
    - **Validation**: Handle invalid inputs appropriately
    - **Depth Awareness**: Consider maximum recursion depth
    - **Performance**: Weigh recursion benefits against overhead
    - **Alternatives**: Know when iteration might be better

!!! quote "Remember"
    "Recursion is powerful for naturally recursive problems like tree traversal and divide-and-conquer algorithms. Use it when it significantly improves code clarity, but be mindful of Go's lack of tail call optimization."