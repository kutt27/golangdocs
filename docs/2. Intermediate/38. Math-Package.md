

# The Math Package in Go: A Comprehensive Guide

## Introduction to the Math Package

The `math` package in Go provides basic constants and mathematical functions for floating-point numbers. It includes operations for trigonometry, logarithms, exponentiation, rounding, and more. This package is essential for scientific computing, graphics programming, statistics, and any application that requires mathematical operations beyond basic arithmetic.

## Basic Constants

The `math` package defines several important mathematical constants:

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Println("Mathematical Constants:")
    fmt.Printf("Pi (π): %.15f\n", math.Pi)
    fmt.Printf("E (e): %.15f\n", math.E)
    fmt.Printf("Phi (φ): %.15f\n", math.Phi)
    fmt.Printf("Sqrt(2): %.15f\n", math.Sqrt2)
    fmt.Printf("Sqrt(E): %.15f\n", math.SqrtE)
    fmt.Printf("Sqrt(Pi): %.15f\n", math.SqrtPi)
    fmt.Printf("Sqrt(Phi): %.15f\n", math.SqrtPhi)
    fmt.Printf("Ln(2): %.15f\n", math.Ln2)
    fmt.Printf("Ln(10): %.15f\n", math.Ln10)
    fmt.Printf("Log2(e): %.15f\n", math.Log2E)
    fmt.Printf("Log10(e): %.15f\n", math.Log10E)
    
    // Machine-specific constants
    fmt.Println("\nMachine-Specific Constants:")
    fmt.Printf("Max float64: %g\n", math.MaxFloat64)
    fmt.Printf("Smallest positive float64: %g\n", math.SmallestNonzeroFloat64)
    fmt.Printf("Max int: %d\n", math.MaxInt)
    fmt.Printf("Min int: %d\n", math.MinInt)
    fmt.Printf("Max int8: %d\n", math.MaxInt8)
    fmt.Printf("Min int8: %d\n", math.MinInt8)
    fmt.Printf("Max int16: %d\n", math.MaxInt16)
    fmt.Printf("Min int16: %d\n", math.MinInt16)
    fmt.Printf("Max int32: %d\n", math.MaxInt32)
    fmt.Printf("Min int32: %d\n", math.MinInt32)
    fmt.Printf("Max int64: %d\n", math.MaxInt64)
    fmt.Printf("Min int64: %d\n", math.MinInt64)
    fmt.Printf("Max uint: %d\n", math.MaxUint)
    fmt.Printf("Max uint8: %d\n", math.MaxUint8)
    fmt.Printf("Max uint16: %d\n", math.MaxUint16)
    fmt.Printf("Max uint32: %d\n", math.MaxUint32)
    fmt.Printf("Max uint64: %d\n", math.MaxUint64)
}
```

## Basic Operations

### Minimum and Maximum

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Find minimum and maximum values
    a, b := 3.14, 2.71
    fmt.Printf("Min(%.2f, %.2f) = %.2f\n", a, b, math.Min(a, b))
    fmt.Printf("Max(%.2f, %.2f) = %.2f\n", a, b, math.Max(a, b))
    
    // Works with multiple values
    values := []float64{1.2, 3.4, 0.5, 7.8, 2.3}
    minVal := values[0]
    maxVal := values[0]
    
    for _, v := range values[1:] {
        minVal = math.Min(minVal, v)
        maxVal = math.Max(maxVal, v)
    }
    
    fmt.Printf("Min of %v = %.2f\n", values, minVal)
    fmt.Printf("Max of %v = %.2f\n", values, maxVal)
}
```

### Absolute Value

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Absolute value
    values := []float64{3.14, -2.71, 0, -0.0, 1.0}
    
    for _, v := range values {
        abs := math.Abs(v)
        fmt.Printf("Abs(%.2f) = %.2f\n", v, abs)
    }
}
```

### Rounding Functions

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    values := []float64{1.2, 1.5, 1.8, -1.2, -1.5, -1.8}
    
    fmt.Println("Rounding Functions:")
    for _, v := range values {
        fmt.Printf("Value: %.1f\n", v)
        fmt.Printf("  Floor: %.1f (nearest integer <= value)\n", math.Floor(v))
        fmt.Printf("  Ceil:  %.1f (nearest integer >= value)\n", math.Ceil(v))
        fmt.Printf("  Round: %.1f (nearest integer, half away from zero)\n", math.Round(v))
        fmt.Printf("  Trunc: %.1f (integer part)\n", math.Trunc(v))
        fmt.Println()
    }
}
```

## Exponentiation and Logarithms

### Exponentiation

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Exponentiation
    base := 2.0
    exponents := []float64{0, 1, 2, 3, 0.5, -1, -2}
    
    fmt.Println("Exponentiation:")
    for _, exp := range exponents {
        result := math.Pow(base, exp)
        fmt.Printf("%.1f^%.1f = %.4f\n", base, exp, result)
    }
    
    // Square root
    values := []float64{4, 9, 16, 2, 0.25}
    fmt.Println("\nSquare Roots:")
    for _, v := range values {
        sqrt := math.Sqrt(v)
        fmt.Printf("Sqrt(%.2f) = %.4f\n", v, sqrt)
    }
    
    // Cube root
    fmt.Println("\nCube Roots:")
    for _, v := range values {
        cbrt := math.Cbrt(v)
        fmt.Printf("Cbrt(%.2f) = %.4f\n", v, cbrt)
    }
}
```

### Logarithms

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Natural logarithm (base e)
    values := []float64{1, math.E, math.E * math.E, 10}
    fmt.Println("Natural Logarithms:")
    for _, v := range values {
        ln := math.Log(v)
        fmt.Printf("Ln(%.4f) = %.4f\n", v, ln)
    }
    
    // Base-2 logarithm
    fmt.Println("\nBase-2 Logarithms:")
    for _, v := range values {
        log2 := math.Log2(v)
        fmt.Printf("Log2(%.4f) = %.4f\n", v, log2)
    }
    
    // Base-10 logarithm
    fmt.Println("\nBase-10 Logarithms:")
    for _, v := range values {
        log10 := math.Log10(v)
        fmt.Printf("Log10(%.4f) = %.4f\n", v, log10)
    }
}
```

## Trigonometric Functions

### Basic Trigonometry

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Convert degrees to radians
    degToRad := func(deg float64) float64 {
        return deg * math.Pi / 180
    }
    
    angles := []float64{0, 30, 45, 60, 90, 180, 270, 360}
    
    fmt.Println("Trigonometric Functions:")
    fmt.Println("Angle (deg) | Angle (rad) | Sin     | Cos     | Tan")
    fmt.Println("-----------|-------------|---------|---------|---------")
    
    for _, deg := range angles {
        rad := degToRad(deg)
        sin := math.Sin(rad)
        cos := math.Cos(rad)
        tan := math.Tan(rad)
        
        fmt.Printf("%9.0f   | %11.4f | %7.4f | %7.4f | %7.4f\n", deg, rad, sin, cos, tan)
    }
}
```

### Inverse Trigonometric Functions

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Convert radians to degrees
    radToDeg := func(rad float64) float64 {
        return rad * 180 / math.Pi
    }
    
    values := []float64{-1, -0.5, 0, 0.5, 1}
    
    fmt.Println("Inverse Trigonometric Functions:")
    fmt.Println("Value | Asin (rad) | Asin (deg) | Acos (rad) | Acos (deg) | Atan (rad) | Atan (deg)")
    fmt.Println("------|------------|------------|------------|------------|------------|------------")
    
    for _, v := range values {
        asin := math.Asin(v)
        acos := math.Acos(v)
        atan := math.Atan(v)
        
        fmt.Printf("%5.1f | %10.4f | %10.4f | %10.4f | %10.4f | %10.4f | %10.4f\n", 
            v, asin, radToDeg(asin), acos, radToDeg(acos), atan, radToDeg(atan))
    }
}
```

### Hyperbolic Functions

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    values := []float64{-2, -1, 0, 1, 2}
    
    fmt.Println("Hyperbolic Functions:")
    fmt.Println("Value | Sinh    | Cosh    | Tanh")
    fmt.Println("------|---------|---------|---------")
    
    for _, v := range values {
        sinh := math.Sinh(v)
        cosh := math.Cosh(v)
        tanh := math.Tanh(v)
        
        fmt.Printf("%5.1f | %7.4f | %7.4f | %7.4f\n", v, sinh, cosh, tanh)
    }
    
    // Inverse hyperbolic functions
    fmt.Println("\nInverse Hyperbolic Functions:")
    fmt.Println("Value | Asinh   | Acosh   | Atanh")
    fmt.Println("------|---------|---------|---------")
    
    for _, v := range values {
        // Acosh is only defined for v >= 1
        // Atanh is only defined for -1 < v < 1
        asinh := math.Asinh(v)
        var acosh float64
        if v >= 1 {
            acosh = math.Acosh(v)
        } else {
            acosh = math.NaN()
        }
        var atanh float64
        if v > -1 && v < 1 {
            atanh = math.Atanh(v)
        } else {
            atanh = math.NaN()
        }
        
        fmt.Printf("%5.1f | %7.4f | %7.4f | %7.4f\n", v, asinh, acosh, atanh)
    }
}
```

## Special Functions

### Modulo Operation

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Modulo operation (remainder after division)
    values := []struct {
        x float64
        y float64
    }{
        {5, 3},
        {5, -3},
        {-5, 3},
        {-5, -3},
        {10.5, 3},
        {10.5, 2.5},
    }
    
    fmt.Println("Modulo Operation:")
    fmt.Println("x     | y     | x mod y")
    fmt.Println("------|-------|--------")
    
    for _, v := range values {
        mod := math.Mod(v.x, v.y)
        fmt.Printf("%5.1f | %5.1f | %7.4f\n", v.x, v.y, mod)
    }
}
```

### Signum Function

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Signum function (returns -1, 0, or 1)
    values := []float64{-5.2, -0.0, 0, 0.0, 3.14}
    
    fmt.Println("Signum Function:")
    for _, v := range values {
        sign := math.Copysign(1, v)
        if v == 0 {
            sign = 0
        }
        fmt.Printf("Sign(%.2f) = %.0f\n", v, sign)
    }
    
    // CopySign function
    fmt.Println("\nCopySign Function:")
    magnitudes := []float64{5.2, 3.14, 1.0}
    signs := []float64{-1.0, 1.0, -0.0}
    
    for _, mag := range magnitudes {
        for _, sign := range signs {
            result := math.Copysign(mag, sign)
            fmt.Printf("CopySign(%.2f, %.2f) = %.2f\n", mag, sign, result)
        }
    }
}
```

### Remainder Function

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Remainder function (similar to Mod but with different behavior for negative numbers)
    values := []struct {
        x float64
        y float64
    }{
        {5, 3},
        {5, -3},
        {-5, 3},
        {-5, -3},
        {10.5, 3},
        {10.5, 2.5},
    }
    
    fmt.Println("Remainder Function:")
    fmt.Println("x     | y     | Remainder")
    fmt.Println("------|-------|----------")
    
    for _, v := range values {
        rem := math.Remainder(v.x, v.y)
        fmt.Printf("%5.1f | %5.1f | %9.4f\n", v.x, v.y, rem)
    }
}
```

### Special Values

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Special values
    fmt.Println("Special Values:")
    fmt.Printf("Positive Infinity: %g\n", math.Inf(1))
    fmt.Printf("Negative Infinity: %g\n", math.Inf(-1))
    fmt.Printf("Not a Number (NaN): %g\n", math.NaN())
    
    // Check for special values
    values := []float64{1.0, math.Inf(1), math.Inf(-1), math.NaN()}
    
    fmt.Println("\nChecking Special Values:")
    for _, v := range values {
        fmt.Printf("Value: %g\n", v)
        fmt.Printf("  IsInf(1): %t\n", math.IsInf(v, 1))
        fmt.Printf("  IsInf(-1): %t\n", math.IsInf(v, -1))
        fmt.Printf("  IsNaN: %t\n", math.IsNaN(v))
        fmt.Printf("  IsFinite: %t\n", !math.IsInf(v, 0) && !math.IsNaN(v))
        fmt.Println()
    }
}
```

## Random Number Generation

While the `math` package doesn't directly provide random number generation, it's often used in conjunction with the `math/rand` package for mathematical operations on random numbers.

```go
package main

import (
    "fmt"
    "math"
    "math/rand"
    "time"
)

func main() {
    // Seed the random number generator
    rand.Seed(time.Now().UnixNano())
    
    // Generate random numbers in different ranges
    fmt.Println("Random Numbers:")
    
    // Random float between 0 and 1
    for i := 0; i < 5; i++ {
        r := rand.Float64()
        fmt.Printf("Random [0,1): %f\n", r)
    }
    
    // Random float in a custom range [min, max)
    min, max := 5.0, 10.0
    fmt.Printf("\nRandom numbers in range [%.1f, %.1f):\n", min, max)
    for i := 0; i < 5; i++ {
        r := min + rand.Float64()*(max-min)
        fmt.Printf("%.2f\n", r)
    }
    
    // Random integer in a range [min, max]
    minInt, maxInt := 1, 100
    fmt.Printf("\nRandom integers in range [%d, %d]:\n", minInt, maxInt)
    for i := 0; i < 5; i++ {
        r := minInt + rand.Intn(maxInt-minInt+1)
        fmt.Printf("%d\n", r)
    }
    
    // Normally distributed random numbers
    fmt.Println("\nNormally distributed random numbers (mean=0, stddev=1):")
    for i := 0; i < 5; i++ {
        r := rand.NormFloat64()
        fmt.Printf("%.4f\n", r)
    }
    
    // Exponentially distributed random numbers
    fmt.Println("\nExponentially distributed random numbers (rate=1):")
    for i := 0; i < 5; i++ {
        r := rand.ExpFloat64()
        fmt.Printf("%.4f\n", r)
    }
}
```

## Complex Numbers

The `math/cmplx` package provides functions for complex numbers, which are built on top of the `math` package.

```go
package main

import (
    "fmt"
    "math"
    "math/cmplx"
)

func main() {
    // Create complex numbers
    a := complex(3, 4)  // 3 + 4i
    b := complex(1, -2) // 1 - 2i
    
    fmt.Printf("a = %v\n", a)
    fmt.Printf("b = %v\n", b)
    
    // Basic operations
    fmt.Println("\nBasic Operations:")
    fmt.Printf("a + b = %v\n", a+b)
    fmt.Printf("a - b = %v\n", a-b)
    fmt.Printf("a * b = %v\n", a*b)
    fmt.Printf("a / b = %v\n", a/b)
    
    // Complex number functions
    fmt.Println("\nComplex Number Functions:")
    fmt.Printf("Real(a) = %v\n", real(a))
    fmt.Printf("Imag(a) = %v\n", imag(a))
    fmt.Printf("Conj(a) = %v\n", cmplx.Conj(a))
    fmt.Printf("Abs(a) = %v\n", cmplx.Abs(a))
    fmt.Printf("Phase(a) = %v\n", cmplx.Phase(a))
    
    // Polar form
    r, theta := cmplx.Polar(a)
    fmt.Printf("Polar form of a: r = %v, θ = %v\n", r, theta)
    fmt.Printf("Back to rectangular: %v\n", cmplx.Rect(r, theta))
    
    // Complex exponentials and logarithms
    fmt.Println("\nComplex Exponentials and Logarithms:")
    fmt.Printf("Exp(a) = %v\n", cmplx.Exp(a))
    fmt.Printf("Log(a) = %v\n", cmplx.Log(a))
    fmt.Printf("Sqrt(a) = %v\n", cmplx.Sqrt(a))
    
    // Complex trigonometric functions
    fmt.Println("\nComplex Trigonometric Functions:")
    fmt.Printf("Sin(a) = %v\n", cmplx.Sin(a))
    fmt.Printf("Cos(a) = %v\n", cmplx.Cos(a))
    fmt.Printf("Tan(a) = %v\n", cmplx.Tan(a))
}
```

## Best Practices

### 1. Handle Special Values

```go
package main

import (
    "fmt"
    "math"
)

func safeSqrt(x float64) (float64, error) {
    if x < 0 {
        return 0, fmt.Errorf("square root of negative number")
    }
    return math.Sqrt(x), nil
}

func main() {
    values := []float64{4, -1, 0}
    
    for _, v := range values {
        result, err := safeSqrt(v)
        if err != nil {
            fmt.Printf("Sqrt(%.1f): Error - %v\n", v, err)
        } else {
            fmt.Printf("Sqrt(%.1f): %.4f\n", v, result)
        }
    }
}
```

### 2. Use Appropriate Precision

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Be aware of floating-point precision
    a := 0.1
    b := 0.2
    sum := a + b
    
    fmt.Printf("%.20f + %.20f = %.20f\n", a, b, sum)
    fmt.Printf("Expected: %.20f\n", 0.3)
    fmt.Printf("Equal: %t\n", sum == 0.3) // This will be false due to precision issues
    
    // Use a tolerance for comparison
    tolerance := 1e-10
    equal := math.Abs(sum-0.3) < tolerance
    fmt.Printf("Equal with tolerance: %t\n", equal)
}
```

### 3. Avoid Division by Zero

```go
package main

import (
    "fmt"
    "math"
)

func safeDivide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("division by zero")
    }
    return a / b, nil
}

func main() {
    values := []struct {
        a float64
        b float64
    }{
        {10, 2},
        {10, 0},
        {0, 5},
    }
    
    for _, v := range values {
        result, err := safeDivide(v.a, v.b)
        if err != nil {
            fmt.Printf("%.1f / %.1f: Error - %v\n", v.a, v.b, err)
        } else {
            fmt.Printf("%.1f / %.1f = %.4f\n", v.a, v.b, result)
        }
    }
}
```

### 4. Use Constants for Readability

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // Use math constants for readability and precision
    radius := 5.0
    
    // Calculate circumference
    circumference := 2 * math.Pi * radius
    fmt.Printf("Circumference: %.2f\n", circumference)
    
    // Calculate area
    area := math.Pi * math.Pow(radius, 2)
    fmt.Printf("Area: %.2f\n", area)
    
    // Calculate volume of a sphere
    volume := (4.0 / 3.0) * math.Pi * math.Pow(radius, 3)
    fmt.Printf("Volume: %.2f\n", volume)
}
```

### 5. Be Aware of Performance

```go
package main

import (
    "fmt"
    "math"
    "time"
)

func main() {
    // Compare performance of different approaches
    n := 10000000
    values := make([]float64, n)
    for i := range values {
        values[i] = float64(i)
    }
    
    // Using math.Pow
    start := time.Now()
    sum1 := 0.0
    for _, v := range values {
        sum1 += math.Pow(v, 2)
    }
    elapsed1 := time.Since(start)
    
    // Using multiplication
    start = time.Now()
    sum2 := 0.0
    for _, v := range values {
        sum2 += v * v
    }
    elapsed2 := time.Since(start)
    
    fmt.Printf("Using math.Pow: %v, sum = %.0f\n", elapsed1, sum1)
    fmt.Printf("Using multiplication: %v, sum = %.0f\n", elapsed2, sum2)
    fmt.Printf("Multiplication is %.2fx faster\n", float64(elapsed1)/float64(elapsed2))
}
```

## Real-World Example: Statistical Analysis

Let's create a comprehensive example that demonstrates various mathematical functions in a statistical analysis context:

```go
package main

import (
    "fmt"
    "math"
    "math/rand"
    "sort"
    "time"
)

type Stats struct {
    Count     int
    Min       float64
    Max       float64
    Sum       float64
    Mean      float64
    Median    float64
    Mode      float64
    Variance  float64
    StdDev    float64
    Skewness  float64
    Kurtosis  float64
}

func main() {
    // Generate some sample data
    rand.Seed(time.Now().UnixNano())
    data := make([]float64, 1000)
    for i := range data {
        // Generate normally distributed data
        data[i] = rand.NormFloat64()*2 + 10
    }
    
    // Calculate statistics
    stats := CalculateStats(data)
    
    // Print results
    fmt.Println("Statistical Analysis:")
    fmt.Printf("Count: %d\n", stats.Count)
    fmt.Printf("Min: %.4f\n", stats.Min)
    fmt.Printf("Max: %.4f\n", stats.Max)
    fmt.Printf("Sum: %.4f\n", stats.Sum)
    fmt.Printf("Mean: %.4f\n", stats.Mean)
    fmt.Printf("Median: %.4f\n", stats.Median)
    fmt.Printf("Mode: %.4f\n", stats.Mode)
    fmt.Printf("Variance: %.4f\n", stats.Variance)
    fmt.Printf("Standard Deviation: %.4f\n", stats.StdDev)
    fmt.Printf("Skewness: %.4f\n", stats.Skewness)
    fmt.Printf("Kurtosis: %.4f\n", stats.Kurtosis)
    
    // Calculate percentiles
    percentiles := []float64{10, 25, 50, 75, 90}
    fmt.Println("\nPercentiles:")
    for _, p := range percentiles {
        value := Percentile(data, p)
        fmt.Printf("%dth percentile: %.4f\n", int(p), value)
    }
    
    // Histogram
    fmt.Println("\nHistogram:")
    bins := 10
    hist := Histogram(data, bins)
    min := stats.Min
    max := stats.Max
    binWidth := (max - min) / float64(bins)
    
    for i, count := range hist {
        binStart := min + float64(i)*binWidth
        binEnd := binStart + binWidth
        bar := strings.Repeat("*", count/10) // Scale down for display
        fmt.Printf("[%.2f, %.2f): %d %s\n", binStart, binEnd, count, bar)
    }
}

func CalculateStats(data []float64) Stats {
    if len(data) == 0 {
        return Stats{}
    }
    
    // Sort data for median and percentiles
    sorted := make([]float64, len(data))
    copy(sorted, data)
    sort.Float64s(sorted)
    
    // Basic statistics
    count := len(data)
    min := sorted[0]
    max := sorted[count-1]
    sum := 0.0
    for _, v := range data {
        sum += v
    }
    mean := sum / float64(count)
    
    // Median
    var median float64
    if count%2 == 0 {
        median = (sorted[count/2-1] + sorted[count/2]) / 2
    } else {
        median = sorted[count/2]
    }
    
    // Mode (simplified implementation)
    freq := make(map[float64]int)
    for _, v := range data {
        freq[v]++
    }
    
    mode := sorted[0]
    maxFreq := 1
    for v, f := range freq {
        if f > maxFreq {
            maxFreq = f
            mode = v
        }
    }
    
    // Variance and standard deviation
    variance := 0.0
    for _, v := range data {
        variance += math.Pow(v-mean, 2)
    }
    variance /= float64(count)
    stdDev := math.Sqrt(variance)
    
    // Skewness and kurtosis
    skewness := 0.0
    kurtosis := 0.0
    for _, v := range data {
        z := (v - mean) / stdDev
        skewness += math.Pow(z, 3)
        kurtosis += math.Pow(z, 4)
    }
    skewness /= float64(count)
    kurtosis = kurtosis/float64(count) - 3
    
    return Stats{
        Count:    count,
        Min:      min,
        Max:      max,
        Sum:      sum,
        Mean:     mean,
        Median:   median,
        Mode:     mode,
        Variance: variance,
        StdDev:   stdDev,
        Skewness: skewness,
        Kurtosis: kurtosis,
    }
}

func Percentile(data []float64, p float64) float64 {
    if len(data) == 0 {
        return math.NaN()
    }
    
    // Sort data if not already sorted
    sorted := make([]float64, len(data))
    copy(sorted, data)
    sort.Float64s(sorted)
    
    // Calculate percentile
    n := float64(len(sorted))
    pos := p / 100 * (n - 1)
    
    lower := math.Floor(pos)
    upper := math.Ceil(pos)
    
    if lower == upper {
        return sorted[int(lower)]
    }
    
    d := pos - lower
    return sorted[int(lower)] + d*(sorted[int(upper)]-sorted[int(lower)])
}

func Histogram(data []float64, bins int) []int {
    if len(data) == 0 || bins <= 0 {
        return nil
    }
    
    // Find min and max
    min, max := data[0], data[0]
    for _, v := range data {
        if v < min {
            min = v
        }
        if v > max {
            max = v
        }
    }
    
    // Create histogram
    hist := make([]int, bins)
    binWidth := (max - min) / float64(bins)
    
    for _, v := range data {
        bin := int((v - min) / binWidth)
        if bin >= bins {
            bin = bins - 1
        }
        hist[bin]++
    }
    
    return hist
}
```

### How This Example Demonstrates Math Concepts:

1. **Basic Statistics**:
   - Calculating min, max, sum, and mean
   - Finding median and mode
   - Computing variance and standard deviation

2. **Advanced Statistics**:
   - Calculating skewness and kurtosis
   - Computing percentiles
   - Creating histograms

3. **Math Functions**:
   - Using `math.Pow` for variance calculation
   - Using `math.Sqrt` for standard deviation
   - Using `math.Floor` and `math.Ceil` for percentile calculation

4. **Data Analysis**:
   - Sorting data for statistical calculations
   - Binning data for histogram creation
   - Visualizing data distribution

5. **Real-World Application**:
   - Statistical analysis of normally distributed data
   - Visualization of data distribution through histograms
   - Calculation of various statistical measures

## Conclusion

The `math` package is a fundamental part of Go's standard library for mathematical operations:

### Key Takeaways:
1. **Constants**:
   - Provides important mathematical constants like Pi, E, and Phi
   - Includes machine-specific constants for numeric limits

2. **Basic Operations**:
   - Min, Max, Abs for basic comparisons
   - Floor, Ceil, Round, Trunc for rounding operations

3. **Exponentiation and Logarithms**:
   - Pow, Sqrt, Cbrt for power operations
   - Log, Log2, Log10 for logarithmic functions

4. **Trigonometric Functions**:
   - Sin, Cos, Tan and their inverses
   - Hyperbolic functions and their inverses

5. **Special Functions**:
   - Mod, Remainder for modulo operations
   - Copysign for sign manipulation
   - Functions for handling special values like Inf and NaN

6. **Best Practices**:
   - Handle special values and edge cases
   - Be aware of floating-point precision limitations
   - Avoid division by zero
   - Use constants for readability
   - Consider performance implications

By mastering the `math` package, you'll be able to perform a wide range of mathematical operations in your Go applications, from basic arithmetic to complex statistical analysis. The functions provided by this package are optimized for performance and accuracy, making them suitable for scientific computing, graphics programming, and any application that requires mathematical operations.