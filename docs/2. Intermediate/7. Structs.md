

# Go Structs: Custom Data Types and Composition

!!! abstract "Overview"
    Master Go structs - collections of fields that form custom data types. Learn struct definition, initialization, methods, embedding, and composition patterns for building robust, maintainable applications.

!!! tip "Key Points"
    - Structs group related data into single entities
    - Support both value and pointer semantics
    - Enable composition over inheritance
    - Fields can be exported (public) or unexported (private)
    - Zero values provide safe defaults

## Understanding Structs

Structs are Go's primary mechanism for creating custom data types by grouping related fields together.

!!! info "Struct Composition"
    ```mermaid
    graph LR
        A[Struct] --> B[Fields]
        A --> C[Methods]
        A --> D[Tags]
        B --> E[Named Fields]
        B --> F[Typed Fields]
        C --> G[Value Receivers]
        C --> H[Pointer Receivers]
        D --> I[Metadata]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Defining Structs

!!! example "Basic Struct Definition"
    ```go title="struct_definition.go" linenums="1" hl_lines="3-7"
    package main

    type Person struct {
        Name string
        Age  int
        Email string
    }

    func main() {
        // Struct usage
        p := Person{Name: "Alice", Age: 30, Email: "alice@example.com"}
        fmt.Printf("%+v\n", p)
    }
    ```

### Struct Characteristics:
- **Fields**: Each field has a name and a type
- **Order**: Field order matters for memory layout
- **Exportability**: Capitalized fields are exported (public)
- **Zero Values**: Each field has a zero value when uninitialized

## Creating and Initializing Structs

!!! example "Struct Initialization Methods"
    ```go title="struct_initialization.go" linenums="1" hl_lines="8-25"
    package main

    import "fmt"

    type Person struct {
        Name  string
        Age   int
        Email string
    }

    func main() {
        // Named initialization
        p1 := Person{
            Name:  "Alice",
            Age:   30,
            Email: "alice@example.com",
        }
        fmt.Printf("Named: %+v\n", p1)
        
        // Positional initialization (must match field order)
        p2 := Person{"Bob", 25, "bob@example.com"}
        fmt.Printf("Positional: %+v\n", p2)
        
        // Using new() returns a pointer to a zero-value struct
        p3 := new(Person)
        p3.Name = "Charlie"
        p3.Age = 35
        fmt.Printf("New: %+v\n", p3)
        
        // Partial initialization
        p4 := Person{Name: "Diana"}
        fmt.Printf("Partial: %+v\n", p4) // Email is empty string, Age is 0
    }
    ```

## Accessing and Modifying Struct Fields

!!! example "Field Access and Modification"
    ```go title="field_access.go" linenums="1" hl_lines="8-19"
    package main

    import "fmt"

    type Person struct {
        Name  string
        Age   int
        Email string
    }

    func main() {
        p := Person{Name: "Alice", Age: 30}
        
        // Access fields
        fmt.Println("Name:", p.Name)
        fmt.Println("Age:", p.Age)
        
        // Modify fields
        p.Age = 31
        fmt.Println("New Age:", p.Age)
        
        // Working with pointers
        pPtr := &Person{Name: "Bob", Age: 25}
        pPtr.Age = 26        // Same as (*pPtr).Age = 26
        fmt.Println("Pointer Age:", pPtr.Age)
    }
    ```

## Structs with Methods

Methods are functions with a special receiver argument. They can be defined on any named type.

!!! example "Value and Pointer Receivers"
    ```go title="method_receivers.go" linenums="1" hl_lines="8-24"
    package main

    import "fmt"

    type Rectangle struct {
        Width, Height float64
    }

    // Method with value receiver
    func (r Rectangle) Area() float64 {
        return r.Width * r.Height
    }

    // Method with pointer receiver (can modify struct)
    func (r *Rectangle) Scale(factor float64) {
        r.Width *= factor
        r.Height *= factor
    }

    func main() {
        rect := Rectangle{Width: 10, Height: 5}
        fmt.Println("Area:", rect.Area()) // 50
        
        rect.Scale(2)
        fmt.Printf("Scaled: %+v\n", rect) // {Width:20 Height:10}
    }
    ```

### When to Use Pointer Receivers:
1. When you need to modify the receiver
2. When the struct is large (to avoid copying)
3. When consistency is needed (mixing value and pointer receivers can be confusing)

## Struct Composition (Embedding)

Go supports composition through struct embedding, which allows one struct to include another, inheriting its fields and methods.

!!! example "Basic Embedding"
    ```go title="basic_embedding.go" linenums="1" hl_lines="8-28"
    package main

    import "fmt"

    type Address struct {
        Street string
        City   string
    }

    type Person struct {
        Name    string
        Age     int
        Address // Embedded struct
    }

    func (a Address) FullAddress() string {
        return fmt.Sprintf("%s, %s", a.Street, a.City)
    }

    func main() {
        p := Person{
            Name: "Alice",
            Age:  30,
            Address: Address{
                Street: "123 Main St",
                City:   "New York",
            },
        }
        
        // Access embedded fields directly
        fmt.Println("City:", p.City)       // New York
        fmt.Println("Street:", p.Street)    // 123 Main St
        
        // Access via embedded type name
        fmt.Println("City:", p.Address.City) // New York
        
        // Can call embedded method directly
        fmt.Println(p.FullAddress()) // 123 Main St, New York
    }
    ```

!!! example "Overriding Embedded Methods"
    ```go title="method_override.go" linenums="1" hl_lines="14-20"
    package main

    import "fmt"

    type Address struct {
        Street string
        City   string
    }

    func (a Address) FullAddress() string {
        return fmt.Sprintf("%s, %s", a.Street, a.City)
    }

    type Person struct {
        Name    string
        Age     int
        Address // Embedded struct
    }

    func (p Person) FullAddress() string {
        return fmt.Sprintf("%s: %s, %s", p.Name, p.Street, p.City)
    }

    func main() {
        p := Person{
            Name: "Alice",
            Address: Address{
                Street: "123 Main St",
                City:   "New York",
            },
        }
        
        fmt.Println(p.FullAddress()) // Alice: 123 Main St, New York
    }
    ```

## Struct Tags

Struct tags are metadata attached to struct fields that provide instructions to other packages, commonly used for serialization, validation, and ORM mapping.

!!! example "Struct Tags"
    ```go title="struct_tags.go" linenums="1" hl_lines="3-11"
    package main

    type User struct {
        ID       int    `json:"id"`
        Username string `json:"username"`
        Email    string `json:"email" validate:"required"`
        Password string `json:"-"` // "-" means ignore this field
    }

    type Product struct {
        ID          int     `json:"id"`
        Name        string  `json:"name"`
        Price       float64 `json:"price,omitempty"` // Omit if zero value
        Description string  `json:"description,omitempty"`
    }

    type Customer struct {
        ID        int       `db:"id"`
        FirstName string    `db:"first_name"`
        LastName  string    `db:"last_name"`
        CreatedAt time.Time `db:"created_at"`
    }
    ```

### Common Tag Formats:
1. **JSON Serialization**: `json:"field_name"`
2. **Database Mapping**: `db:"column_name"`
3. **Validation**: `validate:"required,email"`

## Comparing Structs

Structs can be compared using `==` and `!=` operators if all their fields are comparable:

!!! example "Struct Comparison"
    ```go title="struct_comparison.go" linenums="1" hl_lines="8-19"
    package main

    import "fmt"

    type Point struct {
        X, Y int
    }

    func main() {
        p1 := Point{X: 1, Y: 2}
        p2 := Point{X: 1, Y: 2}
        p3 := Point{X: 1, Y: 3}
        
        fmt.Println(p1 == p2) // true
        fmt.Println(p1 == p3) // false
        
        // Limitations:
        // - Structs with slice or map fields cannot be compared directly
        // - Structs with function fields cannot be compared
        // - For complex comparisons, implement a custom method
    }
    ```

## Real-World Example: JSON API Handler

Let's build a practical example that demonstrates struct usage in a web API context:

!!! example "JSON API Handler"
    ```go title="api_handler.go" linenums="1" hl_lines="8-60"
    package main

    import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "time"
    )

    // Product represents a product in our inventory
    type Product struct {
        ID          int       `json:"id"`
        Name        string    `json:"name" validate:"required"`
        Description string    `json:"description,omitempty"`
        Price       float64   `json:"price" validate:"required,gte=0"`
        Category    string    `json:"category"`
        InStock     bool      `json:"in_stock"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
    }

    // ProductRequest represents the JSON request body for creating/updating products
    type ProductRequest struct {
        Name        string  `json:"name" validate:"required"`
        Description string  `json:"description"`
        Price       float64 `json:"price" validate:"required,gte=0"`
        Category    string  `json:"category"`
        InStock     bool    `json:"in_stock"`
    }

    // ProductResponse wraps the product with metadata
    type ProductResponse struct {
        Success bool      `json:"success"`
        Message string    `json:"message,omitempty"`
        Data    *Product  `json:"data,omitempty"`
        Errors  []string  `json:"errors,omitempty"`
    }

    // ProductStore simulates a database
    type ProductStore struct {
        products map[int]*Product
        nextID   int
    }

    func NewProductStore() *ProductStore {
        return &ProductStore{
            products: make(map[int]*Product),
            nextID:   1,
        }
    }

    func (s *ProductStore) AddProduct(p *Product) int {
        p.ID = s.nextID
        p.CreatedAt = time.Now()
        p.UpdatedAt = time.Now()
        s.products[p.ID] = p
        s.nextID++
        return p.ID
    }

    func main() {
        store := NewProductStore()
        
        // Add some sample data
        store.AddProduct(&Product{
            Name:     "Laptop",
            Price:    999.99,
            Category: "Electronics",
            InStock:  true,
        })
        
        // Setup routes
        http.HandleFunc("/products", func(w http.ResponseWriter, r *http.Request) {
            // In a real app, this would be more complex
            product := &Product{
                ID:        1,
                Name:      "Laptop",
                Price:     999.99,
                Category:  "Electronics",
                InStock:   true,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
            }
            
            response := ProductResponse{
                Success: true,
                Data:    product,
            }
            
            json.NewEncoder(w).Encode(response)
        })
        
        fmt.Println("Server starting on port 8080...")
        log.Fatal(http.ListenAndServe(":8080", nil))
    }
    ```

### How This Example Demonstrates Struct Concepts:

1. **Struct Definition**:
   - `Product` struct with various field types
   - `ProductRequest` for input validation
   - `ProductResponse` for API responses

2. **Struct Tags**:
   - JSON tags for serialization (`json:"id"`)
   - Validation tags (`validate:"required"`)
   - Special tags like `omitempty` and `-`

3. **Method Definitions**:
   - Methods on `ProductStore` for data operations
   - Pointer receivers for modifying data

4. **Real-World Usage**:
   - JSON serialization/deserialization
   - API request/response handling

## Best Practices

!!! warning "Common Pitfalls"
    - Mixing value and pointer receivers inconsistently
    - Forgetting that struct fields are zero-valued when not initialized
    - Using deep embedding hierarchies that create confusion
    - Neglecting to use struct tags for serialization

!!! example "Best Practice Patterns"
    ```go title="best_practices.go" linenums="1" hl_lines="8-25"
    package main

    import "fmt"

    // Good: Clear field organization
    type User struct {
        ID        int      `json:"id"`
        Username  string   `json:"username"`
        Email     string   `json:"email"`
        CreatedAt time.Time `json:"created_at"`
        // Group related fields
        Profile UserProfile `json:"profile"`
    }

    type UserProfile struct {
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
        Bio       string `json:"bio,omitempty"`
    }

    // Good: Consistent method receivers
    func (u *User) UpdateEmail(email string) {
        u.Email = email
    }

    // Good: Proper use of struct tags
    type Config struct {
        Debug       bool   `json:"debug" yaml:"debug"`
        LogLevel    string `json:"log_level" yaml:"log_level"`
        DatabaseURL string `json:"database_url" yaml:"database_url"`
    }

    func main() {
        // Good: Named initialization for clarity
        user := User{
            Username: "johndoe",
            Email:    "john@example.com",
            Profile: UserProfile{
                FirstName: "John",
                LastName:  "Doe",
            },
        }
        
        fmt.Printf("%+v\n", user)
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Struct Definition**: Use `type Name struct { fields }` syntax
    - **Initialization**: Named initialization is preferred for clarity
    - **Methods**: Use pointer receivers when modification is needed
    - **Composition**: Embed structs to promote fields and methods
    - **Tags**: Add metadata for serialization, validation, and ORM
    - **Comparison**: Only comparable if all fields are comparable
    - **Best Practices**: Consistent receivers, clear field organization, proper tag usage

!!! quote "Remember"
    "Structs in Go provide a way to create custom data types that group related data together. They are the foundation of Go's approach to object-oriented programming, emphasizing composition over inheritance. Mastering structs is essential for building well-organized, maintainable Go applications."