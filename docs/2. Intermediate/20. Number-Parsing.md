

# Number Parsing in Go: A Comprehensive Guide

## Introduction to Number Parsing
Number parsing is the process of converting string representations of numbers into their corresponding numeric types. In Go, this is a common operation when dealing with user input, configuration files, network protocols, and data interchange formats. Go provides robust built-in functions for parsing numbers with proper error handling.

## Basic Integer Parsing

### 1. Parsing Integers
The `strconv` package provides functions for parsing integers from strings:

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// ParseInt with base 10
	i, err := strconv.ParseInt("123", 10, 64)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Parsed int64: %d, type: %T\n", i, i)

	// ParseInt with different bases
	bases := []int{2, 8, 10, 16}
	numbers := []string{"1010", "755", "123", "FF"}
	
	for i := range bases {
		n, err := strconv.ParseInt(numbers[i], bases[i], 64)
		if err != nil {
			fmt.Printf("Error parsing %s in base %d: %v\n", numbers[i], bases[i], err)
			continue
		}
		fmt.Printf("%s (base %d) = %d (decimal)\n", numbers[i], bases[i], n)
	}
}
```

### 2. Parsing with Specific Bit Sizes
```go
func main() {
	// Parse to int8
	i8, err := strconv.ParseInt("127", 10, 8)
	if err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Printf("int8: %d\n", int8(i8))
	}

	// Parse to int16
	i16, err := strconv.ParseInt("32767", 10, 16)
	if err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Printf("int16: %d\n", int16(i16))
	}

	// Parse to int32
	i32, err := strconv.ParseInt("2147483647", 10, 32)
	if err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Printf("int32: %d\n", int32(i32))
	}

	// Parse to int64
	i64, err := strconv.ParseInt("9223372036854775807", 10, 64)
	if err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Printf("int64: %d\n", i64)
	}
}
```

### 3. Parsing Unsigned Integers
```go
func main() {
	// ParseUint
	u, err := strconv.ParseUint("4294967295", 10, 64)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Parsed uint64: %d, type: %T\n", u, u)

	// Parse to uint8
	u8, err := strconv.ParseUint("255", 10, 8)
	if err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Printf("uint8: %d\n", uint8(u8))
	}

	// Parse to uint16
	u16, err := strconv.ParseUint("65535", 10, 16)
	if err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Printf("uint16: %d\n", uint16(u16))
	}
}
```

## Floating-Point Parsing

### 1. Parsing Floats
```go
func main() {
	// ParseFloat to float64
	f64, err := strconv.ParseFloat("3.14159", 64)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Parsed float64: %f, type: %T\n", f64, f64)

	// ParseFloat to float32
	f32, err := strconv.ParseFloat("3.14159", 32)
	if err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Printf("Parsed float32: %f, type: %T\n", float32(f32), f32)
	}

	// Scientific notation
	sci, err := strconv.ParseFloat("1.23e-4", 64)
	if err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Printf("Scientific notation: %g\n", sci)
	}
}
```

### 2. Special Floating-Point Values
```go
func main() {
	// Parse special values
	specialValues := []string{"inf", "+Inf", "-Inf", "NaN"}
	
	for _, val := range specialValues {
		f, err := strconv.ParseFloat(val, 64)
		if err != nil {
			fmt.Printf("Error parsing %s: %v\n", val, err)
			continue
		}
		fmt.Printf("%s -> %f\n", val, f)
	}
}
```

## Convenience Functions

### 1. Atoi and Itoa
For simple base-10 integer conversion:

```go
func main() {
	// Atoi (ASCII to integer)
	i, err := strconv.Atoi("123")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Atoi result: %d, type: %T\n", i, i)

	// Itoa (integer to ASCII)
	s := strconv.Itoa(456)
	fmt.Printf("Itoa result: %s, type: %T\n", s, s)
}
```

### 2. ParseBool
```go
func main() {
	// Parse boolean values
	boolStrings := []string{"true", "false", "1", "0", "t", "f", "TRUE", "FALSE"}
	
	for _, s := range boolStrings {
		b, err := strconv.ParseBool(s)
		if err != nil {
			fmt.Printf("Error parsing %q: %v\n", s, err)
			continue
		}
		fmt.Printf("%q -> %t\n", s, b)
	}
}
```

## Advanced Parsing Techniques

### 1. Parsing with Custom Formats
```go
func main() {
	// Parse number with commas
	numWithCommas := "1,234,567"
	
	// Remove commas before parsing
	cleaned := strings.ReplaceAll(numWithCommas, ",", "")
	num, err := strconv.ParseInt(cleaned, 10, 64)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Number with commas: %d\n", num)

	// Parse currency
	currency := "$1,234.56"
	cleaned = strings.ReplaceAll(currency, "$", "")
	cleaned = strings.ReplaceAll(cleaned, ",", "")
	f, err := strconv.ParseFloat(cleaned, 64)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Currency: %.2f\n", f)
}
```

### 2. Parsing Number Ranges
```go
func parseRange(s string) (min, max int, err error) {
	parts := strings.Split(s, "-")
	if len(parts) != 2 {
		return 0, 0, fmt.Errorf("invalid range format")
	}
	
	min, err = strconv.Atoi(strings.TrimSpace(parts[0]))
	if err != nil {
		return 0, 0, fmt.Errorf("invalid min value: %w", err)
	}
	
	max, err = strconv.Atoi(strings.TrimSpace(parts[1]))
	if err != nil {
		return 0, 0, fmt.Errorf("invalid max value: %w", err)
	}
	
	if min > max {
		return 0, 0, fmt.Errorf("min cannot be greater than max")
	}
	
	return min, max, nil
}

func main() {
	ranges := []string{"1-10", "100-200", "50-25"}
	
	for _, r := range ranges {
		min, max, err := parseRange(r)
		if err != nil {
			fmt.Printf("Error parsing %q: %v\n", r, err)
			continue
		}
		fmt.Printf("Range %q: %d to %d\n", r, min, max)
	}
}
```

### 3. Parsing Multiple Numbers from a String
```go
func parseNumbers(s string) ([]int, error) {
	fields := strings.Fields(s)
	numbers := make([]int, 0, len(fields))
	
	for _, field := range fields {
		num, err := strconv.Atoi(field)
		if err != nil {
			return nil, fmt.Errorf("invalid number %q: %w", field, err)
		}
		numbers = append(numbers, num)
	}
	
	return numbers, nil
}

func main() {
	data := "10 20 30 40 50"
	numbers, err := parseNumbers(data)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	
	fmt.Printf("Parsed numbers: %v\n", numbers)
	fmt.Printf("Sum: %d\n", sum(numbers))
}

func sum(numbers []int) int {
	total := 0
	for _, num := range numbers {
		total += num
	}
	return total
}
```

## Error Handling

### 1. Common Parsing Errors
```go
func main() {
	// Invalid number format
	_, err := strconv.ParseInt("abc", 10, 64)
	fmt.Printf("ParseInt error: %v\n", err) // strconv.ParseInt: parsing "abc": invalid syntax

	// Out of range
	_, err = strconv.ParseInt("999999999999999999999999999999", 10, 64)
	fmt.Printf("ParseInt error: %v\n", err) // strconv.ParseInt: parsing "999999999999999999999999999999": value out of range

	// Invalid base
	_, err = strconv.ParseInt("123", 37, 64) // Base must be between 2 and 36
	fmt.Printf("ParseInt error: %v\n", err)

	// Empty string
	_, err = strconv.ParseInt("", 10, 64)
	fmt.Printf("ParseInt error: %v\n", err)
}
```

### 2. Safe Parsing with Defaults
```go
func safeParseInt(s string, defaultValue int64) int64 {
	if s == "" {
		return defaultValue
	}
	
	i, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		return defaultValue
	}
	
	return i
}

func main() {
	values := []string{"123", "abc", "", "999999999999999999999999999999"}
	defaultValue := int64(0)
	
	for _, val := range values {
		result := safeParseInt(val, defaultValue)
		fmt.Printf("safeParseInt(%q, %d) = %d\n", val, defaultValue, result)
	}
}
```

### 3. Parsing with Validation
```go
func parsePositiveInt(s string) (int, error) {
	i, err := strconv.Atoi(s)
	if err != nil {
		return 0, fmt.Errorf("invalid integer: %w", err)
	}
	
	if i <= 0 {
		return 0, fmt.Errorf("value must be positive")
	}
	
	return i, nil
}

func parsePercentage(s string) (float64, error) {
	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return 0, fmt.Errorf("invalid percentage: %w", err)
	}
	
	if f < 0 || f > 100 {
		return 0, fmt.Errorf("percentage must be between 0 and 100")
	}
	
	return f, nil
}

func main() {
	// Test positive integer parsing
	intTests := []string{"10", "-5", "0", "abc"}
	for _, test := range intTests {
		result, err := parsePositiveInt(test)
		if err != nil {
			fmt.Printf("parsePositiveInt(%q): %v\n", test, err)
		} else {
			fmt.Printf("parsePositiveInt(%q): %d\n", test, result)
		}
	}

	// Test percentage parsing
	percentTests := []string{"50", "150", "-10", "abc"}
	for _, test := range percentTests {
		result, err := parsePercentage(test)
		if err != nil {
			fmt.Printf("parsePercentage(%q): %v\n", test, err)
		} else {
			fmt.Printf("parsePercentage(%q): %.1f%%\n", test, result)
		}
	}
}
```

## Real-World Example: Configuration Parser

Let's build a comprehensive configuration parser that handles various number formats:

```go
package main

import (
	"fmt"
	"strconv"
	"strings"
	"time"
)

// Config represents application configuration
type Config struct {
	ServerPort     int
	MaxConnections int
	Timeout        time.Duration
	CacheSize      int64
	DebugMode      bool
	Threshold      float64
	RetryCount     int
}

// ConfigParser handles parsing configuration values
type ConfigParser struct {
	values map[string]string
}

func NewConfigParser(values map[string]string) *ConfigParser {
	return &ConfigParser{
		values: values,
	}
}

func (cp *ConfigParser) Parse() (*Config, error) {
	config := &Config{}
	
	// Parse server port
	port, err := cp.parseInt("server_port", 8080, 1, 65535)
	if err != nil {
		return nil, fmt.Errorf("invalid server_port: %w", err)
	}
	config.ServerPort = port
	
	// Parse max connections
	maxConn, err := cp.parseInt("max_connections", 100, 1, 10000)
	if err != nil {
		return nil, fmt.Errorf("invalid max_connections: %w", err)
	}
	config.MaxConnections = maxConn
	
	// Parse timeout (supports duration strings)
	timeout, err := cp.parseDuration("timeout", 30*time.Second)
	if err != nil {
		return nil, fmt.Errorf("invalid timeout: %w", err)
	}
	config.Timeout = timeout
	
	// Parse cache size (supports K, M, G suffixes)
	cacheSize, err := cp.parseSize("cache_size", 1024*1024) // Default 1MB
	if err != nil {
		return nil, fmt.Errorf("invalid cache_size: %w", err)
	}
	config.CacheSize = cacheSize
	
	// Parse debug mode
	debug, err := cp.parseBool("debug_mode", false)
	if err != nil {
		return nil, fmt.Errorf("invalid debug_mode: %w", err)
	}
	config.DebugMode = debug
	
	// Parse threshold
	threshold, err := cp.parseFloat("threshold", 0.5, 0.0, 1.0)
	if err != nil {
		return nil, fmt.Errorf("invalid threshold: %w", err)
	}
	config.Threshold = threshold
	
	// Parse retry count
	retryCount, err := cp.parseInt("retry_count", 3, 0, 10)
	if err != nil {
		return nil, fmt.Errorf("invalid retry_count: %w", err)
	}
	config.RetryCount = retryCount
	
	return config, nil
}

func (cp *ConfigParser) parseInt(key string, defaultValue, min, max int) (int, error) {
	value, exists := cp.values[key]
	if !exists || value == "" {
		return defaultValue, nil
	}
	
	i, err := strconv.Atoi(value)
	if err != nil {
		return 0, fmt.Errorf("invalid integer: %w", err)
	}
	
	if i < min || i > max {
		return 0, fmt.Errorf("value %d is out of range [%d, %d]", i, min, max)
	}
	
	return i, nil
}

func (cp *ConfigParser) parseFloat(key string, defaultValue, min, max float64) (float64, error) {
	value, exists := cp.values[key]
	if !exists || value == "" {
		return defaultValue, nil
	}
	
	f, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return 0, fmt.Errorf("invalid float: %w", err)
	}
	
	if f < min || f > max {
		return 0, fmt.Errorf("value %f is out of range [%f, %f]", f, min, max)
	}
	
	return f, nil
}

func (cp *ConfigParser) parseBool(key string, defaultValue bool) (bool, error) {
	value, exists := cp.values[key]
	if !exists || value == "" {
		return defaultValue, nil
	}
	
	b, err := strconv.ParseBool(value)
	if err != nil {
		return false, fmt.Errorf("invalid boolean: %w", err)
	}
	
	return b, nil
}

func (cp *ConfigParser) parseDuration(key string, defaultValue time.Duration) (time.Duration, error) {
	value, exists := cp.values[key]
	if !exists || value == "" {
		return defaultValue, nil
	}
	
	// Try to parse as duration string first
	duration, err := time.ParseDuration(value)
	if err == nil {
		return duration, nil
	}
	
	// If that fails, try to parse as seconds
	seconds, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return 0, fmt.Errorf("invalid duration: %w", err)
	}
	
	return time.Duration(seconds * float64(time.Second)), nil
}

func (cp *ConfigParser) parseSize(key string, defaultValue int64) (int64, error) {
	value, exists := cp.values[key]
	if !exists || value == "" {
		return defaultValue, nil
	}
	
	// Check for size suffixes
	suffixes := map[string]int64{
		"K": 1024,
		"M": 1024 * 1024,
		"G": 1024 * 1024 * 1024,
		"T": 1024 * 1024 * 1024 * 1024,
	}
	
	for suffix, multiplier := range suffixes {
		if strings.HasSuffix(value, suffix) {
			numStr := strings.TrimSuffix(value, suffix)
			num, err := strconv.ParseInt(numStr, 10, 64)
			if err != nil {
				return 0, fmt.Errorf("invalid size: %w", err)
			}
			return num * multiplier, nil
		}
	}
	
	// No suffix, parse as bytes
	return strconv.ParseInt(value, 10, 64)
}

func main() {
	// Sample configuration values
	configValues := map[string]string{
		"server_port":     "8080",
		"max_connections": "100",
		"timeout":        "30s",
		"cache_size":     "2M",
		"debug_mode":     "true",
		"threshold":      "0.75",
		"retry_count":    "3",
	}
	
	// Parse configuration
	parser := NewConfigParser(configValues)
	config, err := parser.Parse()
	if err != nil {
		fmt.Printf("Error parsing configuration: %v\n", err)
		return
	}
	
	// Print parsed configuration
	fmt.Println("=== Parsed Configuration ===")
	fmt.Printf("Server Port: %d\n", config.ServerPort)
	fmt.Printf("Max Connections: %d\n", config.MaxConnections)
	fmt.Printf("Timeout: %v\n", config.Timeout)
	fmt.Printf("Cache Size: %d bytes\n", config.CacheSize)
	fmt.Printf("Debug Mode: %t\n", config.DebugMode)
	fmt.Printf("Threshold: %.2f\n", config.Threshold)
	fmt.Printf("Retry Count: %d\n", config.RetryCount)
	
	// Test error cases
	fmt.Println("\n=== Testing Error Cases ===")
	errorConfigs := []map[string]string{
		{"server_port": "99999"}, // Out of range
		{"timeout": "invalid"},    // Invalid duration
		{"cache_size": "2X"},     // Invalid suffix
		{"debug_mode": "maybe"},   // Invalid boolean
	}
	
	for i, values := range errorConfigs {
		fmt.Printf("\nTest case %d:\n", i+1)
		parser := NewConfigParser(values)
		_, err := parser.Parse()
		if err != nil {
			fmt.Printf("Expected error: %v\n", err)
		} else {
			fmt.Println("Unexpected success")
		}
	}
}
```

### How This Example Works:

1. **Configuration Structure**:
   - Defines a `Config` struct with various numeric and boolean fields
   - Supports different data types (int, float64, bool, duration, size)

2. **Parser Implementation**:
   - `ConfigParser` handles parsing of configuration values
   - Provides type-specific parsing methods with validation
   - Supports default values and range checking

3. **Advanced Parsing Features**:
   - Duration parsing (supports "30s", "1h", etc.)
   - Size parsing with suffixes (K, M, G, T)
   - Boolean parsing with multiple formats
   - Range validation for all numeric values

4. **Error Handling**:
   - Comprehensive error messages
   - Graceful handling of missing values
   - Type-specific validation

### Real-World Applications:

1. **Application Configuration**:
   - Environment variable parsing
   - Configuration file parsing
   - Command-line argument processing

2. **Data Validation**:
   - User input validation
   - API parameter parsing
   - Form data processing

3. **Protocol Handling**:
   - Network protocol parsing
   - File format parsing
   - Database result processing

## Best Practices

### 1. Always Check Errors
```go
// Good: Check errors
i, err := strconv.Atoi("123")
if err != nil {
    // Handle error
}

// Bad: Ignore errors
i, _ := strconv.Atoi("123") // Might panic on invalid input
```

### 2. Validate Input Ranges
```go
// Good: Validate range
func parsePort(s string) (int, error) {
    port, err := strconv.Atoi(s)
    if err != nil {
        return 0, err
    }
    if port < 1 || port > 65535 {
        return 0, fmt.Errorf("port must be between 1 and 65535")
    }
    return port, nil
}

// Bad: No validation
func parsePortBad(s string) (int, error) {
    return strconv.Atoi(s)
}
```

### 3. Provide Default Values
```go
// Good: Provide defaults
func parseIntWithDefault(s string, defaultValue int) int {
    if s == "" {
        return defaultValue
    }
    i, err := strconv.Atoi(s)
    if err != nil {
        return defaultValue
    }
    return i
}

// Bad: No default handling
func parseIntBad(s string) int {
    i, _ := strconv.Atoi(s)
    return i
}
```

### 4. Use Appropriate Types
```go
// Good: Use appropriate bit size
func parseUserID(s string) (int32, error) {
    i, err := strconv.ParseInt(s, 10, 32)
    if err != nil {
        return 0, err
    }
    return int32(i), nil
}

// Bad: Always use int64
func parseUserIDBad(s string) (int64, error) {
    return strconv.ParseInt(s, 10, 64)
}
```

## Performance Considerations

### 1. Reuse Parsers
```go
// Good: Reuse scanner
scanner := bufio.NewScanner(strings.NewReader("1 2 3 4 5"))
for scanner.Scan() {
    num, err := strconv.Atoi(scanner.Text())
    // ...
}

// Bad: Create new scanner for each number
data := "1 2 3 4 5"
fields := strings.Fields(data)
for _, field := range fields {
    num, err := strconv.Atoi(field)
    // ...
}
```

### 2. Batch Processing
```go
// Good: Process in batches
func parseNumbersBatch(data []string) ([]int, error) {
    numbers := make([]int, len(data))
    for i, s := range data {
        num, err := strconv.Atoi(s)
        if err != nil {
            return nil, err
        }
        numbers[i] = num
    }
    return numbers, nil
}

// Bad: Process one by one with append
func parseNumbersBad(data []string) ([]int, error) {
    var numbers []int
    for _, s := range data {
        num, err := strconv.Atoi(s)
        if err != nil {
            return nil, err
        }
        numbers = append(numbers, num)
    }
    return numbers, nil
}
```

## Conclusion

Number parsing is a fundamental operation in Go programming. The `strconv` package provides comprehensive functions for converting strings to numeric types with proper error handling. By mastering these functions and following best practices, you can:

1. **Parse Various Number Formats**:
   - Integers with different bases
   - Floating-point numbers
   - Special values (inf, NaN)
   - Boolean values

2. **Handle Edge Cases**:
   - Invalid input formats
   - Out-of-range values
   - Missing or empty values
   - Custom formats (currency, sizes, durations)

3. **Build Robust Applications**:
   - Configuration parsing
   - Input validation
   - Data processing
   - Protocol implementation

The configuration parser example demonstrates how to build a comprehensive parsing system that handles various numeric types, validates ranges, and provides meaningful error messages. By following the patterns shown in this guide, you can create reliable and maintainable code for parsing numbers in your Go applications.

Key takeaways:
1. **Always check errors** when parsing numbers
2. **Validate input ranges** to prevent invalid values
3. **Provide default values** for missing or invalid input
4. **Use appropriate types** (int8, int16, etc.) for your data
5. **Handle custom formats** (currency, sizes, durations) with preprocessing

Number parsing might seem straightforward, but it's full of edge cases that can lead to bugs or security vulnerabilities if not handled properly. With Go's robust standard library and the patterns shown in this guide, you can build reliable and secure number parsing functionality.