

{# Cryptographic Hashing in Go: SHA-256/512 and the Crypto Package

!!! abstract "Overview"
    Master Go's cryptographic hashing capabilities using the crypto package. Learn to implement SHA-256 and SHA-512 hash functions, understand HMAC for message authentication, implement secure password hashing with bcrypt and scrypt, and build practical security applications like file integrity verification systems.

!!! tip "Key Points"
    - Use SHA-256 for general-purpose integrity checking and SHA-512 for higher security requirements
    - Hash functions are deterministic, one-way functions that produce fixed-size outputs
    - Never use plain hash functions for passwords - use specialized algorithms like bcrypt or scrypt
    - Implement HMAC for message authentication and integrity verification
    - Use constant-time comparison for security-sensitive operations
    - Essential for data integrity verification, password storage, digital signatures, and blockchain applications

## Understanding Cryptographic Hashing

Cryptographic hash functions are fundamental building blocks of modern cryptography. They transform arbitrary input data into fixed-size output values (hashes) with specific security properties that make them essential for many security applications.

!!! info "Hash Function Properties"
    ```mermaid
    graph LR
        A[Cryptographic Hash Functions] --> B[Deterministic]
        A --> C[Pre-image Resistant]
        A --> D[Second Pre-image Resistant]
        A --> E[Collision Resistant]
        A --> F[Avalanche Effect]
        B --> G[Same input = Same output]
        C --> H[Hard to find input from hash]
        D --> I[Hard to find second input with same hash]
        E --> J[Hard to find any two inputs with same hash]
        F --> K[Small input change = Big output change]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Key Properties of Cryptographic Hash Functions

- **Deterministic**: Same input always produces same output
- **Pre-image resistant**: Given a hash, it's computationally infeasible to find the input
- **Second pre-image resistant**: Given an input, it's hard to find another input with same hash
- **Collision resistant**: Hard to find two different inputs with same hash
- **Avalanche effect**: Small change in input produces significant change in output

### Common Hash Algorithms

- **MD5**: 128-bit hash (broken, not recommended for security)
- **SHA-1**: 160-bit hash (deprecated for security)
- **SHA-256**: 256-bit hash (part of SHA-2 family)
- **SHA-512**: 512-bit hash (part of SHA-2 family)
- **SHA-3**: Latest standard (Keccak algorithm)

## SHA-256 Implementation in Go

### 1. Basic SHA-256 Hashing

!!! example "Basic SHA-256 Hashing"
    ```go title="basic_sha256.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
    )

    func main() {
        // Simple string hashing
        data := "Hello, World!"
        hash := sha256.Sum256([]byte(data))
        
        // Convert to hexadecimal string
        hashString := hex.EncodeToString(hash[:])
        fmt.Printf("SHA-256 hash of %q: %s\n", data, hashString)
        // Output: SHA-256 hash of "Hello, World!": dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f
    }
    ```

### 2. Hashing Files

!!! example "Hashing Files"
    ```go title="file_hashing.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io"
        "os"
    )

    func hashFile(filename string) (string, error) {
        file, err := os.Open(filename)
        if err != nil {
            return "", err
        }
        defer file.Close()
        
        hasher := sha256.New()
        if _, err := io.Copy(hasher, file); err != nil {
            return "", err
        }
        
        return hex.EncodeToString(hasher.Sum(nil)), nil
    }

    func main() {
        // Create a sample file
        content := []byte("This is a test file for SHA-256 hashing.")
        err := os.WriteFile("test.txt", content, 0644)
        if err != nil {
            fmt.Println("Error creating file:", err)
            return
        }
        
        // Hash the file
        hash, err := hashFile("test.txt")
        if err != nil {
            fmt.Println("Error hashing file:", err)
            return
        }
        
        fmt.Printf("SHA-256 hash of file: %s\n", hash)
        
        // Clean up
        os.Remove("test.txt")
    }
    ```

### 3. Incremental Hashing

!!! example "Incremental Hashing"
    ```go title="incremental_hashing.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
    )

    func incrementalHash() {
        hasher := sha256.New()
        
        // Write data in chunks
        hasher.Write([]byte("First part "))
        hasher.Write([]byte("second part "))
        hasher.Write([]byte("third part"))
        
        hash := hasher.Sum(nil)
        fmt.Printf("Incremental hash: %x\n", hash)
    }

    func main() {
        incrementalHash()
    }
    ```

## SHA-512 Implementation in Go

### 1. Basic SHA-512 Hashing

!!! example "Basic SHA-512 Hashing"
    ```go title="basic_sha512.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "crypto/sha512"
        "encoding/hex"
        "fmt"
    )

    func main() {
        data := "Hello, World!"
        hash := sha512.Sum512([]byte(data))
        
        fmt.Printf("SHA-512 hash of %q:\n%x\n", data, hash)
    }
    ```

### 2. SHA-512/224 and SHA-512/256 Variants

!!! example "SHA-512 Variants"
    ```go title="sha512_variants.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "crypto/sha512"
        "encoding/hex"
        "fmt"
    )

    func main() {
        data := "Hello, World!"
        
        // SHA-512/224 (truncated to 224 bits)
        hash224 := sha512.Sum512_224([]byte(data))
        fmt.Printf("SHA-512/224: %x\n", hash224)
        
        // SHA-512/256 (truncated to 256 bits)
        hash256 := sha512.Sum512_256([]byte(data))
        fmt.Printf("SHA-512/256: %x\n", hash256)
    }
    ```

## The Crypto Package

### 1. Overview of Go's Crypto Package

Go's `crypto` package provides a collection of cryptographic algorithms:
- Hash functions (SHA-256, SHA-512, etc.)
- Message Authentication Codes (HMAC)
- Digital signatures
- Encryption and decryption
- Random number generation

!!! example "Available Hash Functions"
    ```go title="available_hashes.go" linenums="1" hl_lines="8-36"
    package main

    import (
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "encoding/hex"
        "fmt"
    )

    func availableHashes() {
        data := "Hello, World!"
        
        // MD5 (not secure, for legacy compatibility)
        md5Hash := md5.Sum([]byte(data))
        fmt.Printf("MD5: %x\n", md5Hash)
        
        // SHA-1 (deprecated)
        sha1Hash := sha1.Sum([]byte(data))
        fmt.Printf("SHA-1: %x\n", sha1Hash)
        
        // SHA-224
        sha224Hash := sha256.Sum224([]byte(data))
        fmt.Printf("SHA-224: %x\n", sha224Hash)
        
        // SHA-256
        sha256Hash := sha256.Sum256([]byte(data))
        fmt.Printf("SHA-256: %x\n", sha256Hash)
        
        // SHA-384
        sha384Hash := sha512.Sum384([]byte(data))
        fmt.Printf("SHA-384: %x\n", sha384Hash)
        
        // SHA-512
        sha512Hash := sha512.Sum512([]byte(data))
        fmt.Printf("SHA-512: %x\n", sha512Hash)
    }

    func main() {
        availableHashes()
    }
    ```

## HMAC (Hash-based Message Authentication Code)

### 1. HMAC with SHA-256

!!! example "HMAC with SHA-256"
    ```go title="hmac_sha256.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
    )

    func computeHMAC(message, key []byte) []byte {
        mac := hmac.New(sha256.New, key)
        mac.Write(message)
        return mac.Sum(nil)
    }

    func main() {
        message := []byte("Important message")
        key := []byte("secret-key")
        
        // Compute HMAC
        hmac := computeHMAC(message, key)
        fmt.Printf("HMAC-SHA256: %x\n", hmac)
        
        // Verify HMAC (in real scenario, receiver would do this)
        receivedHMAC := computeHMAC(message, key)
        if hmac.Equal(receivedHMAC, hmac) {
            fmt.Println("HMAC verification: SUCCESS")
        } else {
            fmt.Println("HMAC verification: FAILED")
        }
    }
    ```

## Password Hashing

### 1. Why Not Use Plain Hash Functions for Passwords?

Plain hash functions are fast, which makes them vulnerable to brute-force attacks. Passwords should be hashed with:
- **Slow hashing functions** (to slow down brute-force)
- **Salting** (to prevent rainbow table attacks)
- **Key stretching** (multiple iterations)

### 2. Using bcrypt for Password Hashing

!!! example "Using bcrypt for Password Hashing"
    ```go title="bcrypt_password.go" linenums="1" hl_lines="8-36"
    package main

    import (
        "fmt"
        "golang.org/x/crypto/bcrypt"
    )

    func hashPassword(password string) (string, error) {
        // Generate a salt (bcrypt handles this automatically)
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil {
            return "", err
        }
        return string(hashedPassword), nil
    }

    func checkPassword(hashedPassword, password string) bool {
        err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
        return err == nil
    }

    func main() {
        password := "mySecretPassword123"
        
        // Hash the password
        hashed, err := hashPassword(password)
        if err != nil {
            fmt.Println("Error hashing password:", err)
            return
        }
        fmt.Printf("Hashed password: %s\n", hashed)
        
        // Check password
        match := checkPassword(hashed, password)
        fmt.Printf("Password check: %v\n", match)
        
        // Check wrong password
        match = checkPassword(hashed, "wrongPassword")
        fmt.Printf("Wrong password check: %v\n", match)
    }
    ```

### 3. Using scrypt for Password Hashing

!!! example "Using scrypt for Password Hashing"
    ```go title="scrypt_password.go" linenums="1" hl_lines="8-48"
    package main

    import (
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "golang.org/x/crypto/scrypt"
        "golang.org/x/crypto/subtle"
    )

    func hashPasswordScrypt(password string) (string, error) {
        // Generate a random salt
        salt := make([]byte, 16)
        if _, err := rand.Read(salt); err != nil {
            return "", err
        }
        
        // Hash the password with scrypt
        hash, err := scrypt.Key([]byte(password), salt, 32768, 8, 1, 32)
        if err != nil {
            return "", err
        }
        
        // Prepend salt to hash for storage
        storedHash := append(salt, hash...)
        return base64.StdEncoding.EncodeToString(storedHash), nil
    }

    func checkPasswordScrypt(hashedPassword, password string) (bool, error) {
        // Decode the stored hash
        storedHash, err := base64.StdEncoding.DecodeString(hashedPassword)
        if err != nil {
            return false, err
        }
        
        // Extract salt and hash
        salt := storedHash[:16]
        expectedHash := storedHash[16:]
        
        // Hash the provided password with the same salt
        hash, err := scrypt.Key([]byte(password), salt, 32768, 8, 1, 32)
        if err != nil {
            return false, err
        }
        
        // Compare hashes
        return subtle.ConstantTimeCompare(expectedHash, hash), nil
    }

    func main() {
        password := "mySecretPassword123"
        
        // Hash the password
        hashed, err := hashPasswordScrypt(password)
        if err != nil {
            fmt.Println("Error hashing password:", err)
            return
        }
        fmt.Printf("Hashed password: %s\n", hashed)
        
        // Check password
        match, err := checkPasswordScrypt(hashed, password)
        if err != nil {
            fmt.Println("Error checking password:", err)
            return
        }
        fmt.Printf("Password check: %v\n", match)
    }
    ```

## Real-World Example: File Integrity Checker

Let's build a comprehensive file integrity checker that uses SHA-256 to detect file changes:

!!! example "File Integrity Checker"
    ```go title="file_integrity.go" linenums="1" hl_lines="8-60"
    package main

    import (
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"
    )

    // FileHash represents a file and its hash
    type FileHash struct {
        Path     string    `json:"path"`
        Hash     string    `json:"hash"`
        Modified time.Time `json:"modified"`
        Size     int64     `json:"size"`
    }

    // IntegrityDatabase stores file hashes for integrity checking
    type IntegrityDatabase struct {
        Files map[string]FileHash `json:"files"`
    }

    // NewIntegrityDatabase creates a new integrity database
    func NewIntegrityDatabase() *IntegrityDatabase {
        return &IntegrityDatabase{
            Files: make(map[string]FileHash),
        }
    }

    // AddFile adds a file to the database
    func (db *IntegrityDatabase) AddFile(path string) error {
        // Get file info
        info, err := os.Stat(path)
        if err != nil {
            return fmt.Errorf("failed to stat file: %w", err)
        }
        
        // Calculate hash
        hash, err := calculateFileHash(path)
        if err != nil {
            return fmt.Errorf("failed to calculate hash: %w", err)
        }
        
        // Add to database
        db.Files[path] = FileHash{
            Path:     path,
            Hash:     hash,
            Modified: info.ModTime(),
            Size:     info.Size(),
        }
        
        return nil
    }

    // AddDirectory adds all files in a directory to the database
    func (db *IntegrityDatabase) AddDirectory(dirPath string) error {
        return filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
            if err != nil {
                return err
            }
            
            // Skip directories
            if info.IsDir() {
                return nil
            }
            
            // Add file to database
            if err := db.AddFile(path); err != nil {
                fmt.Printf("Error adding file %s: %v\n", path, err)
            }
            
            return nil
        })
    }

    // CheckIntegrity checks if files have been modified
    func (db *IntegrityDatabase) CheckIntegrity() ([]string, error) {
        var modifiedFiles []string
        
        for path, storedHash := range db.Files {
            // Check if file still exists
            if _, err := os.Stat(path); os.IsNotExist(err) {
                modifiedFiles = append(modifiedFiles, fmt.Sprintf("DELETED: %s", path))
                continue
            }
            
            // Get current file info
            info, err := os.Stat(path)
            if err != nil {
                modifiedFiles = append(modifiedFiles, fmt.Sprintf("ERROR: %s - %v", path, err))
                continue
            }
            
            // Check modification time
            if info.ModTime() != storedHash.Modified {
                modifiedFiles = append(modifiedFiles, fmt.Sprintf("MODIFIED: %s (timestamp changed)", path))
                continue
            }
            
            // Check size
            if info.Size() != storedHash.Size {
                modifiedFiles = append(modifiedFiles, fmt.Sprintf("MODIFIED: %s (size changed)", path))
                continue
            }
            
            // Check hash
            currentHash, err := calculateFileHash(path)
            if err != nil {
                modifiedFiles = append(modifiedFiles, fmt.Sprintf("ERROR: %s - %v", path, err))
                continue
            }
            
            if currentHash != storedHash.Hash {
                modifiedFiles = append(modifiedFiles, fmt.Sprintf("MODIFIED: %s (content changed)", path))
            }
        }
        
        return modifiedFiles, nil
    }

    // Save saves the database to a file
    func (db *IntegrityDatabase) Save(filename string) error {
        data, err := json.MarshalIndent(db, "", "  ")
        if err != nil {
            return fmt.Errorf("failed to marshal database: %w", err)
        }
        
        return os.WriteFile(filename, data, 0644)
    }

    // Load loads the database from a file
    func (db *IntegrityDatabase) Load(filename string) error {
        data, err := os.ReadFile(filename)
        if err != nil {
            return fmt.Errorf("failed to read database file: %w", err)
        }
        
        return json.Unmarshal(data, db)
    }

    // calculateFileHash calculates the SHA-256 hash of a file
    func calculateFileHash(filename string) (string, error) {
        file, err := os.Open(filename)
        if err != nil {
            return "", err
        }
        defer file.Close()
        
        hasher := sha256.New()
        if _, err := io.Copy(hasher, file); err != nil {
            return "", err
        }
        
        return hex.EncodeToString(hasher.Sum(nil)), nil
    }

    func main() {
        // Create a sample directory structure
        baseDir := "test_files"
        subDir := filepath.Join(baseDir, "subdir")
        
        // Create directories
        os.MkdirAll(subDir, 0755)
        defer os.RemoveAll(baseDir) // Clean up
        
        // Create sample files
        files := map[string]string{
            filepath.Join(baseDir, "file1.txt"):          "This is file 1",
            filepath.Join(baseDir, "file2.txt"):          "This is file 2",
            filepath.Join(subDir, "subfile1.txt"):       "This is subfile 1",
            filepath.Join(subDir, "subfile2.txt"):       "This is subfile 2",
        }
        
        for path, content := range files {
            err := os.WriteFile(path, []byte(content), 0644)
            if err != nil {
                fmt.Printf("Error creating file %s: %v\n", path, err)
                continue
            }
        }
        
        // Create integrity database
        db := NewIntegrityDatabase()
        
        // Add all files to database
        fmt.Println("Adding files to integrity database...")
        err := db.AddDirectory(baseDir)
        if err != nil {
            fmt.Printf("Error adding directory: %v\n", err)
            return
        }
        
        // Save database
        dbFile := "integrity_db.json"
        err = db.Save(dbFile)
        if err != nil {
            fmt.Printf("Error saving database: %v\n", err)
            return
        }
        fmt.Printf("Database saved to %s\n", dbFile)
        
        // Check integrity (should be clean)
        fmt.Println("\nChecking integrity (should be clean)...")
        modified, err := db.CheckIntegrity()
        if err != nil {
            fmt.Printf("Error checking integrity: %v\n", err)
            return
        }
        
        if len(modified) == 0 {
            fmt.Println("All files are intact!")
        } else {
            fmt.Println("Modified files:")
            for _, msg := range modified {
                fmt.Println("  -", msg)
            }
        }
        
        // Modify a file
        fmt.Println("\nModifying a file...")
        modifiedFile := filepath.Join(baseDir, "file1.txt")
        err = os.WriteFile(modifiedFile, []byte("This file has been modified!"), 0644)
        if err != nil {
            fmt.Printf("Error modifying file: %v\n", err)
            return
        }
        
        // Check integrity again
        fmt.Println("\nChecking integrity (should detect modification)...")
        modified, err = db.CheckIntegrity()
        if err != nil {
            fmt.Printf("Error checking integrity: %v\n", err)
            return
        }
        
        fmt.Println("Modified files:")
        for _, msg := range modified {
            fmt.Println("  -", msg)
        }
        
        // Delete a file
        fmt.Println("\nDeleting a file...")
        deletedFile := filepath.Join(subDir, "subfile1.txt")
        err = os.Remove(deletedFile)
        if err != nil {
            fmt.Printf("Error deleting file: %v\n", err)
            return
        }
        
        // Check integrity again
        fmt.Println("\nChecking integrity (should detect deletion)...")
        modified, err = db.CheckIntegrity()
        if err != nil {
            fmt.Printf("Error checking integrity: %v\n", err)
            return
        }
        
        fmt.Println("Modified files:")
        for _, msg := range modified {
            fmt.Println("  -", msg)
        }
        
        // Clean up
        os.Remove(dbFile)
    }
    ```

### How This Example Works:

1. **File Integrity Database**:
   - Stores SHA-256 hashes of files along with metadata
   - Tracks file paths, modification times, and sizes
   - Saves and loads database from JSON

2. **Directory Scanning**:
   - Recursively scans directories to add all files
   - Calculates SHA-256 hashes for each file
   - Stores file metadata for comparison

3. **Integrity Checking**:
   - Compares current file state with stored hashes
   - Detects modifications, deletions, and other changes
   - Provides detailed reports of all changes

4. **Security Features**:
   - Uses SHA-256 for cryptographic integrity
   - Checks multiple attributes (hash, size, timestamp)
   - Provides comprehensive change detection

### Real-World Applications:

1. **Security Auditing**:
   - Detect unauthorized file changes
   - Monitor system files for tampering
   - Verify software integrity

2. **Backup Verification**:
   - Ensure backup files haven't been corrupted
   - Verify restore operations
   - Detect bit rot in storage systems

3. **Compliance Monitoring**:
   - Track changes to regulated files
   - Maintain audit trails
   - Demonstrate data integrity

## Best Practices

!!! tip "Choosing the Right Hash Algorithm"
    Select the appropriate hash algorithm based on your security requirements.

!!! example "Choosing the Right Hash Algorithm"
    ```go title="hash_algorithm_selection.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "crypto/sha256"
        "crypto/sha512"
    )

    func main() {
        data := []byte("sensitive data")
        
        // For general purpose integrity checking
        hash256 := sha256.Sum256(data)
        
        // For higher security requirements
        hash512 := sha512.Sum512(data)
        
        // For legacy systems (not recommended for new applications)
        // hash1 := sha1.Sum(data) // Deprecated
    }
    ```

!!! tip "Constant-Time Comparison"
    Use constant-time comparison for security-sensitive operations to prevent timing attacks.

!!! example "Constant-Time Comparison"
    ```go title="constant_time_comparison.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "crypto/subtle"
    )

    func main() {
        expectedHash := []byte("expected_hash_value")
        actualHash := []byte("actual_hash_value")
        
        // Good: Use constant-time comparison
        if subtle.ConstantTimeCompare(expectedHash, actualHash) == 1 {
            // Hashes match
        }
        
        // Bad: Regular comparison vulnerable to timing attacks
        // if expectedHash == actualHash {
        //     // Hashes match
        // }
    }
    ```

!!! tip "Password Hashing Best Practices"
    Always use specialized password hashing algorithms instead of plain hash functions.

!!! example "Password Hashing Best Practices"
    ```go title="password_hashing_best_practices.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "golang.org/x/crypto/bcrypt"
    )

    func main() {
        password := []byte("user_password")
        
        // Good: Use bcrypt with appropriate cost
        hashedPassword, err := bcrypt.GenerateFromPassword(password, 12)
        if err != nil {
            // Handle error
        }
        
        // Bad: Use plain hash functions for passwords
        // hash := sha256.Sum256(password) // Vulnerable to brute-force
    }
    ```

!!! tip "Secure Salt Usage"
    Always use unique, randomly generated salts for password hashing.

!!! example "Secure Salt Usage"
    ```go title="secure_salt_usage.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "crypto/rand"
        "encoding/hex"
    )

    func generateSalt() (string, error) {
        salt := make([]byte, 16)
        if _, err := rand.Read(salt); err != nil {
            return "", err
        }
        return hex.EncodeToString(salt), nil
    }

    func main() {
        // Generate a unique salt for each password
        salt, err := generateSalt()
        if err != nil {
            // Handle error
        }
        // Use salt with password hashing algorithm
    }
    ```

## Security Considerations

!!! warning "Hash Function Security"
    Be aware of the security status of different hash algorithms.

!!! example "Hash Function Security"
    ```go title="hash_function_security.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
    )

    func main() {
        // Security status of hash functions:
        fmt.Println("MD5: BROKEN - Vulnerable to collision attacks")
        fmt.Println("SHA-1: DEPRECATED - Theoretically broken")
        fmt.Println("SHA-256: SECURE - Recommended for most applications")
        fmt.Println("SHA-512: SECURE - Higher security, more resources")
        fmt.Println("SHA-3: SECURE - Latest standard, alternative to SHA-2")
    }
    ```

!!! warning "Password Hashing Security"
    Never use plain hash functions for password storage.

!!! example "Password Hashing Security"
    ```go title="password_hashing_security.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "crypto/sha256"
        "golang.org/x/crypto/bcrypt"
    )

    func main() {
        password := "user_password"
        
        // Good: Use specialized password hashing algorithms
        hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        
        // Bad: Use plain hash functions for passwords
        // insecureHash := sha256.Sum256([]byte(password)) // Vulnerable to brute-force
        _ = hashedPassword
    }
    ```

!!! warning "Integrity Verification Security"
    Store hashes securely and consider using HMAC for verification by untrusted parties.

!!! example "Integrity Verification Security"
    ```go title="integrity_verification_security.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "crypto/hmac"
        "crypto/sha256"
    )

    func main() {
        message := []byte("important message")
        key := []byte("secret_key")
        
        // Good: Use HMAC for message authentication
        mac := hmac.New(sha256.New, key)
        mac.Write(message)
        hmacValue := mac.Sum(nil)
        
        // Store HMAC securely, separate from the message
        _ = hmacValue
    }
    ```

## Performance Considerations

!!! warning "Hash Function Performance"
    Consider performance implications when choosing between hash algorithms.

!!! example "Hash Function Performance"
    ```go title="hash_function_performance.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "crypto/sha256"
        "crypto/sha512"
        "fmt"
        "time"
    )

    func benchmarkHashes(data []byte) {
        start := time.Now()
        sha256.Sum256(data)
        sha256Duration := time.Since(start)
        
        start = time.Now()
        sha512.Sum512(data)
        sha512Duration := time.Since(start)
        
        fmt.Printf("SHA-256: %v\n", sha256Duration)
        fmt.Printf("SHA-512: %v\n", sha512Duration)
    }

    func main() {
        data := make([]byte, 1024*1024) // 1MB of data
        benchmarkHashes(data)
    }
    ```

!!! warning "Memory Usage for Large Files"
    Use streaming for large files to avoid memory issues.

!!! example "Memory Usage for Large Files"
    ```go title="memory_usage_large_files.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io"
        "os"
    )

    // Good: Stream hashing for large files
    func hashLargeFile(filename string) (string, error) {
        file, err := os.Open(filename)
        if err != nil {
            return "", err
        }
        defer file.Close()
        
        hasher := sha256.New()
        if _, err := io.Copy(hasher, file); err != nil {
            return "", err
        }
        
        return hex.EncodeToString(hasher.Sum(nil)), nil
    }

    // Bad: Load entire file into memory
    func hashLargeFileBad(filename string) (string, error) {
        // data, err := os.ReadFile(filename) // Could use too much memory
        // hash := sha256.Sum256(data)
        // return hex.EncodeToString(hash[:]), nil
        return "", nil
    }

    func main() {
        // Example usage
        hash, err := hashLargeFile("large_file.bin")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Println("Hash:", hash)
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Hash Functions**: Use SHA-256 for general purposes, SHA-512 for higher security
    - **Password Hashing**: Always use bcrypt, scrypt, or Argon2 - never plain hash functions
    - **Message Authentication**: Use HMAC with a strong hash algorithm
    - **File Integrity**: Use streaming for large files to avoid memory issues
    - **Security**: Use constant-time comparison for sensitive operations
    - **Performance**: Consider speed vs. security trade-offs when choosing algorithms

!!! quote "Remember"
    "Cryptographic hashing is a fundamental security primitive in Go. The crypto package provides robust implementations of hash functions, HMAC, and password hashing algorithms. By understanding the properties of hash functions and following best practices, you can effectively use cryptographic hashing to ensure data integrity, secure passwords, and build trustworthy security applications in Go."