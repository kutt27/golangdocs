
# Go Interfaces: Contracts and Polymorphism

!!! abstract "Overview"
    Master Go interfaces - contracts that define method signatures without implementation. Learn implicit satisfaction, interface composition, type assertions, and patterns for building flexible, testable code.

!!! tip "Key Points"
    - Interfaces define method contracts, not implementations
    - Implicit satisfaction - no explicit "implements" keyword
    - Enable polymorphism and dependency injection
    - Empty interface `interface{}` accepts any type
    - Type assertions provide runtime type checking

## Understanding Interfaces

Interfaces in Go define contracts that specify what methods a type must have, enabling polymorphism and flexible code design.

## Defining Interfaces

### Basic Interface Definition
```go
type Writer interface {
    Write([]byte) (int, error)
}
```

### Interface with Multiple Methods
```go
type ReadWriter interface {
    Read([]byte) (int, error)
    Write([]byte) (int, error)
}
```

### Empty Interface
The empty interface `interface{}` is satisfied by all types since it has no methods:
```go
var anything interface{}
anything = 42
anything = "hello"
anything = struct{ Name string }{Name: "Alice"}
```

## Implicit Interface Implementation
Go's interfaces are satisfied implicitly - no explicit declaration is needed:

```go
type File struct {
    name string
}

func (f *File) Write(data []byte) (int, error) {
    // Implementation
    return len(data), nil
}

// File automatically implements Writer interface
func useWriter(w Writer) {
    w.Write([]byte("hello"))
}

func main() {
    file := &File{name: "test.txt"}
    useWriter(file) // Works because File implements Writer
}
```

## Interface Values and Types

### Interface Value Structure
An interface value consists of:
- A concrete type (the type that implements the interface)
- A concrete value (the value of that type)

```go
var w Writer
fmt.Printf("(%v, %T)\n", w, w) // (<nil>, <nil>)

file := &File{name: "test.txt"}
w = file
fmt.Printf("(%v, %T)\n", w, w) // (&{test.txt}, *main.File)
```

### Nil Interface Values
An interface value is nil only if both its type and value are nil:

```go
var w Writer
fmt.Println(w == nil) // true

var file *File
w = file
fmt.Println(w == nil) // false (type is *File, value is nil)
```

## Type Assertions and Type Switches

### Type Assertion
Extract the concrete value from an interface:

```go
func process(i interface{}) {
    if s, ok := i.(string); ok {
        fmt.Println("String value:", s)
    } else {
        fmt.Println("Not a string")
    }
}

func main() {
    process("hello")  // String value: hello
    process(42)       // Not a string
}
```

### Type Switch
Check against multiple types:

```go
func describe(i interface{}) {
    switch v := i.(type) {
    case string:
        fmt.Printf("String: %q\n", v)
    case int:
        fmt.Printf("Integer: %d\n", v)
    case bool:
        fmt.Printf("Boolean: %t\n", v)
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}

func main() {
    describe("hello")  // String: "hello"
    describe(42)       // Integer: 42
    describe(true)     // Boolean: true
    describe(3.14)     // Unknown type: float64
}
```

## Common Standard Library Interfaces

### 1. `io.Reader` and `io.Writer`
```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```

### 2. `fmt.Stringer`
```go
type Stringer interface {
    String() string
}

type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d years)", p.Name, p.Age)
}

func main() {
    p := Person{"Alice", 30}
    fmt.Println(p) // Automatically calls String()
}
```

### 3. `error` Interface
```go
type error interface {
    Error() string
}

type MyError struct {
    Message string
}

func (e MyError) Error() string {
    return e.Message
}

func main() {
    err := MyError{"something went wrong"}
    fmt.Println(err) // something went wrong
}
```

### 4. `sort.Interface`
```go
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}

type ByLength []string

func (s ByLength) Len() int           { return len(s) }
func (s ByLength) Less(i, j int) bool { return len(s[i]) < len(s[j]) }
func (s ByLength) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

func main() {
    fruits := []string{"apple", "banana", "cherry"}
    sort.Sort(ByLength(fruits))
    fmt.Println(fruits) // [apple cherry banana]
}
```

## Interface Composition
Interfaces can be composed of other interfaces:

```go
type Reader interface {
    Read([]byte) (int, error)
}

type Closer interface {
    Close() error
}

type ReadCloser interface {
    Reader
    Closer
}
```

## Best Practices for Interfaces

### 1. Keep Interfaces Small
Follow the interface segregation principle:

```go
// Good: Small, focused interface
type Reader interface {
    Read([]byte) (int, error)
}

// Bad: Large, bloated interface
type FileSystemObject interface {
    Read([]byte) (int, error)
    Write([]byte) (int, error)
    Seek(offset int64, whence int) (int64, error)
    Close() error
    Readdir(count int) ([]os.FileInfo, error)
    // ... many more methods
}
```

### 2. Accept Interfaces, Return Structs
```go
// Good: Accept interface, return concrete type
func ProcessData(r io.Reader) ([]byte, error) {
    // Process data
    return result, nil
}

// Bad: Return interface
func GetData() io.Reader {
    return bytes.NewReader(data)
}
```

### 3. Design for Behavior, Not Implementation
Focus on what the interface does, not how it's implemented:

```go
// Good: Behavior-focused
type Storer interface {
    Store(key string, value interface{}) error
    Retrieve(key string) (interface{}, error)
}

// Bad: Implementation-focused
type SQLStorer interface {
    Exec(query string, args ...interface{}) (sql.Result, error)
    Query(query string, args ...interface{}) (*sql.Rows, error)
}
```

## Real-World Example: Pluggable Storage System

Let's build a storage system that supports multiple backends (in-memory, file-based, and database) using interfaces:

```go
package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"sync"
)

// Storage defines the interface for our storage backends
type Storage interface {
	Store(key string, value interface{}) error
	Retrieve(key string) (interface{}, error)
	Delete(key string) error
	List() ([]string, error)
	Close() error
}

// InMemoryStorage implements Storage using a map
type InMemoryStorage struct {
	data map[string]interface{}
	mu   sync.RWMutex
}

func NewInMemoryStorage() *InMemoryStorage {
	return &InMemoryStorage{
		data: make(map[string]interface{}),
	}
}

func (s *InMemoryStorage) Store(key string, value interface{}) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.data[key] = value
	return nil
}

func (s *InMemoryStorage) Retrieve(key string) (interface{}, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	value, exists := s.data[key]
	if !exists {
		return nil, errors.New("key not found")
	}
	return value, nil
}

func (s *InMemoryStorage) Delete(key string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if _, exists := s.data[key]; !exists {
		return errors.New("key not found")
	}
	delete(s.data, key)
	return nil
}

func (s *InMemoryStorage) List() ([]string, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	keys := make([]string, 0, len(s.data))
	for k := range s.data {
		keys = append(keys, k)
	}
	return keys, nil
}

func (s *InMemoryStorage) Close() error {
	// Nothing to do for in-memory storage
	return nil
}

// FileStorage implements Storage using the filesystem
type FileStorage struct {
	baseDir string
}

func NewFileStorage(baseDir string) (*FileStorage, error) {
	if err := os.MkdirAll(baseDir, 0755); err != nil {
		return nil, err
	}
	return &FileStorage{baseDir: baseDir}, nil
}

func (s *FileStorage) filePath(key string) string {
	return fmt.Sprintf("%s/%s.json", s.baseDir, key)
}

func (s *FileStorage) Store(key string, value interface{}) error {
	data, err := json.Marshal(value)
	if err != nil {
		return err
	}
	return os.WriteFile(s.filePath(key), data, 0644)
}

func (s *FileStorage) Retrieve(key string) (interface{}, error) {
	data, err := os.ReadFile(s.filePath(key))
	if os.IsNotExist(err) {
		return nil, errors.New("key not found")
	}
	if err != nil {
		return nil, err
	}
	
	var value interface{}
	if err := json.Unmarshal(data, &value); err != nil {
		return nil, err
	}
	return value, nil
}

func (s *FileStorage) Delete(key string) error {
	err := os.Remove(s.filePath(key))
	if os.IsNotExist(err) {
		return errors.New("key not found")
	}
	return err
}

func (s *FileStorage) List() ([]string, error) {
	entries, err := os.ReadDir(s.baseDir)
	if err != nil {
		return nil, err
	}
	
	keys := make([]string, 0, len(entries))
	for _, entry := range entries {
		if !entry.IsDir() {
			// Remove .json extension
			name := entry.Name()
			if len(name) > 5 && name[len(name)-5:] == ".json" {
				keys = append(keys, name[:len(name)-5])
			}
		}
	}
	return keys, nil
}

func (s *FileStorage) Close() error {
	// Nothing to do for file storage
	return nil
}

// StorageService provides additional functionality on top of Storage
type StorageService struct {
	storage Storage
}

func NewStorageService(storage Storage) *StorageService {
	return &StorageService{storage: storage}
}

func (s *StorageService) StoreUser(id string, user map[string]interface{}) error {
	return s.storage.Store(id, user)
}

func (s *StorageService) GetUser(id string) (map[string]interface{}, error) {
	value, err := s.storage.Retrieve(id)
	if err != nil {
		return nil, err
	}
	
	user, ok := value.(map[string]interface{})
	if !ok {
		return nil, errors.New("invalid user data format")
	}
	return user, nil
}

func (s *StorageService) DeleteUser(id string) error {
	return s.storage.Delete(id)
}

func (s *StorageService) ListUsers() ([]string, error) {
	return s.storage.List()
}

func (s *StorageService) Close() error {
	return s.storage.Close()
}

// Usage example
func main() {
	// Choose storage backend
	var storage Storage
	
	// Option 1: In-memory storage
	storage = NewInMemoryStorage()
	
	// Option 2: File storage (uncomment to use)
	// fileStorage, err := NewFileStorage("./data")
	// if err != nil {
	//     panic(err)
	// }
	// storage = fileStorage
	
	// Create service
	service := NewStorageService(storage)
	defer service.Close()
	
	// Store some users
	users := []map[string]interface{}{
		{"name": "Alice", "age": 30, "email": "alice@example.com"},
		{"name": "Bob", "age": 25, "email": "bob@example.com"},
		{"name": "Charlie", "age": 35, "email": "charlie@example.com"},
	}
	
	for i, user := range users {
		id := fmt.Sprintf("user%d", i+1)
		if err := service.StoreUser(id, user); err != nil {
			fmt.Printf("Error storing user %s: %v\n", id, err)
		}
	}
	
	// List all users
	fmt.Println("\nStored users:")
	ids, err := service.ListUsers()
	if err != nil {
		fmt.Printf("Error listing users: %v\n", err)
		return
	}
	
	for _, id := range ids {
		user, err := service.GetUser(id)
		if err != nil {
			fmt.Printf("Error retrieving user %s: %v\n", id, err)
			continue
		}
		fmt.Printf("%s: %+v\n", id, user)
	}
	
	// Delete a user
	if len(ids) > 0 {
		if err := service.DeleteUser(ids[0]); err != nil {
			fmt.Printf("Error deleting user: %v\n", err)
		} else {
			fmt.Printf("\nDeleted user: %s\n", ids[0])
		}
	}
}
```

### How This Example Demonstrates Interface Concepts:

1. **Interface Definition**:
   - `Storage` interface defines the contract for all storage backends
   - Clear separation between interface and implementation

2. **Multiple Implementations**:
   - `InMemoryStorage` uses a map for storage
   - `FileStorage` uses the filesystem
   - Both implement the same interface

3. **Service Layer**:
   - `StorageService` adds business logic on top of storage
   - Works with any Storage implementation

4. **Polymorphism**:
   - Can switch between storage backends without changing service code
   - Code works with any type that satisfies the Storage interface

### Real-World Applications of This Pattern:

1. **Database Abstraction**:
   - Support multiple databases (SQL, NoSQL, in-memory)
   - Easy to switch or add new database backends

2. **Logging Systems**:
   - Support multiple log outputs (console, file, remote)
   - Pluggable log formatters

3. **Message Queues**:
   - Support different message brokers (RabbitMQ, Kafka, AWS SQS)
   - Consistent API regardless of backend

4. **Caching Layers**:
   - Support multiple cache providers (Redis, Memcached, in-memory)
   - Easy to switch caching strategies

### Benefits of This Approach:

1. **Decoupling**:
   - Business logic doesn't depend on concrete implementations
   - Easy to replace or add new implementations

2. **Testability**:
   - Easy to mock dependencies for testing
   - Can test business logic with fake storage

3. **Flexibility**:
   - Can choose implementation based on environment
   - Easy to extend with new features

4. **Maintainability**:
   - Clear contracts between components
   - Changes to implementation don't affect consumers

## Advanced Interface Patterns

### 1. Interface Embedding
```go
type Reader interface {
    Read([]byte) (int, error)
}

type Closer interface {
    Close() error
}

type ReadCloser interface {
    Reader
    Closer
}
```

### 2. Interface with Type Parameters (Go 1.18+)
```go
type Container[T any] interface {
    Put(T)
    Get() T
}

type StringContainer struct {
    items []string
}

func (s *StringContainer) Put(item string) {
    s.items = append(s.items, item)
}

func (s *StringContainer) Get() string {
    if len(s.items) == 0 {
        return ""
    }
    item := s.items[0]
    s.items = s.items[1:]
    return item
}
```

### 3. Interface for Dependency Injection
```go
type Database interface {
    Query(query string, args ...interface{}) (*sql.Rows, error)
    Exec(query string, args ...interface{}) (sql.Result, error)
}

type Service struct {
    db Database
}

func NewService(db Database) *Service {
    return &Service{db: db}
}
```

## Conclusion

Interfaces are a cornerstone of Go's design philosophy, enabling:

1. **Polymorphism**:
   - Treat different types uniformly
   - Write flexible, reusable code
   - Implement design patterns effectively

2. **Decoupling**:
   - Separate contracts from implementations
   - Reduce dependencies between components
   - Enable easier testing and maintenance

3. **Extensibility**:
   - Add new implementations without changing existing code
   - Support multiple backends or strategies
   - Build pluggable systems

4. **Abstraction**:
   - Focus on behavior rather than implementation
   - Create clean APIs
   - Hide implementation details

The storage system example demonstrates how interfaces enable building flexible, maintainable systems that can adapt to changing requirements. By defining clear contracts and implementing them consistently, you can create software that's both powerful and easy to understand.

Key takeaways:
1. Interfaces define behavior, not data
2. Implementation is implicit - no "implements" keyword needed
3. Small, focused interfaces are better than large ones
4. Accept interfaces, return concrete types
5. Use interfaces to decouple components and enable testing

Mastering interfaces is essential for writing idiomatic Go code that's flexible, maintainable, and testable. They are one of Go's most powerful features for building robust, scalable software systems.