

# Go Interfaces: Contracts and Polymorphism

!!! abstract "Overview"
    Master Go interfaces - contracts that define method signatures without implementation. Learn implicit satisfaction, interface composition, type assertions, and patterns for building flexible, testable code.

!!! tip "Key Points"
    - Interfaces define method contracts, not implementations
    - Implicit satisfaction - no explicit "implements" keyword
    - Enable polymorphism and dependency injection
    - Empty interface `interface{}` accepts any type
    - Type assertions provide runtime type checking

## Understanding Interfaces

Interfaces in Go define contracts that specify what methods a type must have, enabling polymorphism and flexible code design.

!!! info "Interface Structure"
    ```mermaid
    graph LR
        A[Interface] --> B[Method Signatures]
        A --> C[Implicit Implementation]
        A --> D[Polymorphism]
        B --> E[Method Names]
        B --> F[Parameters]
        B --> G[Return Types]
        C --> H[No Declaration Needed]
        D --> I[Multiple Types]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Defining Interfaces

!!! example "Basic Interface Definition"
    ```go title="basic_interface.go" linenums="1" hl_lines="3-5"
    package main

    type Writer interface {
        Write([]byte) (int, error)
    }

    func main() {
        // Implementation examples follow
    }
    ```

!!! example "Interface with Multiple Methods"
    ```go title="multi_method_interface.go" linenums="1" hl_lines="3-7"
    package main

    type ReadWriter interface {
        Read([]byte) (int, error)
        Write([]byte) (int, error)
    }

    func main() {
        // Implementation examples follow
    }
    ```

!!! example "Empty Interface"
    ```go title="empty_interface.go" linenums="1" hl_lines="6-11"
    package main

    import "fmt"

    func main() {
        // The empty interface interface{} is satisfied by all types
        var anything interface{}
        anything = 42
        anything = "hello"
        anything = struct{ Name string }{Name: "Alice"}
        
        fmt.Printf("Value: %v, Type: %T\n", anything, anything)
    }
    ```

## Implicit Interface Implementation

Go's interfaces are satisfied implicitly - no explicit declaration is needed:

!!! example "Implicit Implementation"
    ```go title="implicit_implementation.go" linenums="1" hl_lines="8-20"
    package main

    import "fmt"

    type Writer interface {
        Write([]byte) (int, error)
    }

    type File struct {
        name string
    }

    func (f *File) Write(data []byte) (int, error) {
        fmt.Printf("Writing to file %s: %s\n", f.name, string(data))
        return len(data), nil
    }

    func useWriter(w Writer) {
        w.Write([]byte("hello"))
    }

    func main() {
        file := &File{name: "test.txt"}
        useWriter(file) // Works because File implements Writer
    }
    ```

## Interface Values and Types

### Interface Value Structure
An interface value consists of:
- A concrete type (the type that implements the interface)
- A concrete value (the value of that type)

!!! example "Interface Value Structure"
    ```go title="interface_value_structure.go" linenums="1" hl_lines="8-16"
    package main

    import "fmt"

    type Writer interface {
        Write([]byte) (int, error)
    }

    type File struct {
        name string
    }

    func (f *File) Write(data []byte) (int, error) {
        return len(data), nil
    }

    func main() {
        var w Writer
        fmt.Printf("(%v, %T)\n", w, w) // (<nil>, <nil>)

        file := &File{name: "test.txt"}
        w = file
        fmt.Printf("(%v, %T)\n", w, w) // (&{test.txt}, *main.File)
    }
    ```

### Nil Interface Values
An interface value is nil only if both its type and value are nil:

!!! example "Nil Interface Values"
    ```go title="nil_interface.go" linenums="1" hl_lines="8-16"
    package main

    import "fmt"

    type Writer interface {
        Write([]byte) (int, error)
    }

    type File struct {
        name string
    }

    func (f *File) Write(data []byte) (int, error) {
        return len(data), nil
    }

    func main() {
        var w Writer
        fmt.Println(w == nil) // true

        var file *File
        w = file
        fmt.Println(w == nil) // false (type is *File, value is nil)
    }
    ```

## Type Assertions and Type Switches

### Type Assertion
Extract the concrete value from an interface:

!!! example "Type Assertion"
    ```go title="type_assertion.go" linenums="1" hl_lines="8-18"
    package main

    import "fmt"

    func process(i interface{}) {
        if s, ok := i.(string); ok {
            fmt.Println("String value:", s)
        } else {
            fmt.Println("Not a string")
        }
    }

    func main() {
        process("hello")  // String value: hello
        process(42)       // Not a string
    }
    ```

### Type Switch
Check against multiple types:

!!! example "Type Switch"
    ```go title="type_switch.go" linenums="1" hl_lines="8-22"
    package main

    import "fmt"

    func describe(i interface{}) {
        switch v := i.(type) {
        case string:
            fmt.Printf("String: %q\n", v)
        case int:
            fmt.Printf("Integer: %d\n", v)
        case bool:
            fmt.Printf("Boolean: %t\n", v)
        default:
            fmt.Printf("Unknown type: %T\n", v)
        }
    }

    func main() {
        describe("hello")  // String: "hello"
        describe(42)       // Integer: 42
        describe(true)     // Boolean: true
        describe(3.14)     // Unknown type: float64
    }
    ```

## Common Standard Library Interfaces

### 1. `io.Reader` and `io.Writer`

!!! example "Reader and Writer Interfaces"
    ```go title="io_interfaces.go" linenums="1" hl_lines="3-10"
    package main

    import (
        "io"
        "os"
    )

    type Reader interface {
        Read(p []byte) (n int, err error)
    }

    type Writer interface {
        Write(p []byte) (n int, err error)
    }

    func main() {
        // os.Stdin implements Reader
        // os.Stdout implements Writer
        io.Copy(os.Stdout, os.Stdin)
    }
    ```

### 2. `fmt.Stringer`

!!! example "Stringer Interface"
    ```go title="stringer_interface.go" linenums="1" hl_lines="8-17"
    package main

    import "fmt"

    type Person struct {
        Name string
        Age  int
    }

    func (p Person) String() string {
        return fmt.Sprintf("%s (%d years)", p.Name, p.Age)
    }

    func main() {
        p := Person{"Alice", 30}
        fmt.Println(p) // Automatically calls String()
    }
    ```

### 3. `error` Interface

!!! example "Error Interface"
    ```go title="error_interface.go" linenums="1" hl_lines="8-17"
    package main

    import "fmt"

    type MyError struct {
        Message string
    }

    func (e MyError) Error() string {
        return e.Message
    }

    func main() {
        err := MyError{"something went wrong"}
        fmt.Println(err) // something went wrong
    }
    ```

### 4. `sort.Interface`

!!! example "Sort Interface"
    ```go title="sort_interface.go" linenums="1" hl_lines="8-23"
    package main

    import (
        "fmt"
        "sort"
    )

    type ByLength []string

    func (s ByLength) Len() int           { return len(s) }
    func (s ByLength) Less(i, j int) bool { return len(s[i]) < len(s[j]) }
    func (s ByLength) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

    func main() {
        fruits := []string{"apple", "banana", "cherry"}
        sort.Sort(ByLength(fruits))
        fmt.Println(fruits) // [apple cherry banana]
    }
    ```

## Interface Composition

Interfaces can be composed of other interfaces:

!!! example "Interface Composition"
    ```go title="interface_composition.go" linenums="1" hl_lines="3-13"
    package main

    type Reader interface {
        Read([]byte) (int, error)
    }

    type Closer interface {
        Close() error
    }

    type ReadCloser interface {
        Reader
        Closer
    }

    func main() {
        // Implementation examples
    }
    ```

## Best Practices for Interfaces

### 1. Keep Interfaces Small
Follow the interface segregation principle:

!!! warning "Interface Size"
    Large interfaces with many methods violate the single responsibility principle and make implementations difficult.

!!! example "Small vs Large Interfaces"
    ```go title="interface_size.go" linenums="1" hl_lines="3-18"
    package main

    // Good: Small, focused interface
    type Reader interface {
        Read([]byte) (int, error)
    }

    // Bad: Large, bloated interface
    type FileSystemObject interface {
        Read([]byte) (int, error)
        Write([]byte) (int, error)
        Seek(offset int64, whence int) (int64, error)
        Close() error
        Readdir(count int) ([]os.FileInfo, error)
        // ... many more methods
    }
    ```

### 2. Accept Interfaces, Return Structs

!!! tip "Interface Return Values"
    Return concrete types rather than interfaces to make API boundaries clear and avoid unnecessary abstraction.

!!! example "Accept Interfaces, Return Structs"
    ```go title="interface_return.go" linenums="1" hl_lines="8-16"
    package main

    import "io"

    // Good: Accept interface, return concrete type
    func ProcessData(r io.Reader) ([]byte, error) {
        // Process data
        return []byte("processed"), nil
    }

    // Bad: Return interface
    func GetData() io.Reader {
        return nil // Implementation would return a concrete type
    }

    func main() {
        // Usage examples
    }
    ```

### 3. Design for Behavior, Not Implementation

Focus on what the interface does, not how it's implemented:

!!! example "Behavior-Focused Design"
    ```go title="behavior_focused.go" linenums="1" hl_lines="3-16"
    package main

    // Good: Behavior-focused
    type Storer interface {
        Store(key string, value interface{}) error
        Retrieve(key string) (interface{}, error)
    }

    // Bad: Implementation-focused
    type SQLStorer interface {
        Exec(query string, args ...interface{}) (sql.Result, error)
        Query(query string, args ...interface{}) (*sql.Rows, error)
    }
    ```

## Real-World Example: Pluggable Storage System

Let's build a storage system that supports multiple backends (in-memory, file-based, and database) using interfaces:

!!! example "Storage System"
    ```go title="storage_system.go" linenums="1" hl_lines="8-50"
    package main

    import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "sync"
    )

    // Storage defines the interface for our storage backends
    type Storage interface {
        Store(key string, value interface{}) error
        Retrieve(key string) (interface{}, error)
        Delete(key string) error
        List() ([]string, error)
        Close() error
    }

    // InMemoryStorage implements Storage using a map
    type InMemoryStorage struct {
        data map[string]interface{}
        mu   sync.RWMutex
    }

    func NewInMemoryStorage() *InMemoryStorage {
        return &InMemoryStorage{
            data: make(map[string]interface{}),
        }
    }

    func (s *InMemoryStorage) Store(key string, value interface{}) error {
        s.mu.Lock()
        defer s.mu.Unlock()
        s.data[key] = value
        return nil
    }

    func (s *InMemoryStorage) Retrieve(key string) (interface{}, error) {
        s.mu.RLock()
        defer s.mu.RUnlock()
        value, exists := s.data[key]
        if !exists {
            return nil, errors.New("key not found")
        }
        return value, nil
    }

    func (s *InMemoryStorage) Delete(key string) error {
        s.mu.Lock()
        defer s.mu.Unlock()
        if _, exists := s.data[key]; !exists {
            return errors.New("key not found")
        }
        delete(s.data, key)
        return nil
    }

    func (s *InMemoryStorage) List() ([]string, error) {
        s.mu.RLock()
        defer s.mu.RUnlock()
        keys := make([]string, 0, len(s.data))
        for k := range s.data {
            keys = append(keys, k)
        }
        return keys, nil
    }

    func (s *InMemoryStorage) Close() error {
        // Nothing to do for in-memory storage
        return nil
    }

    // FileStorage implements Storage using the filesystem
    type FileStorage struct {
        baseDir string
    }

    func NewFileStorage(baseDir string) (*FileStorage, error) {
        if err := os.MkdirAll(baseDir, 0755); err != nil {
            return nil, err
        }
        return &FileStorage{baseDir: baseDir}, nil
    }

    func (s *FileStorage) filePath(key string) string {
        return fmt.Sprintf("%s/%s.json", s.baseDir, key)
    }

    func (s *FileStorage) Store(key string, value interface{}) error {
        data, err := json.Marshal(value)
        if err != nil {
            return err
        }
        return os.WriteFile(s.filePath(key), data, 0644)
    }

    func (s *FileStorage) Retrieve(key string) (interface{}, error) {
        data, err := os.ReadFile(s.filePath(key))
        if os.IsNotExist(err) {
            return nil, errors.New("key not found")
        }
        if err != nil {
            return nil, err
        }
        
        var value interface{}
        if err := json.Unmarshal(data, &value); err != nil {
            return nil, err
        }
        return value, nil
    }

    func (s *FileStorage) Delete(key string) error {
        err := os.Remove(s.filePath(key))
        if os.IsNotExist(err) {
            return errors.New("key not found")
        }
        return err
    }

    func (s *FileStorage) List() ([]string, error) {
        entries, err := os.ReadDir(s.baseDir)
        if err != nil {
            return nil, err
        }
        
        keys := make([]string, 0, len(entries))
        for _, entry := range entries {
            if !entry.IsDir() {
                // Remove .json extension
                name := entry.Name()
                if len(name) > 5 && name[len(name)-5:] == ".json" {
                    keys = append(keys, name[:len(name)-5])
                }
            }
        }
        return keys, nil
    }

    func (s *FileStorage) Close() error {
        // Nothing to do for file storage
        return nil
    }

    // StorageService provides additional functionality on top of Storage
    type StorageService struct {
        storage Storage
    }

    func NewStorageService(storage Storage) *StorageService {
        return &StorageService{storage: storage}
    }

    func (s *StorageService) StoreUser(id string, user map[string]interface{}) error {
        return s.storage.Store(id, user)
    }

    func (s *StorageService) GetUser(id string) (map[string]interface{}, error) {
        value, err := s.storage.Retrieve(id)
        if err != nil {
            return nil, err
        }
        
        user, ok := value.(map[string]interface{})
        if !ok {
            return nil, errors.New("invalid user data format")
        }
        return user, nil
    }

    func main() {
        // Choose storage backend
        var storage Storage
        
        // Option 1: In-memory storage
        storage = NewInMemoryStorage()
        
        // Option 2: File storage (uncomment to use)
        // fileStorage, err := NewFileStorage("./data")
        // if err != nil {
        //     panic(err)
        // }
        // storage = fileStorage
        
        // Create service
        service := NewStorageService(storage)
        defer service.Close()
        
        // Store some users
        users := []map[string]interface{}{
            {"name": "Alice", "age": 30, "email": "alice@example.com"},
            {"name": "Bob", "age": 25, "email": "bob@example.com"},
            {"name": "Charlie", "age": 35, "email": "charlie@example.com"},
        }
        
        for i, user := range users {
            id := fmt.Sprintf("user%d", i+1)
            if err := service.StoreUser(id, user); err != nil {
                fmt.Printf("Error storing user %s: %v\n", id, err)
            }
        }
        
        // List all users
        fmt.Println("\nStored users:")
        ids, err := service.ListUsers()
        if err != nil {
            fmt.Printf("Error listing users: %v\n", err)
            return
        }
        
        for _, id := range ids {
            user, err := service.GetUser(id)
            if err != nil {
                fmt.Printf("Error retrieving user %s: %v\n", id, err)
                continue
            }
            fmt.Printf("%s: %+v\n", id, user)
        }
    }
    ```

### How This Example Demonstrates Interface Concepts:

1. **Interface Definition**:
   - `Storage` interface defines the contract for all storage backends
   - Clear separation between interface and implementation

2. **Multiple Implementations**:
   - `InMemoryStorage` uses a map for storage
   - `FileStorage` uses the filesystem
   - Both implement the same interface

3. **Service Layer**:
   - `StorageService` adds business logic on top of storage
   - Works with any Storage implementation

4. **Polymorphism**:
   - Can switch between storage backends without changing service code
   - Code works with any type that satisfies the Storage interface

## Advanced Interface Patterns

### 1. Interface Embedding

!!! example "Interface Embedding"
    ```go title="interface_embedding.go" linenums="1" hl_lines="3-11"
    package main

    type Reader interface {
        Read([]byte) (int, error)
    }

    type Closer interface {
        Close() error
    }

    type ReadCloser interface {
        Reader
        Closer
    }

    func main() {
        // Implementation examples
    }
    ```

### 2. Interface for Dependency Injection

!!! example "Dependency Injection"
    ```go title="dependency_injection.go" linenums="1" hl_lines="8-18"
    package main

    import "database/sql"

    type Database interface {
        Query(query string, args ...interface{}) (*sql.Rows, error)
        Exec(query string, args ...interface{}) (sql.Result, error)
    }

    type Service struct {
        db Database
    }

    func NewService(db Database) *Service {
        return &Service{db: db}
    }

    func main() {
        // Implementation examples
    }
    ```

## Best Practices

!!! warning "Common Pitfalls"
    - Creating overly large interfaces that are hard to implement
    - Returning interfaces instead of concrete types
    - Using interfaces when concrete types would suffice
    - Forgetting that nil pointers can satisfy non-nil interfaces

!!! example "Best Practice Patterns"
    ```go title="best_practices.go" linenums="1" hl_lines="8-20"
    package main

    import "io"

    // Good: Small, focused interface
    type Reader interface {
        Read([]byte) (int, error)
    }

    // Good: Accept interface, return concrete type
    func ProcessData(r io.Reader) ([]byte, error) {
        // Process data
        return []byte("processed"), nil
    }

    // Good: Behavior-focused interface
    type Storer interface {
        Store(key string, value interface{}) error
        Retrieve(key string) (interface{}, error)
    }

    func main() {
        // Usage examples
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Interface Definition**: Define method signatures without implementation
    - **Implicit Satisfaction**: Types implement interfaces automatically by defining methods
    - **Polymorphism**: Treat different types uniformly through interfaces
    - **Interface Composition**: Build complex interfaces from smaller ones
    - **Type Assertions**: Extract concrete values from interfaces
    - **Best Practices**: Keep interfaces small, accept interfaces return concrete types

!!! quote "Remember"
    "Interfaces in Go provide a powerful way to define contracts between components. By focusing on behavior rather than implementation, they enable decoupling, testability, and flexibility. Mastering interfaces is key to writing idiomatic, maintainable Go code that can evolve with changing requirements."