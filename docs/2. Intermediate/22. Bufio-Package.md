

# The `bufio` Package in Go: A Comprehensive Guide

## Introduction to Buffered I/O
The `bufio` package in Go implements buffered I/O, wrapping `io.Reader` and `io.Writer` objects to create buffered readers and writers. Buffering reduces the number of system calls and improves performance, especially when dealing with small, frequent I/O operations.

## Why Use Buffered I/O?
- **Performance**: Reduces system call overhead by reading/writing in chunks
- **Convenience**: Provides helpful methods for common operations like reading lines
- **Efficiency**: Minimizes disk/network I/O operations
- **Flexibility**: Works with any `io.Reader` or `io.Writer`

## Buffered Readers (`bufio.Reader`)

### 1. Creating a Buffered Reader
```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func main() {
	// Create a buffered reader from a string
	reader := bufio.NewReader(strings.NewReader("Hello, World!\nThis is a test.\n"))
	
	// Read the entire content
	content, err := io.ReadAll(reader)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("Content:", string(content))
}
```

### 2. Reading by Lines
```go
func main() {
	data := "First line\nSecond line\nThird line\n"
	reader := bufio.NewReader(strings.NewReader(data))
	
	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			fmt.Println("Error:", err)
			return
		}
		fmt.Printf("Line: %q\n", strings.TrimSpace(line))
	}
}
```

### 3. Reading Bytes
```go
func main() {
	data := "Hello, World!"
	reader := bufio.NewReader(strings.NewReader(data))
	
	// Read first 5 bytes
	buf := make([]byte, 5)
	n, err := reader.Read(buf)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Read %d bytes: %q\n", n, buf)
	
	// Peek at next bytes without advancing
	peeked, err := reader.Peek(3)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Peeked: %q\n", peeked)
}
```

### 4. Using `ReadLine` (Deprecated but Still Used)
```go
func main() {
	data := "Line 1\nLine 2\nLine 3\n"
	reader := bufio.NewReader(strings.NewReader(data))
	
	for {
		line, isPrefix, err := reader.ReadLine()
		if err != nil {
			if err == io.EOF {
				break
			}
			fmt.Println("Error:", err)
			return
		}
		
		fmt.Printf("Line: %q (isPrefix: %v)\n", line, isPrefix)
	}
}
```

## The `bufio.Scanner` Type

### 1. Basic Scanning
```go
func main() {
	data := "word1 word2 word3\nline2 word4"
	scanner := bufio.NewScanner(strings.NewReader(data))
	
	// Scan line by line (default)
	for scanner.Scan() {
		fmt.Println("Line:", scanner.Text())
	}
	
	if err := scanner.Err(); err != nil {
		fmt.Println("Error:", err)
	}
}
```

### 2. Custom Split Functions
```go
func main() {
	data := "apple,banana,cherry,date"
	scanner := bufio.NewScanner(strings.NewReader(data))
	
	// Split by commas
	scanner.Split(bufio.ScanWords) // Default is ScanLines
	
	// Custom split function
	splitFunc := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
		// Skip leading spaces
		start := 0
		for ; start < len(data); start++ {
			if data[start] != ',' {
				break
			}
		}
		
		// Scan until comma or EOF
		for i := start; i < len(data); i++ {
			if data[i] == ',' {
				return i + 1, data[start:i], nil
			}
		}
		
		// If we're at EOF, we have a final, non-terminated line
		if atEOF && len(data) > start {
			return len(data), data[start:], nil
		}
		
		// Request more data
		return start, nil, nil
	}
	
	scanner.Split(splitFunc)
	
	for scanner.Scan() {
		fmt.Println("Token:", scanner.Text())
	}
}
```

### 3. Built-in Split Functions
```go
func main() {
	data := "word1 word2\nword3 word4"
	
	// ScanLines (default)
	fmt.Println("ScanLines:")
	scanner := bufio.NewScanner(strings.NewReader(data))
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}
	
	// ScanWords
	fmt.Println("\nScanWords:")
	scanner = bufio.NewScanner(strings.NewReader(data))
	scanner.Split(bufio.ScanWords)
	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}
	
	// ScanBytes
	fmt.Println("\nScanBytes:")
	scanner = bufio.NewScanner(strings.NewReader(data))
	scanner.Split(bufio.ScanBytes)
	for scanner.Scan() {
		fmt.Printf("%q ", scanner.Text())
	}
	fmt.Println()
	
	// ScanRunes
	fmt.Println("\nScanRunes:")
	scanner = bufio.NewScanner(strings.NewReader(data))
	scanner.Split(bufio.ScanRunes)
	for scanner.Scan() {
		fmt.Printf("%q ", scanner.Text())
	}
	fmt.Println()
}
```

## Buffered Writers (`bufio.Writer`)

### 1. Creating a Buffered Writer
```go
func main() {
	// Create a buffered writer that writes to os.Stdout
	writer := bufio.NewWriter(os.Stdout)
	
	// Write data
	_, err := writer.WriteString("Hello, Buffered World!\n")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	
	// Remember to flush!
	err = writer.Flush()
	if err != nil {
		fmt.Println("Error flushing:", err)
	}
}
```

### 2. Writing with Buffering
```go
func main() {
	var buf bytes.Buffer
	writer := bufio.NewWriter(&buf)
	
	// Write multiple times
	for i := 0; i < 5; i++ {
		_, err := writer.WriteString(fmt.Sprintf("Line %d\n", i+1))
		if err != nil {
			fmt.Println("Error:", err)
			return
		}
		// Data is buffered, not yet written to buf
	}
	
	// Flush to write all buffered data
	err := writer.Flush()
	if err != nil {
		fmt.Println("Error flushing:", err)
		return
	}
	
	fmt.Println("Buffer content:")
	fmt.Print(buf.String())
}
```

### 3. Available and Size
```go
func main() {
	writer := bufio.NewWriterSize(os.Stdout, 32) // 32-byte buffer
	
	// Check available buffer space
	fmt.Printf("Available: %d bytes\n", writer.Available())
	
	// Write some data
	writer.WriteString("Hello")
	fmt.Printf("Available after write: %d bytes\n", writer.Available())
	
	// Check buffer size
	fmt.Printf("Buffer size: %d bytes\n", writer.Size())
	
	// Flush
	writer.Flush()
}
```

## Real-World Example: Log File Processor

Let's build a comprehensive log file processor that demonstrates various `bufio` features:

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"regexp"
	"strings"
	"time"
)

// LogEntry represents a parsed log entry
type LogEntry struct {
	Timestamp time.Time
	Level     string
	Message   string
	Source    string
}

// LogProcessor handles log file processing
type LogProcessor struct {
	inputFile  string
	outputFile string
	filter     *regexp.Regexp
	stats      struct {
		TotalLines   int
		ErrorLines   int
		WarningLines int
		InfoLines    int
	}
}

func NewLogProcessor(input, output string, filterPattern string) (*LogProcessor, error) {
	lp := &LogProcessor{
		inputFile:  input,
		outputFile: output,
	}
	
	if filterPattern != "" {
		var err error
		lp.filter, err = regexp.Compile(filterPattern)
		if err != nil {
			return nil, fmt.Errorf("invalid filter pattern: %w", err)
		}
	}
	
	return lp, nil
}

// ProcessFile reads the input log file, processes it, and writes to output
func (lp *LogProcessor) ProcessFile() error {
	// Open input file
	inputFile, err := os.Open(lp.inputFile)
	if err != nil {
		return fmt.Errorf("failed to open input file: %w", err)
	}
	defer inputFile.Close()
	
	// Create output file
	outputFile, err := os.Create(lp.outputFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outputFile.Close()
	
	// Create buffered reader and writer
	reader := bufio.NewReader(inputFile)
	writer := bufio.NewWriter(outputFile)
	defer writer.Flush()
	
	// Process line by line
	lineNumber := 0
	for {
		lineNumber++
		line, err := reader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("error reading line %d: %w", lineNumber, err)
		}
		
		// Parse log entry
		entry, err := lp.parseLogEntry(line, lineNumber)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing line %d: %v\n", lineNumber, err)
			continue
		}
		
		// Apply filter if specified
		if lp.filter != nil && !lp.filter.MatchString(entry.Message) {
			continue
		}
		
		// Update statistics
		lp.updateStats(entry)
		
		// Write processed entry
		if err := lp.writeLogEntry(writer, entry); err != nil {
			return fmt.Errorf("error writing line %d: %w", lineNumber, err)
		}
	}
	
	// Write summary statistics
	if err := lp.writeSummary(writer); err != nil {
		return fmt.Errorf("error writing summary: %w", err)
	}
	
	fmt.Printf("Processing complete. Processed %d lines.\n", lp.stats.TotalLines)
	return nil
}

// parseLogEntry parses a single log line
func (lp *LogProcessor) parseLogEntry(line string, lineNumber int) (*LogEntry, error) {
	line = strings.TrimSpace(line)
	if line == "" {
		return nil, fmt.Errorf("empty line")
	}
	
	// Simple log format: [timestamp] [level] [source] message
	// Example: [2023-11-15T14:30:45Z] [ERROR] [server] Database connection failed
	
	parts := strings.SplitN(line, "]", 3)
	if len(parts) < 3 {
		return nil, fmt.Errorf("invalid log format")
	}
	
	// Parse timestamp
	timestampStr := strings.Trim(parts[0], "[ ")
	timestamp, err := time.Parse(time.RFC3339, timestampStr)
	if err != nil {
		return nil, fmt.Errorf("invalid timestamp: %w", err)
	}
	
	// Parse level
	levelStr := strings.Trim(parts[1], "[ ")
	level := strings.ToUpper(levelStr)
	
	// Parse source and message
	rest := strings.TrimSpace(parts[2])
	sourceEnd := strings.Index(rest, "]")
	if sourceEnd == -1 {
		return nil, fmt.Errorf("invalid source format")
	}
	
	source := strings.Trim(rest[:sourceEnd], "[ ")
	message := strings.TrimSpace(rest[sourceEnd+1:])
	
	return &LogEntry{
		Timestamp: timestamp,
		Level:     level,
		Message:   message,
		Source:    source,
	}, nil
}

// writeLogEntry writes a formatted log entry
func (lp *LogProcessor) writeLogEntry(writer *bufio.Writer, entry *LogEntry) error {
	// Format: [timestamp] LEVEL source: message
	formatted := fmt.Sprintf("[%s] %s %s: %s\n",
		entry.Timestamp.Format(time.RFC3339),
		entry.Level,
		entry.Source,
		entry.Message)
	
	_, err := writer.WriteString(formatted)
	return err
}

// updateStats updates processing statistics
func (lp *LogProcessor) updateStats(entry *LogEntry) {
	lp.stats.TotalLines++
	
	switch entry.Level {
	case "ERROR":
		lp.stats.ErrorLines++
	case "WARNING", "WARN":
		lp.stats.WarningLines++
	case "INFO":
		lp.stats.InfoLines++
	}
}

// writeSummary writes processing summary
func (lp *LogProcessor) writeSummary(writer *bufio.Writer) error {
	summary := fmt.Sprintf(`
=== Processing Summary ===
Total lines processed: %d
Error lines: %d
Warning lines: %d
Info lines: %d
========================
`, lp.stats.TotalLines, lp.stats.ErrorLines, lp.stats.WarningLines, lp.stats.InfoLines)
	
	_, err := writer.WriteString(summary)
	return err
}

// generateSampleLog creates a sample log file for testing
func generateSampleLog(filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()
	
	writer := bufio.NewWriter(file)
	defer writer.Flush()
	
	logEntries := []string{
		"[2023-11-15T14:30:45Z] [INFO] [server] Server started",
		"[2023-11-15T14:31:00Z] [INFO] [database] Connected to database",
		"[2023-11-15T14:31:15Z] [WARNING] [auth] Failed login attempt",
		"[2023-11-15T14:31:30Z] [ERROR] [database] Connection timeout",
		"[2023-11-15T14:31:45Z] [INFO] [server] Request processed",
		"[2023-11-15T14:32:00Z] [ERROR] [server] Internal server error",
	}
	
	for _, entry := range logEntries {
		if _, err := writer.WriteString(entry + "\n"); err != nil {
			return err
		}
	}
	
	return nil
}

func main() {
	// Generate sample log file
	inputFile := "sample.log"
	outputFile := "processed.log"
	
	if err := generateSampleLog(inputFile); err != nil {
		fmt.Printf("Error generating sample log: %v\n", err)
		return
	}
	fmt.Println("Generated sample log file:", inputFile)
	
	// Create log processor
	processor, err := NewLogProcessor(inputFile, outputFile, "server|database")
	if err != nil {
		fmt.Printf("Error creating log processor: %v\n", err)
		return
	}
	
	// Process the log file
	if err := processor.ProcessFile(); err != nil {
		fmt.Printf("Error processing log file: %v\n", err)
		return
	}
	
	fmt.Println("Log processing complete. Output written to:", outputFile)
	
	// Display the processed file
	fmt.Println("\n=== Processed Log Content ===")
	content, err := os.ReadFile(outputFile)
	if err != nil {
		fmt.Printf("Error reading output file: %v\n", err)
		return
	}
	fmt.Print(string(content))
}
```

### How This Example Works:

1. **Log Processing Pipeline**:
   - Reads log file line by line using `bufio.Reader`
   - Parses each log entry into structured data
   - Applies filtering based on regex patterns
   - Writes processed entries using `bufio.Writer`

2. **Buffered I/O Operations**:
   - Uses `bufio.NewReader` for efficient line reading
   - Uses `bufio.NewWriter` for efficient writing
   - Demonstrates proper resource management with `defer`

3. **Error Handling**:
   - Handles I/O errors gracefully
   - Provides detailed error messages with line numbers
   - Continues processing after non-critical errors

4. **Statistics Tracking**:
   - Counts different log levels
   - Generates summary reports
   - Writes statistics to output file

### Real-World Applications:

1. **Log Analysis**:
   - Process application logs
   - Filter and categorize log entries
   - Generate summary reports

2. **Data Transformation**:
   - Convert between data formats
   - Clean and normalize data
   - Apply business rules

3. **File Processing**:
   - Process large files efficiently
   - Handle different line endings
   - Memory-efficient processing

## Best Practices

### 1. Always Flush Buffered Writers
```go
// Good: Explicit flush
writer := bufio.NewWriter(file)
_, err := writer.WriteString("data")
if err != nil {
    return err
}
err = writer.Flush() // Important!
if err != nil {
    return err
}

// Bad: Forgetting to flush
writer := bufio.NewWriter(file)
writer.WriteString("data") // Data might not be written!
```

### 2. Handle Scanner Errors
```go
// Good: Check scanner errors
scanner := bufio.NewScanner(file)
for scanner.Scan() {
    // Process line
}
if err := scanner.Err(); err != nil {
    log.Printf("Scanner error: %v", err)
}

// Bad: Ignoring scanner errors
scanner := bufio.NewScanner(file)
for scanner.Scan() {
    // Process line
}
// Might miss important errors!
```

### 3. Choose Appropriate Buffer Sizes
```go
// For small files or frequent operations
reader := bufio.NewReader(os.Stdin) // Default buffer size (4096 bytes)

// For large files or performance-critical code
reader = bufio.NewReaderSize(os.Stdin, 64*1024) // 64KB buffer
```

### 4. Close Resources Properly
```go
// Good: Use defer for cleanup
file, err := os.Open("file.txt")
if err != nil {
    return err
}
defer file.Close()

reader := bufio.NewReader(file)
// Process file...

// Bad: Manual cleanup (error-prone)
file, err := os.Open("file.txt")
if err != nil {
    return err
}
reader := bufio.NewReader(file)
// Process file...
file.Close() // Might not execute if there's an error!
```

## Performance Considerations

### 1. Buffer Size Impact
```go
// Benchmark different buffer sizes
func benchmarkBufferSize(filename string, bufferSize int) time.Duration {
	file, _ := os.Open(filename)
	defer file.Close()
	
	start := time.Now()
	reader := bufio.NewReaderSize(file, bufferSize)
	
	// Read entire file
	_, _ = io.Copy(io.Discard, reader)
	
	return time.Since(start)
}
```

### 2. Scanner vs Manual Reading
```go
// Scanner is convenient but slightly slower
func countLinesScanner(filename string) (int, error) {
	file, err := os.Open(filename)
	if err != nil {
		return 0, err
	}
	defer file.Close()
	
	scanner := bufio.NewScanner(file)
	count := 0
	for scanner.Scan() {
		count++
	}
	return count, scanner.Err()
}

// Manual reading is faster but more code
func countLinesManual(filename string) (int, error) {
	file, err := os.Open(filename)
	if err != nil {
		return 0, err
	}
	defer file.Close()
	
	reader := bufio.NewReader(file)
	count := 0
	for {
		_, err := reader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return 0, err
		}
		count++
	}
	return count, nil
}
```

## Common Patterns

### 1. Line-by-Line Processing
```go
func processFile(filename string, processFunc func(string) error) error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()
	
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		if err := processFunc(scanner.Text()); err != nil {
			return err
		}
	}
	return scanner.Err()
}
```

### 2. Buffered Writing with Auto-Flush
```go
type AutoFlushWriter struct {
	*bufio.Writer
	flushInterval time.Duration
	lastFlush    time.Time
}

func NewAutoFlushWriter(w io.Writer, size int, interval time.Duration) *AutoFlushWriter {
	return &AutoFlushWriter{
		Writer:        bufio.NewWriterSize(w, size),
		flushInterval: interval,
		lastFlush:    time.Now(),
	}
}

func (w *AutoFlushWriter) Write(p []byte) (int, error) {
	n, err := w.Writer.Write(p)
	if err != nil {
		return n, err
	}
	
	// Auto-fllush if interval has passed
	if time.Since(w.lastFlush) > w.flushInterval {
		w.Flush()
		w.lastFlush = time.Now()
	}
	
	return n, nil
}
```

### 3. Custom Split Functions
```go
// Split by multiple delimiters
func scanAnyDelimiter(data []byte, atEOF bool) (advance int, token []byte, err error) {
	// Skip leading delimiters
	start := 0
	for ; start < len(data); start++ {
		if data[start] != ' ' && data[start] != '\t' && data[start] != ',' {
			break
		}
	}
	
	// Scan until delimiter or EOF
	for i := start; i < len(data); i++ {
		if data[i] == ' ' || data[i] == '\t' || data[i] == ',' {
			return i + 1, data[start:i], nil
		}
	}
	
	// If we're at EOF, we have a final token
	if atEOF && len(data) > start {
		return len(data), data[start:], nil
	}
	
	// Request more data
	return start, nil, nil
}
```

## Conclusion

The `bufio` package is essential for efficient I/O operations in Go. It provides:

1. **Buffered Reading**:
   - `bufio.Reader` for efficient reading
   - `bufio.Scanner` for convenient tokenization
   - Various split functions for different parsing needs

2. **Buffered Writing**:
   - `bufio.Writer` for efficient writing
   - Automatic flushing capabilities
   - Buffer size control

3. **Performance Benefits**:
   - Reduced system call overhead
   - Memory-efficient processing of large files
   - Flexible buffer sizing

4. **Convenience Features**:
   - Line-by-line reading
   - Custom tokenization
   - Easy integration with `io.Reader` and `io.Writer`

The log file processor example demonstrates how to build a complete application using `bufio` for efficient file processing. By following best practices and understanding the performance characteristics, you can build fast and reliable I/O operations in your Go applications.

Key takeaways:
1. **Always flush** buffered writers to ensure data is written
2. **Check scanner errors** to catch I/O problems
3. **Choose appropriate buffer sizes** based on your use case
4. **Use defer** for proper resource cleanup
5. **Consider performance** when choosing between Scanner and manual reading

Buffered I/O is a fundamental concept in Go programming, and mastering `bufio` will help you build efficient and reliable applications that handle I/O operations effectively.