

{# Regular Expressions in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master Go's regular expression capabilities using the regexp package. Learn pattern matching, text extraction, validation, and advanced regex techniques for building powerful text processing tools, log parsers, and data validation systems.

!!! tip "Key Points"
    - Go's regexp package is based on RE2, offering fast and safe pattern matching
    - Pre-compile regex patterns with regexp.Compile for better performance
    - Use MatchString for simple checks, FindString for extracting matches
    - ReplaceAllString and ReplaceAllStringFunc for text transformation
    - Extract structured data with submatches and named groups
    - Essential for text processing, validation, parsing, and data extraction

## Understanding Regular Expressions

Regular expressions (regex) are sequences of characters that define search patterns. Go's `regexp` package provides powerful regex capabilities based on the RE2 library, offering fast, safe, and efficient pattern matching. Regular expressions are essential for text processing, validation, parsing, and data extraction.

!!! info "Regex Components"
    ```mermaid
    graph LR
        A[Regular Expressions] --> B[Pattern Matching]
        A --> C[Text Extraction]
        A --> D[Validation]
        A --> E[Replacement]
        B --> F[MatchString]
        C --> G[FindString]
        D --> H[Compile]
        E --> I[ReplaceAllString]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Basic Pattern Matching

### 1. Simple Pattern Matching

!!! example "Simple Pattern Matching"
    ```go title="simple_pattern.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // Check if a string contains a pattern
        matched, err := regexp.MatchString("Go", "I love Go programming")
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Println("Contains 'Go':", matched) // true

        // Case-insensitive matching
        matched, _ = regexp.MatchString(`(?i)go`, "I LOVE GO")
        fmt.Println("Contains 'go' (case-insensitive):", matched) // true
    }
    ```

### 2. Character Classes and Quantifiers

!!! example "Character Classes and Quantifiers"
    ```go title="character_classes.go" linenums="1" hl_lines="8-25"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // Character classes
        patterns := []string{
            `[aeiou]`,    // Any vowel
            `[A-Z]`,      // Any uppercase letter
            `[0-9]`,      // Any digit
            `[^0-9]`,     // Any non-digit
            `\d`,         // Digit (same as [0-9])
            `\w`,         // Word character (alphanumeric + underscore)
            `\s`,         // Whitespace character
        }

        testStr := "Hello World 123!"
        for _, pattern := range patterns {
            matched, _ := regexp.MatchString(pattern, testStr)
            fmt.Printf("Pattern %q matches: %v\n", pattern, matched)
        }
    }
    ```

## Compiling Regular Expressions

### 1. Pre-compiling Patterns

For better performance, especially when using the same pattern multiple times:

!!! example "Pre-compiling Patterns"
    ```go title="precompile.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // Compile a regex pattern
        re, err := regexp.Compile(`\d+`) // One or more digits
        if err != nil {
            fmt.Println("Compilation error:", err)
            return
        }

        // Use the compiled regex
        fmt.Println("Matches digits:", re.MatchString("abc123def")) // true
        fmt.Println("Matches digits:", re.MatchString("abcdef"))    // false
    }
    ```

### 2. Using MustCompile for Known Patterns

When you're sure the pattern is valid (e.g., hardcoded patterns):

!!! example "Using MustCompile"
    ```go title="mustcompile.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // MustCompile panics on invalid patterns
        re := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        
        emails := []string{
            "user@example.com",
            "invalid-email",
            "another.user@domain.co.uk",
        }
        
        for _, email := range emails {
            if re.MatchString(email) {
                fmt.Printf("Valid email: %s\n", email)
            } else {
                fmt.Printf("Invalid email: %s\n", email)
            }
        }
    }
    ```

## Finding Matches

### 1. Finding All Matches

!!! example "Finding All Matches"
    ```go title="find_all_matches.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        re := regexp.MustCompile(`\b\d+\b`) // Whole numbers only
        text := "I have 2 apples and 15 oranges"
        
        // Find all matches
        matches := re.FindAllString(text, -1) // -1 for all matches
        fmt.Println("All numbers:", matches) // [2 15]
        
        // Find first match only
        firstMatch := re.FindString(text)
        fmt.Println("First number:", firstMatch) // 2
    }
    ```

### 2. Finding Match Positions

!!! example "Finding Match Positions"
    ```go title="match_positions.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        re := regexp.MustCompile(`Go`)
        text := "Go is great. Go is efficient."
        
        // Find all matches with positions
        matches := re.FindAllStringIndex(text, -1)
        for _, match := range matches {
            fmt.Printf("Found 'Go' at positions %d-%d\n", match[0], match[1])
        }
        // Output:
        // Found 'Go' at positions 0-2
        // Found 'Go' at positions 13-15
    }
    ```

### 3. Finding Submatches (Groups)

!!! example "Finding Submatches"
    ```go title="submatches.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // Extract date components
        re := regexp.MustCompile(`(\d{4})-(\d{2})-(\d{2})`)
        text := "Date: 2023-11-15"
        
        // Find submatches
        matches := re.FindStringSubmatch(text)
        if len(matches) > 0 {
            fmt.Println("Full match:", matches[0]) // 2023-11-15
            fmt.Println("Year:", matches[1])       // 2023
            fmt.Println("Month:", matches[2])      // 11
            fmt.Println("Day:", matches[3])        // 15
        }
    }
    ```

## Replacing Text

### 1. Simple Replacement

!!! example "Simple Replacement"
    ```go title="simple_replacement.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        re := regexp.MustCompile(`apple`)
        text := "I have an apple and another apple"
        
        // Replace all occurrences
        result := re.ReplaceAllString(text, "orange")
        fmt.Println(result) // I have an orange and another orange
    }
    ```

### 2. Using Functions for Replacement

!!! example "Function Replacement"
    ```go title="function_replacement.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "regexp"
        "strings"
    )

    func main() {
        re := regexp.MustCompile(`\b(\w+)\b`)
        text := "hello world"
        
        // Convert to uppercase using a function
        result := re.ReplaceAllStringFunc(text, strings.ToUpper)
        fmt.Println(result) // HELLO WORLD
    }
    ```

### 3. Using Match Groups in Replacement

!!! example "Group Replacement"
    ```go title="group_replacement.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // Swap first and last name
        re := regexp.MustCompile(`(\w+)\s+(\w+)`)
        text := "John Doe"
        
        // Use $1, $2 for groups
        result := re.ReplaceAllString(text, "$2, $1")
        fmt.Println(result) // Doe, John
    }
    ```

## Splitting Strings

### 1. Splitting by Pattern

!!! example "Splitting by Pattern"
    ```go title="splitting_pattern.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        re := regexp.MustCompile(`\s*,\s*`) // Split by comma with optional whitespace
        text := "apple, banana, cherry,  date"
        
        // Split the string
        parts := re.Split(text, -1)
        fmt.Println(parts) // [apple banana cherry date]
    }
    ```

### 2. Limiting Splits

!!! example "Limiting Splits"
    ```go title="limiting_splits.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        re := regexp.MustCompile(`\s+`)
        text := "Split   this   string"
        
        // Split into at most 3 parts
        parts := re.Split(text, 3)
        fmt.Println(parts) // [Split this string]
    }
    ```

## Advanced Patterns

### 1. Lookarounds

!!! example "Lookarounds"
    ```go title="lookarounds.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // Positive lookahead: password must contain digit
        re := regexp.MustCompile(`^(?=.*\d).+$`)
        fmt.Println("Pass123:", re.MatchString("Pass123")) // true
        fmt.Println("Password:", re.MatchString("Password")) // false
        
        // Negative lookahead: password must not contain 'admin'
        re = regexp.MustCompile(`^(?!.*admin).+$`)
        fmt.Println("user123:", re.MatchString("user123")) // true
        fmt.Println("admin123:", re.MatchString("admin123")) // false
    }
    ```

### 2. Non-capturing Groups

!!! example "Non-capturing Groups"
    ```go title="non_capturing_groups.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // Using (?:...) for non-capturing groups
        re := regexp.MustCompile(`(?:https?|ftp)://([^/]+)`)
        url := "https://example.com/path"
        
        matches := re.FindStringSubmatch(url)
        if len(matches) > 1 {
            fmt.Println("Domain:", matches[1]) // example.com
        }
    }
    ```

### 3. Greedy vs. Lazy Matching

!!! example "Greedy vs. Lazy Matching"
    ```go title="greedy_lazy.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        text := "<div>First</div><div>Second</div>"
        
        // Greedy match (default)
        re := regexp.MustCompile(`<div>.*</div>`)
        fmt.Println("Greedy:", re.FindString(text)) // <div>First</div><div>Second</div>
        
        // Lazy match (non-greedy)
        re = regexp.MustCompile(`<div>.*?</div>`)
        fmt.Println("Lazy:", re.FindString(text)) // <div>First</div>
    }
    ```

## Common Patterns and Examples

### 1. Email Validation

!!! example "Email Validation"
    ```go title="email_validation.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "regexp"
    )

    func validateEmail(email string) bool {
        re := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        return re.MatchString(email)
    }

    func main() {
        emails := []string{
            "user@example.com",
            "user.name@domain.co.uk",
            "invalid-email",
            "@domain.com",
        }
        
        for _, email := range emails {
            fmt.Printf("%s: %v\n", email, validateEmail(email))
        }
    }
    ```

### 2. URL Extraction

!!! example "URL Extraction"
    ```go title="url_extraction.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "regexp"
    )

    func extractURLs(text string) []string {
        // Simplified URL pattern
        re := regexp.MustCompile(`https?://[^\s]+`)
        return re.FindAllString(text, -1)
    }

    func main() {
        text := `Visit https://example.com or http://test.org for more info.`
        urls := extractURLs(text)
        fmt.Println("URLs found:", urls)
    }
    ```

### 3. Phone Number Formatting

!!! example "Phone Number Formatting"
    ```go title="phone_formatting.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "regexp"
    )

    func formatPhoneNumber(phone string) string {
        // Remove all non-digits
        re := regexp.MustCompile(`[^\d]`)
        digits := re.ReplaceAllString(phone, "")
        
        // Format as (XXX) XXX-XXXX
        if len(digits) == 10 {
            return fmt.Sprintf("(%s) %s-%s", digits[0:3], digits[3:6], digits[6:])
        }
        return phone
    }

    func main() {
        phones := []string{
            "1234567890",
            "(123) 456-7890",
            "123-456-7890",
        }
        
        for _, phone := range phones {
            fmt.Printf("%s -> %s\n", phone, formatPhoneNumber(phone))
        }
    }
    ```

## Real-World Example: Log Parser

Let's build a comprehensive log parser that extracts structured information from log entries:

!!! example "Log Parser"
    ```go title="log_parser.go" linenums="1" hl_lines="8-60"
    package main

    import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"
    )

    // LogEntry represents a parsed log entry
    type LogEntry struct {
        Timestamp time.Time
        Level     string
        Message   string
        IP        string
        UserID    string
        Status    int
    }

    // LogParser handles log parsing with regex
    type LogParser struct {
        // Patterns for different log formats
        patterns map[string]*regexp.Regexp
    }

    func NewLogParser() *LogParser {
        return &LogParser{
            patterns: map[string]*regexp.Regexp{
                "apache": regexp.MustCompile(`^(\S+) \S+ \S+ \[([\w:/]+\s[+\-]\d{4})\] "(\S+) (\S+) (\S+)" (\d{3}) (\d+|-)`),
                "nginx":  regexp.MustCompile(`^(\S+) - - \[([\w:/]+\s[+\-]\d{4})\] "(\S+) (\S+) (\S+)" (\d{3}) (\d+|-) "([^"]*)" "([^"]*)"`),
                "custom": regexp.MustCompile(`^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[(\w+)\] (.+?) (?:user:(\S+))? (?:ip:(\S+))? (?:status:(\d+))?$`),
            },
        }
    }

    func (lp *LogParser) ParseLog(line string, format string) (*LogEntry, error) {
        re, exists := lp.patterns[format]
        if !exists {
            return nil, fmt.Errorf("unknown log format: %s", format)
        }

        matches := re.FindStringSubmatch(line)
        if matches == nil {
            return nil, fmt.Errorf("line doesn't match format: %s", line)
        }

        entry := &LogEntry{}

        switch format {
        case "apache":
            // Apache log format: IP - - [timestamp] "method path protocol" status size
            entry.IP = matches[1]
            entry.Timestamp = parseApacheTime(matches[2])
            entry.Message = fmt.Sprintf("%s %s %s", matches[3], matches[4], matches[5])
            entry.Status = parseInt(matches[6])
            entry.Level = getLogLevel(entry.Status)

        case "nginx":
            // Nginx log format (extended)
            entry.IP = matches[1]
            entry.Timestamp = parseApacheTime(matches[2])
            entry.Message = fmt.Sprintf("%s %s %s", matches[3], matches[4], matches[5])
            entry.Status = parseInt(matches[6])
            entry.Level = getLogLevel(entry.Status)

        case "custom":
            // Custom format: timestamp [level] message user:user_id ip:ip status:status
            entry.Timestamp = parseCustomTime(matches[1])
            entry.Level = matches[2]
            entry.Message = matches[3]
            entry.UserID = matches[4]
            entry.IP = matches[5]
            if matches[6] != "" {
                entry.Status = parseInt(matches[6])
            }
        }

        return entry, nil
    }

    // Helper functions
    func parseApacheTime(ts string) time.Time {
        // Parse Apache timestamp format: 10/Oct/2000:13:55:36 -0700
        layout := "02/Jan/2006:15:04:05 -0700"
        t, _ := time.Parse(layout, ts)
        return t
    }

    func parseCustomTime(ts string) time.Time {
        // Parse custom timestamp format: 2023-11-15 14:30:45
        layout := "2006-01-02 15:04:05"
        t, _ := time.Parse(layout, ts)
        return t
    }

    func parseInt(s string) int {
        i, _ := strconv.Atoi(s)
        return i
    }

    func getLogLevel(status int) string {
        if status >= 500 {
            return "ERROR"
        } else if status >= 400 {
            return "WARN"
        } else if status >= 300 {
            return "INFO"
        }
        return "DEBUG"
    }

    func main() {
        parser := NewLogParser()

        // Sample log lines
        logLines := []struct {
            line   string
            format string
        }{
            {
                `127.0.0.1 - - [10/Oct/2023:13:55:36 -0700] "GET /index.html HTTP/1.1" 200 2326`,
                "apache",
            },
            {
                `192.168.1.1 - - [10/Oct/2023:13:56:01 -0700] "POST /api/users HTTP/1.1" 404 1234`,
                "apache",
            },
            {
                `2023-11-15 14:30:45 [INFO] User login successful user:123 ip:192.168.1.100 status:200`,
                "custom",
            },
            {
                `2023-11-15 14:31:02 [ERROR] Database connection failed status:500`,
                "custom",
            },
        }

        for _, logData := range logLines {
            entry, err := parser.ParseLog(logData.line, logData.format)
            if err != nil {
                fmt.Printf("Error parsing log: %v\n", err)
                continue
            }

            fmt.Printf("Parsed Entry:\n")
            fmt.Printf("  Timestamp: %s\n", entry.Timestamp.Format("2006-01-02 15:04:05"))
            fmt.Printf("  Level: %s\n", entry.Level)
            fmt.Printf("  Message: %s\n", entry.Message)
            if entry.IP != "" {
                fmt.Printf("  IP: %s\n", entry.IP)
            }
            if entry.UserID != "" {
                fmt.Printf("  User ID: %s\n", entry.UserID)
            }
            if entry.Status != 0 {
                fmt.Printf("  Status: %d\n", entry.Status)
            }
            fmt.Println()
        }
    }
    ```

### How This Example Works:

1. **Multiple Log Formats**:
   - Supports Apache, Nginx, and custom log formats
   - Each format has its own regex pattern
   - Flexible parsing based on format type

2. **Structured Data Extraction**:
   - Extracts timestamps, IP addresses, user IDs
   - Parses HTTP status codes
   - Determines log levels based on status

3. **Helper Functions**:
   - Time parsing for different formats
   - Integer conversion for status codes
   - Log level determination

4. **Error Handling**:
   - Graceful handling of parsing errors
   - Clear error messages for debugging

### Real-World Applications:

1. **Log Analysis**:
   - Parse application logs
   - Extract metrics and statistics
   - Identify error patterns

2. **Security Monitoring**:
   - Detect suspicious IP addresses
   - Identify failed login attempts
   - Monitor for unusual activity

3. **Data Processing**:
   - Extract structured data from text
   - Transform unstructured logs to JSON
   - Feed data into analytics systems

## Performance Considerations

### 1. Pre-compile Patterns

!!! example "Pre-compile Patterns"
    ```go title="precompile_patterns.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "regexp"
    )

    // Good: Pre-compile for reuse
    var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)

    func validateEmail(email string) bool {
        return emailRegex.MatchString(email)
    }

    // Bad: Compile on every call
    func validateEmailBad(email string) bool {
        re, _ := regexp.Compile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        return re.MatchString(email)
    }

    func main() {
        fmt.Println("Valid:", validateEmail("user@example.com"))
        fmt.Println("Invalid:", validateEmail("invalid-email"))
    }
    ```

### 2. Use Specific Patterns

!!! example "Specific Patterns"
    ```go title="specific_patterns.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // Good: Specific pattern
        re := regexp.MustCompile(`^user_\d+$`)
        fmt.Println("user_123:", re.MatchString("user_123")) // true
        fmt.Println("user_abc:", re.MatchString("user_abc")) // false
        
        // Bad: Too general pattern
        re = regexp.MustCompile(`user.*`)
        fmt.Println("user_123:", re.MatchString("user_123")) // true
        fmt.Println("user_abc:", re.MatchString("user_abc")) // true
    }
    ```

### 3. Avoid Catastrophic Backtracking

!!! example "Avoid Backtracking"
    ```go title="avoid_backtracking.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "regexp"
    )

    func main() {
        // Dangerous: Nested quantifiers can cause exponential backtracking
        // re := regexp.MustCompile(`(a+)+`)
        
        // Better: More specific pattern
        re := regexp.MustCompile(`a+`)
        fmt.Println("Matches a's:", re.MatchString("aaaa")) // true
        fmt.Println("Matches b's:", re.MatchString("bbbb")) // false
    }
    ```

## Best Practices

!!! tip "Pattern Selection"
    Choose the right regex pattern for each use case to ensure accuracy and performance.

!!! example "Pattern Selection"
    ```go title="pattern_selection.go" linenums="1" hl_lines="8-14"
    package main

    import "regexp"

    func main() {
        // Use specific patterns for better performance
        re := regexp.MustCompile(`^user_\d+$`)
        
        // Avoid overly general patterns
        // re = regexp.MustCompile(`user.*`)
    }
    ```

!!! warning "Performance Considerations"
    Avoid complex patterns with nested quantifiers that can cause exponential backtracking.

!!! example "Performance Optimization"
    ```go title="performance_optimization.go" linenums="1" hl_lines="8-18"
    package main

    import "regexp"

    func main() {
        // Good: Pre-compile for reuse
        var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        
        // Bad: Compile on every call
        // func validateEmailBad(email string) bool {
        //     re, _ := regexp.Compile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        //     return re.MatchString(email)
        // }
    }
    ```

!!! tip "Write Readable Patterns"
    Use comments and raw strings for complex patterns to improve maintainability.

!!! example "Readable Patterns"
    ```go title="readable_patterns.go" linenums="1" hl_lines="8-16"
    package main

    import "regexp"

    func main() {
        // Use comments and raw strings for complex patterns
        pattern := `^
            (\d{4})-  # Year
            (\d{2})-  # Month
            (\d{2})   # Day
        $`
        re := regexp.MustCompile(pattern)
        fmt.Println("Matches date:", re.MatchString("2023-11-15")) // true
    }
    ```

!!! tip "Test Your Patterns"
    Thoroughly test regex patterns with various inputs to ensure they work correctly.

!!! example "Testing Patterns"
    ```go title="testing_patterns.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
        "regexp"
        "testing"
    )

    var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)

    func TestEmailRegex(t *testing.T) {
        tests := []struct {
            email string
            valid bool
        }{
            {"user@example.com", true},
            {"invalid-email", false},
            {"@domain.com", false},
        }
        
        for _, test := range tests {
            result := emailRegex.MatchString(test.email)
            if result != test.valid {
                t.Errorf("Email %s: expected %v, got %v", test.email, test.valid, result)
            }
        }
    }

    func main() {
        fmt.Println("Valid email:", emailRegex.MatchString("user@example.com"))
        fmt.Println("Invalid email:", emailRegex.MatchString("invalid-email"))
    }
    ```

!!! tip "Handle Errors Gracefully"
    Always handle potential errors when working with regular expressions.

!!! example "Error Handling"
    ```go title="error_handling.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "regexp"
    )

    func safeFindString(re *regexp.Regexp, str string) string {
        match := re.FindString(str)
        if match == "" {
            return "default"
        }
        return match
    }

    func main() {
        re := regexp.MustCompile(`\d+`)
        fmt.Println("Found:", safeFindString(re, "abc123def")) // 123
        fmt.Println("Found:", safeFindString(re, "abcdef"))    // default
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Basic Functions**: Use `regexp.MatchString` for simple checks, `regexp.Compile` for reusable patterns
    - **Finding Matches**: `FindString` for first match, `FindAllString` for all matches
    - **Extraction**: Use `FindStringSubmatch` to extract groups and subpatterns
    - **Replacement**: `ReplaceAllString` for simple replacement, `ReplaceAllStringFunc` for dynamic replacement
    - **Splitting**: `Split` method to divide strings based on patterns
    - **Advanced Patterns**: Lookarounds, non-capturing groups, lazy quantifiers
    - **Performance**: Pre-compile patterns, avoid nested quantifiers, use specific patterns

!!! quote "Remember"
    "Regular expressions in Go are powerful tools for text processing. By mastering pattern matching, extraction, and replacement techniques, you can build sophisticated text processing systems. Always pre-compile patterns for better performance and test your regex thoroughly with various inputs."