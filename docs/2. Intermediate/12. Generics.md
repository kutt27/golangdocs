

# Generics in Go: A Comprehensive Guide

## Introduction to Generics
Generics, introduced in Go 1.18, enable you to write flexible and reusable code by allowing functions and types to work with any data type while maintaining type safety. Before generics, Go developers often used interfaces and type assertions to achieve similar functionality, but this approach lacked compile-time type checking and could lead to runtime errors.

Generics solve these problems by allowing you to define:
- **Type parameters**: Placeholders for actual types
- **Type constraints**: Rules that specify which types can be used
- **Generic functions and types**: Code that works with multiple types

## Why Use Generics?
1. **Type Safety**: Catch type errors at compile time
2. **Code Reusability**: Write once, use with multiple types
3. **Performance**: Avoid runtime type assertions and conversions
4. **Readability**: Clearer intent than interface-based solutions
5. **Reduced Boilerplate**: Eliminate repetitive code for different types

## Generic Functions

### Basic Syntax
```go
func PrintSlice[T any](s []T) {
    for _, v := range s {
        fmt.Print(v, " ")
    }
    fmt.Println()
}

func main() {
    PrintSlice([]int{1, 2, 3})      // Works with int
    PrintSlice([]string{"a", "b"}) // Works with string
}
```

### Type Parameters
- Declared in square brackets `[]` before function parameters
- Can have multiple type parameters: `[T, U any]`
- Conventionally use single capital letters (T, U, V, etc.)

### Type Constraints
Constraints specify what types can be used as type parameters:

```go
// Using built-in constraints
func SumNumbers[T int | float64](nums []T) T {
    var sum T
    for _, n := range nums {
        sum += n
    }
    return sum
}

func main() {
    fmt.Println(SumNumbers([]int{1, 2, 3}))     // 6
    fmt.Println(SumNumbers([]float64{1.1, 2.2})) // 3.3
}
```

## Built-in Constraints

### `any`
Equivalent to `interface{}`, allows any type:
```go
func Identity[T any](x T) T {
    return x
}
```

### `comparable`
Types that support `==` and `!=` operators:
```go
func FindIndex[T comparable](s []T, target T) int {
    for i, v := range s {
        if v == target {
            return i
        }
    }
    return -1
}

func main() {
    fmt.Println(FindIndex([]int{1, 2, 3}, 2))     // 1
    fmt.Println(FindIndex([]string{"a", "b"}, "b")) // 1
}
```

## Custom Type Constraints

### Using Interfaces
```go
type Stringer interface {
    String() string
}

func PrintStringers[T Stringer](s []T) {
    for _, v := range s {
        fmt.Println(v.String())
    }
}

type Person struct {
    Name string
}

func (p Person) String() string {
    return p.Name
}

func main() {
    people := []Person{{"Alice"}, {"Bob"}}
    PrintStringers(people) // Alice\nBob
}
```

### Approximating Constraints
Use `~` to include types whose underlying type matches:
```go
type Number interface {
    int | int8 | int16 | int32 | int64 | 
    float32 | float64
}

func Max[T Number](a, b T) T {
    if a > b {
        return a
    }
    return b
}

type MyInt int

func main() {
    fmt.Println(Max(10, 20))           // 20
    fmt.Println(Max(MyInt(10), MyInt(20))) // 20
}
```

## Generic Types

### Generic Structs
```go
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}

func main() {
    intStack := &Stack[int]{}
    intStack.Push(1)
    intStack.Push(2)
    fmt.Println(intStack.Pop()) // 2, true

    stringStack := &Stack[string]{}
    stringStack.Push("a")
    stringStack.Push("b")
    fmt.Println(stringStack.Pop()) // "b", true
}
```

### Generic Slices and Maps
```go
// Generic slice type
type Vector[T any] []T

func (v *Vector[T]) Push(item T) {
    *v = append(*v, item)
}

// Generic map type
type Cache[K comparable, V any] struct {
    items map[K]V
}

func (c *Cache[K, V]) Set(key K, value V) {
    if c.items == nil {
        c.items = make(map[K]V)
    }
    c.items[key] = value
}

func (c *Cache[K, V]) Get(key K) (V, bool) {
    value, exists := c.items[key]
    return value, exists
}

func main() {
    vec := Vector[int]{1, 2, 3}
    vec.Push(4)
    fmt.Println(vec) // [1 2 3 4]

    cache := Cache[string, int]{}
    cache.Set("age", 30)
    if age, ok := cache.Get("age"); ok {
        fmt.Println(age) // 30
    }
}
```

## Advanced Generic Patterns

### Generic Methods
```go
type Container[T any] struct {
    value T
}

func (c Container[T]) Get() T {
    return c.value
}

func (c *Container[T]) Set(value T) {
    c.value = value
}

func main() {
    intContainer := Container[int]{value: 42}
    fmt.Println(intContainer.Get()) // 42

    stringContainer := &Container[string]{}
    stringContainer.Set("hello")
    fmt.Println(stringContainer.Get()) // "hello"
}
```

### Type Sets
Define constraints using type sets:
```go
type Ordered interface {
    int | int8 | int16 | int32 | int64 |
    uint | uint8 | uint16 | uint32 | uint64 |
    float32 | float64 |
    ~string
}

func Sort[T Ordered](s []T) {
    sort.Slice(s, func(i, j int) bool {
        return s[i] < s[j]
    })
}

func main() {
    ints := []int{3, 1, 2}
    Sort(ints)
    fmt.Println(ints) // [1 2 3]

    floats := []float64{3.3, 1.1, 2.2}
    Sort(floats)
    fmt.Println(floats) // [1.1 2.2 3.3]
}
```

### Generic Channels
```go
func Process[T any](in <-chan T, out chan<- T, process func(T) T) {
    for item := range in {
        out <- process(item)
    }
    close(out)
}

func main() {
    in := make(chan int, 3)
    out := make(chan int, 3)

    go Process(in, out, func(x int) int {
        return x * 2
    })

    in <- 1
    in <- 2
    in <- 3
    close(in)

    for result := range out {
        fmt.Println(result) // 2, 4, 6
    }
}
```

## Real-World Example: Generic Repository Pattern

Let's build a complete CRUD repository pattern using generics:

```go
package main

import (
	"errors"
	"fmt"
	"sync"
)

// Entity interface defines the basic contract for all entities
type Entity interface {
	GetID() string
	SetID(string)
}

// Repository interface defines the contract for repositories
type Repository[T Entity] interface {
	Create(entity T) error
	GetByID(id string) (T, error)
	Update(entity T) error
	Delete(id string) error
	List() ([]T, error)
}

// InMemoryRepository implements Repository using in-memory storage
type InMemoryRepository[T Entity] struct {
	items map[string]T
	mu    sync.RWMutex
}

func NewInMemoryRepository[T Entity]() *InMemoryRepository[T] {
	return &InMemoryRepository[T]{
		items: make(map[string]T),
	}
}

func (r *InMemoryRepository[T]) Create(entity T) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	id := entity.GetID()
	if id == "" {
		return errors.New("entity must have an ID")
	}

	if _, exists := r.items[id]; exists {
		return fmt.Errorf("entity with ID %s already exists", id)
	}

	r.items[id] = entity
	return nil
}

func (r *InMemoryRepository[T]) GetByID(id string) (T, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	entity, exists := r.items[id]
	if !exists {
		var zero T
		return zero, fmt.Errorf("entity with ID %s not found", id)
	}

	return entity, nil
}

func (r *InMemoryRepository[T]) Update(entity T) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	id := entity.GetID()
	if _, exists := r.items[id]; !exists {
		return fmt.Errorf("entity with ID %s not found", id)
	}

	r.items[id] = entity
	return nil
}

func (r *InMemoryRepository[T]) Delete(id string) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.items[id]; !exists {
		return fmt.Errorf("entity with ID %s not found", id)
	}

	delete(r.items, id)
	return nil
}

func (r *InMemoryRepository[T]) List() ([]T, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	items := make([]T, 0, len(r.items))
	for _, item := range r.items {
		items = append(items, item)
	}

	return items, nil
}

// Service layer that uses the repository
type Service[T Entity] struct {
	repo Repository[T]
}

func NewService[T Entity](repo Repository[T]) *Service[T] {
	return &Service[T]{repo: repo}
}

func (s *Service[T]) Create(entity T) error {
	if entity.GetID() == "" {
		return errors.New("entity must have an ID")
	}
	return s.repo.Create(entity)
}

func (s *Service[T]) Get(id string) (T, error) {
	return s.repo.GetByID(id)
}

func (s *Service[T]) Update(entity T) error {
	if entity.GetID() == "" {
		return errors.New("entity must have an ID")
	}
	return s.repo.Update(entity)
}

func (s *Service[T]) Delete(id string) error {
	if id == "" {
		return errors.New("ID cannot be empty")
	}
	return s.repo.Delete(id)
}

func (s *Service[T]) List() ([]T, error) {
	return s.repo.List()
}

// Example entity implementations
type User struct {
	ID    string
	Name  string
	Email string
	Age   int
}

func (u User) GetID() string {
	return u.ID
}

func (u *User) SetID(id string) {
	u.ID = id
}

type Product struct {
	ID          string
	Name        string
	Description string
	Price       float64
}

func (p Product) GetID() string {
	return p.ID
}

func (p *Product) SetID(id string) {
	p.ID = id
}

func main() {
	// User repository and service
	userRepo := NewInMemoryRepository[User]()
	userService := NewService(userRepo)

	// Create users
	users := []User{
		{ID: "1", Name: "Alice", Email: "alice@example.com", Age: 30},
		{ID: "2", Name: "Bob", Email: "bob@example.com", Age: 25},
	}

	for _, user := range users {
		if err := userService.Create(user); err != nil {
			fmt.Printf("Error creating user: %v\n", err)
		}
	}

	// List users
	userList, err := userService.List()
	if err != nil {
		fmt.Printf("Error listing users: %v\n", err)
	} else {
		fmt.Println("Users:")
		for _, user := range userList {
			fmt.Printf("- %s (%s, %d years)\n", user.Name, user.Email, user.Age)
		}
	}

	// Get user by ID
	user, err := userService.Get("1")
	if err != nil {
		fmt.Printf("Error getting user: %v\n", err)
	} else {
		fmt.Printf("\nRetrieved user: %+v\n", user)
	}

	// Update user
	user.Name = "Alice Smith"
	if err := userService.Update(user); err != nil {
		fmt.Printf("Error updating user: %v\n", err)
	}

	// Product repository and service
	productRepo := NewInMemoryRepository[Product]()
	productService := NewService(productRepo)

	// Create products
	products := []Product{
		{ID: "p1", Name: "Laptop", Description: "High-performance laptop", Price: 999.99},
		{ID: "p2", Name: "Mouse", Description: "Wireless mouse", Price: 29.99},
	}

	for _, product := range products {
		if err := productService.Create(product); err != nil {
			fmt.Printf("Error creating product: %v\n", err)
		}
	}

	// List products
	productList, err := productService.List()
	if err != nil {
		fmt.Printf("Error listing products: %v\n", err)
	} else {
		fmt.Println("\nProducts:")
		for _, product := range productList {
			fmt.Printf("- %s: $%.2f\n", product.Name, product.Price)
		}
	}

	// Delete product
	if err := productService.Delete("p2"); err != nil {
		fmt.Printf("Error deleting product: %v\n", err)
	}

	// Verify deletion
	productList, _ = productService.List()
	fmt.Printf("\nProducts after deletion: %d\n", len(productList))
}
```

### How This Example Demonstrates Generics:

1. **Generic Repository Interface**:
   - `Repository[T Entity]` defines CRUD operations for any entity type
   - Type parameter `T` is constrained to implement `Entity`

2. **Generic Implementation**:
   - `InMemoryRepository[T Entity]` implements the repository interface
   - Works with any type that satisfies the `Entity` constraint

3. **Generic Service Layer**:
   - `Service[T Entity]` provides business logic
   - Reuses the same pattern for different entity types

4. **Multiple Entity Types**:
   - `User` and `Product` both implement `Entity`
   - Same repository and service code works for both

### Real-World Applications:

1. **Database Access Layers**:
   - Generic repositories for different models
   - Consistent CRUD operations across entities

2. **API Handlers**:
   - Generic handlers for common operations
   - Type-safe request/response handling

3. **Caching Systems**:
   - Generic cache implementations
   - Type-safe storage and retrieval

4. **Message Processing**:
   - Generic message handlers
   - Type-safe serialization/deserialization

## Best Practices for Generics

### 1. When to Use Generics
- **Use generics** when:
  - You need to work with multiple types in the same way
  - You want compile-time type safety
  - You're implementing data structures (stacks, queues, etc.)
  - You're creating utility functions (min, max, sort, etc.)

- **Avoid generics** when:
  - You're only working with one specific type
  - The type-specific behavior is more important than reusability
  - The code becomes less readable

### 2. Naming Conventions
- Use single capital letters for type parameters (T, U, V)
- Use descriptive names when the meaning isn't obvious:
  ```go
  func Map[T, U any](s []T, f func(T) U) []U
  ```

### 3. Constraint Design
- Keep constraints as small as possible
- Prefer `~` for underlying types when appropriate
- Use interfaces to define behavior constraints

### 4. Performance Considerations
- Generics don't add runtime overhead
- The compiler generates specialized code for each type
- Monomorphization happens at compile time

### 5. Error Handling
- Provide clear error messages for constraint violations
- Handle type-specific errors appropriately

## Common Patterns with Generics

### 1. Functional Utilities
```go
func Map[T, U any](s []T, f func(T) U) []U {
    result := make([]U, len(s))
    for i, v := range s {
        result[i] = f(v)
    }
    return result
}

func Filter[T any](s []T, f func(T) bool) []T {
    result := make([]T, 0)
    for _, v := range s {
        if f(v) {
            result = append(result, v)
        }
    }
    return result
}

func Reduce[T, U any](s []T, init U, f func(U, T) U) U {
    result := init
    for _, v := range s {
        result = f(result, v)
    }
    return result
}

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    
    // Map: square each number
    squared := Map(numbers, func(x int) int { return x * x })
    fmt.Println(squared) // [1 4 9 16 25]
    
    // Filter: keep even numbers
    evens := Filter(numbers, func(x int) bool { return x%2 == 0 })
    fmt.Println(evens) // [2 4]
    
    // Reduce: sum all numbers
    sum := Reduce(numbers, 0, func(acc, x int) int { return acc + x })
    fmt.Println(sum) // 15
}
```

### 2. Generic Data Structures
```go
// Binary Search Tree
type TreeNode[T comparable] struct {
    Value T
    Left  *TreeNode[T]
    Right *TreeNode[T]
}

func (n *TreeNode[T]) Insert(value T) {
    if value < n.Value {
        if n.Left == nil {
            n.Left = &TreeNode[T]{Value: value}
        } else {
            n.Left.Insert(value)
        }
    } else {
        if n.Right == nil {
            n.Right = &TreeNode[T]{Value: value}
        } else {
            n.Right.Insert(value)
        }
    }
}

func (n *TreeNode[T]) InOrder() []T {
    var result []T
    if n.Left != nil {
        result = append(result, n.Left.InOrder()...)
    }
    result = append(result, n.Value)
    if n.Right != nil {
        result = append(result, n.Right.InOrder()...)
    }
    return result
}

func main() {
    root := &TreeNode[int]{Value: 5}
    root.Insert(3)
    root.Insert(7)
    root.Insert(1)
    root.Insert(9)
    
    fmt.Println(root.InOrder()) // [1 3 5 7 9]
}
```

### 3. Generic Pool Pattern
```go
type Pool[T any] struct {
    items chan T
	factory func() T
}

func NewPool[T any](size int, factory func() T) *Pool[T] {
	p := &Pool[T]{
		items: make(chan T, size),
		factory: factory,
	}
	
	for i := 0; i < size; i++ {
		p.items <- factory()
	}
	
	return p
}

func (p *Pool[T]) Get() T {
	select {
	case item := <-p.items:
		return item
	default:
		return p.factory()
	}
}

func (p *Pool[T]) Put(item T) {
	select {
	case p.items <- item:
		// Item returned to pool
	default:
		// Pool is full, discard item
	}
}

func main() {
	// Pool of buffers
	bufferPool := NewPool(bytes.Buffer, 10, func() bytes.Buffer {
		return bytes.Buffer{}
	})
	
	// Get buffer from pool
	buf := bufferPool.Get()
	buf.WriteString("hello")
	fmt.Println(buf.String()) // hello
	
	// Return buffer to pool
	bufferPool.Put(buf)
}
```

## Conclusion

Generics in Go provide a powerful way to write flexible, reusable, and type-safe code. They enable you to:

1. **Eliminate Code Duplication**:
   - Write once, use with multiple types
   - Create generic data structures and algorithms

2. **Improve Type Safety**:
   - Catch errors at compile time
   - Avoid runtime type assertions

3. **Enhance Performance**:
   - No runtime overhead
   - Compiler optimizations

4. **Express Clear Intent**:
   - Make code more readable
   - Explicitly define type requirements

The repository pattern example demonstrates how generics can create a robust, reusable foundation for data access layers that work with any entity type. By combining generics with interfaces, you can create flexible architectures that are both type-safe and maintainable.

Key takeaways:
1. Use generics when you need to work with multiple types similarly
2. Design constraints carefully to balance flexibility and safety
3. Prefer generics over interface{} for type-safe operations
4. Leverage generics for data structures and utility functions
5. Combine generics with interfaces for maximum flexibility

Generics represent a significant evolution in Go's type system, enabling more expressive and maintainable code while preserving the language's simplicity and performance characteristics.