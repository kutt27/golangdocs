

# URL Parsing in Go: A Comprehensive Guide

## Introduction to URL Parsing
URLs (Uniform Resource Locators) are the foundation of web addressing. In Go, the `net/url` package provides robust functionality for parsing, constructing, and manipulating URLs. Understanding URL parsing is essential for web development, API interactions, and network programming.

## Basic URL Parsing

### 1. Parsing a URL String
The `url.Parse` function converts a URL string into a `url.URL` struct:

```go
package main

import (
	"fmt"
	"net/url"
)

func main() {
	// Parse a complete URL
	rawURL := "https://user:pass@example.com:8080/path/to/resource?query=value#fragment"
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		fmt.Println("Error parsing URL:", err)
		return
	}
	
	fmt.Printf("Parsed URL: %+v\n", parsedURL)
}
```

### 2. Accessing URL Components
The `url.URL` struct contains all components of a URL:

```go
func main() {
	rawURL := "https://user:pass@example.com:8080/path/to/resource?query=value#fragment"
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	
	fmt.Println("Scheme:", parsedURL.Scheme)         // https
	fmt.Println("Opaque:", parsedURL.Opaque)         // (for non-hierarchical URLs)
	fmt.Println("User:", parsedURL.User)            // user:pass
	fmt.Println("Host:", parsedURL.Host)            // example.com:8080
	fmt.Println("Hostname:", parsedURL.Hostname())   // example.com
	fmt.Println("Port:", parsedURL.Port())           // 8080
	fmt.Println("Path:", parsedURL.Path)            // /path/to/resource
	fmt.Println("RawPath:", parsedURL.RawPath)      // /path/to/resource
	fmt.Println("ForceQuery:", parsedURL.ForceQuery) // false
	fmt.Println("RawQuery:", parsedURL.RawQuery)    // query=value
	fmt.Println("Fragment:", parsedURL.Fragment)    // fragment
}
```

## Working with URL Components

### 1. User Information
```go
func main() {
	rawURL := "https://user:password@example.com"
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	
	// Access user information
	user := parsedURL.User
	fmt.Println("Username:", user.Username())        // user
	password, ok := user.Password()
	fmt.Println("Password:", password, ok)         // password true
	
	// Create user info
	newUser := url.UserPassword("newuser", "newpass")
	parsedURL.User = newUser
	fmt.Println("Updated URL:", parsedURL.String()) // https://newuser:newpass@example.com
}
```

### 2. Host and Port
```go
func main() {
	rawURL := "https://example.com:8080"
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	
	fmt.Println("Host:", parsedURL.Host)          // example.com:8080
	fmt.Println("Hostname:", parsedURL.Hostname()) // example.com
	fmt.Println("Port:", parsedURL.Port())         // 8080
	
	// Set port
	parsedURL.Host = "example.com:9090"
	fmt.Println("Updated URL:", parsedURL.String()) // https://example.com:9090
}
```

### 3. Path Manipulation
```go
func main() {
	rawURL := "https://example.com/path/to/resource"
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	
	fmt.Println("Path:", parsedURL.Path) // /path/to/resource
	
	// Join paths
	parsedURL.Path = path.Join(parsedURL.Path, "subresource")
	fmt.Println("Joined path:", parsedURL.Path) // /path/to/resource/subresource
	
	// Clean path
	parsedURL.Path = "/path/./to/../resource"
	fmt.Println("Before clean:", parsedURL.Path) // /path/./to/../resource
	parsedURL.Path = path.Clean(parsedURL.Path)
	fmt.Println("After clean:", parsedURL.Path)  // /path/resource
}
```

## Query Parameters

### 1. Parsing Query Parameters
```go
func main() {
	rawURL := "https://example.com/search?q=golang&sort=desc&page=1"
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	
	// Get query values
	query := parsedURL.Query()
	fmt.Println("Query:", query) // map[q:[golang] sort:[desc] page:[1]]
	
	// Access individual parameters
	fmt.Println("q:", query.Get("q"))     // golang
	fmt.Println("sort:", query.Get("sort")) // desc
	fmt.Println("page:", query.Get("page")) // 1
	fmt.Println("limit:", query.Get("limit")) // "" (empty for missing keys)
	
	// Get all values for a key (for multi-value parameters)
	query.Add("category", "web")
	query.Add("category", "programming")
	fmt.Println("Categories:", query["category"]) // [web programming]
}
```

### 2. Modifying Query Parameters
```go
func main() {
	rawURL := "https://example.com/search?q=golang"
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	
	query := parsedURL.Query()
	
	// Add parameters
	query.Add("sort", "desc")
	query.Add("page", "1")
	
	// Set parameter (replaces existing)
	query.Set("q", "go programming")
	
	// Remove parameter
	query.Del("sort")
	
	// Update the URL's query
	parsedURL.RawQuery = query.Encode()
	fmt.Println("Updated URL:", parsedURL.String())
	// Output: https://example.com/search?q=go+programming&page=1
}
```

### 3. Building Query Strings
```go
func main() {
	// Create query parameters from scratch
	query := url.Values{}
	query.Set("q", "golang")
	query.Set("sort", "desc")
	query.Set("page", "1")
	
	// Encode to string
	queryString := query.Encode()
	fmt.Println("Query string:", queryString) // page=1&q=golang&sort=desc
	
	// Build complete URL
	baseURL := "https://example.com/search"
	fullURL := baseURL + "?" + queryString
	fmt.Println("Full URL:", fullURL)
}
```

## URL Construction and Resolution

### 1. Building URLs from Components
```go
func main() {
	// Create URL from components
	u := &url.URL{
		Scheme:   "https",
		User:     url.UserPassword("user", "pass"),
		Host:     "example.com:8080",
		Path:     "/api/v1/resource",
		RawQuery: "param1=value1&param2=value2",
		Fragment: "section1",
	}
	
	fmt.Println("Constructed URL:", u.String())
	// Output: https://user:pass@example.com:8080/api/v1/resource?param1=value1&param2=value2#section1
}
```

### 2. Relative URL Resolution
```go
func main() {
	baseURL, _ := url.Parse("https://example.com/base/path/")
	
	// Resolve relative URLs
	relativeURLs := []string{
		"subpath",
		"/absolute/path",
		"../parent",
		"?query=param",
		"#fragment",
	}
	
	for _, rel := range relativeURLs {
		resolved := baseURL.ResolveReference(&url.URL{Path: rel})
		fmt.Printf("%-15s -> %s\n", rel, resolved.String())
	}
	
	// Output:
	// subpath         -> https://example.com/base/path/subpath
	// /absolute/path  -> https://example.com/absolute/path
	// ../parent       -> https://example.com/base/parent
	// ?query=param    -> https://example.com/base/path/?query=param
	// #fragment       -> https://example.com/base/path/#fragment
}
```

## URL Encoding and Decoding

### 1. Path and Query Encoding
```go
func main() {
	// URL encoding (percent-encoding)
	original := "hello world! @#$%"
	encoded := url.QueryEscape(original)
	fmt.Println("Encoded:", encoded) // hello+world%21+%40%23%24%25
	
	// URL decoding
	decoded, err := url.QueryEscape(encoded)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("Decoded:", decoded) // hello world! @#$%
	
	// Path encoding (slightly different from query encoding)
	pathEncoded := url.PathEscape("/path with spaces/")
	fmt.Println("Path encoded:", pathEncoded) // /path%20with%20spaces/
	
	pathDecoded, err := url.PathUnescape(pathEncoded)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("Path decoded:", pathDecoded) // /path with spaces/
}
```

### 2. Component Encoding
```go
func main() {
	// Encode individual URL components
	scheme := "https"
	host := "example.com"
	path := "/path with spaces"
	query := "param=value with spaces"
	
	// Build URL with proper encoding
	u := &url.URL{
		Scheme:   scheme,
		Host:     host,
		Path:     path,
		RawQuery: url.QueryEscape(query),
	}
	
	fmt.Println("Encoded URL:", u.String())
	// Output: https://example.com/path%20with%20spaces?param%3Dvalue%20with%20spaces
}
```

## Real-World Example: URL Normalizer

Let's build a comprehensive URL normalizer that handles various URL transformations:

```go
package main

import (
	"fmt"
	"net/url"
	"path"
	"strings"
)

// URLNormalizer handles URL normalization operations
type URLNormalizer struct {
	defaultScheme string
	defaultPort  string
}

func NewURLNormalizer() *URLNormalizer {
	return &URLNormalizer{
		defaultScheme: "https",
		defaultPort:  "443",
	}
}

// NormalizeURL performs various normalization operations on a URL
func (un *URLNormalizer) NormalizeURL(rawURL string) (string, error) {
	// Parse the URL
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		return "", fmt.Errorf("failed to parse URL: %w", err)
	}
	
	// Apply normalizations
	un.normalizeScheme(parsedURL)
	un.normalizeHost(parsedURL)
	un.normalizePath(parsedURL)
	un.normalizePort(parsedURL)
	un.normalizeQuery(parsedURL)
	un.normalizeFragment(parsedURL)
	
	return parsedURL.String(), nil
}

func (un *URLNormalizer) normalizeScheme(u *url.URL) {
	// Default to https if scheme is empty
	if u.Scheme == "" {
		u.Scheme = un.defaultScheme
	} else {
		// Convert scheme to lowercase
		u.Scheme = strings.ToLower(u.Scheme)
	}
}

func (un *URLNormalizer) normalizeHost(u *url.URL) {
	if u.Host == "" {
		return
	}
	
	// Convert host to lowercase
	host := strings.ToLower(u.Host)
	
	// Remove default port
	if u.Scheme == "https" && strings.HasSuffix(host, ":443") {
		host = strings.TrimSuffix(host, ":443")
	} else if u.Scheme == "http" && strings.HasSuffix(host, ":80") {
		host = strings.TrimSuffix(host, ":80")
	}
	
	u.Host = host
}

func (un *URLNormalizer) normalizePath(u *url.URL) {
	if u.Path == "" {
		u.Path = "/"
		return
	}
	
	// Remove trailing slash for non-root paths
	if len(u.Path) > 1 && strings.HasSuffix(u.Path, "/") {
		u.Path = strings.TrimSuffix(u.Path, "/")
	}
	
	// Remove dot segments
	u.Path = path.Clean(u.Path)
	
	// Remove duplicate slashes
	u.Path = strings.ReplaceAll(u.Path, "//", "/")
}

func (un *URLNormalizer) normalizePort(u *url.URL) {
	if u.Port() == "" {
		return
	}
	
	// Remove default ports
	if u.Scheme == "https" && u.Port() == "443" {
		u.Host = u.Hostname()
	} else if u.Scheme == "http" && u.Port() == "80" {
		u.Host = u.Hostname()
	}
}

func (un *URLNormalizer) normalizeQuery(u *url.URL) {
	if u.RawQuery == "" {
		return
	}
	
	query := u.Query()
	
	// Sort query parameters for consistent ordering
	// (Go's url.Values doesn't guarantee order, so we'll sort keys)
	var keys []string
	for k := range query {
		keys = append(keys, k)
	}
	
	// Rebuild query with sorted keys
	sortedQuery := url.Values{}
	for _, k := range keys {
		values := query[k]
		// Sort values for multi-valued parameters
		for i, v1 := range values {
			for j := i + 1; j < len(values); j++ {
				if values[i] > values[j] {
					values[i], values[j] = values[j], values[i]
				}
			}
		}
		sortedQuery[k] = values
	}
	
	u.RawQuery = sortedQuery.Encode()
}

func (un *URLNormalizer) normalizeFragment(u *url.URL) {
	// Remove fragment (optional, depending on use case)
	u.Fragment = ""
}

// CanonicalURL returns a canonical representation of the URL
func (un *URLNormalizer) CanonicalURL(rawURL string) (string, error) {
	normalized, err := un.NormalizeURL(rawURL)
	if err != nil {
		return "", err
	}
	
	// Additional canonicalization steps
	parsed, err := url.Parse(normalized)
	if err != nil {
		return "", err
	}
	
	// Remove default port if present
	if parsed.Port() != "" {
		if (parsed.Scheme == "http" && parsed.Port() == 80) ||
			(parsed.Scheme == "https" && parsed.Port() == 443) {
			parsed.Host = parsed.Hostname()
		}
	}
	
	// Ensure path ends with slash for directories
	if parsed.Path != "/" && !strings.Contains(path.Base(parsed.Path), ".") {
		parsed.Path += "/"
	}
	
	return parsed.String(), nil
}

// CompareURLs checks if two URLs are equivalent after normalization
func (un *URLNormalizer) CompareURLs(url1, url2 string) (bool, error) {
	normalized1, err := un.CanonicalURL(url1)
	if err != nil {
		return false, err
	}
	
	normalized2, err := un.CanonicalURL(url2)
	if err != nil {
		return false, err
	}
	
	return normalized1 == normalized2, nil
}

func main() {
	normalizer := NewURLNormalizer()
	
	// Test URLs
	testURLs := []string{
		"HTTP://Example.com:80/Path/../To/./Resource?b=2&a=1#fragment",
		"https://example.com/Path/To/Resource/?a=1&b=2",
		"http://example.com:443/path/to/resource",
		"https://example.com/path/to/resource/",
		"example.com/path/to/resource",
		"//example.com/path/to/resource",
	}
	
	fmt.Println("=== URL Normalization ===")
	for _, testURL := range testURLs {
		normalized, err := normalizer.NormalizeURL(testURL)
		if err != nil {
			fmt.Printf("Error normalizing %q: %v\n", testURL, err)
			continue
		}
		fmt.Printf("%-50s -> %s\n", testURL, normalized)
	}
	
	fmt.Println("\n=== Canonical URLs ===")
	for _, testURL := range testURLs {
		canonical, err := normalizer.CanonicalURL(testURL)
		if err != nil {
			fmt.Printf("Error canonicalizing %q: %v\n", testURL, err)
			continue
		}
		fmt.Printf("%-50s -> %s\n", testURL, canonical)
	}
	
	fmt.Println("\n=== URL Comparison ===")
	comparisonTests := [][]string{
		{"http://example.com/path", "https://example.com/path"},
		{"https://example.com/path/", "https://example.com/path"},
		{"https://example.com:443/path", "https://example.com/path"},
		{"https://EXAMPLE.com/path", "https://example.com/path"},
		{"https://example.com/path?a=1&b=2", "https://example.com/path?b=2&a=1"},
	}
	
	for _, pair := range comparisonTests {
		equal, err := normalizer.CompareURLs(pair[0], pair[1])
		if err != nil {
			fmt.Printf("Error comparing %q and %q: %v\n", pair[0], pair[1], err)
			continue
		}
		fmt.Printf("%-30s == %-30s -> %t\n", pair[0], pair[1], equal)
	}
}
```

### How This Example Works:

1. **URL Normalization**:
   - Converts scheme to lowercase
   - Normalizes host (lowercase, removes default ports)
   - Cleans path (removes dot segments, duplicate slashes)
   - Sorts query parameters
   - Removes fragments

2. **Canonical URL Generation**:
   - Applies all normalizations
   - Ensures consistent trailing slashes
   - Removes default ports
   - Creates a standard representation

3. **URL Comparison**:
   - Normalizes both URLs
   - Compares canonical forms
   - Handles various equivalent URL formats

### Real-World Applications:

1. **Web Crawlers**:
   - Avoid duplicate content by normalizing URLs
   - Identify equivalent resources
   - Build consistent URL indexes

2. **API Clients**:
   - Normalize request URLs
   - Handle redirects properly
   - Cache responses efficiently

3. **Security Applications**:
   - Detect phishing attempts
   - Validate URL patterns
   - Filter malicious URLs

4. **Analytics Systems**:
   - Aggregate data by normalized URLs
   - Track user journeys consistently
   - Generate accurate reports

## Best Practices

### 1. Always Check Parse Errors
```go
// Good: Check errors
parsedURL, err := url.Parse(userInput)
if err != nil {
    // Handle invalid URL
}

// Bad: Ignore errors
parsedURL, _ := url.Parse(userInput) // Might panic
```

### 2. Use Proper Encoding
```go
// Good: Encode query parameters
query := url.Values{}
query.Set("search", "golang tutorials")
u.RawQuery = query.Encode()

// Bad: Manual concatenation
u.RawQuery = "search=" + "golang tutorials" // Not properly encoded
```

### 3. Handle Relative URLs Carefully
```go
// Good: Use ResolveReference for relative URLs
baseURL, _ := url.Parse("https://example.com/base/")
relativeURL, _ := url.Parse("subpath")
absoluteURL := baseURL.ResolveReference(relativeURL)

// Bad: Manual concatenation
absoluteURL := baseURL.String() + relativeURL.String() // Might be incorrect
```

### 4. Validate URL Components
```go
func validateURL(u *url.URL) error {
	if u.Scheme != "http" && u.Scheme != "https" {
		return fmt.Errorf("unsupported scheme: %s", u.Scheme)
	}
	
	if u.Host == "" {
		return fmt.Errorf("missing host")
	}
	
	// Additional validations...
	return nil
}
```

## Common Pitfalls

### 1. Case Sensitivity
```go
// URLs are case-insensitive in scheme and host
// But case-sensitive in path and query parameters
```

### 2. Trailing Slashes
```go
// /path and /path/ might be different resources
// Normalize based on your application's needs
```

### 3. Default Ports
```go
// http://example.com:80/ and http://example.com/ are the same
// Remove default ports during normalization
```

### 4. Encoding Issues
```go
// Different parts of URL have different encoding rules
// Use PathEscape for paths, QueryEscape for queries
```

## Conclusion

URL parsing is a critical skill for web development and network programming in Go. The `net/url` package provides comprehensive tools for:

1. **Parsing URLs**:
   - Break down URLs into components
   - Handle various URL formats
   - Extract specific parts (scheme, host, path, etc.)

2. **Manipulating URLs**:
   - Modify individual components
   - Add/remove query parameters
   - Build URLs from scratch

3. **Normalizing URLs**:
   - Create consistent representations
   - Handle equivalent URLs
   - Prepare URLs for comparison

4. **Encoding and Decoding**:
   - Properly encode special characters
   - Handle different encoding rules for different parts
   - Avoid security issues from improper encoding

The URL normalizer example demonstrates how to build a robust system for handling URLs in real-world applications. By following best practices and understanding the nuances of URL parsing, you can create reliable and secure applications that work with web resources.

Key takeaways:
1. **Always validate and sanitize** user-provided URLs
2. **Use proper encoding** for different URL components
3. **Normalize URLs** before comparison or storage
4. **Handle relative URLs** with `ResolveReference`
5. **Be aware of security implications** when working with URLs

URL parsing might seem straightforward, but it has many edge cases that can lead to bugs or security vulnerabilities if not handled properly. With Go's excellent `net/url` package and the patterns shown in this guide, you can build robust and secure URL handling in your applications.