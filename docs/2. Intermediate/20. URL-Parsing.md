

{# URL Parsing in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master Go's URL parsing capabilities using the net/url package. Learn to parse, construct, and manipulate URLs, handle query parameters, perform URL encoding/decoding, and build robust URL normalization systems for web development, API interactions, and network programming.

!!! tip "Key Points"
    - Use net/url.Parse to break down URLs into structured components
    - Access and modify URL components like scheme, host, path, and query parameters
    - Handle query parameters with Query() method for parsing and Values for building
    - Use ResolveReference for proper relative URL resolution
    - Apply proper encoding with PathEscape and QueryEscape for different URL components
    - Essential for web development, API clients, web crawlers, and security applications

## Understanding URL Parsing

URLs (Uniform Resource Locators) are the foundation of web addressing. In Go, the `net/url` package provides robust functionality for parsing, constructing, and manipulating URLs. Understanding URL parsing is essential for web development, API interactions, and network programming.

!!! info "URL Components"
    ```mermaid
    graph LR
        A[URL Structure] --> B[Scheme]
        A --> C[User Info]
        A --> D[Host]
        A --> E[Port]
        A --> F[Path]
        A --> G[Query]
        A --> H[Fragment]
        B --> I[https/http/ftp]
        C --> J[username:password]
        D --> K[domain.com]
        E --> L[80/443]
        F --> M[/path/to/resource]
        G --> N[?key=value]
        H --> O[#fragment]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Basic URL Parsing

### 1. Parsing a URL String

The `url.Parse` function converts a URL string into a `url.URL` struct:

!!! example "Parsing a URL String"
    ```go title="url_parsing.go" linenums="1" hl_lines="8-18"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        // Parse a complete URL
        rawURL := "https://user:pass@example.com:8080/path/to/resource?query=value#fragment"
        parsedURL, err := url.Parse(rawURL)
        if err != nil {
            fmt.Println("Error parsing URL:", err)
            return
        }
        
        fmt.Printf("Parsed URL: %+v\n", parsedURL)
    }
    ```

### 2. Accessing URL Components

The `url.URL` struct contains all components of a URL:

!!! example "Accessing URL Components"
    ```go title="url_components.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        rawURL := "https://user:pass@example.com:8080/path/to/resource?query=value#fragment"
        parsedURL, err := url.Parse(rawURL)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        
        fmt.Println("Scheme:", parsedURL.Scheme)         // https
        fmt.Println("Opaque:", parsedURL.Opaque)         // (for non-hierarchical URLs)
        fmt.Println("User:", parsedURL.User)            // user:pass
        fmt.Println("Host:", parsedURL.Host)            // example.com:8080
        fmt.Println("Hostname:", parsedURL.Hostname())   // example.com
        fmt.Println("Port:", parsedURL.Port())           // 8080
        fmt.Println("Path:", parsedURL.Path)            // /path/to/resource
        fmt.Println("RawPath:", parsedURL.RawPath)      // /path/to/resource
        fmt.Println("ForceQuery:", parsedURL.ForceQuery) // false
        fmt.Println("RawQuery:", parsedURL.RawQuery)    // query=value
        fmt.Println("Fragment:", parsedURL.Fragment)    // fragment
    }
    ```

## Working with URL Components

### 1. User Information

!!! example "User Information"
    ```go title="user_info.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        rawURL := "https://user:password@example.com"
        parsedURL, err := url.Parse(rawURL)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        
        // Access user information
        user := parsedURL.User
        fmt.Println("Username:", user.Username())        // user
        password, ok := user.Password()
        fmt.Println("Password:", password, ok)         // password true
        
        // Create user info
        newUser := url.UserPassword("newuser", "newpass")
        parsedURL.User = newUser
        fmt.Println("Updated URL:", parsedURL.String()) // https://newuser:newpass@example.com
    }
    ```

### 2. Host and Port

!!! example "Host and Port"
    ```go title="host_port.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        rawURL := "https://example.com:8080"
        parsedURL, err := url.Parse(rawURL)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        
        fmt.Println("Host:", parsedURL.Host)          // example.com:8080
        fmt.Println("Hostname:", parsedURL.Hostname()) // example.com
        fmt.Println("Port:", parsedURL.Port())         // 8080
        
        // Set port
        parsedURL.Host = "example.com:9090"
        fmt.Println("Updated URL:", parsedURL.String()) // https://example.com:9090
    }
    ```

### 3. Path Manipulation

!!! example "Path Manipulation"
    ```go title="path_manipulation.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
        "net/url"
        "path"
    )

    func main() {
        rawURL := "https://example.com/path/to/resource"
        parsedURL, err := url.Parse(rawURL)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        
        fmt.Println("Path:", parsedURL.Path) // /path/to/resource
        
        // Join paths
        parsedURL.Path = path.Join(parsedURL.Path, "subresource")
        fmt.Println("Joined path:", parsedURL.Path) // /path/to/resource/subresource
        
        // Clean path
        parsedURL.Path = "/path/./to/../resource"
        fmt.Println("Before clean:", parsedURL.Path) // /path/./to/../resource
        parsedURL.Path = path.Clean(parsedURL.Path)
        fmt.Println("After clean:", parsedURL.Path)  // /path/resource
    }
    ```

## Query Parameters

### 1. Parsing Query Parameters

!!! example "Parsing Query Parameters"
    ```go title="query_parsing.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        rawURL := "https://example.com/search?q=golang&sort=desc&page=1"
        parsedURL, err := url.Parse(rawURL)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        
        // Get query values
        query := parsedURL.Query()
        fmt.Println("Query:", query) // map[q:[golang] sort:[desc] page:[1]]
        
        // Access individual parameters
        fmt.Println("q:", query.Get("q"))     // golang
        fmt.Println("sort:", query.Get("sort")) // desc
        fmt.Println("page:", query.Get("page")) // 1
        fmt.Println("limit:", query.Get("limit")) // "" (empty for missing keys)
        
        // Get all values for a key (for multi-value parameters)
        query.Add("category", "web")
        query.Add("category", "programming")
        fmt.Println("Categories:", query["category"]) // [web programming]
    }
    ```

### 2. Modifying Query Parameters

!!! example "Modifying Query Parameters"
    ```go title="query_modification.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        rawURL := "https://example.com/search?q=golang"
        parsedURL, err := url.Parse(rawURL)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        
        query := parsedURL.Query()
        
        // Add parameters
        query.Add("sort", "desc")
        query.Add("page", "1")
        
        // Set parameter (replaces existing)
        query.Set("q", "go programming")
        
        // Remove parameter
        query.Del("sort")
        
        // Update the URL's query
        parsedURL.RawQuery = query.Encode()
        fmt.Println("Updated URL:", parsedURL.String())
        // Output: https://example.com/search?q=go+programming&page=1
    }
    ```

### 3. Building Query Strings

!!! example "Building Query Strings"
    ```go title="building_query.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        // Create query parameters from scratch
        query := url.Values{}
        query.Set("q", "golang")
        query.Set("sort", "desc")
        query.Set("page", "1")
        
        // Encode to string
        queryString := query.Encode()
        fmt.Println("Query string:", queryString) // page=1&q=golang&sort=desc
        
        // Build complete URL
        baseURL := "https://example.com/search"
        fullURL := baseURL + "?" + queryString
        fmt.Println("Full URL:", fullURL)
    }
    ```

## URL Construction and Resolution

### 1. Building URLs from Components

!!! example "Building URLs from Components"
    ```go title="building_urls.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        // Create URL from components
        u := &url.URL{
            Scheme:   "https",
            User:     url.UserPassword("user", "pass"),
            Host:     "example.com:8080",
            Path:     "/api/v1/resource",
            RawQuery: "param1=value1&param2=value2",
            Fragment: "section1",
        }
        
        fmt.Println("Constructed URL:", u.String())
        // Output: https://user:pass@example.com:8080/api/v1/resource?param1=value1&param2=value2#section1
    }
    ```

### 2. Relative URL Resolution

!!! example "Relative URL Resolution"
    ```go title="relative_resolution.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        baseURL, _ := url.Parse("https://example.com/base/path/")
        
        // Resolve relative URLs
        relativeURLs := []string{
            "subpath",
            "/absolute/path",
            "../parent",
            "?query=param",
            "#fragment",
        }
        
        for _, rel := range relativeURLs {
            resolved := baseURL.ResolveReference(&url.URL{Path: rel})
            fmt.Printf("%-15s -> %s\n", rel, resolved.String())
        }
        
        // Output:
        // subpath         -> https://example.com/base/path/subpath
        // /absolute/path  -> https://example.com/absolute/path
        // ../parent       -> https://example.com/base/parent
        // ?query=param    -> https://example.com/base/path/?query=param
        // #fragment       -> https://example.com/base/path/#fragment
    }
    ```

## URL Encoding and Decoding

### 1. Path and Query Encoding

!!! example "Path and Query Encoding"
    ```go title="url_encoding.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        // URL encoding (percent-encoding)
        original := "hello world! @#$%"
        encoded := url.QueryEscape(original)
        fmt.Println("Encoded:", encoded) // hello+world%21+%40%23%24%25
        
        // URL decoding
        decoded, err := url.QueryUnescape(encoded)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Println("Decoded:", decoded) // hello world! @#$%
        
        // Path encoding (slightly different from query encoding)
        pathEncoded := url.PathEscape("/path with spaces/")
        fmt.Println("Path encoded:", pathEncoded) // /path%20with%20spaces/
        
        pathDecoded, err := url.PathUnescape(pathEncoded)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Println("Path decoded:", pathDecoded) // /path with spaces/
    }
    ```

### 2. Component Encoding

!!! example "Component Encoding"
    ```go title="component_encoding.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        // Encode individual URL components
        scheme := "https"
        host := "example.com"
        path := "/path with spaces"
        query := "param=value with spaces"
        
        // Build URL with proper encoding
        u := &url.URL{
            Scheme:   scheme,
            Host:     host,
            Path:     path,
            RawQuery: url.QueryEscape(query),
        }
        
        fmt.Println("Encoded URL:", u.String())
        // Output: https://example.com/path%20with%20spaces?param%3Dvalue%20with%20spaces
    }
    ```

## Real-World Example: URL Normalizer

Let's build a comprehensive URL normalizer that handles various URL transformations:

!!! example "URL Normalizer"
    ```go title="url_normalizer.go" linenums="1" hl_lines="8-60"
    package main

    import (
        "fmt"
        "net/url"
        "path"
        "strings"
    )

    // URLNormalizer handles URL normalization operations
    type URLNormalizer struct {
        defaultScheme string
        defaultPort  string
    }

    func NewURLNormalizer() *URLNormalizer {
        return &URLNormalizer{
            defaultScheme: "https",
            defaultPort:  "443",
        }
    }

    // NormalizeURL performs various normalization operations on a URL
    func (un *URLNormalizer) NormalizeURL(rawURL string) (string, error) {
        // Parse the URL
        parsedURL, err := url.Parse(rawURL)
        if err != nil {
            return "", fmt.Errorf("failed to parse URL: %w", err)
        }
        
        // Apply normalizations
        un.normalizeScheme(parsedURL)
        un.normalizeHost(parsedURL)
        un.normalizePath(parsedURL)
        un.normalizePort(parsedURL)
        un.normalizeQuery(parsedURL)
        un.normalizeFragment(parsedURL)
        
        return parsedURL.String(), nil
    }

    func (un *URLNormalizer) normalizeScheme(u *url.URL) {
        // Default to https if scheme is empty
        if u.Scheme == "" {
            u.Scheme = un.defaultScheme
        } else {
            // Convert scheme to lowercase
            u.Scheme = strings.ToLower(u.Scheme)
        }
    }

    func (un *URLNormalizer) normalizeHost(u *url.URL) {
        if u.Host == "" {
            return
        }
        
        // Convert host to lowercase
        host := strings.ToLower(u.Host)
        
        // Remove default port
        if u.Scheme == "https" && strings.HasSuffix(host, ":443") {
            host = strings.TrimSuffix(host, ":443")
        } else if u.Scheme == "http" && strings.HasSuffix(host, ":80") {
            host = strings.TrimSuffix(host, ":80")
        }
        
        u.Host = host
    }

    func (un *URLNormalizer) normalizePath(u *url.URL) {
        if u.Path == "" {
            u.Path = "/"
            return
        }
        
        // Remove trailing slash for non-root paths
        if len(u.Path) > 1 && strings.HasSuffix(u.Path, "/") {
            u.Path = strings.TrimSuffix(u.Path, "/")
        }
        
        // Remove dot segments
        u.Path = path.Clean(u.Path)
        
        // Remove duplicate slashes
        u.Path = strings.ReplaceAll(u.Path, "//", "/")
    }

    func (un *URLNormalizer) normalizePort(u *url.URL) {
        if u.Port() == "" {
            return
        }
        
        // Remove default ports
        if u.Scheme == "https" && u.Port() == "443" {
            u.Host = u.Hostname()
        } else if u.Scheme == "http" && u.Port() == "80" {
            u.Host = u.Hostname()
        }
    }

    func (un *URLNormalizer) normalizeQuery(u *url.URL) {
        if u.RawQuery == "" {
            return
        }
        
        query := u.Query()
        
        // Sort query parameters for consistent ordering
        // (Go's url.Values doesn't guarantee order, so we'll sort keys)
        var keys []string
        for k := range query {
            keys = append(keys, k)
        }
        
        // Rebuild query with sorted keys
        sortedQuery := url.Values{}
        for _, k := range keys {
            values := query[k]
            // Sort values for multi-valued parameters
            for i, v1 := range values {
                for j := i + 1; j < len(values); j++ {
                    if values[i] > values[j] {
                        values[i], values[j] = values[j], values[i]
                    }
                }
            }
            sortedQuery[k] = values
        }
        
        u.RawQuery = sortedQuery.Encode()
    }

    func (un *URLNormalizer) normalizeFragment(u *url.URL) {
        // Remove fragment (optional, depending on use case)
        u.Fragment = ""
    }

    // CanonicalURL returns a canonical representation of the URL
    func (un *URLNormalizer) CanonicalURL(rawURL string) (string, error) {
        normalized, err := un.NormalizeURL(rawURL)
        if err != nil {
            return "", err
        }
        
        // Additional canonicalization steps
        parsed, err := url.Parse(normalized)
        if err != nil {
            return "", err
        }
        
        // Remove default port if present
        if parsed.Port() != "" {
            if (parsed.Scheme == "http" && parsed.Port() == 80) ||
                (parsed.Scheme == "https" && parsed.Port() == 443) {
                parsed.Host = parsed.Hostname()
            }
        }
        
        // Ensure path ends with slash for directories
        if parsed.Path != "/" && !strings.Contains(path.Base(parsed.Path), ".") {
            parsed.Path += "/"
        }
        
        return parsed.String(), nil
    }

    // CompareURLs checks if two URLs are equivalent after normalization
    func (un *URLNormalizer) CompareURLs(url1, url2 string) (bool, error) {
        normalized1, err := un.CanonicalURL(url1)
        if err != nil {
            return false, err
        }
        
        normalized2, err := un.CanonicalURL(url2)
        if err != nil {
            return false, err
        }
        
        return normalized1 == normalized2, nil
    }

    func main() {
        normalizer := NewURLNormalizer()
        
        // Test URLs
        testURLs := []string{
            "HTTP://Example.com:80/Path/../To/./Resource?b=2&a=1#fragment",
            "https://example.com/Path/To/Resource/?a=1&b=2",
            "http://example.com:443/path/to/resource",
            "https://example.com/path/to/resource/",
            "example.com/path/to/resource",
            "//example.com/path/to/resource",
        }
        
        fmt.Println("=== URL Normalization ===")
        for _, testURL := range testURLs {
            normalized, err := normalizer.NormalizeURL(testURL)
            if err != nil {
                fmt.Printf("Error normalizing %q: %v\n", testURL, err)
                continue
            }
            fmt.Printf("%-50s -> %s\n", testURL, normalized)
        }
        
        fmt.Println("\n=== Canonical URLs ===")
        for _, testURL := range testURLs {
            canonical, err := normalizer.CanonicalURL(testURL)
            if err != nil {
                fmt.Printf("Error canonicalizing %q: %v\n", testURL, err)
                continue
            }
            fmt.Printf("%-50s -> %s\n", testURL, canonical)
        }
        
        fmt.Println("\n=== URL Comparison ===")
        comparisonTests := [][]string{
            {"http://example.com/path", "https://example.com/path"},
            {"https://example.com/path/", "https://example.com/path"},
            {"https://example.com:443/path", "https://example.com/path"},
            {"https://EXAMPLE.com/path", "https://example.com/path"},
            {"https://example.com/path?a=1&b=2", "https://example.com/path?b=2&a=1"},
        }
        
        for _, pair := range comparisonTests {
            equal, err := normalizer.CompareURLs(pair[0], pair[1])
            if err != nil {
                fmt.Printf("Error comparing %q and %q: %v\n", pair[0], pair[1], err)
                continue
            }
            fmt.Printf("%-30s == %-30s -> %t\n", pair[0], pair[1], equal)
        }
    }
    ```

### How This Example Works:

1. **URL Normalization**:
   - Converts scheme to lowercase
   - Normalizes host (lowercase, removes default ports)
   - Cleans path (removes dot segments, duplicate slashes)
   - Sorts query parameters
   - Removes fragments

2. **Canonical URL Generation**:
   - Applies all normalizations
   - Ensures consistent trailing slashes
   - Removes default ports
   - Creates a standard representation

3. **URL Comparison**:
   - Normalizes both URLs
   - Compares canonical forms
   - Handles various equivalent URL formats

### Real-World Applications:

1. **Web Crawlers**:
   - Avoid duplicate content by normalizing URLs
   - Identify equivalent resources
   - Build consistent URL indexes

2. **API Clients**:
   - Normalize request URLs
   - Handle redirects properly
   - Cache responses efficiently

3. **Security Applications**:
   - Detect phishing attempts
   - Validate URL patterns
   - Filter malicious URLs

4. **Analytics Systems**:
   - Aggregate data by normalized URLs
   - Track user journeys consistently
   - Generate accurate reports

## Best Practices

!!! tip "Error Handling"
    Always check errors when parsing URLs to handle invalid input gracefully.

!!! example "Error Handling"
    ```go title="error_handling.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "net/url"
    )

    // Good: Check errors
    func parseURL(input string) (*url.URL, error) {
        parsedURL, err := url.Parse(input)
        if err != nil {
            return nil, err
        }
        return parsedURL, nil
    }

    // Bad: Ignore errors
    func parseURLBad(input string) *url.URL {
        parsedURL, _ := url.Parse(input) // Might panic
        return parsedURL
    }
    ```

!!! tip "Proper Encoding"
    Use proper encoding functions for different URL components to avoid security issues.

!!! example "Proper Encoding"
    ```go title="proper_encoding.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "net/url"
    )

    // Good: Encode query parameters
    func buildURL(base string, params map[string]string) string {
        u, err := url.Parse(base)
        if err != nil {
            return ""
        }
        
        query := u.Query()
        for k, v := range params {
            query.Set(k, v)
        }
        
        u.RawQuery = query.Encode()
        return u.String()
    }

    // Bad: Manual concatenation
    func buildURLBad(base string, params map[string]string) string {
        // result := base + "?"
        // for k, v := range params {
        //     result += k + "=" + v + "&"
        // }
        // return result // Not properly encoded
        return ""
    }
    ```

!!! tip "Relative URL Handling"
    Use ResolveReference for proper relative URL resolution.

!!! example "Relative URL Handling"
    ```go title="relative_url_handling.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "net/url"
    )

    // Good: Use ResolveReference for relative URLs
    func resolveRelative(base, rel string) (string, error) {
        baseURL, err := url.Parse(base)
        if err != nil {
            return "", err
        }
        
        relativeURL, err := url.Parse(rel)
        if err != nil {
            return "", err
        }
        
        resolved := baseURL.ResolveReference(relativeURL)
        return resolved.String(), nil
    }

    // Bad: Manual concatenation
    func resolveRelativeBad(base, rel string) string {
        // return base + rel // Might be incorrect
        return ""
    }
    ```

!!! tip "URL Validation"
    Validate URL components to ensure they meet your application's requirements.

!!! example "URL Validation"
    ```go title="url_validation.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
        "net/url"
        "strings"
    )

    func validateURL(u *url.URL) error {
        if u.Scheme != "http" && u.Scheme != "https" {
            return fmt.Errorf("unsupported scheme: %s", u.Scheme)
        }
        
        if u.Host == "" {
            return fmt.Errorf("missing host")
        }
        
        // Check for valid characters in host
        if strings.ContainsAny(u.Host, " /?#") {
            return fmt.Errorf("invalid host: %s", u.Host)
        }
        
        // Additional validations...
        return nil
    }
    ```

## Common Pitfalls

!!! warning "Case Sensitivity"
    URLs are case-insensitive in scheme and host but case-sensitive in path and query parameters.

!!! example "Case Sensitivity"
    ```go title="case_sensitivity.go" linenums="1" hl_lines="8-16"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        // Scheme and host are case-insensitive
        url1, _ := url.Parse("https://EXAMPLE.com/path")
        url2, _ := url.Parse("https://example.com/PATH")
        
        fmt.Printf("Hosts equal: %t\n", url1.Hostname() == url2.Hostname()) // true
        fmt.Printf("Paths equal: %t\n", url1.Path == url2.Path)               // false
    }
    ```

!!! warning "Trailing Slashes"
    Trailing slashes can indicate different resources - normalize based on your application's needs.

!!! example "Trailing Slashes"
    ```go title="trailing_slashes.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "net/url"
        "strings"
    )

    func normalizeTrailingSlash(u *url.URL) {
        if u.Path != "/" && !strings.Contains(u.Path, ".") {
            if !strings.HasSuffix(u.Path, "/") {
                u.Path += "/"
            }
        }
    }

    func main() {
        u, _ := url.Parse("https://example.com/path")
        fmt.Printf("Before: %s\n", u.String())
        normalizeTrailingSlash(u)
        fmt.Printf("After: %s\n", u.String())
    }
    ```

!!! warning "Default Ports"
    Default ports (80 for HTTP, 443 for HTTPS) should be removed during normalization.

!!! example "Default Ports"
    ```go title="default_ports.go" linenums="1" hl_lines="8-22"
    package main

    import (
        "fmt"
        "net/url"
        "strings"
    )

    func removeDefaultPort(u *url.URL) {
        host := u.Host
        if u.Scheme == "https" && strings.HasSuffix(host, ":443") {
            u.Host = strings.TrimSuffix(host, ":443")
        } else if u.Scheme == "http" && strings.HasSuffix(host, ":80") {
            u.Host = strings.TrimSuffix(host, ":80")
        }
    }

    func main() {
        u, _ := url.Parse("https://example.com:443/path")
        fmt.Printf("Before: %s\n", u.String())
        removeDefaultPort(u)
        fmt.Printf("After: %s\n", u.String())
    }
    ```

!!! warning "Encoding Issues"
    Different parts of URL have different encoding rules - use appropriate functions.

!!! example "Encoding Issues"
    ```go title="encoding_issues.go" linenums="1" hl_lines="8-20"
    package main

    import (
        "fmt"
        "net/url"
    )

    func main() {
        // Path encoding
        path := "/path with spaces"
        encodedPath := url.PathEscape(path)
        fmt.Printf("Path encoded: %s\n", encodedPath)
        
        // Query encoding
        query := "search term"
        encodedQuery := url.QueryEscape(query)
        fmt.Printf("Query encoded: %s\n", encodedQuery)
        
        // Note the difference: space is %20 in path, + in query
    }
    ```

## Quick Reference

!!! success "Key Takeaways"
    - **Basic Parsing**: Use `url.Parse` to break down URLs into structured components
    - **Component Access**: Access scheme, host, path, query, and fragment through URL struct fields
    - **Query Parameters**: Use `Query()` to parse and `Values` to build query strings
    - **URL Construction**: Build URLs from components or use `ResolveReference` for relative URLs
    - **Encoding**: Use `PathEscape` for paths and `QueryEscape` for query parameters
    - **Normalization**: Apply consistent formatting for comparison and storage

!!! quote "Remember"
    "URL parsing is a critical skill for web development and network programming in Go. The net/url package provides comprehensive tools for parsing, manipulating, and normalizing URLs. By following best practices and understanding the nuances of URL handling, you can create reliable and secure applications that work with web resources."