# Random Numbers in Go: A Comprehensive Guide

## Introduction to Random Number Generation
Random numbers are essential for many applications including games, simulations, cryptography, statistical sampling, and more. Go provides two main packages for random number generation:
- `math/rand`: Pseudorandom number generation suitable for simulations, games, and non-cryptographic purposes
- `crypto/rand`: Cryptographically secure random number generation for security-sensitive applications

## Basic Random Number Generation

### 1. Simple Random Numbers
```go
package main

import (
	"fmt"
	"math/rand"
)

func main() {
	// Generate random integers
	fmt.Println("Random integer:", rand.Int())        // Random non-negative integer
	fmt.Println("Random int31:", rand.Int31())       // Random 31-bit integer
	fmt.Println("Random int63:", rand.Int63())       // Random 63-bit integer
	fmt.Println("Random uint32:", rand.Uint32())     // Random 32-bit unsigned integer
	fmt.Println("Random float64:", rand.Float64())   // Random float64 in [0.0, 1.0)
	fmt.Println("Random float32:", rand.Float32())   // Random float32 in [0.0, 1.0)
	
	// Generate random numbers in a specific range
	fmt.Println("Random intn(10):", rand.Intn(10))  // Random integer in [0, 10)
	fmt.Println("Random int31n(10):", rand.Int31n(10)) // Random 31-bit integer in [0, 10)
	fmt.Println("Random int63n(10):", rand.Int63n(10)) // Random 63-bit integer in [0, 10)
}
```

### 2. Seeding the Random Number Generator
By default, the random number generator produces the same sequence of numbers each time. To get different sequences, you need to seed it:

```go
func main() {
	// Without seeding - same sequence every time
	fmt.Println("Without seeding:")
	for i := 0; i < 3; i++ {
		fmt.Println(rand.Intn(100))
	}
	
	// With seeding - different sequence each run
	fmt.Println("\nWith seeding:")
	rand.Seed(time.Now().UnixNano()) // Seed with current time
	for i := 0; i < 3; i++ {
		fmt.Println(rand.Intn(100))
	}
}
```

## Generating Random Numbers in a Range

### 1. Integer Range
```go
// Generate random integer in [min, max]
func randomInt(min, max int) int {
	return min + rand.Intn(max-min+1)
}

func main() {
	rand.Seed(time.Now().UnixNano())
	
	// Generate random numbers between 50 and 100
	for i := 0; i < 5; i++ {
		fmt.Printf("Random between 50-100: %d\n", randomInt(50, 100))
	}
}
```

### 2. Float Range
```go
// Generate random float64 in [min, max)
func randomFloat(min, max float64) float64 {
	return min + rand.Float64()*(max-min)
}

func main() {
	rand.Seed(time.Now().UnixNano())
	
	// Generate random floats between 1.0 and 10.0
	for i := 0; i < 5; i++ {
		fmt.Printf("Random float 1.0-10.0: %.2f\n", randomFloat(1.0, 10.0))
	}
}
```

## Working with Different Data Types

### 1. Random Booleans
```go
func randomBool() bool {
	return rand.Intn(2) == 1
}

func main() {
	rand.Seed(time.Now().UnixNano())
	
	for i := 0; i < 5; i++ {
		fmt.Printf("Random boolean: %t\n", randomBool())
	}
}
```

### 2. Random Strings
```go
const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

func randomString(length int) string {
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

func main() {
	rand.Seed(time.Now().UnixNano())
	
	// Generate random strings of different lengths
	fmt.Println("Random string (8):", randomString(8))
	fmt.Println("Random string (16):", randomString(16))
	fmt.Println("Random string (32):", randomString(32))
}
```

### 3. Random Bytes
```go
func randomBytes(length int) []byte {
	b := make([]byte, length)
	rand.Read(b) // Fill slice with random bytes
	return b
}

func main() {
	rand.Seed(time.Now().UnixNano())
	
	// Generate random byte slices
	bytes := randomBytes(16)
	fmt.Printf("Random bytes: %x\n", bytes)
}
```

## Cryptographically Secure Random Numbers

### 1. Using crypto/rand
For security-sensitive applications like generating tokens, keys, or passwords:

```go
package main

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"math/big"
)

func main() {
	// Generate random integer
	n, _ := rand.Int(rand.Reader, big.NewInt(1000))
	fmt.Println("Secure random int:", n)
	
	// Generate random bytes
	bytes := make([]byte, 32)
	_, err := rand.Read(bytes)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Secure random bytes: %x\n", bytes)
	
	// Generate random hex string
	hexStr := hex.EncodeToString(bytes)
	fmt.Println("Secure random hex:", hexStr)
}
```

### 2. Secure Random String Generation
```go
const secureCharset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()"

func secureRandomString(length int) (string, error) {
	b := make([]byte, length)
	
	// Read random bytes
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}
	
	// Map bytes to charset
	for i := range b {
		b[i] = secureCharset[b[i]%byte(len(secureCharset))]
	}
	
	return string(b), nil
}

func main() {
	// Generate secure random strings
	for i := 8; i <= 32; i += 8 {
		str, err := secureRandomString(i)
		if err != nil {
			fmt.Println("Error:", err)
			continue
		}
		fmt.Printf("Secure random string (%d): %s\n", i, str)
	}
}
```

## Shuffling and Sampling

### 1. Shuffling a Slice
```go
func main() {
	rand.Seed(time.Now().UnixNano())
	
	// Create a slice
	numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	fmt.Println("Original:", numbers)
	
	// Shuffle the slice
	rand.Shuffle(len(numbers), func(i, j int) {
		numbers[i], numbers[j] = numbers[j], numbers[i]
	})
	fmt.Println("Shuffled:", numbers)
}
```

### 2. Random Sampling
```go
// Sample n items from a slice without replacement
func sample[T any](slice []T, n int) []T {
	if n > len(slice) {
		n = len(slice)
	}
	
	// Create a copy to avoid modifying original
	sample := make([]T, n)
	copy(sample, slice)
	
	// Shuffle the sample
	rand.Shuffle(len(sample), func(i, j int) {
		sample[i], sample[j] = sample[j], sample[i]
	})
	
	return sample[:n]
}

func main() {
	rand.Seed(time.Now().UnixNano())
	
	// Sample from a slice
	words := []string{"apple", "banana", "cherry", "date", "elderberry", "fig", "grape"}
	fmt.Println("Sample 3 words:", sample(words, 3))
	fmt.Println("Sample 5 words:", sample(words, 5))
}
```

### 3. Weighted Random Selection
```go
type WeightedItem struct {
	Item   interface{}
	Weight int
}

func weightedRandom(items []WeightedItem) interface{} {
	// Calculate total weight
	totalWeight := 0
	for _, item := range items {
		totalWeight += item.Weight
	}
	
	// Generate random number up to total weight
	r := rand.Intn(totalWeight)
	
	// Find the item
	runningWeight := 0
	for _, item := range items {
		runningWeight += item.Weight
		if r < runningWeight {
			return item.Item
		}
	}
	
	return items[len(items)-1].Item
}

func main() {
	rand.Seed(time.Now().UnixNano())
	
	// Define weighted items
	items := []WeightedItem{
		{"Apple", 10},
		{"Banana", 30},
		{"Cherry", 60},
	}
	
	// Test weighted selection
	counts := make(map[string]int)
	for i := 0; i < 1000; i++ {
		item := weightedRandom(items).(string)
		counts[item]++
	}
	
	fmt.Println("Weighted random selection results:")
	for item, count := range counts {
		fmt.Printf("%s: %d\n", item, count)
	}
}
```

## Random Distributions

### 1. Normal Distribution
```go
// Generate normally distributed random number (Box-Muller transform)
func normalRandom(mean, stdDev float64) float64 {
	u1 := rand.Float64()
	u2 := rand.Float64()
	
	// Box-Muller transform
	z0 := math.Sqrt(-2*math.Log(u1)) * math.Cos(2*math.Pi*u2)
	return z0*stdDev + mean
}

func main() {
	rand.Seed(time.Now().UnixNano())
	
	// Generate normally distributed numbers
	fmt.Println("Normal distribution (mean=0, std=1):")
	for i := 0; i < 10; i++ {
		fmt.Printf("%.4f\n", normalRandom(0, 1))
	}
}
```

### 2. Exponential Distribution
```go
// Generate exponentially distributed random number
func exponentialRandom(lambda float64) float64 {
	return -math.Log(1-rand.Float64()) / lambda
}

func main() {
	rand.Seed(time.Now().UnixNano())
	
	// Generate exponentially distributed numbers
	fmt.Println("Exponential distribution (lambda=1.0):")
	for i := 0; i < 10; i++ {
		fmt.Printf("%.4f\n", exponentialRandom(1.0))
	}
}
```

## Real-World Example: Dice Game Simulator

Let's build a comprehensive dice game simulator that demonstrates various random number concepts:

```go
package main

import (
	"crypto/rand"
	"fmt"
	"math/big"
	"math/rand"
	"time"
)

// Dice represents a multi-sided die
type Dice struct {
	Sides int
}

// Roll simulates rolling the dice
func (d *Dice) Roll() int {
	return rand.Intn(d.Sides) + 1
}

// DiceGame represents a dice game
type DiceGame struct {
	Dice       []Dice
	Players    []Player
	Round      int
	MaxRounds int
}

// Player represents a game player
type Player struct {
	Name   string
	Score  int
	Wins   int
	IsHuman bool
}

// NewDiceGame creates a new dice game
func NewDiceGame(playerNames []string, diceSides []int, maxRounds int) *DiceGame {
	game := &DiceGame{
		MaxRounds: maxRounds,
		Round:     1,
	}
	
	// Create dice
	for _, sides := range diceSides {
		game.Dice = append(game.Dice, Dice{Sides: sides})
	}
	
	// Create players
	for i, name := range playerNames {
		game.Players = append(game.Players, Player{
			Name:   name,
			IsHuman: i == 0, // First player is human
		})
	}
	
	return game
}

// PlayRound plays one round of the game
func (g *DiceGame) PlayRound() {
	fmt.Printf("\n=== Round %d ===\n", g.Round)
	
	for i := range g.Players {
		player := &g.Players[i]
		roundScore := 0
		
		fmt.Printf("%s's turn:\n", player.Name)
		
		// Roll each die
		for j, die := range g.Dice {
			roll := die.Roll()
			roundScore += roll
			fmt.Printf("  Die %d (d%d): %d\n", j+1, die.Sides, roll)
		}
		
		player.Score += roundScore
		fmt.Printf("  Round score: %d, Total score: %d\n", roundScore, player.Score)
	}
	
	g.Round++
}

// GetWinner returns the player with the highest score
func (g *DiceGame) GetWinner() *Player {
	winner := &g.Players[0]
	for _, player := range g.Players {
		if player.Score > winner.Score {
			winner = &player
		}
	}
	return winner
}

// Play plays the entire game
func (g *DiceGame) Play() {
	fmt.Println("Starting Dice Game!")
	fmt.Printf("Players: %v\n", getPlayerNames(g.Players))
	fmt.Printf("Dice: %v\n", getDiceSides(g.Dice))
	fmt.Printf("Max rounds: %d\n", g.MaxRounds)
	
	for g.Round <= g.MaxRounds {
		g.PlayRound()
	}
	
	// Announce winner
	winner := g.GetWinner()
	winner.Wins++
	fmt.Printf("\n=== Game Over ===\n")
	fmt.Printf("Winner: %s with %d points!\n", winner.Name, winner.Score)
	
	// Show final scores
	fmt.Println("\nFinal Scores:")
	for _, player := range g.Players {
		fmt.Printf("%s: %d points\n", player.Name, player.Score)
	}
}

// Helper functions
func getPlayerNames(players []Player) []string {
	names := make([]string, len(players))
	for i, player := range players {
		names[i] = player.Name
	}
	return names
}

func getDiceSides(dice []Dice) []int {
	sides := make([]int, len(dice))
	for i, die := range dice {
		sides[i] = die.Sides
	}
	return sides
}

// MonteCarloSimulation runs multiple game simulations
type MonteCarloSimulation struct {
	GameConfig struct {
		PlayerNames []string
		DiceSides   []int
		MaxRounds   int
	}
	NumSimulations int
}

func NewMonteCarloSimulation(numSimulations int, playerNames []string, diceSides []int, maxRounds int) *MonteCarloSimulation {
	return &MonteCarloSimulation{
		NumSimulations: numSimulations,
		GameConfig: struct {
			PlayerNames []string
			DiceSides   []int
			MaxRounds   int
		}{
			PlayerNames: playerNames,
			DiceSides:   diceSides,
			MaxRounds:   maxRounds,
		},
	}
}

func (mcs *MonteCarloSimulation) Run() map[string]int {
	winCounts := make(map[string]int)
	
	for i := 0; i < mcs.NumSimulations; i++ {
		// Create a new game for each simulation
		game := NewDiceGame(
			mcs.GameConfig.PlayerNames,
			mcs.GameConfig.DiceSides,
			mcs.GameConfig.MaxRounds,
		)
		
		// Play the game
		for game.Round <= game.MaxRounds {
			game.PlayRound()
		}
		
		// Record winner
		winner := game.GetWinner()
		winCounts[winner.Name]++
	}
	
	return winCounts
}

// SecureRandomToken generates a cryptographically secure random token
func SecureRandomToken(length int) (string, error) {
	b := make([]byte, length)
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(b)[:length], nil
}

func main() {
	// Seed the random number generator
	rand.Seed(time.Now().UnixNano())
	
	// Play a single game
	fmt.Println("=== Single Game ===")
	playerNames := []string{"Alice", "Bob", "Charlie"}
	diceSides := []int{6, 6, 20} // Two d6 and one d20
	maxRounds := 5
	
	game := NewDiceGame(playerNames, diceSides, maxRounds)
	game.Play()
	
	// Run Monte Carlo simulation
	fmt.Println("\n=== Monte Carlo Simulation ===")
	simulation := NewMonteCarloSimulation(1000, playerNames, diceSides, maxRounds)
	winCounts := simulation.Run()
	
	fmt.Printf("Win probabilities after %d simulations:\n", simulation.NumSimulations)
	for name, wins := range winCounts {
		probability := float64(wins) / float64(simulation.NumSimulations) * 100
		fmt.Printf("%s: %.1f%% (%d wins)\n", name, probability, wins)
	}
	
	// Generate secure random tokens
	fmt.Println("\n=== Secure Random Tokens ===")
	for i := 16; i <= 64; i += 16 {
		token, err := SecureRandomToken(i)
		if err != nil {
			fmt.Printf("Error generating token: %v\n", err)
			continue
		}
		fmt.Printf("Token (%d): %s\n", i, token)
	}
	
	// Demonstrate weighted random selection
	fmt.Println("\n=== Weighted Random Selection ===")
	loot := []WeightedItem{
		{"Common Sword", 60},
		{"Rare Shield", 30},
		{"Epic Armor", 9},
		{"Legendary Sword", 1},
	}
	
	drops := make(map[string]int)
	for i := 0; i < 1000; i++ {
		item := weightedRandom(loot).(string)
		drops[item]++
	}
	
	fmt.Println("Loot drop rates:")
	for item, count := range drops {
		rate := float64(count) / 10 // Convert to percentage
		fmt.Printf("%s: %.1f%%\n", item, rate)
	}
}
```

### How This Example Works:

1. **Dice Game Simulation**:
   - Models a multi-player dice game with different die types
   - Tracks scores across multiple rounds
   - Determines the winner based on total score

2. **Monte Carlo Simulation**:
   - Runs thousands of game simulations
   - Calculates win probabilities for each player
   - Demonstrates statistical analysis of random events

3. **Secure Random Generation**:
   - Generates cryptographically secure tokens
   - Uses `crypto/rand` for security-sensitive applications
   - Shows proper error handling

4. **Weighted Random Selection**:
   - Implements loot drop system with different rarities
   - Demonstrates probability-based selection
   - Shows statistical distribution of results

### Real-World Applications:

1. **Gaming**:
   - Dice games and card games
   - Loot drop systems
   - Procedural content generation

2. **Simulations**:
   - Monte Carlo methods for risk analysis
   - Scientific simulations
   - Financial modeling

3. **Security**:
   - Generating secure tokens and passwords
   - Cryptographic key generation
   - Session identifiers

4. **Data Analysis**:
   - Random sampling for statistics
   - A/B testing
   - Machine learning (e.g., random forests)

## Best Practices

### 1. Always Seed the Random Generator
```go
// Good: Seed with current time
func init() {
    rand.Seed(time.Now().UnixNano())
}

// Bad: No seeding - same sequence every time
func badRandom() {
    fmt.Println(rand.Intn(100)) // Always same value
}
```

### 2. Use crypto/rand for Security
```go
// Good: Use crypto/rand for security
func generateToken() (string, error) {
    b := make([]byte, 32)
    _, err := rand.Read(b)
    if err != nil {
        return "", err
    }
    return hex.EncodeToString(b), nil
}

// Bad: Use math/rand for security
func generateTokenBad() string {
    b := make([]byte, 32)
    rand.Read(b) // Not cryptographically secure
    return hex.EncodeToString(b)
}
```

### 3. Handle Range Correctly
```go
// Good: Correct range [min, max]
func randomInt(min, max int) int {
    return min + rand.Intn(max-min+1)
}

// Bad: Off-by-one error
func randomIntBad(min, max int) int {
    return min + rand.Intn(max-min) // Excludes max
}
```

### 4. Reuse Random Sources
```go
// Good: Create once, reuse many times
var globalRand = rand.New(rand.NewSource(time.Now().UnixNano()))

func randomInt() int {
    return globalRand.Intn(100)
}

// Bad: Create new source each time
func randomIntBad() int {
    r := rand.New(rand.NewSource(time.Now().UnixNano()))
    return r.Intn(100)
}
```

## Performance Considerations

### 1. Use rand.Read for Bulk Random Data
```go
// Good: Use rand.Read for bulk data
func randomBytes(n int) []byte {
    b := make([]byte, n)
    rand.Read(b)
    return b
}

// Bad: Generate byte by byte
func randomBytesBad(n int) []byte {
    b := make([]byte, n)
    for i := range b {
        b[i] = byte(rand.Intn(256))
    }
    return b
}
```

### 2. Pre-allocate for Random Strings
```go
// Good: Pre-allocate slice
func randomString(n int) string {
    b := make([]byte, n)
    for i := range b {
        b[i] = charset[rand.Intn(len(charset))]
    }
    return string(b)
}

// Bad: String concatenation
func randomStringBad(n int) string {
    var s string
    for i := 0; i < n; i++ {
        s += string(charset[rand.Intn(len(charset))])
    }
    return s
}
```

## Conclusion

Random number generation is a fundamental tool in Go programming with applications across many domains. By understanding both `math/rand` and `crypto/rand`, you can:

1. **Generate Random Data**:
   - Integers, floats, and booleans
   - Strings and byte slices
   - Custom data structures

2. **Implement Random Algorithms**:
   - Shuffling and sampling
   - Weighted selection
   - Monte Carlo simulations

3. **Build Secure Applications**:
   - Generate tokens and passwords
   - Create cryptographic keys
   - Implement secure protocols

4. **Create Engaging Experiences**:
   - Games and simulations
   - Procedural content
   - Randomized user interfaces

The dice game simulator demonstrates how to combine various random number concepts to build a complete application that includes both simple random generation and complex statistical analysis. By following best practices and choosing the right package for your needs, you can implement robust and efficient random number generation in your Go applications.

Key takeaways:
1. **Use `math/rand`** for simulations, games, and non-cryptographic purposes
2. **Use `crypto/rand`** for security-sensitive applications
3. **Always seed** your random generator for different sequences
4. **Handle ranges correctly** to avoid off-by-one errors
5. **Consider performance** when generating large amounts of random data

Random numbers might seem simple, but they're a powerful tool when used correctly. With Go's excellent random number generation capabilities, you can build everything from simple games to complex cryptographic systems.