# Go Functions: Building Blocks of Code

!!! abstract "Overview"
    Master Go's powerful function system for creating modular, reusable code. This comprehensive guide covers function definitions, parameters, return values, variadic functions, and advanced concepts, building upon our understanding of Go's type system and control flow.

!!! tip "Key Points"
    - Functions are first-class citizens in Go
    - Support multiple return values and named returns
    - Variadic functions for flexible parameter lists
    - Function types and higher-order functions
    - Closures and anonymous functions

## Understanding Functions in Go

Functions are the fundamental building blocks of Go programs, providing code organization, reusability, and modularity. Go's function system is both powerful and elegant, supporting advanced features while maintaining simplicity.

!!! info "Function Architecture"
    ```mermaid
    graph TD
        A[Go Function] --> B[Parameters]
        A --> C[Return Values]
        A --> D[Function Body]
        B --> E[Named Parameters]
        B --> F[Variadic Parameters]
        C --> G[Single Return]
        C --> H[Multiple Returns]
        C --> I[Named Returns]
        D --> J[Local Variables]
        D --> K[Closures]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
        style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px
        style C fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
        style D fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    ```

## Basic Function Definitions

Go functions use the `func` keyword and support various parameter and return patterns.

### Function Declaration Patterns

!!! example "Basic Function Syntax"

    === "Simple Functions"
        ```go title="basic_functions.go" linenums="1" hl_lines="6-10"
        package main

        import "fmt"

        // Basic function with parameters and return value
        func add(a int, b int) int {
            return a + b
        }

        // Function with same-type parameters (shorthand)
        func multiply(x, y int) int {
            return x * y
        }

        // Function without parameters
        func greet() string {
            return "Hello, World!"
        }

        func main() {
            sum := add(5, 3)
            product := multiply(4, 7)
            message := greet()
            
            fmt.Printf("Sum: %d, Product: %d\n", sum, product)
            fmt.Printf("Message: %s\n", message)
        }
        ```

    === "No Return Value"
        ```go title="void_functions.go" linenums="1" hl_lines="6-10"
        package main

        import "fmt"

        // Function that performs action without returning value
        func printInfo(name string, age int) {
            fmt.Printf("Name: %s, Age: %d\n", name, age)
        }

        // Function with no parameters and no return
        func sayHello() {
            fmt.Println("Hello from Go!")
        }

        func main() {
            printInfo("Alice", 25)
            sayHello()
            
            // Output:
            // Name: Alice, Age: 25
            // Hello from Go!
        }
        ```

    === "Complex Parameters"
        ```go title="complex_params.go" linenums="1" hl_lines="8-15"
        package main

        import "fmt"

        type Person struct {
            Name string
            Age  int
        }

        // Function with struct parameter
        func describePerson(p Person) string {
            return fmt.Sprintf("%s is %d years old", p.Name, p.Age)
        }

        // Function with slice parameter
        func sumSlice(numbers []int) int {
            total := 0
            for _, num := range numbers {
                total += num
            }
            return total
        }

        func main() {
            person := Person{Name: "Bob", Age: 30}
            description := describePerson(person)
            
            numbers := []int{1, 2, 3, 4, 5}
            total := sumSlice(numbers)
            
            fmt.Println(description)
            fmt.Printf("Sum: %d\n", total)
        }
        ```

## Multiple Return Values

Go's support for multiple return values is one of its most distinctive features, enabling elegant error handling and data processing.

### Multiple Return Patterns

!!! example "Multiple Return Values"

    === "Basic Multiple Returns"
        ```go title="multiple_returns.go" linenums="1" hl_lines="6-10"
        package main

        import "fmt"

        // Function returning multiple values
        func divmod(a, b int) (int, int) {
            quotient := a / b
            remainder := a % b
            return quotient, remainder
        }

        // Function with error handling pattern
        func safeDivide(a, b float64) (float64, error) {
            if b == 0 {
                return 0, fmt.Errorf("division by zero")
            }
            return a / b, nil
        }

        func main() {
            q, r := divmod(17, 5)
            fmt.Printf("17 รท 5 = %d remainder %d\n", q, r)
            
            result, err := safeDivide(10, 2)
            if err != nil {
                fmt.Printf("Error: %v\n", err)
            } else {
                fmt.Printf("Result: %.2f\n", result)
            }
        }
        ```

    === "Named Return Values"
        ```go title="named_returns.go" linenums="1" hl_lines="6-12"
        package main

        import "fmt"

        // Named return values for clarity
        func rectangle(length, width float64) (area, perimeter float64) {
            area = length * width
            perimeter = 2 * (length + width)
            return  // naked return
        }

        // Named returns with early return
        func processNumber(n int) (result int, isEven bool) {
            if n < 0 {
                result = 0
                isEven = false
                return
            }
            
            result = n * n
            isEven = n%2 == 0
            return
        }

        func main() {
            a, p := rectangle(5.0, 3.0)
            fmt.Printf("Rectangle: Area=%.1f, Perimeter=%.1f\n", a, p)
            
            res, even := processNumber(4)
            fmt.Printf("Number 4: Square=%d, Even=%t\n", res, even)
        }
        ```

    === "Ignoring Return Values"
        ```go title="ignore_returns.go" linenums="1" hl_lines="8-15"
        package main

        import (
            "fmt"
            "strconv"
        )

        func main() {
            // Ignore error return value (not recommended)
            value, _ := strconv.Atoi("123")
            fmt.Printf("Parsed value: %d\n", value)
            
            // Ignore first return value
            _, remainder := divmod(17, 5)
            fmt.Printf("Remainder only: %d\n", remainder)
            
            // Use all return values
            quotient, remainder2 := divmod(20, 3)
            fmt.Printf("20 รท 3 = %d remainder %d\n", quotient, remainder2)
        }

        func divmod(a, b int) (int, int) {
            return a / b, a % b
        }
        ```

## Variadic Functions

Variadic functions accept a variable number of arguments, providing flexibility for functions that need to process multiple values.

### Variadic Function Patterns

!!! example "Variadic Functions"

    === "Basic Variadic"
        ```go title="variadic_basic.go" linenums="1" hl_lines="6-12"
        package main

        import "fmt"

        // Variadic function with int parameters
        func sum(numbers ...int) int {
            total := 0
            for _, num := range numbers {
                total += num
            }
            return total
        }

        // Variadic function with string parameters
        func concatenate(separator string, words ...string) string {
            result := ""
            for i, word := range words {
                if i > 0 {
                    result += separator
                }
                result += word
            }
            return result
        }

        func main() {
            // Call with different numbers of arguments
            fmt.Printf("Sum of no numbers: %d\n", sum())
            fmt.Printf("Sum of 1,2,3: %d\n", sum(1, 2, 3))
            fmt.Printf("Sum of 1,2,3,4,5: %d\n", sum(1, 2, 3, 4, 5))
            
            // Variadic with other parameters
            sentence := concatenate(" ", "Go", "is", "awesome")
            fmt.Printf("Sentence: %s\n", sentence)
        }
        ```

    === "Slice Expansion"
        ```go title="slice_expansion.go" linenums="1" hl_lines="8-15"
        package main

        import "fmt"

        func average(numbers ...float64) float64 {
            if len(numbers) == 0 {
                return 0
            }
            
            total := 0.0
            for _, num := range numbers {
                total += num
            }
            return total / float64(len(numbers))
        }

        func main() {
            // Direct arguments
            avg1 := average(1.0, 2.0, 3.0, 4.0, 5.0)
            fmt.Printf("Average (direct): %.2f\n", avg1)
            
            // Slice expansion with ...
            scores := []float64{85.5, 92.0, 78.5, 96.0, 88.5}
            avg2 := average(scores...)
            fmt.Printf("Average (slice): %.2f\n", avg2)
        }
        ```

## Advanced Function Concepts

### Function Types and Higher-Order Functions

!!! example "Function Types"

    === "Function Variables"
        ```go title="function_variables.go" linenums="1" hl_lines="8-15"
        package main

        import "fmt"

        // Define function type
        type MathOperation func(int, int) int

        // Functions that match the type
        func add(a, b int) int { return a + b }
        func multiply(a, b int) int { return a * b }

        // Higher-order function
        func calculate(op MathOperation, x, y int) int {
            return op(x, y)
        }

        func main() {
            // Assign functions to variables
            var operation MathOperation

            operation = add
            result1 := calculate(operation, 5, 3)
            fmt.Printf("Addition: %d\n", result1)

            operation = multiply
            result2 := calculate(operation, 5, 3)
            fmt.Printf("Multiplication: %d\n", result2)
        }
        ```

    === "Anonymous Functions"
        ```go title="anonymous_functions.go" linenums="1" hl_lines="8-15"
        package main

        import "fmt"

        func main() {
            // Anonymous function assigned to variable
            square := func(x int) int {
                return x * x
            }

            // Anonymous function called immediately
            result := func(a, b int) int {
                return a*a + b*b
            }(3, 4)

            fmt.Printf("Square of 5: %d\n", square(5))
            fmt.Printf("Sum of squares: %d\n", result)

            // Anonymous function in slice
            operations := []func(int, int) int{
                func(a, b int) int { return a + b },
                func(a, b int) int { return a - b },
                func(a, b int) int { return a * b },
            }

            for i, op := range operations {
                fmt.Printf("Operation %d: %d\n", i, op(10, 5))
            }
        }
        ```

    === "Closures"
        ```go title="closures.go" linenums="1" hl_lines="6-12"
        package main

        import "fmt"

        // Function that returns a closure
        func makeCounter() func() int {
            count := 0
            return func() int {
                count++
                return count
            }
        }

        // Closure with parameters
        func makeMultiplier(factor int) func(int) int {
            return func(x int) int {
                return x * factor
            }
        }

        func main() {
            // Each counter has its own state
            counter1 := makeCounter()
            counter2 := makeCounter()

            fmt.Printf("Counter1: %d\n", counter1()) // 1
            fmt.Printf("Counter1: %d\n", counter1()) // 2
            fmt.Printf("Counter2: %d\n", counter2()) // 1

            // Closure with captured variable
            double := makeMultiplier(2)
            triple := makeMultiplier(3)

            fmt.Printf("Double 5: %d\n", double(5))   // 10
            fmt.Printf("Triple 5: %d\n", triple(5))   // 15
        }
        ```

### Recursive Functions

!!! example "Recursion Patterns"

    === "Basic Recursion"
        ```go title="recursion_basic.go" linenums="1" hl_lines="6-12"
        package main

        import "fmt"

        // Classic factorial function
        func factorial(n int) int {
            if n <= 1 {
                return 1
            }
            return n * factorial(n-1)
        }

        // Fibonacci sequence
        func fibonacci(n int) int {
            if n <= 1 {
                return n
            }
            return fibonacci(n-1) + fibonacci(n-2)
        }

        func main() {
            fmt.Printf("Factorial of 5: %d\n", factorial(5))

            fmt.Print("Fibonacci sequence: ")
            for i := 0; i < 10; i++ {
                fmt.Printf("%d ", fibonacci(i))
            }
            fmt.Println()
        }
        ```

    === "Tail Recursion"
        ```go title="tail_recursion.go" linenums="1" hl_lines="6-12"
        package main

        import "fmt"

        // Tail-recursive factorial with accumulator
        func factorialTail(n, acc int) int {
            if n <= 1 {
                return acc
            }
            return factorialTail(n-1, n*acc)
        }

        // Helper function for clean interface
        func factorial(n int) int {
            return factorialTail(n, 1)
        }

        // Tail-recursive sum
        func sumRange(start, end, acc int) int {
            if start > end {
                return acc
            }
            return sumRange(start+1, end, acc+start)
        }

        func main() {
            fmt.Printf("Factorial of 10: %d\n", factorial(10))
            fmt.Printf("Sum 1 to 100: %d\n", sumRange(1, 100, 0))
        }
        ```

## Best Practices and Performance

!!! success "Function Best Practices"
    1. **Clear Function Names**
        ```go
        // Good: Descriptive names
        func calculateTotalPrice(items []Item) float64 { ... }
        func validateEmailAddress(email string) bool { ... }

        // Avoid: Unclear names
        func calc(x []Item) float64 { ... }
        func check(s string) bool { ... }
        ```

    2. **Error Handling Pattern**
        ```go
        // Standard Go error handling
        func processFile(filename string) ([]byte, error) {
            data, err := os.ReadFile(filename)
            if err != nil {
                return nil, fmt.Errorf("failed to read %s: %w", filename, err)
            }
            return data, nil
        }
        ```

    3. **Function Size and Responsibility**
        ```go
        // Good: Single responsibility
        func validateInput(input string) error { ... }
        func processData(data []byte) Result { ... }
        func saveResult(result Result) error { ... }

        // Avoid: Functions doing too much
        func validateProcessAndSave(input string) error { ... }
        ```

!!! warning "Common Pitfalls"
    - **Ignoring Errors**: Always handle error return values
    - **Deep Recursion**: Be aware of stack overflow with deep recursion
    - **Closure Variable Capture**: Understand variable capture in loops
    - **Named Return Confusion**: Use named returns judiciously

## Quick Reference

!!! success "Key Takeaways"
    1. **Function Syntax**: `func name(params) returns { body }`
    2. **Multiple Returns**: Go's signature feature for error handling
    3. **Variadic Functions**: Use `...type` for variable arguments
    4. **First-Class Functions**: Assign to variables, pass as parameters
    5. **Closures**: Functions that capture surrounding variables
    6. **Error Handling**: Use `(result, error)` pattern consistently

!!! quote "Remember"
    > "Functions are the building blocks of Go programs. Write small, focused functions with clear names and proper error handling. Embrace multiple return values and use variadic functions when appropriate. When in doubt, keep it simple and readable!"
