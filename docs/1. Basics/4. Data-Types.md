# Data Types in Go

! => Update: Include section for variables, naming conventions, constants, and arithmetic operations

This document provides a comprehensive guide to the data types available in the Go programming language. Understanding data types is fundamental to writing effective Go programs, as they determine the kind of data that can be stored and manipulated.

---

## Overview

Go is a statically typed language, meaning that every variable has a specific type that is known at compile time. Data types in Go can be broadly categorized into:

1. Basic Types
2. Composite Types
3. Reference Types
4. Interface Types

Let's explore each category in detail.

---

## Basic Types

Basic types are the fundamental building blocks of data in Go. They include numeric types, string types, and boolean types.

### Numeric Types

#### Integer Types

Go provides both signed and unsigned integer types of various sizes:

| Type | Size | Range |
|------|------|-------|
| `int8` | 8 bits | -128 to 127 |
| `int16` | 16 bits | -32,768 to 32,767 |
| `int32` | 32 bits | -2,147,483,648 to 2,147,483,647 |
| `int64` | 64 bits | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
| `uint8` | 8 bits | 0 to 255 |
| `uint16` | 16 bits | 0 to 65,535 |
| `uint32` | 32 bits | 0 to 4,294,967,295 |
| `uint64` | 64 bits | 0 to 18,446,744,073,709,551,615 |

There are also two special integer types:

- `int`: Represents a signed integer whose size is platform-dependent (32 bits on 32-bit systems, 64 bits on 64-bit systems).
- `uint`: Represents an unsigned integer whose size is platform-dependent.

There's also `uintptr`, an unsigned integer type large enough to hold the bit pattern of any pointer.

```go
package main

import "fmt"

func main() {
    // Declaring and initializing integer variables
    var a int8 = -128
    var b uint8 = 255
    var c int = 42
    var d uint = 100
    
    fmt.Printf("a: %d, type: %T\n", a, a)
    fmt.Printf("b: %d, type: %T\n", b, b)
    fmt.Printf("c: %d, type: %T\n", c, c)
    fmt.Printf("d: %d, type: %T\n", d, d)
    
    // Integer overflow
    var e int8 = 127
    e++ // This will overflow to -128
    fmt.Printf("e after overflow: %d\n", e)
}
```

#### Floating-Point Types

Go provides two floating-point types:

| Type | Size | Precision |
|------|------|-----------|
| `float32` | 32 bits | Approximately 6 decimal digits |
| `float64` | 64 bits | Approximately 15 decimal digits |

```go
package main

import "fmt"

func main() {
    // Declaring and initializing floating-point variables
    var a float32 = 3.14
    var b float64 = 2.718281828459045
    
    fmt.Printf("a: %f, type: %T\n", a, a)
    fmt.Printf("b: %f, type: %T\n", b, b)
    
    // Floating-point operations
    sum := a + float32(b)
    fmt.Printf("Sum: %f\n", sum)
    
    // Formatting floating-point numbers
    fmt.Printf("b with 4 decimal places: %.4f\n", b)
}
```

#### Complex Types

Go provides two complex number types:

| Type | Size |
|------|------|
| `complex64` | 64 bits (32 bits for real and imaginary parts) |
| `complex128` | 128 bits (64 bits for real and imaginary parts) |

```go
package main

import "fmt"

func main() {
    // Declaring and initializing complex numbers
    var a complex64 = 3 + 4i
    var b complex128 = 5 + 12i
    
    fmt.Printf("a: %v, type: %T\n", a, a)
    fmt.Printf("b: %v, type: %T\n", b, b)
    
    // Accessing real and imaginary parts
    fmt.Printf("Real part of a: %f\n", real(a))
    fmt.Printf("Imaginary part of a: %f\n", imag(a))
    
    // Complex number operations
    sum := a + complex64(b)
    fmt.Printf("Sum: %v\n", sum)
}
```

### String Type

The `string` type represents a sequence of characters. In Go, strings are immutable, which means once created, they cannot be changed.

```go
package main

import "fmt"

func main() {
    // Declaring and initializing strings
    var a string = "Hello, World!"
    b := "Go is awesome"
    
    fmt.Printf("a: %s, type: %T\n", a, a)
    fmt.Printf("b: %s, type: %T\n", b, b)
    
    // String concatenation
    c := a + " " + b
    fmt.Printf("Concatenated: %s\n", c)
    
    // String length
    fmt.Printf("Length of a: %d\n", len(a))
    
    // Accessing individual characters (runes)
    fmt.Printf("First character of a: %c\n", a[0])
    
    // String slicing
    fmt.Printf("Substring of a (0:5): %s\n", a[0:5])
    
    // Multiline strings
    d := `This is a
multiline string`
    fmt.Printf("Multiline string:\n%s\n", d)
}
```

### Boolean Type

The `bool` type represents boolean values, which can be either `true` or `false`.

```go
package main

import "fmt"

func main() {
    // Declaring and initializing boolean variables
    var a bool = true
    b := false
    
    fmt.Printf("a: %t, type: %T\n", a, a)
    fmt.Printf("b: %t, type: %T\n", b, b)
    
    // Boolean operations
    c := a && b // Logical AND
    d := a || b // Logical OR
    e := !a     // Logical NOT
    
    fmt.Printf("a AND b: %t\n", c)
    fmt.Printf("a OR b: %t\n", d)
    fmt.Printf("NOT a: %t\n", e)
    
    // Comparison operations
    f := 5 > 3
    g := 10 == 10
    
    fmt.Printf("5 > 3: %t\n", f)
    fmt.Printf("10 == 10: %t\n", g)
}
```

---

## Composite Types

Composite types are constructed from basic types and other composite types. They include arrays, slices, structs, and maps.

### Arrays

Arrays are fixed-length sequences of elements of the same type. The length of an array is part of its type, so arrays of different lengths are considered different types.

```go
package main

import "fmt"

func main() {
    // Declaring and initializing arrays
    var a [5]int
    b := [3]int{1, 2, 3}
    c := [...]int{4, 5, 6, 7} // Compiler determines the length
    
    fmt.Printf("a: %v, type: %T\n", a, a)
    fmt.Printf("b: %v, type: %T\n", b, b)
    fmt.Printf("c: %v, type: %T\n", c, c)
    
    // Accessing array elements
    a[0] = 10
    fmt.Printf("First element of a: %d\n", a[0])
    
    // Array length
    fmt.Printf("Length of b: %d\n", len(b))
    
    // Iterating over an array
    fmt.Print("Elements of c: ")
    for i, v := range c {
        fmt.Printf("%d ", v)
        if i < len(c)-1 {
            fmt.Printf("(%d) ", i)
        }
    }
    fmt.Println()
    
    // Multidimensional arrays
    d := [2][3]int{
        {1, 2, 3},
        {4, 5, 6},
    }
    fmt.Printf("2D array: %v\n", d)
}
```

### Slices

Slices are dynamic, flexible views into the elements of an array. Unlike arrays, slices can grow and shrink.

```go
package main

import "fmt"

func main() {
    // Creating a slice from an array
    arr := [5]int{1, 2, 3, 4, 5}
    slice := arr[1:4] // Elements from index 1 to 3
    
    fmt.Printf("Array: %v\n", arr)
    fmt.Printf("Slice: %v, type: %T\n", slice, slice)
    
    // Slice length and capacity
    fmt.Printf("Length of slice: %d\n", len(slice))
    fmt.Printf("Capacity of slice: %d\n", cap(slice))
    
    // Creating a slice with make
    slice2 := make([]int, 3, 5) // Length 3, capacity 5
    fmt.Printf("Slice created with make: %v, len: %d, cap: %d\n", slice2, len(slice2), cap(slice2))
    
    // Slice literals
    slice3 := []int{10, 20, 30}
    fmt.Printf("Slice literal: %v\n", slice3)
    
    // Modifying a slice
    slice[0] = 100
    fmt.Printf("Modified slice: %v\n", slice)
    fmt.Printf("Original array after modification: %v\n", arr)
    
    // Appending to a slice
    slice = append(slice, 6)
    fmt.Printf("Slice after append: %v\n", slice)
    
    // Copying slices
    slice4 := make([]int, len(slice))
    copy(slice4, slice)
    fmt.Printf("Copied slice: %v\n", slice4)
    
    // Slice operations
    fmt.Printf("First element: %d\n", slice[0])
    fmt.Printf("Last element: %d\n", slice[len(slice)-1])
    fmt.Printf("Sub-slice [1:3]: %v\n", slice[1:3])
    
    // Iterating over a slice
    fmt.Print("Elements of slice: ")
    for i, v := range slice {
        fmt.Printf("%d ", v)
        if i < len(slice)-1 {
            fmt.Printf("(%d) ", i)
        }
    }
    fmt.Println()
}
```

### Structs

Structs are collections of named fields, each with its own type. They are used to group related data together.

```go
package main

import "fmt"

// Defining a struct type
type Person struct {
    Name string
    Age  int
    City string
}

func main() {
    // Creating and initializing a struct
    p1 := Person{Name: "Alice", Age: 30, City: "New York"}
    fmt.Printf("Person: %+v\n", p1)
    
    // Accessing struct fields
    fmt.Printf("Name: %s\n", p1.Name)
    fmt.Printf("Age: %d\n", p1.Age)
    
    // Modifying struct fields
    p1.Age = 31
    fmt.Printf("Updated person: %+v\n", p1)
    
    // Creating a struct with field names
    p2 := Person{
        Name: "Bob",
        Age:  25,
        City: "Los Angeles",
    }
    fmt.Printf("Person 2: %+v\n", p2)
    
    // Creating a struct without field names (order matters)
    p3 := Person{"Charlie", 35, "Chicago"}
    fmt.Printf("Person 3: %+v\n", p3)
    
    // Creating a pointer to a struct
    p4 := &Person{Name: "David", Age: 40, City: "Houston"}
    fmt.Printf("Person 4 (pointer): %+v\n", *p4)
    
    // Accessing struct fields through a pointer
    fmt.Printf("Name: %s\n", p4.Name) // No need to dereference
    
    // Anonymous structs
    p5 := struct {
        Name string
        Age  int
    }{
        Name: "Eve",
        Age:  28,
    }
    fmt.Printf("Anonymous struct: %+v\n", p5)
    
    // Nested structs
    type Address struct {
        Street  string
        City    string
        Country string
    }
    
    type Employee struct {
        Name    string
        Age     int
        Address Address
    }
    
    emp := Employee{
        Name: "Frank",
        Age:  45,
        Address: Address{
            Street:  "123 Main St",
            City:    "Boston",
            Country: "USA",
        },
    }
    fmt.Printf("Employee: %+v\n", emp)
    fmt.Printf("Employee city: %s\n", emp.Address.City)
}
```

### Maps

Maps are unordered collections of key-value pairs, where each key is unique. Maps are also known as hash tables or dictionaries in other languages.

```go
package main

import "fmt"

func main() {
    // Creating and initializing a map
    var m map[string]int
    m = make(map[string]int)
    
    // Adding key-value pairs
    m["one"] = 1
    m["two"] = 2
    m["three"] = 3
    
    fmt.Printf("Map: %v\n", m)
    
    // Map literal
    m2 := map[string]int{
        "apple":  5,
        "banana": 3,
        "orange": 7,
    }
    fmt.Printf("Map literal: %v\n", m2)
    
    // Accessing map values
    value := m["one"]
    fmt.Printf("Value for key 'one': %d\n", value)
    
    // Checking if a key exists
    value, exists := m["four"]
    if exists {
        fmt.Printf("Value for key 'four': %d\n", value)
    } else {
        fmt.Println("Key 'four' does not exist in the map")
    }
    
    // Deleting a key-value pair
    delete(m, "two")
    fmt.Printf("Map after deletion: %v\n", m)
    
    // Map length
    fmt.Printf("Length of m2: %d\n", len(m2))
    
    // Iterating over a map
    fmt.Print("Key-value pairs in m2:\n")
    for key, value := range m2 {
        fmt.Printf("  %s: %d\n", key, value)
    }
    
    // Maps with struct values
    type Person struct {
        Name string
        Age  int
    }
    
    people := map[int]Person{
        1: {Name: "Alice", Age: 30},
        2: {Name: "Bob", Age: 25},
    }
    fmt.Printf("Map with struct values: %+v\n", people)
    
    // Maps of maps
    nested := map[string]map[string]int{
        "fruits": {
            "apple":  5,
            "banana": 3,
        },
        "vegetables": {
            "carrot": 7,
            "potato": 10,
        },
    }
    fmt.Printf("Nested map: %+v\n", nested)
    fmt.Printf("Number of apples: %d\n", nested["fruits"]["apple"])
}
```

---

## Reference Types

Reference types are special types that refer to an underlying data structure. They include pointers, functions, channels, and interfaces (which we'll cover in the next section).

### Pointers

A pointer holds the memory address of a value. The type `*T` is a pointer to a `T` value. Its zero value is `nil`.

```go
package main

import "fmt"

func main() {
    // Basic pointer operations
    i := 42
    p := &i // p is a pointer to i
    
    fmt.Printf("i: %d\n", i)
    fmt.Printf("p: %p (memory address of i)\n", p)
    fmt.Printf("*p: %d (value at the address p points to)\n", *p)
    
    // Modifying the value through a pointer
    *p = 21
    fmt.Printf("i after modification through pointer: %d\n", i)
    
    // Pointer to a pointer
    pp := &p
    fmt.Printf("pp: %p (memory address of p)\n", pp)
    fmt.Printf("*pp: %p (value at the address pp points to, which is p)\n", *pp)
    fmt.Printf("**pp: %d (value at the address *pp points to)\n", **pp)
    
    // Pointers and structs
    type Person struct {
        Name string
        Age  int
    }
    
    person := Person{Name: "Alice", Age: 30}
    personPtr := &person
    
    fmt.Printf("Person: %+v\n", person)
    fmt.Printf("Person pointer: %p\n", personPtr)
    
    // Accessing struct fields through a pointer
    fmt.Printf("Name: %s\n", (*personPtr).Name) // Explicit dereference
    fmt.Printf("Age: %d\n", personPtr.Age)     // Implicit dereference
    
    // Modifying struct fields through a pointer
    personPtr.Age = 31
    fmt.Printf("Person after modification: %+v\n", person)
    
    // Nil pointers
    var nilPtr *int
    fmt.Printf("Nil pointer: %v\n", nilPtr)
    
    // This would cause a runtime panic:
    // fmt.Printf("Value of nil pointer: %d\n", *nilPtr)
    
    // Pointers as function parameters
    x := 1
    increment(&x)
    fmt.Printf("x after increment: %d\n", x)
}

func increment(p *int) {
    *p++
}
```

### Functions

In Go, functions are first-class citizens, meaning they can be assigned to variables, passed as arguments, and returned from other functions.

```go
package main

import "fmt"

// Function that takes two integers and returns their sum
func add(a, b int) int {
    return a + b
}

// Function that returns multiple values
func divide(a, b int) (int, int) {
    quotient := a / b
    remainder := a % b
    return quotient, remainder
}

// Function that takes a function as a parameter
func applyOperation(a, b int, op func(int, int) int) int {
    return op(a, b)
}

// Function that returns another function
func getMultiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

// Function with named return values
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return // Return the named return values
}

func main() {
    // Calling a function
    result := add(3, 4)
    fmt.Printf("3 + 4 = %d\n", result)
    
    // Function with multiple return values
    q, r := divide(10, 3)
    fmt.Printf("10 / 3 = %d with remainder %d\n", q, r)
    
    // Ignoring a return value
    q2, _ := divide(10, 3)
    fmt.Printf("10 / 3 = %d (remainder ignored)\n", q2)
    
    // Function as a parameter
    sum := applyOperation(5, 6, add)
    fmt.Printf("5 + 6 = %d\n", sum)
    
    // Anonymous function (lambda)
    multiply := func(a, b int) int {
        return a * b
    }
    product := applyOperation(5, 6, multiply)
    fmt.Printf("5 * 6 = %d\n", product)
    
    // Function that returns a function
    times2 := getMultiplier(2)
    times3 := getMultiplier(3)
    fmt.Printf("5 * 2 = %d\n", times2(5))
    fmt.Printf("5 * 3 = %d\n", times3(5))
    
    // Function with named return values
    x, y := split(17)
    fmt.Printf("split(17) = %d, %d\n", x, y)
    
    // Recursive function
    fmt.Printf("5! = %d\n", factorial(5))
}

func factorial(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorial(n-1)
}
```

### Channels

Channels are typed conduits through which you can send and receive values with the channel operator, `<-`. They are a key feature of Go's concurrency model.

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // Creating a channel
    ch := make(chan int)
    
    // Sending a value into a channel
    go func() {
        ch <- 42 // Send 42 to the channel
    }()
    
    // Receiving a value from a channel
    value := <-ch
    fmt.Printf("Received: %d\n", value)
    
    // Buffered channel
    bufferedCh := make(chan int, 2)
    bufferedCh <- 1
    bufferedCh <- 2
    
    fmt.Printf("Received from buffered channel: %d\n", <-bufferedCh)
    fmt.Printf("Received from buffered channel: %d\n", <-bufferedCh)
    
    // Channel direction
    // pings is a channel that only accepts values for sending
    pings := make(chan string)
    // pongs is a channel that only accepts values for receiving
    pongs := make(chan string)
    
    go ping(pings, "passed message")
    go pong(pings, pongs)
    
    msg := <-pongs
    fmt.Printf("Received: %s\n", msg)
    
    // Closing a channel
    jobs := make(chan int, 5)
    done := make(chan bool)
    
    go func() {
        for {
            j, more := <-jobs
            if more {
                fmt.Printf("Received job: %d\n", j)
            } else {
                fmt.Println("Received all jobs")
                done <- true
                return
            }
        }
    }()
    
    for j := 1; j <= 3; j++ {
        jobs <- j
        fmt.Printf("Sent job: %d\n", j)
    }
    close(jobs)
    fmt.Println("Sent all jobs")
    
    <-done
    
    // Range over channels
    queue := make(chan string, 2)
    queue <- "one"
    queue <- "two"
    close(queue)
    
    fmt.Println("Range over channel:")
    for elem := range queue {
        fmt.Println(elem)
    }
    
    // Select statement with channels
    c1 := make(chan string)
    c2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        c1 <- "one"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 <- "two"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("Received", msg1)
        case msg2 := <-c2:
            fmt.Println("Received", msg2)
        }
    }
}

// Function that only sends to a channel
func ping(pings chan<- string, msg string) {
    pings <- msg
}

// Function that receives from one channel and sends to another
func pong(pings <-chan string, pongs chan<- string) {
    msg := <-pings
    pongs <- msg
}
```

---

## Interface Types

Interfaces are abstract types that define a set of method signatures. A type implements an interface by implementing its methods, without any explicit declaration.

```go
package main

import (
    "fmt"
    "math"
)

// Defining an interface
type geometry interface {
    area() float64
    perim() float64
}

// Implementing the interface for a rectangle
type rect struct {
    width, height float64
}

func (r rect) area() float64 {
    return r.width * r.height
}

func (r rect) perim() float64 {
    return 2*r.width + 2*r.height
}

// Implementing the interface for a circle
type circle struct {
    radius float64
}

func (c circle) area() float64 {
    return math.Pi * c.radius * c.radius
}

func (c circle) perim() float64 {
    return 2 * math.Pi * c.radius
}

func measure(g geometry) {
    fmt.Println(g)
    fmt.Println("Area:", g.area())
    fmt.Println("Perimeter:", g.perim())
}

func main() {
    r := rect{width: 3, height: 4}
    c := circle{radius: 5}
    
    // Both rect and circle implement the geometry interface
    measure(r)
    measure(c)
    
    // Interface values
    var g geometry
    g = rect{width: 10, height: 20}
    fmt.Printf("Type of g: %T, Value: %v\n", g, g)
    
    g = circle{radius: 15}
    fmt.Printf("Type of g: %T, Value: %v\n", g, g)
    
    // Type assertion
    var i interface{} = "hello"
    
    s, ok := i.(string)
    fmt.Printf("s: %v, ok: %v\n", s, ok)
    
    f, ok := i.(float64)
    fmt.Printf("f: %v, ok: %v\n", f, ok)
    
    // Type switch
    do(21)
    do("hello")
    do(true)
}

func do(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("Twice %v is %v\n", v, v*2)
    case string:
        fmt.Printf("%q is %v bytes long\n", v, len(v))
    default:
        fmt.Printf("I don't know about type %T!\n", v)
    }
}
```

---

## Type Conversions

Go requires explicit type conversions when mixing types in an expression. This is different from languages like C or Java that perform implicit type conversions.

```go
package main

import "fmt"

func main() {
    // Basic type conversions
    var i int = 42
    var f float64 = float64(i)
    var u uint = uint(f)
    
    fmt.Printf("i: %v, type: %T\n", i, i)
    fmt.Printf("f: %v, type: %T\n", f, f)
    fmt.Printf("u: %v, type: %T\n", u, u)
    
    // String conversions
    s := string(65) // Convert ASCII code to string
    fmt.Printf("ASCII 65 as string: %s\n", s)
    
    // Converting between integer types
    var a int16 = 1000
    var b int8 = int8(a) // Possible truncation
    fmt.Printf("a: %d, b: %d\n", a, b)
    
    // Converting strings to numbers
    str := "123"
    num, err := strconv.Atoi(str)
    if err != nil {
        fmt.Println("Error converting string to int:", err)
    } else {
        fmt.Printf("String %s converted to int: %d\n", str, num)
    }
    
    // Converting numbers to strings
    numStr := strconv.Itoa(456)
    fmt.Printf("Int 456 converted to string: %s\n", numStr)
    
    // Converting between float and string
    floatStr := "3.14"
    floatValue, err := strconv.ParseFloat(floatStr, 64)
    if err != nil {
        fmt.Println("Error converting string to float:", err)
    } else {
        fmt.Printf("String %s converted to float: %f\n", floatStr, floatValue)
    }
    
    // Converting float to string
    floatToStr := strconv.FormatFloat(2.718, 'f', -1, 64)
    fmt.Printf("Float 2.718 converted to string: %s\n", floatToStr)
}
```

---

## Type Inference

Go supports type inference, which allows you to omit the type in variable declarations when the type can be inferred from the context.

```go
package main

import "fmt"

func main() {
    // Variable declaration with type inference
    i := 42           // int
    f := 3.14         // float64
    s := "hello"      // string
    b := true         // bool
    
    fmt.Printf("i: %v, type: %T\n", i, i)
    fmt.Printf("f: %v, type: %T\n", f, f)
    fmt.Printf("s: %v, type: %T\n", s, s)
    fmt.Printf("b: %v, type: %T\n", b, b)
    
    // Type inference with composite literals
    arr := [3]int{1, 2, 3}        // [3]int
    slice := []int{4, 5, 6}       // []int
    m := map[string]int{"a": 1}   // map[string]int
    
    fmt.Printf("arr: %v, type: %T\n", arr, arr)
    fmt.Printf("slice: %v, type: %T\n", slice, slice)
    fmt.Printf("m: %v, type: %T\n", m, m)
    
    // Type inference with function return values
    j, k := getValues()
    fmt.Printf("j: %v, type: %T\n", j, j)
    fmt.Printf("k: %v, type: %T\n", k, k)
}

func getValues() (int, string) {
    return 42, "answer"
}
```

---

## Zero Values

In Go, variables declared without an explicit initial value are given their zero value. The zero value is:

- `0` for numeric types
- `false` for the boolean type
- `""` (empty string) for the string type
- `nil` for pointer, function, interface, slice, channel, and map types

```go
package main

import "fmt"

func main() {
    // Zero values for basic types
    var i int
    var f float64
    var b bool
    var s string
    
    fmt.Printf("int zero value: %v\n", i)
    fmt.Printf("float64 zero value: %v\n", f)
    fmt.Printf("bool zero value: %v\n", b)
    fmt.Printf("string zero value: %q\n", s)
    
    // Zero values for composite types
    var arr [3]int
    var slice []int
    var m map[string]int
    
    fmt.Printf("array zero value: %v\n", arr)
    fmt.Printf("slice zero value: %v, len: %d, cap: %d\n", slice, len(slice), cap(slice))
    fmt.Printf("map zero value: %v, len: %d\n", m, len(m))
    
    // Zero values for reference types
    var p *int
    var fn func()
    var ch chan int
    var iface interface{}
    
    fmt.Printf("pointer zero value: %v\n", p)
    fmt.Printf("function zero value: %v\n", fn)
    fmt.Printf("channel zero value: %v\n", ch)
    fmt.Printf("interface zero value: %v\n", iface)
    
    // Using zero values
    // This is safe because the zero value for a map is nil, and len(nil) returns 0
    if len(m) == 0 {
        fmt.Println("Map is empty")
    }
    
    // This would cause a runtime panic because you can't write to a nil map
    // m["key"] = "value"
    
    // Initialize the map first
    m = make(map[string]int)
    m["key"] = 1
    fmt.Printf("Map after initialization: %v\n", m)
}
```

---

## Conclusion

Understanding data types is fundamental to programming in Go. In this guide, we've covered:

1. **Basic Types**: Integers, floating-point numbers, complex numbers, strings, and booleans.
2. **Composite Types**: Arrays, slices, structs, and maps.
3. **Reference Types**: Pointers, functions, and channels.
4. **Interface Types**: Abstract types that define sets of methods.
5. **Type Conversions**: Explicit conversions between types.
6. **Type Inference**: Letting Go infer types from context.
7. **Zero Values**: Default values for uninitialized variables.

As you continue to learn Go, you'll find that these data types form the foundation for building more complex and powerful programs. Understanding their characteristics and how to use them effectively will make you a more proficient Go developer.

