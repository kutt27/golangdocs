# Go Data Types: Variables, Constants & Operations

!!! abstract "Overview"
    Master Go's type system, from basic data types to variables, constants, and arithmetic operations. This comprehensive guide covers everything you need to know about working with data in Go, building upon our foundation from Hello World and compiler basics.

!!! tip "Key Points"
    - Go is statically typed with compile-time type checking
    - Rich set of built-in types for different use cases
    - Powerful variable declaration and initialization patterns
    - Constants provide compile-time guarantees
    - Type-safe arithmetic operations

## Understanding Go's Type System :gear:

Go is a statically typed language, meaning every variable has a specific type known at compile time. This provides safety, performance, and clarity in your programs.

!!! info "Type Categories"
    ```mermaid
    graph TD
        A[Go Data Types] --> B[Basic Types]
        A --> C[Composite Types]
        A --> D[Reference Types]
        A --> E[Interface Types]
        B --> B1[Numeric]
        B --> B2[String]
        B --> B3[Boolean]
        B1 --> B1a[Integers]
        B1 --> B1b[Floating Point]
        B1 --> B1c[Complex]
        C --> C1[Arrays]
        C --> C2[Structs]
        D --> D1[Slices]
        D --> D2[Maps]
        D --> D3[Channels]
        D --> D4[Pointers]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

## Variables: Storing and Managing Data :package:

Variables are named storage locations that hold values of a specific type. Go provides several ways to declare and initialize variables.

### Variable Declaration Methods

!!! example "Declaration Patterns"

    === "Method 1: var with Type"
        ```go title="explicit_types.go" linenums="1" hl_lines="6 7 8"
        package main

        import "fmt"

        func main() {
            var name string
            var age int
            var isStudent bool

            fmt.Printf("Name: %s, Age: %d, Student: %t\n", name, age, isStudent)
            // Output: Name: , Age: 0, Student: false
        }
        ```

        !!! tip "Zero Values"
            Variables declared without initialization get their type's zero value automatically.

    === "Method 2: var with Initialization"
        ```go title="var_init.go" linenums="1" hl_lines="6 7 8"
        package main

        import "fmt"

        func main() {
            var name string = "Alice"
            var age int = 25
            var isStudent bool = true

            fmt.Printf("Name: %s, Age: %d, Student: %t\n", name, age, isStudent)
            // Output: Name: Alice, Age: 25, Student: true
        }
        ```

    === "Method 3: Short Declaration"
        ```go title="short_declaration.go" linenums="1" hl_lines="6 7 8"
        package main

        import "fmt"

        func main() {
            name := "Bob"        // Type inferred as string
            age := 30           // Type inferred as int
            isStudent := false  // Type inferred as bool

            fmt.Printf("Name: %s, Age: %d, Student: %t\n", name, age, isStudent)
            // Output: Name: Bob, Age: 30, Student: false
        }
        ```

        !!! tip "Most Common"
            Short declaration (`:=`) is the most commonly used method in Go.

### Multiple Variable Declaration

!!! example "Declaring Multiple Variables"

    === "Grouped Declaration"
        ```go title="grouped_vars.go" linenums="1" hl_lines="6-10"
        package main

        import "fmt"

        func main() {
            var (
                name     string = "Charlie"
                age      int    = 35
                salary   float64 = 75000.50
                isActive bool   = true
            )

            fmt.Printf("Employee: %s, Age: %d, Salary: %.2f, Active: %t\n",
                name, age, salary, isActive)
        }
        ```

    === "Multiple Assignment"
        ```go title="multiple_assignment.go" linenums="1" hl_lines="6"
        package main

        import "fmt"

        func main() {
            name, age, city := "Diana", 28, "New York"

            fmt.Printf("Name: %s, Age: %d, City: %s\n", name, age, city)
            // Output: Name: Diana, Age: 28, City: New York
        }
        ```

### Variable Naming Conventions :memo:

!!! success "Go Naming Best Practices"
    1. **CamelCase**: Use camelCase for variable names
        ```go
        firstName := "John"
        lastName := "Doe"
        phoneNumber := "123-456-7890"
        ```

    2. **Descriptive Names**: Choose meaningful names
        ```go
        // Good
        userAge := 25
        totalPrice := 99.99

        // Avoid
        a := 25
        tp := 99.99
        ```

    3. **Short Names for Short Scope**: Use short names for limited scope
        ```go
        for i := 0; i < 10; i++ {  // 'i' is fine for loop counter
            // ...
        }
        ```

    4. **Exported vs Unexported**: Capitalization determines visibility
        ```go
        var PublicVariable = "visible outside package"
        var privateVariable = "only visible within package"
        ```

## Basic Data Types Deep Dive :mag:

### Integer Types

Go provides a rich set of integer types for different use cases and memory requirements.

!!! example "Integer Type Reference"
    | Type | Size | Range | Use Case |
    |:-----|:-----|:------|:---------|
    | `int8` | 8 bits | -128 to 127 | Small signed values |
    | `int16` | 16 bits | -32,768 to 32,767 | Medium signed values |
    | `int32` | 32 bits | -2.1B to 2.1B | Large signed values |
    | `int64` | 64 bits | -9.2E18 to 9.2E18 | Very large signed values |
    | `uint8` | 8 bits | 0 to 255 | Small unsigned values |
    | `uint16` | 16 bits | 0 to 65,535 | Medium unsigned values |
    | `uint32` | 32 bits | 0 to 4.3B | Large unsigned values |
    | `uint64` | 64 bits | 0 to 1.8E19 | Very large unsigned values |
    | `int` | Platform | 32 or 64 bits | General purpose |
    | `uint` | Platform | 32 or 64 bits | General unsigned |
    | `uintptr` | Platform | Pointer size | Memory addresses |

!!! example "Integer Examples"

    === "Basic Integer Usage"
        ```go title="integers.go" linenums="1"
        package main

        import "fmt"

        func main() {
            // Different integer types
            var smallNum int8 = 127
            var mediumNum int16 = 32767
            var largeNum int32 = 2147483647
            var veryLargeNum int64 = 9223372036854775807

            // Platform-dependent int
            var defaultInt int = 42

            // Unsigned integers
            var positiveNum uint8 = 255
            var bigPositive uint32 = 4294967295

            fmt.Printf("int8: %d\n", smallNum)
            fmt.Printf("int16: %d\n", mediumNum)
            fmt.Printf("int32: %d\n", largeNum)
            fmt.Printf("int64: %d\n", veryLargeNum)
            fmt.Printf("int: %d\n", defaultInt)
            fmt.Printf("uint8: %d\n", positiveNum)
            fmt.Printf("uint32: %d\n", bigPositive)
        }
        ```

    === "Integer Overflow Behavior"
        ```go title="overflow.go" linenums="1" hl_lines="8 9"
        package main

        import "fmt"

        func main() {
            var maxInt8 int8 = 127
            fmt.Printf("Max int8: %d\n", maxInt8)

            // This would cause overflow (compile-time error)
            // var overflow int8 = 128  // Error: constant 128 overflows int8

            // Runtime overflow wraps around
            maxInt8++
            fmt.Printf("After increment: %d\n", maxInt8) // -128
        }
        ```

### Floating-Point Types

Go provides two floating-point types for decimal numbers.

!!! example "Floating-Point Types"
    | Type | Size | Precision | Range |
    |:-----|:-----|:----------|:------|
    | `float32` | 32 bits | ~7 decimal digits | ±1.18E-38 to ±3.4E38 |
    | `float64` | 64 bits | ~15 decimal digits | ±2.23E-308 to ±1.8E308 |

    === "Basic Float Usage"
        ```go title="floats.go" linenums="1"
        package main

        import "fmt"

        func main() {
            var price float32 = 19.99
            var pi float64 = 3.141592653589793

            // Type inference defaults to float64
            temperature := 23.5

            fmt.Printf("Price: %.2f\n", price)
            fmt.Printf("Pi: %.15f\n", pi)
            fmt.Printf("Temperature: %.1f°C\n", temperature)

            // Scientific notation
            var scientific float64 = 1.23e-4
            fmt.Printf("Scientific: %e\n", scientific)
        }
        ```

    === "Precision Considerations"
        ```go title="precision.go" linenums="1" hl_lines="8-11"
        package main

        import "fmt"

        func main() {
            var f32 float32 = 0.1
            var f64 float64 = 0.1

            // Floating-point precision differences
            fmt.Printf("float32: %.20f\n", f32)
            fmt.Printf("float64: %.20f\n", f64)
            // float32: 0.10000000149011611938
            // float64: 0.10000000000000000555
        }
        ```

### String Type

Strings in Go are immutable sequences of bytes, typically containing UTF-8 encoded text.

!!! example "String Operations"

    === "Basic String Usage"
        ```go title="strings.go" linenums="1"
        package main

        import "fmt"

        func main() {
            var greeting string = "Hello, World!"
            name := "Go"

            // String concatenation
            message := greeting + " Welcome to " + name + "!"

            // String length
            fmt.Printf("Message: %s\n", message)
            fmt.Printf("Length: %d bytes\n", len(message))

            // Raw strings (backticks)
            multiline := `This is a
            multi-line
            string`
            fmt.Println(multiline)
        }
        ```

    === "String Indexing and Slicing"
        ```go title="string_slicing.go" linenums="1" hl_lines="8-12"
        package main

        import "fmt"

        func main() {
            text := "Hello, Go!"

            // String indexing (returns byte values)
            fmt.Printf("First byte: %c (%d)\n", text[0], text[0])
            fmt.Printf("Last byte: %c (%d)\n", text[len(text)-1], text[len(text)-1])

            // String slicing
            fmt.Printf("Substring: %s\n", text[0:5])   // "Hello"
            fmt.Printf("From index 7: %s\n", text[7:]) // "Go!"
        }
        ```

### Boolean Type

The boolean type represents truth values: `true` or `false`.

!!! example "Boolean Usage"
    ```go title="booleans.go" linenums="1"
    package main

    import "fmt"

    func main() {
        var isActive bool = true
        var isComplete bool = false

        // Boolean operations
        fmt.Printf("Active: %t\n", isActive)
        fmt.Printf("Complete: %t\n", isComplete)

        // Logical operations
        fmt.Printf("AND: %t\n", isActive && isComplete)  // false
        fmt.Printf("OR: %t\n", isActive || isComplete)   // true
        fmt.Printf("NOT: %t\n", !isActive)              // false

        // Boolean in conditions
        if isActive {
            fmt.Println("System is running")
        }
    }
    ```

## Constants: Immutable Values :lock:

Constants are immutable values known at compile time. They provide guarantees and optimizations.

### Constant Declaration

!!! example "Constant Types"

    === "Basic Constants"
        ```go title="constants.go" linenums="1" hl_lines="6-9"
        package main

        import "fmt"

        func main() {
            const pi = 3.14159
            const greeting = "Hello"
            const maxUsers = 1000
            const isEnabled = true

            fmt.Printf("Pi: %.5f\n", pi)
            fmt.Printf("Greeting: %s\n", greeting)
            fmt.Printf("Max Users: %d\n", maxUsers)
            fmt.Printf("Enabled: %t\n", isEnabled)
        }
        ```

    === "Typed Constants"
        ```go title="typed_constants.go" linenums="1" hl_lines="6-9"
        package main

        import "fmt"

        func main() {
            const pi float64 = 3.14159265359
            const name string = "Go Language"
            const version int = 1
            const stable bool = true

            fmt.Printf("Language: %s v%d\n", name, version)
            fmt.Printf("Pi: %.10f\n", pi)
            fmt.Printf("Stable: %t\n", stable)
        }
        ```

    === "Constant Groups"
        ```go title="constant_groups.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func main() {
            const (
                StatusPending   = "pending"
                StatusApproved  = "approved"
                StatusRejected  = "rejected"
                MaxRetries      = 3
                TimeoutSeconds  = 30
            )

            fmt.Printf("Status: %s\n", StatusPending)
            fmt.Printf("Max Retries: %d\n", MaxRetries)
            fmt.Printf("Timeout: %d seconds\n", TimeoutSeconds)
        }
        ```

### Enumerations with iota

Go doesn't have built-in enums, but you can create them using constants and `iota`.

!!! example "Using iota for Enumerations"

    === "Basic iota Usage"
        ```go title="iota_basic.go" linenums="1" hl_lines="6-11"
        package main

        import "fmt"

        func main() {
            const (
                Sunday = iota    // 0
                Monday           // 1
                Tuesday          // 2
                Wednesday        // 3
                Thursday         // 4
                Friday           // 5
                Saturday         // 6
            )

            fmt.Printf("Sunday: %d\n", Sunday)
            fmt.Printf("Wednesday: %d\n", Wednesday)
            fmt.Printf("Saturday: %d\n", Saturday)
        }
        ```

    === "Advanced iota Patterns"
        ```go title="iota_advanced.go" linenums="1" hl_lines="6-12"
        package main

        import "fmt"

        func main() {
            const (
                _  = iota             // Skip 0
                KB = 1 << (10 * iota) // 1024
                MB                    // 1048576
                GB                    // 1073741824
                TB                    // 1099511627776
            )

            fmt.Printf("1 KB = %d bytes\n", KB)
            fmt.Printf("1 MB = %d bytes\n", MB)
            fmt.Printf("1 GB = %d bytes\n", GB)
        }
        ```

## Arithmetic Operations :calculator:

Go provides standard arithmetic operations with type safety and predictable behavior.

### Basic Arithmetic Operators

!!! example "Arithmetic Operations"

    === "Basic Operations"
        ```go title="arithmetic.go" linenums="1"
        package main

        import "fmt"

        func main() {
            a, b := 15, 4

            fmt.Printf("a = %d, b = %d\n", a, b)
            fmt.Printf("Addition: %d + %d = %d\n", a, b, a+b)
            fmt.Printf("Subtraction: %d - %d = %d\n", a, b, a-b)
            fmt.Printf("Multiplication: %d * %d = %d\n", a, b, a*b)
            fmt.Printf("Division: %d / %d = %d\n", a, b, a/b)
            fmt.Printf("Remainder: %d %% %d = %d\n", a, b, a%b)

            // Floating-point division
            fmt.Printf("Float Division: %.2f / %.2f = %.2f\n",
                float64(a), float64(b), float64(a)/float64(b))
        }
        ```

    === "Assignment Operators"
        ```go title="assignment_ops.go" linenums="1" hl_lines="8-13"
        package main

        import "fmt"

        func main() {
            x := 10
            fmt.Printf("Initial x: %d\n", x)

            x += 5   // x = x + 5
            fmt.Printf("After x += 5: %d\n", x)

            x -= 3   // x = x - 3
            fmt.Printf("After x -= 3: %d\n", x)

            x *= 2   // x = x * 2
            fmt.Printf("After x *= 2: %d\n", x)

            x /= 4   // x = x / 4
            fmt.Printf("After x /= 4: %d\n", x)
        }
        ```

    === "Increment/Decrement"
        ```go title="increment.go" linenums="1" hl_lines="8-11"
        package main

        import "fmt"

        func main() {
            counter := 5
            fmt.Printf("Initial counter: %d\n", counter)

            counter++  // Increment by 1
            fmt.Printf("After counter++: %d\n", counter)

            counter--  // Decrement by 1
            fmt.Printf("After counter--: %d\n", counter)

            // Note: ++counter and --counter are not valid in Go
        }
        ```

### Type Conversions

Go requires explicit type conversions between different numeric types.

!!! example "Type Conversion Examples"

    === "Numeric Conversions"
        ```go title="conversions.go" linenums="1" hl_lines="8-12"
        package main

        import "fmt"

        func main() {
            var i int = 42
            var f float64 = float64(i)  // int to float64
            var u uint = uint(f)        // float64 to uint

            fmt.Printf("int: %d\n", i)
            fmt.Printf("float64: %.2f\n", f)
            fmt.Printf("uint: %d\n", u)

            // String conversions
            var str string = fmt.Sprintf("%d", i)
            fmt.Printf("string: %s\n", str)
        }
        ```

    === "Safe Conversions"
        ```go title="safe_conversions.go" linenums="1" hl_lines="8-15"
        package main

        import "fmt"

        func main() {
            var bigNum int64 = 1000000

            // Safe conversion (value fits)
            var smallNum int32 = int32(bigNum)
            fmt.Printf("Safe conversion: %d\n", smallNum)

            // Potentially unsafe conversion
            var veryBig int64 = 9223372036854775807
            var truncated int32 = int32(veryBig)
            fmt.Printf("Truncated: %d\n", truncated) // May lose data
        }
        ```

## Advanced Type Concepts :gear:

### Type Aliases and Definitions

!!! example "Custom Types"

    === "Type Aliases"
        ```go title="type_alias.go" linenums="1" hl_lines="6-7"
        package main

        import "fmt"

        func main() {
            type UserID = int64    // Type alias
            type Username = string // Type alias

            var id UserID = 12345
            var name Username = "alice"

            fmt.Printf("User ID: %d\n", id)
            fmt.Printf("Username: %s\n", name)

            // Can use interchangeably with underlying type
            var regularInt int64 = id
            fmt.Printf("Regular int: %d\n", regularInt)
        }
        ```

    === "Type Definitions"
        ```go title="type_definition.go" linenums="1" hl_lines="6-7"
        package main

        import "fmt"

        func main() {
            type Temperature float64  // New type
            type Distance int         // New type

            var temp Temperature = 23.5
            var dist Distance = 100

            fmt.Printf("Temperature: %.1f°C\n", temp)
            fmt.Printf("Distance: %d meters\n", dist)

            // Cannot mix with underlying type without conversion
            // var f float64 = temp  // Error!
            var f float64 = float64(temp)  // OK
            fmt.Printf("As float64: %.1f\n", f)
        }
        ```

## Best Practices :notebook:

!!! success "Data Type Best Practices"
    1. **Choose Appropriate Types**
        - Use `int` for general integer operations
        - Use specific sizes (`int32`, `int64`) when needed
        - Prefer `float64` over `float32` for precision

    2. **Variable Naming**
        - Use descriptive names for clarity
        - Follow Go naming conventions
        - Use short names for limited scope

    3. **Constants Over Variables**
        - Use constants for values that don't change
        - Group related constants together
        - Use `iota` for enumerations

    4. **Type Safety**
        - Explicit type conversions prevent bugs
        - Be careful with numeric overflow
        - Validate conversions when necessary

!!! warning "Common Pitfalls"
    - **Integer Overflow**: Be aware of type limits
    - **Float Precision**: Floating-point arithmetic isn't exact
    - **Type Mixing**: Go doesn't allow implicit conversions
    - **String Immutability**: Strings can't be modified in place

## Quick Reference :bookmark_tabs:

!!! success "Key Takeaways"
    1. **Variables**: Multiple declaration methods (`:=` most common)
    2. **Types**: Rich set of numeric, string, and boolean types
    3. **Constants**: Immutable values with compile-time guarantees
    4. **Operations**: Type-safe arithmetic with explicit conversions
    5. **Best Practices**: Choose appropriate types and follow conventions

!!! quote "Remember"
    > "Go's type system is designed for clarity and safety. Embrace explicit conversions and descriptive naming for maintainable code."

