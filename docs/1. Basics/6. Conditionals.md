# Conditional Statements in Go: If-Else and Switch

This document provides a comprehensive guide to conditional statements in Go, focusing on `if-else` and `switch` statements. Understanding these control structures is essential for writing programs that can make decisions and execute different code paths based on certain conditions.

---

## Overview

Conditional statements allow a program to execute specific code blocks based on whether certain conditions are met. Go provides two primary conditional constructs:

1. `if-else` statements: For executing code based on boolean conditions
2. `switch` statements: For selecting between multiple code paths based on the value of an expression

Both constructs are fundamental to controlling the flow of execution in a Go program.

---

## If-Else Statements

### Basic If Statement

The simplest form of conditional statement is the `if` statement, which executes a block of code only if a specified condition is true.

#### Syntax

```go
if condition {
    // code to execute if condition is true
}
```

#### Example

```go
package main

import "fmt"

func main() {
    x := 10
    
    if x > 5 {
        fmt.Println("x is greater than 5")
    }
    
    // Output: x is greater than 5
}
```

### If-Else Statement

The `if-else` statement provides an alternative code block to execute when the condition is false.

#### Syntax

```go
if condition {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}
```

#### Example

```go
package main

import "fmt"

func main() {
    x := 3
    
    if x > 5 {
        fmt.Println("x is greater than 5")
    } else {
        fmt.Println("x is not greater than 5")
    }
    
    // Output: x is not greater than 5
}
```

### If-Else If-Else Statement

For multiple conditions, you can chain `if-else` statements using `else if`.

#### Syntax

```go
if condition1 {
    // code to execute if condition1 is true
} else if condition2 {
    // code to execute if condition2 is true
} else {
    // code to execute if all conditions are false
}
```

#### Example

```go
package main

import "fmt"

func main() {
    x := 7
    
    if x > 10 {
        fmt.Println("x is greater than 10")
    } else if x > 5 {
        fmt.Println("x is greater than 5 but not greater than 10")
    } else {
        fmt.Println("x is 5 or less")
    }
    
    // Output: x is greater than 5 but not greater than 10
}
```

### If with a Short Statement

In Go, you can include a short statement before the condition in an `if` statement. This statement is executed before the condition is evaluated.

#### Syntax

```go
if statement; condition {
    // code to execute if condition is true
}
```

#### Example

```go
package main

import "fmt"

func main() {
    // Using a short statement to declare and initialize a variable
    if x := 10; x > 5 {
        fmt.Println("x is greater than 5")
    }
    
    // x is not accessible outside the if block
    
    // Output: x is greater than 5
}
```

### If with Initialization and Else

You can also use the short statement with `if-else` constructs.

#### Example

```go
package main

import "fmt"

func main() {
    if x := 10; x > 5 {
        fmt.Println("x is greater than 5")
    } else {
        fmt.Println("x is 5 or less")
    }
    
    // Output: x is greater than 5
}
```

### Nested If Statements

You can nest `if` statements inside other `if` statements to create more complex conditional logic.

#### Example

```go
package main

import "fmt"

func main() {
    x := 10
    y := 20
    
    if x > 5 {
        fmt.Println("x is greater than 5")
        
        if y > 15 {
            fmt.Println("y is greater than 15")
        } else {
            fmt.Println("y is 15 or less")
        }
    } else {
        fmt.Println("x is 5 or less")
    }
    
    // Output:
    // x is greater than 5
    // y is greater than 15
}
```

---

## Switch Statements

The `switch` statement provides a more concise way to write multiple `if-else` statements when you're comparing a single value against multiple possibilities.

### Basic Switch Statement

#### Syntax

```go
switch expression {
case value1:
    // code to execute if expression == value1
case value2:
    // code to execute if expression == value2
default:
    // code to execute if expression doesn't match any case
}
```

#### Example

```go
package main

import "fmt"

func main() {
    day := "Tuesday"
    
    switch day {
    case "Monday":
        fmt.Println("It's Monday")
    case "Tuesday":
        fmt.Println("It's Tuesday")
    case "Wednesday":
        fmt.Println("It's Wednesday")
    default:
        fmt.Println("It's another day")
    }
    
    // Output: It's Tuesday
}
```

### Switch without an Expression

You can use a `switch` statement without an expression, which is equivalent to `switch true`. This is a cleaner way to write long `if-else-if` chains.

#### Example

```go
package main

import "fmt"

func main() {
    x := 42
    
    switch {
    case x < 0:
        fmt.Println("x is negative")
    case x == 0:
        fmt.Println("x is zero")
    case x > 0 && x < 50:
        fmt.Println("x is positive but less than 50")
    default:
        fmt.Println("x is 50 or greater")
    }
    
    // Output: x is positive but less than 50
}
```

### Multiple Cases in a Switch

You can test multiple values in a single case by separating them with commas.

#### Example

```go
package main

import "fmt"

func main() {
    day := "Friday"
    
    switch day {
    case "Monday", "Tuesday", "Wednesday", "Thursday", "Friday":
        fmt.Println("It's a weekday")
    case "Saturday", "Sunday":
        fmt.Println("It's a weekend")
    default:
        fmt.Println("Invalid day")
    }
    
    // Output: It's a weekday
}
```

### Fallthrough in Switch

By default, Go's `switch` statement doesn't "fall through" to the next case after executing a case. If you want this behavior, you can use the `fallthrough` keyword.

#### Example

```go
package main

import "fmt"

func main() {
    x := 1
    
    switch x {
    case 1:
        fmt.Println("x is 1")
        fallthrough
    case 2:
        fmt.Println("x is 1 or 2")
    case 3:
        fmt.Println("x is 3")
    default:
        fmt.Println("x is something else")
    }
    
    // Output:
    // x is 1
    // x is 1 or 2
}
```

### Switch with a Short Statement

Like `if` statements, `switch` statements can include a short statement before the expression.

#### Example

```go
package main

import "fmt"

func main() {
    // Using a short statement to declare and initialize a variable
    switch x := 2; x {
    case 1:
        fmt.Println("x is 1")
    case 2:
        fmt.Println("x is 2")
    default:
        fmt.Println("x is something else")
    }
    
    // x is not accessible outside the switch block
    
    // Output: x is 2
}
```

### Type Switch

Go supports a special form of `switch` called a type switch, which is used to determine the type of an interface value.

#### Example

```go
package main

import "fmt"

func main() {
    var i interface{} = "hello"
    
    switch v := i.(type) {
    case int:
        fmt.Printf("i is an int with value %d\n", v)
    case string:
        fmt.Printf("i is a string with value %q\n", v)
    case bool:
        fmt.Printf("i is a bool with value %t\n", v)
    default:
        fmt.Printf("i is of an unknown type %T\n", v)
    }
    
    // Output: i is a string with value "hello"
}
```

---

## Practical Examples

### Checking Even or Odd Numbers

```go
package main

import "fmt"

func main() {
    // Using if-else to check if a number is even or odd
    num := 7
    
    if num%2 == 0 {
        fmt.Printf("%d is even\n", num)
    } else {
        fmt.Printf("%d is odd\n", num)
    }
    
    // Output: 7 is odd
}
```

### Grading System

```go
package main

import "fmt"

func main() {
    // Using if-else-if for a grading system
    score := 85
    
    if score >= 90 {
        fmt.Println("Grade: A")
    } else if score >= 80 {
        fmt.Println("Grade: B")
    } else if score >= 70 {
        fmt.Println("Grade: C")
    } else if score >= 60 {
        fmt.Println("Grade: D")
    } else {
        fmt.Println("Grade: F")
    }
    
    // Output: Grade: B
}
```

### Using Switch for a Simple Calculator

```go
package main

import "fmt"

func main() {
    // Using switch for a simple calculator
    num1 := 10
    num2 := 5
    operator := "+"
    
    var result int
    
    switch operator {
    case "+":
        result = num1 + num2
    case "-":
        result = num1 - num2
    case "*":
        result = num1 * num2
    case "/":
        result = num1 / num2
    default:
        fmt.Println("Invalid operator")
        return
    }
    
    fmt.Printf("%d %s %d = %d\n", num1, operator, num2, result)
    
    // Output: 10 + 5 = 15
}
```

### Checking Leap Year

```go
package main

import "fmt"

func isLeapYear(year int) bool {
    if year%4 != 0 {
        return false
    } else if year%100 != 0 {
        return true
    } else if year%400 != 0 {
        return false
    } else {
        return true
    }
}

func main() {
    // Using nested if-else to check for a leap year
    year := 2020
    
    if isLeapYear(year) {
        fmt.Printf("%d is a leap year\n", year)
    } else {
        fmt.Printf("%d is not a leap year\n", year)
    }
    
    // Output: 2020 is a leap year
}
```

### Menu Selection with Switch

```go
package main

import "fmt"

func main() {
    // Using switch for menu selection
    choice := 2
    
    switch choice {
    case 1:
        fmt.Println("You selected option 1")
    case 2:
        fmt.Println("You selected option 2")
    case 3:
        fmt.Println("You selected option 3")
    default:
        fmt.Println("Invalid choice")
    }
    
    // Output: You selected option 2
}
```

### Complex Conditional Logic

```go
package main

import "fmt"

func canVote(age int, isCitizen bool, isRegistered bool) bool {
    if age >= 18 && isCitizen && isRegistered {
        return true
    }
    return false
}

func main() {
    // Using complex conditions with logical operators
    age := 25
    isCitizen := true
    isRegistered := true
    
    if canVote(age, isCitizen, isRegistered) {
        fmt.Println("You are eligible to vote")
    } else {
        fmt.Println("You are not eligible to vote")
    }
    
    // Output: You are eligible to vote
}
```

---

## Best Practices

1. **Keep conditions simple**:
   - Complex conditions can be hard to understand and maintain.
   - Consider breaking complex conditions into simpler ones or using helper functions.

2. **Use `switch` for multiple comparisons of the same value**:
   - `switch` statements are often more readable than long `if-else-if` chains.

3. **Use `if` for boolean conditions**:
   - If you're checking boolean conditions rather than comparing values, `if` statements are usually more appropriate.

4. **Include a `default` case in `switch` statements**:
   - This ensures that all possible values are handled, even unexpected ones.

5. **Use `fallthrough` sparingly**:
   - The `fallthrough` behavior is different from many other languages and can be surprising if not used carefully.

6. **Use descriptive variable names in conditions**:
   - This makes your code more readable and self-documenting.

7. **Avoid deeply nested conditionals**:
   - Deeply nested `if` statements can be hard to follow.
   - Consider refactoring nested conditionals into separate functions or using early returns.

8. **Use the short statement form when appropriate**:
   - The short statement form can make your code more concise, especially when dealing with error handling.

---

## Conclusion

Conditional statements are fundamental to controlling the flow of execution in Go programs:

1. `if-else` statements are used to execute code based on boolean conditions.
   - They can be chained with `else if` for multiple conditions.
   - They can include a short statement before the condition.
   - They can be nested for more complex logic.

2. `switch` statements provide a concise way to compare a value against multiple possibilities.
   - They can be used with or without an expression.
   - They can handle multiple cases with a single block of code.
   - They can include a short statement before the expression.
   - They support type switches for determining the type of interface values.

Understanding when and how to use these conditional constructs will help you write more efficient, readable, and maintainable Go code. As you continue to learn Go, you'll find that these control structures are used extensively in Go programs, from simple scripts to complex applications.