# Go Control Flow: Defer, Panic, and Recover

Go has a few unique control flow mechanisms for handling cleanup and unexpected errors.

### 1. Defer

**`defer`** schedules a function call to be run immediately before the surrounding function returns. It is most commonly used for **cleanup** (like closing a file or a database connection).

```go
package main
import "fmt"
import "os"

func main() {
    f := createFile("/tmp/defer.txt")
    defer closeFile(f) // This runs AT THE END of main()
    writeFile(f)
}

func createFile(p string) *os.File {
    fmt.Println("creating")
    f, err := os.Create(p)
    if err != nil {
        panic(err)
    }
    return f
}

func writeFile(f *os.File) {
    fmt.Println("writing")
    fmt.Fprintln(f, "data")
}

func closeFile(f *os.File) {
    fmt.Println("closing")
    f.Close()
}
```

### 2. Panic

A **`panic`** typically means something went unexpectedly wrong. We mostly use it to fail fast on errors that shouldn't happen during normal operation.

```go
panic("a problem occurred")
```

When a function panics, its execution stops, and any **deferred** functions are executed.

### 3. Recover

**`recover`** is a built-in function that regains control of a panicking goroutine. `recover` is only useful inside **deferred** functions.

```go
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()

    panic("CRITICAL ERROR")
    fmt.Println("This will never run")
}
```

### Summary Table

| Keyword | Purpose |
| :--- | :--- |
| **`defer`** | Delay execution until the function returns. Used for cleanup. |
| **`panic`** | Stop normal execution immediately. Used for unrecoverable errors. |
| **`recover`** | Catch a panic and stop the program from crashing. |
