# Go Control Flow: Defer, Panic, Recover, and Exit

!!! abstract "Overview"
    Master Go's advanced control flow mechanisms for robust error handling and resource management. This comprehensive guide covers defer statements, panic/recover patterns, and program termination, building upon our understanding of functions and error handling.

!!! tip "Key Points"
    - Defer ensures cleanup code execution
    - Panic/recover provides exception-like error handling
    - Exit terminates programs with status codes
    - Essential for resource management and error recovery
    - Critical for writing robust Go applications

## Understanding Control Flow in Go :traffic_light:

Go provides several mechanisms for controlling program execution flow beyond basic conditionals and loops. These advanced features enable elegant resource management and error handling patterns.

!!! info "Control Flow Mechanisms"
    ```mermaid
    graph TD
        A[Control Flow] --> B[defer]
        A --> C[panic]
        A --> D[recover]
        A --> E[exit]
        B --> F[Resource Cleanup]
        B --> G[LIFO Execution]
        C --> H[Error Propagation]
        C --> I[Stack Unwinding]
        D --> J[Error Recovery]
        D --> K[Graceful Handling]
        E --> L[Program Termination]
        E --> M[Status Codes]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
        style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px
        style C fill:#ffebee,stroke:#c62828,stroke-width:2px
        style D fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
        style E fill:#fff3e0,stroke:#e65100,stroke-width:2px
    ```

## Defer: Guaranteed Cleanup :broom:

The `defer` statement schedules function calls to execute when the surrounding function returns, ensuring cleanup code runs regardless of how the function exits.

### Basic Defer Patterns

!!! example "Defer Fundamentals"

    === "Basic Defer Usage"
        ```go title="basic_defer.go" linenums="1" hl_lines="8-12"
        package main

        import "fmt"

        func demonstrateDefer() {
            fmt.Println("Start of function")
            
            // Defer statements execute in LIFO order
            defer fmt.Println("First defer")
            defer fmt.Println("Second defer")
            defer fmt.Println("Third defer")
            
            fmt.Println("End of function")
        }

        func main() {
            demonstrateDefer()
            
            // Output:
            // Start of function
            // End of function
            // Third defer
            // Second defer
            // First defer
        }
        ```

    === "Resource Management"
        ```go title="resource_cleanup.go" linenums="1" hl_lines="8-15"
        package main

        import (
            "fmt"
            "os"
        )

        func processFile(filename string) error {
            file, err := os.Open(filename)
            if err != nil {
                return err
            }
            defer file.Close()  // Guaranteed cleanup
            
            // Process file content
            fmt.Printf("Processing file: %s\n", filename)
            
            // File will be closed even if an error occurs
            return nil
        }

        func main() {
            err := processFile("example.txt")
            if err != nil {
                fmt.Printf("Error: %v\n", err)
            }
        }
        ```

    === "Multiple Defers"
        ```go title="multiple_defers.go" linenums="1" hl_lines="8-18"
        package main

        import "fmt"

        func complexOperation() {
            fmt.Println("Starting complex operation")
            
            // Setup resources
            defer fmt.Println("Cleanup: Database connection")
            defer fmt.Println("Cleanup: Network connection")
            defer fmt.Println("Cleanup: File handles")
            
            // Simulate work
            fmt.Println("Performing work...")
            
            // All defers execute in reverse order
            fmt.Println("Work completed")
        }

        func main() {
            complexOperation()
            
            // Output:
            // Starting complex operation
            // Performing work...
            // Work completed
            // Cleanup: File handles
            // Cleanup: Network connection
            // Cleanup: Database connection
        }
        ```

### Advanced Defer Techniques

!!! example "Advanced Defer Patterns"

    === "Defer with Variables"
        ```go title="defer_variables.go" linenums="1" hl_lines="8-15"
        package main

        import "fmt"

        func deferWithVariables() {
            x := 10
            
            // Arguments evaluated immediately
            defer fmt.Printf("Deferred: x = %d\n", x)
            
            x = 20
            fmt.Printf("Current: x = %d\n", x)
            
            // x in defer is still 10 (captured at defer time)
        }

        func deferWithClosure() {
            x := 10
            
            // Closure captures variable by reference
            defer func() {
                fmt.Printf("Closure: x = %d\n", x)
            }()
            
            x = 20
            fmt.Printf("Current: x = %d\n", x)
            
            // x in closure is 20 (current value)
        }

        func main() {
            fmt.Println("=== Defer with Variables ===")
            deferWithVariables()
            
            fmt.Println("\n=== Defer with Closure ===")
            deferWithClosure()
        }
        ```

    === "Defer for Timing"
        ```go title="defer_timing.go" linenums="1" hl_lines="8-15"
        package main

        import (
            "fmt"
            "time"
        )

        func timeFunction(name string) func() {
            start := time.Now()
            return func() {
                fmt.Printf("%s took %v\n", name, time.Since(start))
            }
        }

        func expensiveOperation() {
            defer timeFunction("expensiveOperation")()
            
            // Simulate work
            time.Sleep(100 * time.Millisecond)
            fmt.Println("Operation completed")
        }

        func main() {
            expensiveOperation()
            
            // Output:
            // Operation completed
            // expensiveOperation took ~100ms
        }
        ```

## Panic: Exception-Like Error Handling :warning:

Panic stops normal execution and begins unwinding the stack, executing deferred functions along the way.

### Panic Patterns

!!! example "Panic Mechanisms"

    === "Basic Panic"
        ```go title="basic_panic.go" linenums="1" hl_lines="8-15"
        package main

        import "fmt"

        func riskyFunction(value int) {
            defer fmt.Println("Cleanup in riskyFunction")
            
            if value < 0 {
                panic("negative value not allowed")
            }
            
            fmt.Printf("Processing value: %d\n", value)
        }

        func main() {
            defer fmt.Println("Main function cleanup")
            
            fmt.Println("Starting program")
            riskyFunction(5)   // Works fine
            riskyFunction(-1)  // Causes panic
            
            fmt.Println("This won't be reached")
        }
        ```

    === "Panic with Custom Types"
        ```go title="custom_panic.go" linenums="1" hl_lines="8-18"
        package main

        import "fmt"

        type ValidationError struct {
            Field   string
            Message string
        }

        func (e ValidationError) Error() string {
            return fmt.Sprintf("validation error in %s: %s", e.Field, e.Message)
        }

        func validateAge(age int) {
            if age < 0 {
                panic(ValidationError{
                    Field:   "age",
                    Message: "cannot be negative",
                })
            }
            if age > 150 {
                panic(ValidationError{
                    Field:   "age", 
                    Message: "unrealistic value",
                })
            }
        }

        func main() {
            defer func() {
                if r := recover(); r != nil {
                    fmt.Printf("Caught panic: %v\n", r)
                }
            }()
            
            validateAge(-5)  // Will panic
        }
        ```

## Recover: Graceful Error Recovery :shield:

Recover regains control of a panicking goroutine, allowing graceful error handling and program continuation.

### Recover Patterns

!!! example "Recovery Mechanisms"

    === "Basic Recovery"
        ```go title="basic_recover.go" linenums="1" hl_lines="8-18"
        package main

        import "fmt"

        func safeDivide(a, b float64) (result float64, err error) {
            defer func() {
                if r := recover(); r != nil {
                    err = fmt.Errorf("division error: %v", r)
                }
            }()

            if b == 0 {
                panic("division by zero")
            }

            result = a / b
            return
        }

        func main() {
            // Safe division that handles panic
            result, err := safeDivide(10, 2)
            if err != nil {
                fmt.Printf("Error: %v\n", err)
            } else {
                fmt.Printf("Result: %.2f\n", result)
            }

            // Division by zero - recovered
            result, err = safeDivide(10, 0)
            if err != nil {
                fmt.Printf("Error: %v\n", err)
            } else {
                fmt.Printf("Result: %.2f\n", result)
            }
        }
        ```

    === "Server Error Recovery"
        ```go title="server_recovery.go" linenums="1" hl_lines="8-20"
        package main

        import (
            "fmt"
            "log"
        )

        func handleRequest(requestID int) {
            defer func() {
                if r := recover(); r != nil {
                    log.Printf("Request %d panicked: %v", requestID, r)
                    // Log error, send error response, etc.
                }
            }()

            // Simulate request processing
            if requestID == 13 {
                panic("unlucky request number")
            }

            fmt.Printf("Successfully processed request %d\n", requestID)
        }

        func main() {
            // Process multiple requests
            for i := 10; i <= 15; i++ {
                handleRequest(i)
            }

            fmt.Println("Server continues running...")
        }
        ```

    === "Typed Recovery"
        ```go title="typed_recovery.go" linenums="1" hl_lines="15-25"
        package main

        import "fmt"

        type NetworkError struct {
            Code    int
            Message string
        }

        func (e NetworkError) Error() string {
            return fmt.Sprintf("network error %d: %s", e.Code, e.Message)
        }

        func networkOperation() error {
            defer func() {
                if r := recover(); r != nil {
                    // Type assertion on recovered value
                    if netErr, ok := r.(NetworkError); ok {
                        fmt.Printf("Recovered network error: %v\n", netErr)
                    } else {
                        fmt.Printf("Recovered unknown error: %v\n", r)
                        panic(r) // Re-panic if not our error type
                    }
                }
            }()

            // Simulate network error
            panic(NetworkError{Code: 500, Message: "connection timeout"})
        }

        func main() {
            err := networkOperation()
            if err != nil {
                fmt.Printf("Function returned error: %v\n", err)
            }
        }
        ```

## Exit: Program Termination :stop_sign:

The `os.Exit` function terminates the program immediately with a specified exit code.

### Exit Patterns

!!! example "Program Termination"

    === "Basic Exit"
        ```go title="basic_exit.go" linenums="1" hl_lines="8-15"
        package main

        import (
            "fmt"
            "os"
        )

        func main() {
            fmt.Println("Starting program")

            // Check some condition
            if len(os.Args) < 2 {
                fmt.Println("Error: Missing required argument")
                os.Exit(1)  // Exit with error code
            }

            fmt.Printf("Processing argument: %s\n", os.Args[1])
            fmt.Println("Program completed successfully")
            os.Exit(0)  // Exit with success code
        }
        ```

    === "Graceful Shutdown"
        ```go title="graceful_shutdown.go" linenums="1" hl_lines="8-20"
        package main

        import (
            "fmt"
            "os"
            "os/signal"
            "syscall"
        )

        func cleanup() {
            fmt.Println("Performing cleanup...")
            // Close files, connections, etc.
        }

        func main() {
            // Setup signal handling for graceful shutdown
            c := make(chan os.Signal, 1)
            signal.Notify(c, os.Interrupt, syscall.SIGTERM)

            go func() {
                <-c
                fmt.Println("\nReceived shutdown signal")
                cleanup()
                os.Exit(0)
            }()

            fmt.Println("Program running... Press Ctrl+C to exit")

            // Simulate work
            select {} // Block forever
        }
        ```

## Best Practices and Performance :notebook:

!!! success "Control Flow Best Practices"
    1. **Defer for Resource Management**
        ```go
        // Good: Always defer cleanup
        func processFile(filename string) error {
            file, err := os.Open(filename)
            if err != nil {
                return err
            }
            defer file.Close()  // Guaranteed cleanup

            // Process file...
            return nil
        }
        ```

    2. **Recover Only When Necessary**
        ```go
        // Good: Specific recovery for known panics
        defer func() {
            if r := recover(); r != nil {
                if err, ok := r.(MyError); ok {
                    // Handle specific error
                } else {
                    panic(r) // Re-panic unknown errors
                }
            }
        }()
        ```

    3. **Use Exit Codes Appropriately**
        ```go
        // Standard exit codes
        const (
            ExitSuccess = 0
            ExitError   = 1
            ExitUsage   = 2
        )

        if invalidInput {
            fmt.Fprintf(os.Stderr, "Invalid input\n")
            os.Exit(ExitUsage)
        }
        ```

!!! warning "Common Pitfalls"
    - **Defer in Loops**: Be careful with defer in loops (memory accumulation)
    - **Panic for Control Flow**: Don't use panic for normal error handling
    - **Ignoring Recovery**: Always check if recovery is needed
    - **Exit vs Return**: Use os.Exit sparingly, prefer returning errors

## Quick Reference :bookmark_tabs:

!!! success "Key Takeaways"
    1. **Defer**: Use for cleanup, executes in LIFO order
    2. **Panic**: For unrecoverable errors, unwinds stack
    3. **Recover**: Catch panics in deferred functions only
    4. **Exit**: Immediate termination with status codes
    5. **Resource Management**: Always defer cleanup operations
    6. **Error Handling**: Prefer errors over panic for expected failures

!!! quote "Remember"
    > "Control flow mechanisms are powerful tools for robust Go programs. Use defer for guaranteed cleanup, panic/recover for exceptional situations, and exit for program termination. Always prefer explicit error handling over panic for expected error conditions!"
