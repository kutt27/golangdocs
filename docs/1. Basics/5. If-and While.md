# Loops in Go: For Loop (with break/continue) and For Loop as While

This document provides a comprehensive guide to the `for` loop in Go, including its use with `break` and `continue` statements, and how it can be used as a `while` loop. Understanding loops is essential for writing efficient and concise code in Go.

---

## Overview

Go has only one loop construct: the `for` loop. Despite this single construct, the `for` loop is versatile and can be used in several ways:

1. The classic three-component `for` loop
2. The `for` loop with `range` (for iterating over data structures)
3. The `for` loop as a `while` loop
4. The infinite `for` loop

We'll explore each of these patterns, with special attention to the `break` and `continue` statements and the use of `for` as a `while` loop.

---

## The Classic For Loop

The classic `for` loop in Go is similar to the `for` loop in C, Java, and other languages. It consists of three components separated by semicolons:

1. The init statement: executed before the first iteration
2. The condition expression: evaluated before each iteration
3. The post statement: executed at the end of each iteration

### Syntax

```go
for init; condition; post {
    // loop body
}
```

### Example

```go
package main

import "fmt"

func main() {
    // Classic for loop
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }
    
    // Output:
    // 0
    // 1
    // 2
    // 3
    // 4
}
```

### Explanation

1. `i := 0` is the init statement, which initializes the counter variable `i` to 0.
2. `i < 5` is the condition expression, which is checked before each iteration. If it evaluates to `true`, the loop body is executed.
3. `i++` is the post statement, which increments `i` after each iteration.

---

## Break and Continue Statements

### The Break Statement

The `break` statement terminates the innermost `for`, `switch`, or `select` statement. It's used to exit a loop before it would normally terminate.

#### Example with Break

```go
package main

import "fmt"

func main() {
    // Using break to exit a loop
    for i := 0; i < 10; i++ {
        if i == 5 {
            break // Exit the loop when i equals 5
        }
        fmt.Println(i)
    }
    
    // Output:
    // 0
    // 1
    // 2
    // 3
    // 4
}
```

#### Breaking Out of Nested Loops

In Go, the `break` statement only breaks out of the innermost loop. To break out of nested loops, you can use labels.

```go
package main

import "fmt"

func main() {
    // Using labels to break out of nested loops
    outerLoop:
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            if i == 1 && j == 1 {
                break outerLoop // Break out of both loops
            }
            fmt.Printf("i: %d, j: %d\n", i, j)
        }
    }
    
    // Output:
    // i: 0, j: 0
    // i: 0, j: 1
    // i: 0, j: 2
    // i: 1, j: 0
}
```

### The Continue Statement

The `continue` statement skips the rest of the current iteration of the innermost `for` loop and moves to the next iteration.

#### Example with Continue

```go
package main

import "fmt"

func main() {
    // Using continue to skip iterations
    for i := 0; i < 10; i++ {
        if i%2 == 0 {
            continue // Skip even numbers
        }
        fmt.Println(i)
    }
    
    // Output:
    // 1
    // 3
    // 5
    // 7
    // 9
}
```

#### Continue with Labels

Like `break`, `continue` can also be used with labels to continue the outer loop from within a nested loop.

```go
package main

import "fmt"

func main() {
    // Using labels with continue
    outerLoop:
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            if i == 1 && j == 1 {
                continue outerLoop // Continue the outer loop
            }
            fmt.Printf("i: %d, j: %d\n", i, j)
        }
    }
    
    // Output:
    // i: 0, j: 0
    // i: 0, j: 1
    // i: 0, j: 2
    // i: 1, j: 0
    // i: 2, j: 0
    // i: 2, j: 1
    // i: 2, j: 2
}
```

---

## The For Loop as a While Loop

Go doesn't have a separate `while` loop construct. Instead, you can use a `for` loop with only a condition expression to achieve the same behavior as a `while` loop.

### Syntax

```go
for condition {
    // loop body
}
```

### Example

```go
package main

import "fmt"

func main() {
    // Using for as a while loop
    n := 1
    for n < 5 {
        fmt.Println(n)
        n++
    }
    
    // Output:
    // 1
    // 2
    // 3
    // 4
}
```

### Explanation

In this example, the `for` loop has only a condition expression `n < 5`. The loop continues to execute as long as this condition is `true`. The variable `n` is incremented inside the loop body, similar to how you would use a `while` loop in other languages.

### More Complex Example

```go
package main

import "fmt"

func main() {
    // Using for as a while loop with multiple conditions
    sum := 0
    i := 1
    
    for sum < 100 && i < 20 {
        sum += i
        fmt.Printf("i: %d, sum: %d\n", i, sum)
        i++
    }
    
    fmt.Printf("Final sum: %d\n", sum)
}
```

---

## The Infinite For Loop

An infinite `for` loop can be created by omitting all three components. This is useful for loops that should run until explicitly terminated with a `break` statement or a `return` statement.

### Syntax

```go
for {
    // loop body
}
```

### Example with Break

```go
package main

import "fmt"

func main() {
    // Infinite for loop with break
    count := 0
    for {
        fmt.Println("Loop iteration")
        count++
        
        if count >= 3 {
            break // Exit the infinite loop
        }
    }
    
    fmt.Println("Loop terminated")
}
```

### Example with Return

```go
package main

import "fmt"

func main() {
    // Infinite for loop with return
    count := 0
    for {
        fmt.Println("Loop iteration")
        count++
        
        if count >= 3 {
            fmt.Println("Returning from main")
            return // Exit the function and the program
        }
    }
    
    // This line will never be reached
    fmt.Println("This won't be printed")
}
```

---

## For Loop with Range

The `for` loop with `range` is used to iterate over elements of various data structures, such as slices, arrays, strings, maps, and channels.

### Syntax

```go
for index, value := range collection {
    // loop body
}
```

### Example with Slice

```go
package main

import "fmt"

func main() {
    // Using for with range on a slice
    fruits := []string{"apple", "banana", "orange"}
    
    for index, value := range fruits {
        fmt.Printf("Index: %d, Value: %s\n", index, value)
    }
    
    // Output:
    // Index: 0, Value: apple
    // Index: 1, Value: banana
    // Index: 2, Value: orange
}
```

### Example with Map

```go
package main

import "fmt"

func main() {
    // Using for with range on a map
    ages := map[string]int{
        "Alice":  25,
        "Bob":    30,
        "Charlie": 35,
    }
    
    for key, value := range ages {
        fmt.Printf("Key: %s, Value: %d\n", key, value)
    }
    
    // Output (order may vary):
    // Key: Alice, Value: 25
    // Key: Bob, Value: 30
    // Key: Charlie, Value: 35
}
```

### Example with String

```go
package main

import "fmt"

func main() {
    // Using for with range on a string
    str := "hello"
    
    for index, runeValue := range str {
        fmt.Printf("Index: %d, Rune: %c, Unicode: %U\n", index, runeValue, runeValue)
    }
    
    // Output:
    // Index: 0, Rune: h, Unicode: U+0068
    // Index: 1, Rune: e, Unicode: U+0065
    // Index: 2, Rune: l, Unicode: U+006C
    // Index: 3, Rune: l, Unicode: U+006C
    // Index: 4, Rune: o, Unicode: U+006F
}
```

### Ignoring Index or Value

If you only need the index or the value, you can use the blank identifier `_` to ignore the other component.

```go
package main

import "fmt"

func main() {
    // Ignoring the value
    fruits := []string{"apple", "banana", "orange"}
    
    for index, _ := range fruits {
        fmt.Printf("Index: %d\n", index)
    }
    
    // Ignoring the index
    for _, value := range fruits {
        fmt.Printf("Value: %s\n", value)
    }
}
```

---

## Practical Examples

### Summing Numbers with a For Loop

```go
package main

import "fmt"

func main() {
    // Summing numbers from 1 to 10
    sum := 0
    for i := 1; i <= 10; i++ {
        sum += i
    }
    fmt.Printf("Sum of numbers from 1 to 10: %d\n", sum)
}
```

### Finding Prime Numbers

```go
package main

import "fmt"

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            return false
        }
    }
    
    return true
}

func main() {
    // Finding prime numbers up to 20
    fmt.Println("Prime numbers up to 20:")
    for i := 1; i <= 20; i++ {
        if isPrime(i) {
            fmt.Println(i)
        }
    }
}
```

### Using For as a While Loop for User Input

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strings"
)

func main() {
    // Using for as a while loop to read user input
    scanner := bufio.NewScanner(os.Stdin)
    
    fmt.Println("Enter text (type 'exit' to quit):")
    for scanner.Scan() {
        input := scanner.Text()
        
        if strings.ToLower(input) == "exit" {
            break
        }
        
        fmt.Printf("You entered: %s\n", input)
        fmt.Println("Enter more text (or 'exit' to quit):")
    }
    
    if err := scanner.Err(); err != nil {
        fmt.Println("Error reading input:", err)
    }
    
    fmt.Println("Program ended")
}
```

### Processing a Slice with Break and Continue

```go
package main

import "fmt"

func main() {
    // Processing a slice with break and continue
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    target := 7
    found := false
    
    for _, num := range numbers {
        if num%2 == 0 {
            continue // Skip even numbers
        }
        
        fmt.Printf("Checking odd number: %d\n", num)
        
        if num == target {
            found = true
            break // Exit the loop when target is found
        }
    }
    
    if found {
        fmt.Printf("Found target %d\n", target)
    } else {
        fmt.Printf("Target %d not found\n", target)
    }
}
```

---

## Best Practices

1. **Use the simplest form of the loop that fits your needs**:
   - Use the classic `for` loop when you need to iterate a specific number of times.
   - Use `for` with `range` when you need to iterate over elements of a collection.
   - Use `for` as a `while` loop when you need to loop until a condition is met.
   - Use the infinite `for` loop with `break` when you need to loop until an event occurs.

2. **Avoid infinite loops without a termination condition**:
   - Always ensure that your infinite loops have a way to exit, either with `break` or `return`.

3. **Use meaningful variable names**:
   - Use descriptive names for loop variables, especially in nested loops.

4. **Limit the use of `break` and `continue`**:
   - While `break` and `continue` are useful, overusing them can make your code harder to understand.
   - Consider refactoring complex loops with multiple `break` and `continue` statements into separate functions.

5. **Prefer `for` with `range` for iterating over collections**:
   - It's more idiomatic in Go and less error-prone than using index-based loops.

6. **Be careful with modifying the collection you're iterating over**:
   - Modifying a collection while iterating over it can lead to unexpected behavior.

---

## Conclusion

In Go, the `for` loop is a versatile construct that can be used in several ways:

1. The classic three-component `for` loop for iterating a specific number of times.
2. The `for` loop with `range` for iterating over elements of a collection.
3. The `for` loop as a `while` loop for looping until a condition is met.
4. The infinite `for` loop for looping until an event occurs.

The `break` and `continue` statements provide additional control over loop execution, allowing you to exit loops early or skip iterations. Understanding these loop constructs and control statements is essential for writing efficient and readable Go code.

As you continue to learn Go, you'll find that these loop patterns are used extensively in Go programs, from simple scripts to complex applications. Mastering them will make you a more effective Go developer.