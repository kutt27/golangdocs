

{
# Stateful Goroutines in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master stateful goroutines in Go to build concurrent systems that maintain state without locks. Learn how to encapsulate state within goroutines and communicate via channels, following the "Do not communicate by sharing memory; instead, share memory by communicating" philosophy. Understand the actor model, common patterns, and best practices for building robust, concurrent state management in Go.

!!! tip "Key Points"
    - **Stateful Goroutines**: Goroutines that encapsulate and manage state, communicating via channels rather than shared memory
    - **Actor Model**: Each stateful goroutine acts as an independent actor with its own state and message queue
    - **Channel Communication**: Use channels for all state operations, ensuring thread-safe access without locks
    - **Common Patterns**: Counter, bank account, chat room, and worker pool with state
    - **Benefits**: Eliminates race conditions, simplifies concurrency, and provides clear state boundaries
    - **Pitfalls**: Deadlocks, goroutine leaks, and complex error handling require careful design
    - **Best Practices**: Always handle shutdown gracefully, use buffered channels appropriately, and test thoroughly
    - **Performance**: Stateful goroutines can be more efficient than mutex-based solutions for high-contention scenarios

## Understanding Stateful Goroutines

Stateful goroutines are a powerful concurrency pattern in Go where each goroutine maintains its own private state and communicates with other goroutines exclusively through channels. This approach follows Go's core philosophy of communication over shared memory, providing a clean way to manage state in concurrent systems.

!!! info "Stateful Goroutine Architecture"
    ```mermaid
    graph TB
        A[Client Goroutines] -->|Messages| B[Stateful Goroutine]
        B --> C[Private State]
        B --> D[Message Queue]
        D --> E[Process Messages]
        E --> F[Update State]
        E --> G[Send Response]
        style A fill:#ccf,stroke:#333,stroke-width:2px,color:#000
        style B fill:#f9f,stroke:#333,stroke-width:2px,color:#000
        style C fill:#9cf,stroke:#333,stroke-width:2px,color:#000
    ```

### Core Principles

1. **Encapsulation**: State is private to the goroutine and never shared directly
2. **Message Passing**: All state modifications happen through channel messages
3. **Sequential Processing**: Messages are processed one at a time, ensuring consistency
4. **Isolation**: Each stateful goroutine operates independently, reducing contention

## Basic Stateful Goroutine Pattern

!!! example "Simple Counter with Stateful Goroutine"
    ```go title="counter.go" linums="1" hl_lines="8-60"
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    // Command represents an operation on the counter
    type Command struct {
        Op    string // "increment", "decrement", "get", "quit"
        Value int    // For increment/decrement
        Resp  chan int // Channel for response
    }

    // counterGoroutine manages the counter state
    func counterGoroutine(commands <-chan Command) {
        counter := 0 // Private state
        
        for cmd := range commands {
            switch cmd.Op {
            case "increment":
                counter += cmd.Value
                if cmd.Resp != nil {
                    cmd.Resp <- counter
                }
            case "decrement":
                counter -= cmd.Value
                if cmd.Resp != nil {
                    cmd.Resp <- counter
                }
            case "get":
                if cmd.Resp != nil {
                    cmd.Resp <- counter
                }
            case "quit":
                return
            }
        }
    }

    func main() {
        commands := make(chan Command, 10)
        
        // Start the counter goroutine
        go counterGoroutine(commands)
        
        var wg sync.WaitGroup
        
        // Start multiple goroutines to interact with the counter
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(id int) {
                defer wg.Done()
                
                for j := 0; j < 3; j++ {
                    resp := make(chan int, 1)
                    commands <- Command{Op: "increment", Value: 1, Resp: resp}
                    value := <-resp
                    fmt.Printf("Worker %d: Counter = %d\n", id, value)
                    time.Sleep(time.Millisecond * 100)
                }
            }(i)
        }
        
        wg.Wait()
        
        // Get final value
        resp := make(chan int, 1)
        commands <- Command{Op: "get", Resp: resp}
        fmt.Printf("Final counter value: %d\n", <-resp)
        
        // Shutdown the goroutine
        commands <- Command{Op: "quit"}
        close(commands)
    }
    ```

## Actor Model Implementation

The actor model is a conceptual model where concurrent computation is performed by actors, which are stateful goroutines that respond to messages.

!!! example "Actor Model Example"
    ```go title="actor_model.go" linums="1" hl_lines="8-100"
    package main

    import (
        "fmt"
        "math/rand"
        "time"
    )

    // Message represents a message sent to an actor
    type Message interface {
        Sender() *Actor
        Content() interface{}
    }

    // BaseMessage implements the Message interface
    type BaseMessage struct {
        sender  *Actor
        content interface{}
    }

    func (m BaseMessage) Sender() *Actor    { return m.sender }
    func (m BaseMessage) Content() interface{} { return m.content }

    // Actor represents a stateful goroutine
    type Actor struct {
        inbox    chan Message
        handlers map[string]func(Message)
        state    interface{}
    }

    // NewActor creates a new actor
    func NewActor(initialState interface{}) *Actor {
        return &Actor{
            inbox:    make(chan Message, 100),
            handlers: make(map[string]func(Message)),
            state:    initialState,
        }
    }

    // RegisterHandler registers a message handler
    func (a *Actor) RegisterHandler(msgType string, handler func(Message)) {
        a.handlers[msgType] = handler
    }

    // Send sends a message to the actor
    func (a *Actor) Send(msg Message) {
        a.inbox <- msg
    }

    // Start starts the actor's message processing loop
    func (a *Actor) Start() {
        go func() {
            for msg := range a.inbox {
                if handler, exists := a.handlers[msg.Content().(string)]; exists {
                    handler(msg)
                }
            }
        }()
    }

    // Stop stops the actor
    func (a *Actor) Stop() {
        close(a.inbox)
    }

    // BankAccount represents a bank account actor
    type BankAccount struct {
        balance float64
        owner   string
    }

    // BankAccountMessage represents a bank account operation
    type BankAccountMessage struct {
        Operation string
        Amount    float64
        Sender    *Actor
    }

    func main() {
        // Create a bank account actor
        account := NewActor(&BankAccount{
            balance: 1000.0,
            owner:   "Alice",
        })
        
        // Register handlers
        account.RegisterHandler("deposit", func(msg Message) {
            content := msg.Content().(BankAccountMessage)
            state := account.state.(*BankAccount)
            state.balance += content.Amount
            fmt.Printf("Deposited %.2f, new balance: %.2f\n", content.Amount, state.balance)
        })
        
        account.RegisterHandler("withdraw", func(msg Message) {
            content := msg.Content().(BankAccountMessage)
            state := account.state.(*BankAccount)
            if state.balance >= content.Amount {
                state.balance -= content.Amount
                fmt.Printf("Withdrew %.2f, new balance: %.2f\n", content.Amount, state.balance)
            } else {
                fmt.Printf("Insufficient funds for withdrawal of %.2f\n", content.Amount)
            }
        })
        
        account.RegisterHandler("balance", func(msg Message) {
            state := account.state.(*BankAccount)
            fmt.Printf("Current balance: %.2f\n", state.balance)
        })
        
        // Start the actor
        account.Start()
        
        // Simulate transactions
        transactions := []BankAccountMessage{
            {"deposit", 500.0, nil},
            {"withdraw", 200.0, nil},
            {"withdraw", 1500.0, nil}, // Should fail
            {"balance", 0, nil},
            {"deposit", 300.0, nil},
            {"balance", 0, nil},
        }
        
        for _, tx := range transactions {
            account.Send(BaseMessage{
                sender:  nil,
                content: tx,
            })
            time.Sleep(time.Millisecond * 100)
        }
        
        // Stop the actor
        time.Sleep(time.Second)
        account.Stop()
    }
    ```

## Common Patterns

### 1. Worker Pool with Shared State

!!! example "Worker Pool with Shared State"
    ```go title="worker_pool_state.go" linums="1" hl_lines="8-90"
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    // Task represents a unit of work
    type Task struct {
        ID   int
        Data string
    }

    // Result represents the result of a task
    type Result struct {
        TaskID int
        Output string
        Error  error
    }

    // WorkerPoolCommand represents a command to the worker pool
    type WorkerPoolCommand struct {
        Op      string // "add", "remove", "status", "quit"
        Task    Task
        WorkerID int
        Resp    chan interface{}
    }

    // WorkerPool manages a pool of workers with shared state
    func WorkerPool(commands <-chan WorkerPoolCommand) {
        workers := make(map[int]chan Task)
        results := make(chan Result, 100)
        nextID := 1
        
        for cmd := range commands {
            switch cmd.Op {
            case "add":
                workerID := nextID
                nextID++
                
                // Create worker channels
                taskCh := make(chan Task, 10)
                workers[workerID] = taskCh
                
                // Start worker goroutine
                go func(id int, tasks <-chan Task) {
                    for task := range tasks {
                        // Simulate work
                        time.Sleep(time.Duration(task.ID%3+1) * 100 * time.Millisecond)
                        
                        // Simulate occasional errors
                        var err error
                        if task.ID%7 == 0 {
                            err = fmt.Errorf("worker %d failed on task %d", id, task.ID)
                        }
                        
                        results <- Result{
                            TaskID: task.ID,
                            Output: fmt.Sprintf("Worker %d processed: %s", id, task.Data),
                            Error:  err,
                        }
                    }
                }(workerID, taskCh)
                
                if cmd.Resp != nil {
                    cmd.Resp <- workerID
                }
                
            case "remove":
                if taskCh, exists := workers[cmd.WorkerID]; exists {
                    close(taskCh)
                    delete(workers, cmd.WorkerID)
                    if cmd.Resp != nil {
                        cmd.Resp <- nil
                    }
                } else if cmd.Resp != nil {
                    cmd.Resp <- fmt.Errorf("worker not found")
                }
                
            case "status":
                status := struct {
                    WorkerCount int
                    ActiveTasks int
                }{
                    WorkerCount: len(workers),
                    ActiveTasks: len(results),
                }
                if cmd.Resp != nil {
                    cmd.Resp <- status
                }
                
            case "quit":
                // Close all worker channels
                for id, taskCh := range workers {
                    close(taskCh)
                    fmt.Printf("Stopped worker %d\n", id)
                }
                return
            }
        }
    }

    func main() {
        commands := make(chan WorkerPoolCommand, 10)
        
        // Start the worker pool
        go WorkerPool(commands)
        
        // Add workers
        for i := 0; i < 3; i++ {
            resp := make(chan interface{}, 1)
            commands <- WorkerPoolCommand{Op: "add", Resp: resp}
            workerID := <-resp
            fmt.Printf("Added worker %d\n", workerID)
        }
        
        // Submit tasks
        var wg sync.WaitGroup
        for i := 1; i <= 10; i++ {
            wg.Add(1)
            go func(taskID int) {
                defer wg.Done()
                
                // Get a random worker
                workerID := (taskID % 3) + 1
                
                // Submit task (in a real system, we'd route to specific workers)
                resp := make(chan interface{}, 1)
                commands <- WorkerPoolCommand{
                    Op:      "status",
                    Resp:    resp,
                }
                status := <-resp
                
                fmt.Printf("Task %d submitted (workers: %d)\n", taskID, status.(struct {
                    WorkerCount int
                    ActiveTasks int
                }).WorkerCount)
            }(i)
        }
        
        wg.Wait()
        
        // Check status
        resp := make(chan interface{}, 1)
        commands <- WorkerPoolCommand{Op: "status", Resp: resp}
        status := <-resp
        fmt.Printf("Final status: %+v\n", status)
        
        // Shutdown
        commands <- WorkerPoolCommand{Op: "quit"}
        close(commands)
    }
    ```

### 2. Chat Room with Stateful Goroutines

!!! example "Chat Room Implementation"
    ```go title="chat_room.go" linums="1" hl_lines="8-120"
    package main

    import (
        "bufio"
        "fmt"
        "os"
        "strings"
        "sync"
        "time"
    )

    // Message represents a chat message
    type Message struct {
        User    string
        Content string
        Time    time.Time
    }

    // ChatCommand represents a command to the chat room
    type ChatCommand struct {
        Op      string // "join", "leave", "message", "history", "quit"
        User    string
        Content string
        Resp    chan interface{}
    }

    // ChatRoom manages the chat state
    func ChatRoom(commands <-chan ChatCommand) {
        users := make(map[string]chan Message)
        history := make([]Message, 0, 100)
        
        for cmd := range commands {
            switch cmd.Op {
            case "join":
                if _, exists := users[cmd.User]; !exists {
                    userCh := make(chan Message, 50)
                    users[cmd.User] = userCh
                    
                    // Broadcast join message
                    joinMsg := Message{
                        User:    "System",
                        Content: fmt.Sprintf("%s joined the chat", cmd.User),
                        Time:    time.Now(),
                    }
                    broadcastMessage(users, joinMsg)
                    
                    if cmd.Resp != nil {
                        cmd.Resp <- userCh
                    }
                } else if cmd.Resp != nil {
                    cmd.Resp <- fmt.Errorf("user already exists")
                }
                
            case "leave":
                if userCh, exists := users[cmd.User]; exists {
                    // Broadcast leave message
                    leaveMsg := Message{
                        User:    "System",
                        Content: fmt.Sprintf("%s left the chat", cmd.User),
                        Time:    time.Now(),
                    }
                    broadcastMessage(users, leaveMsg)
                    
                    // Remove user
                    close(userCh)
                    delete(users, cmd.User)
                    
                    if cmd.Resp != nil {
                        cmd.Resp <- nil
                    }
                } else if cmd.Resp != nil {
                    cmd.Resp <- fmt.Errorf("user not found")
                }
                
            case "message":
                if _, exists := users[cmd.User]; exists {
                    msg := Message{
                        User:    cmd.User,
                        Content: cmd.Content,
                        Time:    time.Now(),
                    }
                    
                    // Add to history
                    history = append(history, msg)
                    if len(history) > 100 {
                        history = history[1:]
                    }
                    
                    // Broadcast to all users
                    broadcastMessage(users, msg)
                    
                    if cmd.Resp != nil {
                        cmd.Resp <- nil
                    }
                } else if cmd.Resp != nil {
                    cmd.Resp <- fmt.Errorf("user not in chat")
                }
                
            case "history":
                if cmd.Resp != nil {
                    cmd.Resp <- history
                }
                
            case "quit":
                // Close all user channels
                for user, userCh := range users {
                    close(userCh)
                    fmt.Printf("Removed user %s\n", user)
                }
                return
            }
        }
    }

    // broadcastMessage sends a message to all users
    func broadcastMessage(users map[string]chan Message, msg Message) {
        for _, userCh := range users {
            select {
            case userCh <- msg:
                // Message sent
            default:
                // User channel full, message dropped
            }
        }
    }

    // userSimulator simulates a chat user
    func userSimulator(name string, commands chan<- ChatCommand, wg *sync.WaitGroup) {
        defer wg.Done()
        
        // Join the chat
        resp := make(chan interface{}, 1)
        commands <- ChatCommand{Op: "join", User: name, Resp: resp}
        userCh := <-resp.(chan Message)
        
        // Start listening for messages
        go func() {
            for msg := range userCh {
                fmt.Printf("[%s] %s: %s\n", msg.Time.Format("15:04:05"), msg.User, msg.Content)
            }
        }()
        
        // Send some messages
        messages := []string{
            "Hello everyone!",
            "How are you doing?",
            "Nice weather today",
            "Goodbye!",
        }
        
        for _, msg := range messages {
            commands <- ChatCommand{Op: "message", User: name, Content: msg}
            time.Sleep(time.Millisecond * 500)
        }
        
        // Leave the chat
        commands <- ChatCommand{Op: "leave", User: name}
    }

    func main() {
        commands := make(chan ChatCommand, 10)
        
        // Start the chat room
        go ChatRoom(commands)
        
        var wg sync.WaitGroup
        
        // Start user simulators
        users := []string{"Alice", "Bob", "Charlie"}
        for _, user := range users {
            wg.Add(1)
            go userSimulator(user, commands, &wg)
        }
        
        // Wait for all users to finish
        wg.Wait()
        
        // Get chat history
        resp := make(chan interface{}, 1)
        commands <- ChatCommand{Op: "history", Resp: resp}
        history := <-resp.([]Message)
        
        fmt.Printf("\nChat History (%d messages):\n", len(history))
        for _, msg := range history {
            fmt.Printf("[%s] %s: %s\n", msg.Time.Format("15:04:05"), msg.User, msg.Content)
        }
        
        // Shutdown
        commands <- ChatCommand{Op: "quit"}
        close(commands)
    }
    ```

### 3. Rate Limiter with State

!!! example "Rate Limiter Stateful Goroutine"
    ```go title="rate_limiter.go" linums="1" hl_lines="8-80"
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    // RateLimitCommand represents a command to the rate limiter
    type RateLimitCommand struct {
        Op      string // "allow", "reset", "status", "quit"
        Key     string
        Tokens  int
        Resp    chan bool
    }

    // RateLimiter manages rate limiting state
    func RateLimiter(commands <-chan RateLimitCommand) {
        // State: map of key to (tokens, lastRefill)
        limiters := make(map[string]struct {
            tokens    int
            lastRefill time.Time
        })
        
        // Configuration
        maxTokens := 10
        refillRate := time.Second
        
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()
        
        for {
            select {
            case cmd := <-commands:
                switch cmd.Op {
                case "allow":
                    state, exists := limiters[cmd.Key]
                    if !exists {
                        state = struct {
                            tokens    int
                            lastRefill time.Time
                        }{
                            tokens:    maxTokens,
                            lastRefill: time.Now(),
                        }
                        limiters[cmd.Key] = state
                    }
                    
                    // Check if we have enough tokens
                    if state.tokens >= cmd.Tokens {
                        state.tokens -= cmd.Tokens
                        limiters[cmd.Key] = state
                        if cmd.Resp != nil {
                            cmd.Resp <- true
                        }
                    } else {
                        if cmd.Resp != nil {
                            cmd.Resp <- false
                        }
                    }
                    
                case "reset":
                    if _, exists := limiters[cmd.Key]; exists {
                        delete(limiters, cmd.Key)
                    }
                    if cmd.Resp != nil {
                        cmd.Resp <- true
                    }
                    
                case "status":
                    if state, exists := limiters[cmd.Key]; exists {
                        status := struct {
                            Tokens int
                            Key    string
                        }{
                            Tokens: state.tokens,
                            Key:    cmd.Key,
                        }
                        if cmd.Resp != nil {
                            cmd.Resp <- status
                        }
                    } else if cmd.Resp != nil {
                        cmd.Resp <- nil
                    }
                    
                case "quit":
                    return
                }
                
            case <-ticker.C:
                // Refill tokens for all limiters
                now := time.Now()
                for key, state := range limiters {
                    elapsed := now.Sub(state.lastRefill)
                    if elapsed >= refillRate {
                        tokensToAdd := int(elapsed / refillRate)
                        if tokensToAdd > 0 {
                            state.tokens = min(state.tokens+tokensToAdd, maxTokens)
                            state.lastRefill = now
                            limiters[key] = state
                        }
                    }
                }
            }
        }
    }

    func min(a, b int) int {
        if a < b {
            return a
        }
        return b
    }

    func main() {
        commands := make(chan RateLimitCommand, 10)
        
        // Start the rate limiter
        go RateLimiter(commands)
        
        var wg sync.WaitGroup
        
        // Simulate multiple clients
        clients := []string{"client1", "client2", "client3"}
        for _, client := range clients {
            wg.Add(1)
            go func(clientID string) {
                defer wg.Done()
                
                for i := 0; i < 15; i++ {
                    resp := make(chan bool, 1)
                    commands <- RateLimitCommand{
                        Op:     "allow",
                        Key:    clientID,
                        Tokens: 1,
                        Resp:   resp,
                    }
                    
                    allowed := <-resp
                    if allowed {
                        fmt.Printf("%s: Request %d allowed\n", clientID, i+1)
					} else {
                        fmt.Printf("%s: Request %d denied\n", clientID, i+1)
                    }
                    
                    time.Sleep(200 * time.Millisecond)
                }
            }(client)
        }
        
        wg.Wait()
        
        // Check status
        for _, client := range clients {
            resp := make(chan bool, 1)
            commands <- RateLimitCommand{
                Op:   "status",
                Key:  client,
                Resp: resp,
            }
            status := <-resp
            if status != nil {
                fmt.Printf("%s status: %+v\n", client, status)
            } else {
                fmt.Printf("%s: No active limiter\n", client)
            }
        }
        
        // Shutdown
        commands <- RateLimitCommand{Op: "quit"}
        close(commands)
    }
    ```

## Best Practices

!!! tip "Design Clear Message Protocols"
    Define clear, type-safe message protocols for communication with stateful goroutines.

!!! example "Message Protocol Design"
    ```go title="message_protocol.go" linums="1" hl_lines="8-50"
    package main

    import (
        "fmt"
    )

    // Use typed messages instead of string-based commands
    type DatabaseCommand interface {
        Execute(db *DatabaseState) interface{}
    }

    type InsertCommand struct {
        Key   string
        Value interface{}
    }

    func (c InsertCommand) Execute(db *DatabaseState) interface{} {
        db.data[c.Key] = c.Value
        return nil
    }

    type GetCommand struct {
        Key  string
        Resp chan<- interface{}
    }

    func (c GetCommand) Execute(db *DatabaseState) interface{} {
        if value, exists := db.data[c.Key]; exists {
            return value
        }
        return nil
    }

    type DeleteCommand struct {
        Key string
    }

    func (c DeleteCommand) Execute(db *DatabaseState) interface{} {
        delete(db.data, c.Key)
        return nil
    }

    // DatabaseState encapsulates the database state
    type DatabaseState struct {
        data map[string]interface{}
    }

    // DatabaseGoroutine manages the database state
    func DatabaseGoroutine(commands <-chan DatabaseCommand) {
        state := &DatabaseState{
            data: make(map[string]interface{}),
        }
        
        for cmd := range commands {
            result := cmd.Execute(state)
            
            // Handle response if needed
            if getCmd, ok := cmd.(GetCommand); ok {
                getCmd.Resp <- result
            }
        }
    }

    func main() {
        commands := make(chan DatabaseCommand, 10)
        
        go DatabaseGoroutine(commands)
        
        // Insert data
        commands <- InsertCommand{Key: "name", Value: "Alice"}
        commands <- InsertCommand{Key: "age", Value: 30}
        
        // Get data
        resp := make(chan interface{}, 1)
        commands <- GetCommand{Key: "name", Resp: resp}
        fmt.Printf("Name: %v\n", <-resp)
        
        // Delete data
        commands <- DeleteCommand{Key: "age"}
        
        close(commands)
    }
    ```

!!! tip "Handle Graceful Shutdown"
    Always implement proper shutdown mechanisms to prevent goroutine leaks.

!!! example "Graceful Shutdown"
    ```go title="graceful_shutdown.go" linums="1" hl_lines="8-60"
    package main

    import (
        "context"
        "fmt"
        "sync"
        "time"
    )

    // ServiceCommand represents a command to the service
    type ServiceCommand struct {
        Op    string // "process", "status", "shutdown"
        Data  string
        Resp  chan<- string
    }

    // Service manages the service state
    func Service(ctx context.Context, commands <-chan ServiceCommand) {
        activeRequests := 0
        shutdownInitiated := false
        
        for {
            select {
            case cmd := <-commands:
                switch cmd.Op {
                case "process":
                    if shutdownInitiated {
                        if cmd.Resp != nil {
                            cmd.Resp <- "service shutting down"
                        }
                        continue
                    }
                    
                    activeRequests++
                    go func(data string, resp chan<- string) {
                        defer func() {
                            commands <- ServiceCommand{Op: "complete"}
                        }()
                        
                        // Simulate work
                        time.Sleep(time.Second)
                        
                        if resp != nil {
                            resp <- fmt.Sprintf("processed: %s", data)
                        }
                    }(cmd.Data, cmd.Resp)
                    
                case "status":
                    status := fmt.Sprintf("active requests: %d, shutdown: %v", 
                        activeRequests, shutdownInitiated)
                    if cmd.Resp != nil {
                        cmd.Resp <- status
                    }
                    
                case "shutdown":
                    shutdownInitiated = true
                    if cmd.Resp != nil {
                        cmd.Resp <- "shutdown initiated"
                    }
                    
                case "complete":
                    activeRequests--
                    if shutdownInitiated && activeRequests == 0 {
                        return
                    }
                }
                
            case <-ctx.Done():
                // Context cancelled, force shutdown
                return
            }
        }
    }

    func main() {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        
        commands := make(chan ServiceCommand, 10)
        
        go Service(ctx, commands)
        
        // Send some requests
        for i := 0; i < 5; i++ {
            resp := make(chan string, 1)
            commands <- ServiceCommand{
                Op:   "process",
                Data: fmt.Sprintf("task-%d", i),
                Resp: resp,
            }
            fmt.Println(<-resp)
        }
        
        // Initiate shutdown
        resp := make(chan string, 1)
        commands <- ServiceCommand{Op: "shutdown", Resp: resp}
        fmt.Println(<-resp)
        
        // Wait for graceful shutdown
        time.Sleep(2 * time.Second)
        
        // Check status
        resp = make(chan string, 1)
        commands <- ServiceCommand{Op: "status", Resp: resp}
        fmt.Println(<-resp)
        
        close(commands)
    }
    ```

!!! tip "Use Buffered Channels Appropriately"
    Choose buffer sizes carefully to balance throughput and memory usage.

!!! example "Channel Buffering"
    ```go title="channel_buffering.go" linums="1" hl_lines="8-50"
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    // WorkerCommand represents a command to the worker
    type WorkerCommand struct {
        TaskID int
        Data   string
        Resp   chan<- string
    }

    // Worker processes tasks
    func Worker(commands <-chan WorkerCommand) {
        for cmd := range commands {
            // Simulate work
            time.Sleep(time.Millisecond * time.Duration(cmd.TaskID%5+1)*100)
            
            result := fmt.Sprintf("processed task %d: %s", cmd.TaskID, cmd.Data)
            if cmd.Resp != nil {
                cmd.Resp <- result
            }
        }
    }

    func main() {
        // Unbuffered channel - synchronous
        unbuffered := make(chan WorkerCommand)
        go Worker(unbuffered)
        
        start := time.Now()
        var wg sync.WaitGroup
        
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(id int) {
                defer wg.Done()
                resp := make(chan string, 1)
                unbuffered <- WorkerCommand{TaskID: id, Data: fmt.Sprintf("task-%d", id), Resp: resp}
                <-resp
            }(i)
        }
        
        wg.Wait()
        fmt.Printf("Unbuffered took: %v\n", time.Since(start))
        
        // Buffered channel - asynchronous
        buffered := make(chan WorkerCommand, 10)
        go Worker(buffered)
        
        start = time.Now()
        wg = sync.WaitGroup{}
        
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(id int) {
                defer wg.Done()
                resp := make(chan string, 1)
                buffered <- WorkerCommand{TaskID: id, Data: fmt.Sprintf("task-%d", id), Resp: resp}
                <-resp
            }(i)
        }
        
        wg.Wait()
        fmt.Printf("Buffered took: %v\n", time.Since(start))
        
        close(unbuffered)
        close(buffered)
    }
    ```

## Pitfalls and Solutions

!!! tip "Avoid Deadlocks"
    Be careful with circular dependencies and synchronous communication patterns.

!!! example "Deadlock Prevention"
    ```go title="deadlock_prevention.go" linums="1" hl_lines="8-60"
    package main

    import (
        "fmt"
        "time"
    )

    // Bad: Potential deadlock with synchronous communication
    type BadActor struct {
        inbox chan string
        peer  *BadActor
    }

    func NewBadActor() *BadActor {
        return &BadActor{
            inbox: make(chan string),
        }
    }

    func (a *BadActor) SetPeer(peer *BadActor) {
        a.peer = peer
    }

    func (a *BadActor) Start() {
        go func() {
            for msg := range a.inbox {
                fmt.Printf("Actor received: %s\n", msg)
                // This can cause deadlock if both actors send to each other simultaneously
                a.peer.inbox <- "response"
            }
        }()
    }

    // Good: Asynchronous communication prevents deadlock
    type GoodActor struct {
        inbox  chan string
        peer   *GoodActor
        quit   chan struct{}
    }

    func NewGoodActor() *GoodActor {
        return &GoodActor{
            inbox: make(chan string, 10),
            quit:  make(chan struct{}),
        }
    }

    func (a *GoodActor) SetPeer(peer *GoodActor) {
        a.peer = peer
    }

    func (a *GoodActor) Start() {
        go func() {
            for {
                select {
                case msg := <-a.inbox:
                    fmt.Printf("Actor received: %s\n", msg)
                    // Use buffered channel and select to prevent blocking
                    select {
                    case a.peer.inbox <- "response":
                        // Sent successfully
                    default:
                        // Peer busy, drop response or handle differently
                        fmt.Println("Peer busy, response dropped")
                    }
                case <-a.quit:
                    return
                }
            }
        }()
    }

    func (a *GoodActor) Stop() {
        close(a.quit)
    }

    func main() {
        // Demonstrate bad actor (commented out to avoid deadlock)
        /*
        actor1 := NewBadActor()
        actor2 := NewBadActor()
        actor1.SetPeer(actor2)
        actor2.SetPeer(actor1)
        actor1.Start()
        actor2.Start()
        
        actor1.inbox <- "hello"
        time.Sleep(time.Second)
        */
        
        // Demonstrate good actor
        actor1 := NewGoodActor()
        actor2 := NewGoodActor()
        actor1.SetPeer(actor2)
        actor2.SetPeer(actor1)
        actor1.Start()
        actor2.Start()
        
        actor1.inbox <- "hello"
        time.Sleep(time.Second)
        
        actor1.Stop()
        actor2.Stop()
    }
    ```

!!! tip "Prevent Goroutine Leaks"
    Always provide a way to terminate stateful goroutines.

!!! example "Goroutine Leak Prevention"
    ```go title="goroutine_leak_prevention.go" linums="1" hl_lines="8-70"
    package main

    import (
        "fmt"
        "runtime"
        "time"
    )

    // Bad: Goroutine that never terminates
    func badLeakyGoroutine(ch <-chan int) {
        for {
            // This goroutine will never exit because it doesn't check for channel closure
            val := <-ch
            fmt.Printf("Received: %d\n", val)
        }
    }

    // Good: Goroutine that can terminate
    func goodGoroutine(ch <-chan int, quit <-chan struct{}) {
        for {
            select {
            case val := <-ch:
                fmt.Printf("Received: %d\n", val)
            case <-quit:
                fmt.Println("Goroutine quitting")
                return
            }
        }
    }

    // Better: Using context for cancellation
    func betterGoroutine(ctx context.Context, ch <-chan int) {
        for {
            select {
            case val := <-ch:
                fmt.Printf("Received: %d\n", val)
            case <-ctx.Done():
                fmt.Printf("Goroutine quitting: %v\n", ctx.Err())
                return
            }
        }
    }

    func main() {
        // Check initial goroutine count
        fmt.Printf("Initial goroutines: %d\n", runtime.NumGoroutine())
        
        // Demonstrate leaky goroutine (commented out)
        /*
        leakyCh := make(chan int)
        go badLeakyGoroutine(leakyCh)
        leakyCh <- 1
        fmt.Printf("After leaky goroutine: %d\n", runtime.NumGoroutine())
        */
        
        // Demonstrate good goroutine
        goodCh := make(chan int)
        quit := make(chan struct{})
        go goodGoroutine(goodCh, quit)
        
        goodCh <- 1
        goodCh <- 2
        quit <- struct{}{}
        time.Sleep(time.Millisecond) // Give goroutine time to quit
        fmt.Printf("After good goroutine: %d\n", runtime.NumGoroutine())
        
        // Demonstrate better goroutine with context
        ctx, cancel := context.WithCancel(context.Background())
        betterCh := make(chan int)
        go betterGoroutine(ctx, betterCh)
        
        betterCh <- 1
        betterCh <- 2
        cancel()
        time.Sleep(time.Millisecond) // Give goroutine time to quit
        fmt.Printf("After better goroutine: %d\n", runtime.NumGoroutine())
    }
    ```

## Real-World Example: Distributed Task Queue

Let's create a comprehensive example that demonstrates stateful goroutines in a distributed task queue system:

!!! example "Distributed Task Queue"
    ```go title="task_queue.go" linums="1" hl_lines="8-200"
    package main

    import (
        "context"
        "fmt"
        "math/rand"
        "sync"
        "time"
    )

    // Task represents a unit of work
    type Task struct {
        ID        string
        Type      string
        Payload   interface{}
        CreatedAt time.Time
        Status    string // "pending", "running", "completed", "failed"
        Result    interface{}
        Error     error
        Retries   int
    }

    // QueueCommand represents a command to the task queue
    type QueueCommand struct {
        Op      string // "enqueue", "dequeue", "complete", "fail", "status", "quit"
        Task    *Task
        WorkerID string
        Resp    chan<- interface{}
    }

    // TaskQueue manages the distributed task queue
    func TaskQueue(ctx context.Context, commands <-chan QueueCommand) {
        pending := make(map[string]*Task)
        running := make(map[string]*Task)
        completed := make(map[string]*Task)
        failed := make(map[string]*Task)
        workers := make(map[string]bool)
        
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case cmd := <-commands:
                switch cmd.Op {
                case "enqueue":
                    task := cmd.Task
                    task.Status = "pending"
                    pending[task.ID] = task
                    if cmd.Resp != nil {
                        cmd.Resp <- task.ID
                    }
                    
                case "dequeue":
                    // Find a pending task
                    var task *Task
                    for _, t := range pending {
                        task = t
                        break
                    }
                    
                    if task != nil {
                        delete(pending, task.ID)
                        task.Status = "running"
                        running[task.ID] = task
                        workers[cmd.WorkerID] = true
                        
                        if cmd.Resp != nil {
                            cmd.Resp <- task
                        }
                    } else {
                        if cmd.Resp != nil {
                            cmd.Resp <- (*Task)(nil)
                        }
                    }
                    
                case "complete":
                    if task, exists := running[cmd.Task.ID]; exists {
                        delete(running, cmd.Task.ID)
                        task.Status = "completed"
                        task.Result = cmd.Task.Result
                        completed[task.ID] = task
                        delete(workers, cmd.WorkerID)
                        
                        if cmd.Resp != nil {
                            cmd.Resp <- nil
                        }
                    } else if cmd.Resp != nil {
                        cmd.Resp <- fmt.Errorf("task not found or not running")
                    }
                    
                case "fail":
                    if task, exists := running[cmd.Task.ID]; exists {
                        delete(running, cmd.Task.ID)
                        task.Retries++
                        
                        if task.Retries < 3 {
                            // Retry the task
                            task.Status = "pending"
                            pending[task.ID] = task
                        } else {
                            // Max retries reached
                            task.Status = "failed"
                            task.Error = cmd.Task.Error
                            failed[task.ID] = task
                        }
                        delete(workers, cmd.WorkerID)
                        
                        if cmd.Resp != nil {
                            cmd.Resp <- nil
                        }
                    } else if cmd.Resp != nil {
                        cmd.Resp <- fmt.Errorf("task not found or not running")
                    }
                    
                case "status":
                    status := struct {
                        Pending   int
                        Running   int
                        Completed int
                        Failed    int
                        Workers   int
                    }{
                        Pending:   len(pending),
                        Running:   len(running),
                        Completed: len(completed),
                        Failed:    len(failed),
                        Workers:   len(workers),
                    }
                    if cmd.Resp != nil {
                        cmd.Resp <- status
                    }
                    
                case "quit":
                    return
                }
                
            case <-ticker.C:
                // Clean up old completed tasks
                cutoff := time.Now().Add(-1 * time.Hour)
                for id, task := range completed {
                    if task.CreatedAt.Before(cutoff) {
                        delete(completed, id)
                    }
                }
                
                // Check for stuck tasks
                for id, task := range running {
                    if time.Since(task.CreatedAt) > 5*time.Minute {
                        delete(running, id)
                        task.Status = "failed"
                        task.Error = fmt.Errorf("task timed out")
                        failed[id] = task
                    }
                }
                
            case <-ctx.Done():
                // Context cancelled, shutdown gracefully
                return
            }
        }
    }

    // Worker represents a task worker
    type Worker struct {
        ID       string
        queue    chan<- QueueCommand
        quit     chan struct{}
    }

    func NewWorker(id string, queue chan<- QueueCommand) *Worker {
        return &Worker{
            ID:    id,
            queue: queue,
            quit:  make(chan struct{}),
        }
    }

    func (w *Worker) Start() {
        go func() {
            for {
                select {
                case <-w.quit:
                    return
                default:
                    // Try to dequeue a task
                    resp := make(chan interface{}, 1)
                    w.queue <- QueueCommand{
                        Op:      "dequeue",
                        WorkerID: w.ID,
                        Resp:    resp,
                    }
                    
                    task := <-resp
                    if task == nil {
                        // No tasks available
                        time.Sleep(time.Second)
                        continue
                    }
                    
                    // Process the task
                    t := task.(*Task)
                    fmt.Printf("Worker %s processing task %s\n", w.ID, t.ID)
                    
                    // Simulate work
                    time.Sleep(time.Duration(rand.Intn(3)+1) * time.Second)
                    
                    // Simulate occasional failures
                    var err error
                    if rand.Intn(10) == 0 {
                        err = fmt.Errorf("random failure")
                    }
                    
                    if err != nil {
                        // Report failure
                        w.queue <- QueueCommand{
                            Op:   "fail",
                            Task: &Task{
                                ID:    t.ID,
                                Error: err,
                            },
                        }
                    } else {
                        // Report completion
                        w.queue <- QueueCommand{
                            Op: "complete",
                            Task: &Task{
                                ID:     t.ID,
                                Result: fmt.Sprintf("processed by %s", w.ID),
                            },
                        }
                    }
                }
            }
        }()
    }

    func (w *Worker) Stop() {
        close(w.quit)
    }

    func main() {
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        
        commands := make(chan QueueCommand, 100)
        
        // Start the task queue
        go TaskQueue(ctx, commands)
        
        // Start workers
        workers := []*Worker{
            NewWorker("worker-1", commands),
            NewWorker("worker-2", commands),
            NewWorker("worker-3", commands),
        }
        
        for _, worker := range workers {
            worker.Start()
        }
        
        // Enqueue some tasks
        for i := 0; i < 20; i++ {
            task := &Task{
                ID:        fmt.Sprintf("task-%d", i),
                Type:      "test",
                Payload:   fmt.Sprintf("payload-%d", i),
                CreatedAt: time.Now(),
                Status:    "pending",
            }
            
            resp := make(chan interface{}, 1)
            commands <- QueueCommand{
                Op:   "enqueue",
                Task: task,
                Resp: resp,
            }
            
            taskID := <-resp
            fmt.Printf("Enqueued task %s\n", taskID)
        }
        
        // Monitor progress
        ticker := time.NewTicker(2 * time.Second)
        defer ticker.Stop()
        
        for i := 0; i < 10; i++ {
            select {
            case <-ticker.C:
                resp := make(chan interface{}, 1)
                commands <- QueueCommand{
                    Op:   "status",
                    Resp: resp,
                }
                
                status := <-resp
                fmt.Printf("Queue status: %+v\n", status)
                
                // Check if all tasks are processed
                s := status.(struct {
                    Pending   int
                    Running   int
                    Completed int
                    Failed    int
                    Workers   int
                })
                
                if s.Pending == 0 && s.Running == 0 {
                    fmt.Println("All tasks processed!")
                    break
                }
            }
        }
        
        // Shutdown
        for _, worker := range workers {
            worker.Stop()
        }
        
        cancel()
        time.Sleep(time.Second)
        close(commands)
    }
    ```

### How This Example Demonstrates Stateful Goroutine Concepts:

1. **State Encapsulation**:
   - The task queue maintains private state for pending, running, completed, and failed tasks
   - Workers maintain their own state and communicate exclusively through channels

2. **Message Passing**:
   - All operations on the queue happen through explicit commands
   - Workers communicate with the queue via a well-defined protocol

3. **Actor Model**:
   - Each worker acts as an independent actor processing tasks
   - The task queue itself is an actor managing the overall state

4. **Error Handling**:
   - Failed tasks are retried up to a maximum number of times
   - Timeout detection for stuck tasks

5. **Resource Management**:
   - Worker registration and deregistration
   - Cleanup of old completed tasks
   - Graceful shutdown with context cancellation

6. **Monitoring**:
   - Status reporting for queue state
   - Progress tracking through the command interface

## Quick Reference

!!! success "Key Takeaways"
    - **State Encapsulation**: Keep state private to goroutines and communicate via channels
    - **Actor Model**: Treat each stateful goroutine as an independent actor with message processing
    - **Message Protocols**: Design clear, type-safe message protocols for communication
    - **Sequential Processing**: Process messages one at a time to ensure state consistency
    - **Graceful Shutdown**: Always implement proper shutdown mechanisms to prevent leaks
    - **Error Handling**: Design comprehensive error handling and recovery mechanisms
    - **Performance**: Use buffered channels appropriately and avoid blocking operations
    - **Testing**: Test stateful goroutines thoroughly, including edge cases and failure scenarios
    - **Monitoring**: Implement status reporting and health checks for stateful components
    - **Scalability**: Design stateful goroutines to be composable and distributable

!!! quote "Remember"
    "Stateful goroutines are a powerful pattern in Go that enables building complex concurrent systems with clear boundaries and message-based communication. By encapsulating state within goroutines and using channels for all interactions, you can eliminate race conditions and build more maintainable concurrent code. While they require careful design to avoid deadlocks and leaks, stateful goroutines provide an elegant solution to many concurrency problems, especially when implementing actor systems, worker pools, and distributed services."}