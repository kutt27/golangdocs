# Goroutines in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master Go's lightweight concurrency model using goroutines - the foundation of Go's exceptional performance and scalability. Learn to create, manage, and synchronize thousands of concurrent operations efficiently. Understand how goroutines differ from traditional threads, communicate through channels, and implement robust concurrent patterns for real-world applications.

!!! tip "Key Points"
    - Goroutines are lightweight threads managed by the Go runtime, not the OS
    - Created with the `go` keyword, enabling simple concurrent execution
    - Communicate through channels rather than shared memory for safer concurrency
    - Synchronize using sync.WaitGroup, sync.Mutex, and other primitives
    - Handle cancellation and timeouts with the context package
    - Select statements enable non-blocking communication across multiple channels
    - Common patterns include worker pools, pipelines, and fan-in/fan-out
    - Proper error handling and resource management are critical for robust concurrent systems

## Understanding Goroutines

Goroutines are the cornerstone of Go's concurrency model. They're functions or methods that run concurrently with other functions or methods, managed by the Go runtime rather than the operating system. This makes them extremely lightweight - you can run hundreds of thousands or even millions of goroutines in a single Go program.

!!! info "Goroutine Architecture"
    ```mermaid
    graph TB
        A[Go Program] --> B[Go Runtime]
        B --> C[Goroutine Scheduler]
        C --> D[Goroutine 1]
        C --> E[Goroutine 2]
        C --> F[Goroutine 3]
        C --> G[Goroutine N]
        D --> H[OS Thread 1]
        E --> H
        F --> I[OS Thread 2]
        G --> I
        H --> J[CPU Core 1]
        I --> K[CPU Core 2]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
        style B fill:#f9f,stroke:#333,stroke-width:2px,color:#000
        style C fill:#ccf,stroke:#333,stroke-width:2px,color:#000
    ```

Unlike traditional threads:
- Goroutines start with a small stack (2KB) that grows as needed
- Goroutine scheduling happens in user space, not kernel space
- Context switching between goroutines is much faster than between OS threads
- Goroutines are multiplexed onto a smaller number of OS threads

## Creating Goroutines

Creating a goroutine is as simple as prefixing a function call with the `go` keyword:

!!! example "Basic Goroutine Creation"
    ```go title="basic_goroutine.go" linenums="1" hl_lines="8-10"
    package main

    import (
        "fmt"
        "time"
    )

    func sayHello() {
        fmt.Println("Hello from goroutine!")
    }

    func main() {
        // Start a goroutine
        go sayHello()
        
        // Give the goroutine time to execute
        time.Sleep(100 * time.Millisecond)
        fmt.Println("Hello from main!")
    }
    ```

!!! example "Anonymous Function Goroutine"
    ```go title="anonymous_goroutine.go" linenums="1" hl_lines="8-12"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        // Start a goroutine with an anonymous function
        go func() {
            fmt.Println("Hello from anonymous goroutine!")
        }()
        
        time.Sleep(100 * time.Millisecond)
        fmt.Println("Hello from main!")
    }
    ```

!!! example "Goroutine with Parameters"
    ```go title="parameterized_goroutine.go" linenums="1" hl_lines="8-14"
    package main

    import (
        "fmt"
        "time"
    )

    func greet(name string) {
        fmt.Printf("Hello, %s!\n", name)
    }

    func main() {
        names := []string{"Alice", "Bob", "Charlie"}
        
        for _, name := range names {
            go greet(name)
        }
        
        time.Sleep(100 * time.Millisecond)
        fmt.Println("All greetings sent!")
    }
    ```

## Synchronization with sync.WaitGroup

When you need to wait for multiple goroutines to complete, use `sync.WaitGroup`:

!!! example "Using WaitGroup"
    ```go title="waitgroup_example.go" linenums="1" hl_lines="8-32"
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    func worker(id int, wg *sync.WaitGroup) {
        defer wg.Done() // Decrement counter when done
        
        fmt.Printf("Worker %d starting\n", id)
        time.Sleep(time.Duration(id) * 100 * time.Millisecond)
        fmt.Printf("Worker %d done\n", id)
    }

    func main() {
        var wg sync.WaitGroup
        
        // Start 3 workers
        for i := 1; i <= 3; i++ {
            wg.Add(1) // Increment counter
            go worker(i, &wg)
        }
        
        // Wait for all workers to finish
        wg.Wait()
        fmt.Println("All workers completed!")
    }
    ```

## Communication with Channels

Channels are the primary way goroutines communicate and synchronize. They provide a type-safe conduit for passing values between goroutines.

!!! example "Basic Channel Usage"
    ```go title="basic_channel.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "time"
    )

    func sendData(ch chan<- string) {
        ch <- "Hello from sender!"
    }

    func receiveData(ch <-chan string) {
        msg := <-ch
        fmt.Println("Received:", msg)
    }

    func main() {
        // Create an unbuffered channel
        messageChannel := make(chan string)
        
        // Start sender and receiver goroutines
        go sendData(messageChannel)
        go receiveData(messageChannel)
        
        // Wait for communication to complete
        time.Sleep(100 * time.Millisecond)
        fmt.Println("Communication completed!")
    }
    ```

!!! example "Buffered Channels"
    ```go title="buffered_channel.go" linenums="1" hl_lines="8-24"
    package main

    import (
        "fmt"
    )

    func main() {
        // Create a buffered channel with capacity 3
        ch := make(chan int, 3)
        
        // Send doesn't block until buffer is full
        ch <- 1
        ch <- 2
        ch <- 3
        
        fmt.Println("Sent 3 values to buffered channel")
        
        // Receive values
        fmt.Println(<-ch)
        fmt.Println(<-ch)
        fmt.Println(<-ch)
        
        fmt.Println("All values received")
    }
    ```

!!! example "Channel Directions"
    ```go title="channel_directions.go" linenums="1" hl_lines="8-28"
    package main

    import (
        "fmt"
    )

    // Sender can only send to channel
    func sender(ch chan<- int) {
        for i := 1; i <= 5; i++ {
            ch <- i
        }
        close(ch) // Close channel when done
    }

    // Receiver can only receive from channel
    func receiver(ch <-chan int, done chan<- bool) {
        for num := range ch {
            fmt.Println("Received:", num)
        }
        done <- true
    }

    func main() {
        dataCh := make(chan int)
        doneCh := make(chan bool)
        
        go sender(dataCh)
        go receiver(dataCh, doneCh)
        
        <-doneCh
        fmt.Println("Communication completed!")
    }
    ```

## Select Statement

The `select` statement allows a goroutine to wait on multiple communication operations:

!!! example "Select Statement"
    ```go title="select_example.go" linenums="1" hl_lines="8-34"
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        ch1 := make(chan string)
        ch2 := make(chan string)
        
        // Start two goroutines that send to different channels
        go func() {
            time.Sleep(100 * time.Millisecond)
            ch1 <- "Message from channel 1"
        }()
        
        go func() {
            time.Sleep(200 * time.Millisecond)
            ch2 <- "Message from channel 2"
        }()
        
        // Use select to wait for either channel
        for i := 0; i < 2; i++ {
            select {
            case msg1 := <-ch1:
                fmt.Println("Received:", msg1)
            case msg2 := <-ch2:
                fmt.Println("Received:", msg2)
            case <-time.After(300 * time.Millisecond):
                fmt.Println("Timeout!")
            }
        }
        
        fmt.Println("All messages received!")
    }
    ```

## Context Package

The `context` package provides a way to carry deadlines, cancellation signals, and other request-scoped values across API boundaries:

!!! example "Context with Cancellation"
    ```go title="context_cancellation.go" linenums="1" hl_lines="8-42"
    package main

    import (
        "context"
        "fmt"
        "time"
    )

    func worker(ctx context.Context, id int) {
        for {
            select {
            case <-ctx.Done():
                fmt.Printf("Worker %d: %s\n", id, ctx.Err())
                return
            default:
                fmt.Printf("Worker %d: Working...\n", id)
                time.Sleep(500 * time.Millisecond)
            }
        }
    }

    func main() {
        // Create a context that can be cancelled
        ctx, cancel := context.WithCancel(context.Background())
        
        // Start 3 workers
        for i := 1; i <= 3; i++ {
            go worker(ctx, i)
        }
        
        // Let workers work for a while
        time.Sleep(2 * time.Second)
        
        // Cancel the context to stop all workers
        fmt.Println("Cancelling context...")
        cancel()
        
        // Give workers time to clean up
        time.Sleep(500 * time.Millisecond)
        fmt.Println("All workers stopped!")
    }
    ```

!!! example "Context with Timeout"
    ```go title="context_timeout.go" linenums="1" hl_lines="8-33"
    package main

    import (
        "context"
        "fmt"
        "time"
    )

    func longRunningTask(ctx context.Context) {
        select {
        case <-time.After(3 * time.Second):
            fmt.Println("Task completed successfully")
        case <-ctx.Done():
            fmt.Println("Task cancelled:", ctx.Err())
        }
    }

    func main() {
        // Create a context with 2-second timeout
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel() // Release resources if timeout doesn't occur
        
        fmt.Println("Starting long-running task with 2-second timeout")
        go longRunningTask(ctx)
        
        // Wait for context to timeout
        select {
        case <-ctx.Done():
            fmt.Println("Context done:", ctx.Err())
        }
    }
    ```

## Common Concurrency Patterns

### 1. Worker Pool

!!! example "Worker Pool Pattern"
    ```go title="worker_pool.go" linenums="1" hl_lines="8-54"
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {
        defer wg.Done()
        
        for j := range jobs {
            fmt.Printf("Worker %d processing job %d\n", id, j)
            time.Sleep(time.Second) // Simulate work
            results <- j * 2
        }
    }

    func main() {
        const numJobs = 5
        const numWorkers = 3
        
        jobs := make(chan int, numJobs)
        results := make(chan int, numJobs)
        var wg sync.WaitGroup
        
        // Start workers
        for w := 1; w <= numWorkers; w++ {
            wg.Add(1)
            go worker(w, jobs, results, &wg)
        }
        
        // Send jobs
        for j := 1; j <= numJobs; j++ {
            jobs <- j
        }
        close(jobs)
        
        // Wait for all workers to finish
        wg.Wait()
        close(results)
        
        // Collect results
        for result := range results {
            fmt.Println("Result:", result)
        }
        
        fmt.Println("All jobs processed!")
    }
    ```

### 2. Pipeline Pattern

!!! example "Pipeline Pattern"
    ```go title="pipeline.go" linenums="1" hl_lines="8-46"
    package main

    import (
        "fmt"
        "sync"
    )

    // Stage 1: Generate numbers
    func generator(nums ...int) <-chan int {
        out := make(chan int)
        go func() {
            defer close(out)
            for _, n := range nums {
                out <- n
            }
        }()
        return out
    }

    // Stage 2: Square numbers
    func square(in <-chan int) <-chan int {
        out := make(chan int)
        go func() {
            defer close(out)
            for n := range in {
                out <- n * n
            }
        }()
        return out
    }

    // Stage 3: Calculate sum
    func sum(in <-chan int) <-chan int {
        out := make(chan int)
        go func() {
            defer close(out)
            total := 0
            for n := range in {
                total += n
            }
            out <- total
        }()
        return out
    }

    func main() {
        // Create pipeline
        numbers := generator(1, 2, 3, 4, 5)
        squares := square(numbers)
        result := sum(squares)
        
        // Get final result
        fmt.Println("Sum of squares:", <-result)
    }
    ```

### 3. Fan-in/Fan-out

!!! example "Fan-in/Fan-out Pattern"
    ```go title="fan_in_out.go" linenums="1" hl_lines="8-52"
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    // Worker function (fan-out)
    func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {
        defer wg.Done()
        
        for job := range jobs {
            fmt.Printf("Worker %d started job %d\n", id, job)
            time.Sleep(time.Duration(job) * 100 * time.Millisecond)
            results <- job * 2
            fmt.Printf("Worker %d finished job %d\n", id, job)
        }
    }

    // Fan-in: merge multiple channels into one
    func merge(cs ...<-chan int) <-chan int {
        var wg sync.WaitGroup
        out := make(chan int)
        
        // Start an output goroutine for each input channel
        output := func(c <-chan int) {
            defer wg.Done()
            for n := range c {
                out <- n
            }
        }
        
        wg.Add(len(cs))
        for _, c := range cs {
            go output(c)
        }
        
        // Start a goroutine to close out once all outputs are done
        go func() {
            wg.Wait()
            close(out)
        }()
        
        return out
    }

    func main() {
        jobs := make(chan int, 10)
        results := make(chan int, 10)
        
        // Create 3 worker channels
        workerChans := make([]chan int, 3)
        for i := 0; i < 3; i++ {
            workerChans[i] = make(chan int)
        }
        
        // Start workers
        var wg sync.WaitGroup
        for i := 0; i < 3; i++ {
            wg.Add(1)
            go worker(i+1, workerChans[i], results, &wg)
        }
        
        // Distribute jobs to workers (fan-out)
        go func() {
            for i := 1; i <= 9; i++ {
                workerChans[i%3] <- i
            }
            for _, ch := range workerChans {
                close(ch)
            }
        }()
        
        // Wait for all workers to finish
        wg.Wait()
        close(results)
        
        // Collect results
        for result := range results {
            fmt.Println("Result:", result)
        }
        
        fmt.Println("All jobs completed!")
    }
    ```

## Best Practices

!!! tip "Avoid Data Races"
    Always synchronize access to shared data to prevent data races.

!!! example "Mutex Protection"
    ```go title="mutex_protection.go" linenums="1" hl_lines="8-26"
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    type Counter struct {
        mu    sync.Mutex
        value int
    }

    func (c *Counter) Increment() {
        c.mu.Lock()
        defer c.mu.Unlock()
        c.value++
    }

    func main() {
        counter := Counter{}
        var wg sync.WaitGroup
        
        for i := 0; i < 1000; i++ {
            wg.Add(1)
            go func() {
                defer wg.Done()
                counter.Increment()
            }()
        }
        
        wg.Wait()
        fmt.Println("Final counter value:", counter.value)
    }
    ```

!!! tip "Prevent Goroutine Leaks"
    Always ensure goroutines can terminate, especially with channels.

!!! example "Goroutine Cleanup"
    ```go title="goroutine_cleanup.go" linenums="1" hl_lines="8-33"
    package main

    import (
        "context"
        "fmt"
        "time"
    )

    func worker(ctx context.Context, jobs <-chan int) {
        for {
            select {
            case job, ok := <-jobs:
                if !ok {
                    fmt.Println("Worker: channel closed, exiting")
                    return
                }
                fmt.Printf("Worker: processing job %d\n", job)
                time.Sleep(500 * time.Millisecond)
            case <-ctx.Done():
                fmt.Println("Worker: cancelled, exiting")
                return
            }
        }
    }

    func main() {
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        
        jobs := make(chan int)
        go worker(ctx, jobs)
        
        // Send some jobs
        for i := 1; i <= 3; i++ {
            jobs <- i
        }
        
        // Cancel context to stop worker
        cancel()
        
        // Give worker time to clean up
        time.Sleep(100 * time.Millisecond)
        fmt.Println("Main: worker stopped")
    }
    ```

!!! tip "Limit Concurrency"
    Use semaphores or worker pools to limit the number of concurrent goroutines.

!!! example "Concurrency Limiting"
    ```go title="concurrency_limiting.go" linenums="1" hl_lines="8-38"
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    func processTask(id int, sem chan struct{}, wg *sync.WaitGroup) {
        defer wg.Done()
        
        // Acquire semaphore
        sem <- struct{}{}
        defer func() { <-sem }() // Release semaphore
        
        fmt.Printf("Task %d started\n", id)
        time.Sleep(500 * time.Millisecond)
        fmt.Printf("Task %d completed\n", id)
    }

    func main() {
        const maxConcurrency = 3
        const numTasks = 10
        
        // Semaphore to limit concurrency
        sem := make(chan struct{}, maxConcurrency)
        var wg sync.WaitGroup
        
        // Start tasks
        for i := 1; i <= numTasks; i++ {
            wg.Add(1)
            go processTask(i, sem, &wg)
        }
        
        wg.Wait()
        fmt.Println("All tasks completed!")
    }
    ```

!!! tip "Handle Errors Properly"
    Collect errors from goroutines rather than ignoring them.

!!! example "Error Handling"
    ```go title="error_handling.go" linenums="1" hl_lines="8-42"
    package main

    import (
        "errors"
        "fmt"
        "sync"
    )

    func worker(id int, jobs <-chan int, results chan<- int, errChan chan<- error, wg *sync.WaitGroup) {
        defer wg.Done()
        
        for job := range jobs {
            if job%3 == 0 {
                errChan <- fmt.Errorf("worker %d: invalid job %d", id, job)
                continue
            }
            
            results <- job * 2
        }
    }

    func main() {
        jobs := make(chan int, 10)
        results := make(chan int, 10)
        errChan := make(chan error, 10)
        var wg sync.WaitGroup
        
        // Start workers
        for i := 1; i <= 3; i++ {
            wg.Add(1)
            go worker(i, jobs, results, errChan, &wg)
        }
        
        // Send jobs
        for i := 1; i <= 10; i++ {
            jobs <- i
        }
        close(jobs)
        
        // Wait for workers to finish
        wg.Wait()
        close(results)
        close(errChan)
        
        // Collect results
        for result := range results {
            fmt.Println("Result:", result)
        }
        
        // Collect errors
        var errs []error
        for err := range errChan {
            errs = append(errs, err)
        }
        
        if len(errs) > 0 {
            fmt.Println("Encountered errors:")
            for _, err := range errs {
                fmt.Println("-", err)
            }
        }
    }
    ```

## Real-World Example: Concurrent Web Scraper

Let's create a comprehensive example that demonstrates various goroutine concepts in a web scraping context:

!!! example "Concurrent Web Scraper"
    ```go title="web_scraper.go" linenums="1" hl_lines="8-102"
    package main

    import (
        "context"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"
    )

    // Result represents a scraped page
    type Result struct {
        URL   string
        Size  int
        Error error
    }

    // Worker function to fetch URLs
    func fetcher(ctx context.Context, id int, urls <-chan string, results chan<- Result, wg *sync.WaitGroup) {
        defer wg.Done()
        
        client := &http.Client{
            Timeout: 5 * time.Second,
        }
        
        for url := range urls {
            select {
            case <-ctx.Done():
                results <- Result{URL: url, Error: ctx.Err()}
                return
            default:
                // Create a new request with context
                req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
                if err != nil {
                    results <- Result{URL: url, Error: err}
                    continue
                }
                
                // Send request
                resp, err := client.Do(req)
                if err != nil {
                    results <- Result{URL: url, Error: err}
                    continue
                }
                
                // Read response body
                body, err := io.ReadAll(resp.Body)
                resp.Body.Close()
                if err != nil {
                    results <- Result{URL: url, Error: err}
                    continue
                }
                
                // Send result
                results <- Result{
                    URL:  url,
                    Size: len(body),
                }
            }
        }
    }

    func main() {
        // URLs to scrape
        urls := []string{
            "https://example.com",
            "https://golang.org",
            "https://github.com",
            "https://stackoverflow.com",
            "https://go.dev",
            "https://pkg.go.dev",
            "https://blog.golang.org",
            "https://tour.golang.org",
        }
        
        // Create channels
        urlChan := make(chan string, len(urls))
        resultChan := make(chan Result, len(urls))
        
        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        
        // Start workers
        const numWorkers = 4
        var wg sync.WaitGroup
        
        for i := 1; i <= numWorkers; i++ {
            wg.Add(1)
            go fetcher(ctx, i, urlChan, resultChan, &wg)
        }
        
        // Send URLs to workers
        go func() {
            for _, url := range urls {
                urlChan <- url
            }
            close(urlChan)
        }()
        
        // Start a goroutine to close result channel when all workers are done
        go func() {
            wg.Wait()
            close(resultChan)
        }()
        
        // Collect results
        var totalSize int
        var errors []error
        
        for result := range resultChan {
            if result.Error != nil {
                errors = append(errors, result.Error)
                continue
            }
            
            fmt.Printf("Fetched %s: %d bytes\n", result.URL, result.Size)
            totalSize += result.Size
        }
        
        // Print summary
        fmt.Printf("\nSummary:\n")
        fmt.Printf("Total URLs processed: %d\n", len(urls))
        fmt.Printf("Total bytes fetched: %d\n", totalSize)
        fmt.Printf("Errors encountered: %d\n", len(errors))
        
        if len(errors) > 0 {
            fmt.Println("\nErrors:")
            for _, err := range errors {
                fmt.Println("-", err)
            }
        }
    }
    ```

### How This Example Demonstrates Goroutine Concepts:

1. **Worker Pool Pattern**:
   - Multiple goroutines process URLs from a shared channel
   - Fixed number of workers limit concurrency

2. **Context for Cancellation**:
   - Context with timeout ensures the scraper doesn't run indefinitely
   - Workers respect context cancellation

3. **Error Handling**:
   - Errors are collected and reported separately
   - Each worker handles its own errors

4. **Resource Management**:
   - HTTP client with timeout prevents hanging requests
   - Proper cleanup of response bodies

5. **Synchronization**:
   - WaitGroup ensures all workers complete before closing results
   - Channels coordinate work distribution and result collection

6. **Graceful Shutdown**:
   - Context cancellation allows for clean shutdown
   - Workers exit gracefully when context is cancelled

## Quick Reference

!!! success "Key Takeaways"
    - **Lightweight Concurrency**: Goroutines are extremely lightweight (start with 2KB stack)
    - **Simple Creation**: Use the `go` keyword to start a goroutine
    - **Channel Communication**: Prefer channels over shared memory for communication
    - **Synchronization**: Use sync.WaitGroup, sync.Mutex, and other primitives as needed
    - **Context Management**: Use context for cancellation, timeouts, and request-scoped values
    - **Select Statements**: Handle multiple channels with select for non-blocking operations
    - **Common Patterns**: Implement worker pools, pipelines, and fan-in/fan-out for scalable designs
    - **Error Handling**: Collect and handle errors from goroutines properly
    - **Resource Management**: Always ensure goroutines can terminate to prevent leaks
    - **Concurrency Limits**: Control the number of concurrent goroutines to avoid resource exhaustion

!!! quote "Remember"
    "Goroutines are the heart of Go's concurrency model, enabling developers to build highly concurrent and scalable applications with ease. By mastering goroutines, channels, and synchronization primitives, you can leverage Go's full potential for building efficient concurrent systems. The key is to think in terms of communication and coordination rather than shared memory and locks."