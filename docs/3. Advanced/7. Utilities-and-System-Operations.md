# Utilities and System Operations in Go: A Comprehensive Guide

!!! abstract "Overview"
    Master Go's powerful utilities and system operations for building robust, efficient applications. Learn to sort collections with built-in algorithms, implement comprehensive testing and benchmarking, execute and manage external processes, and handle system signals gracefully. Understand how these fundamental operations form the backbone of system programming in Go, enabling you to create reliable, high-performance software.

!!! tip "Key Points"
    - **Sorting**: Go provides efficient sorting algorithms through the `sort` package, supporting both built-in and custom types
    - **Testing**: Built-in testing framework with `testing` package, table-driven tests, mocking, and coverage analysis
    - **Benchmarking**: Integrated benchmarking tools to measure and optimize performance
    - **Process Execution**: Execute external commands with `os/exec`, manage I/O, and handle process lifecycle
    - **Signals**: Handle system signals for graceful shutdown, interruption, and inter-process communication
    - **Integration**: These utilities work together to create robust system-level applications
    - **Best Practices**: Proper error handling, resource management, and signal handling are critical
    - **Performance**: Understanding the performance characteristics of sorting and process operations

## Sorting in Go

Go's `sort` package provides powerful sorting capabilities for both built-in types and custom data structures. It implements efficient sorting algorithms and offers flexible interfaces for custom sorting logic.

!!! info "Sorting Algorithms in Go"
    ```mermaid
    graph TB
        A[Go Sort Package] --> B[Built-in Types]
        A --> C[Custom Types]
        A --> D[Sorting Interfaces]
        B --> E[Ints]
        B --> F[Float64s]
        B --> G[Strings]
        C --> H[Custom Structs]
        C --> I[Slices of Structs]
        D --> J[sort.Interface]
        D --> K[Less Function]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Sorting Built-in Types

!!! example "Sorting Basic Types"
    ```go title="basic_sorting.go" linums="1" hl_lines="8-40"
    package main

    import (
        "fmt"
        "sort"
    )

    func main() {
        // Sorting integers
        ints := []int{5, 2, 6, 3, 1, 4}
        fmt.Println("Before sorting:", ints)
        sort.Ints(ints)
        fmt.Println("After sorting:", ints)
        
        // Sorting floats
        floats := []float64{5.5, 2.2, 6.6, 3.3, 1.1, 4.4}
        fmt.Println("\nBefore sorting:", floats)
        sort.Float64s(floats)
        fmt.Println("After sorting:", floats)
        
        // Sorting strings
        strings := []string{"banana", "apple", "cherry", "date"}
        fmt.Println("\nBefore sorting:", strings)
        sort.Strings(strings)
        fmt.Println("After sorting:", strings)
        
        // Checking if sorted
        isSorted := sort.IntsAreSorted(ints)
        fmt.Println("\nAre ints sorted?", isSorted)
    }
    ```

### Sorting Custom Types

!!! example "Sorting Custom Structs"
    ```go title="custom_sorting.go" linums="1" hl_lines="8-60"
    package main

    import (
        "fmt"
        "sort"
    )

    // Person represents a person with name and age
    type Person struct {
        Name string
        Age  int
    }

    // ByAge implements sort.Interface for []Person based on Age field
    type ByAge []Person

    func (a ByAge) Len() int           { return len(a) }
    func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
    func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }

    // ByName implements sort.Interface for []Person based on Name field
    type ByName []Person

    func (a ByName) Len() int           { return len(a) }
    func (a ByName) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
    func (a ByName) Less(i, j int) bool { return a[i].Name < a[j].Name }

    func main() {
        people := []Person{
            {"Alice", 25},
            {"Bob", 30},
            {"Charlie", 20},
            {"David", 35},
        }
        
        fmt.Println("Original:")
        for _, p := range people {
            fmt.Printf("%s: %d\n", p.Name, p.Age)
        }
        
        // Sort by age
        fmt.Println("\nSorted by age:")
        sort.Sort(ByAge(people))
        for _, p := range people {
            fmt.Printf("%s: %d\n", p.Name, p.Age)
        }
        
        // Sort by name
        fmt.Println("\nSorted by name:")
        sort.Sort(ByName(people))
        for _, p := range people {
            fmt.Printf("%s: %d\n", p.Name, p.Age)
        }
    }
    ```

### Using sort.Slice for Custom Sorting

!!! example "Sort Slice with Custom Function"
    ```go title="sort_slice.go" linums="1" hl_lines="8-40"
    package main

    import (
        "fmt"
        "sort"
    )

    type Product struct {
        Name  string
        Price float64
        Sold  int
    }

    func main() {
        products := []Product{
            {"Laptop", 999.99, 50},
            {"Phone", 699.99, 120},
            {"Tablet", 399.99, 80},
            {"Monitor", 299.99, 60},
        }
        
        fmt.Println("Original:")
        for _, p := range products {
            fmt.Printf("%s: $%.2f (Sold: %d)\n", p.Name, p.Price, p.Sold)
        }
        
        // Sort by price ascending
        fmt.Println("\nSorted by price (ascending):")
        sort.Slice(products, func(i, j int) bool {
            return products[i].Price < products[j].Price
        })
        for _, p := range products {
            fmt.Printf("%s: $%.2f (Sold: %d)\n", p.Name, p.Price, p.Sold)
        }
        
        // Sort by sold units descending
        fmt.Println("\nSorted by sold units (descending):")
        sort.Slice(products, func(i, j int) bool {
            return products[i].Sold > products[j].Sold
        })
        for _, p := range products {
            fmt.Printf("%s: $%.2f (Sold: %d)\n", p.Name, p.Price, p.Sold)
        }
    }
    ```

### Stable Sorting

!!! example "Stable Sorting"
    ```go title="stable_sorting.go" linums="1" hl_lines="8-40"
    package main

    import (
        "fmt"
        "sort"
    )

    type Student struct {
        Name   string
        Grade  int
        Class  string
    }

    func main() {
        students := []Student{
            {"Alice", 85, "A"},
            {"Bob", 85, "B"},
            {"Charlie", 90, "A"},
            {"David", 85, "C"},
            {"Eve", 90, "B"},
        }
        
        fmt.Println("Original:")
        for _, s := range students {
            fmt.Printf("%s: Grade %d, Class %s\n", s.Name, s.Grade, s.Class)
        }
        
        // Sort by grade (unstable - order of same grades may change)
        fmt.Println("\nUnstable sort by grade:")
        sort.Slice(students, func(i, j int) bool {
            return students[i].Grade < students[j].Grade
        })
        for _, s := range students {
            fmt.Printf("%s: Grade %d, Class %s\n", s.Name, s.Grade, s.Class)
        }
        
        // Reset to original order
        students = []Student{
            {"Alice", 85, "A"},
            {"Bob", 85, "B"},
            {"Charlie", 90, "A"},
            {"David", 85, "C"},
            {"Eve", 90, "B"},
        }
        
        // Stable sort by grade (preserves original order for same grades)
        fmt.Println("\nStable sort by grade:")
        sort.SliceStable(students, func(i, j int) bool {
            return students[i].Grade < students[j].Grade
        })
        for _, s := range students {
            fmt.Printf("%s: Grade %d, Class %s\n", s.Name, s.Grade, s.Class)
        }
    }
    ```

## Testing and Benchmarking in Go

Go has a built-in testing framework that makes it easy to write tests and benchmarks for your code. The `testing` package provides the necessary tools to verify correctness and measure performance.

!!! info "Testing Framework Components"
    ```mermaid
    graph TB
        A[Testing Framework] --> B[Unit Tests]
        A --> C[Benchmarks]
        A --> D[Examples]
        A --> E[Coverage]
        B --> F[Table-driven Tests]
        B --> G[Mocking]
        C --> H[Performance Measurement]
        C --> I[Memory Allocation]
        D --> J[Documentation]
        E --> K[Coverage Reports]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Writing Unit Tests

!!! example "Basic Unit Test"
    ```go title="basic_test.go" linums="1" hl_lines="8-40"
    package main

    import (
        "testing"
    )

    // Add function to test
    func Add(a, b int) int {
        return a + b
    }

    // TestAdd tests the Add function
    func TestAdd(t *testing.T) {
        tests := []struct {
            name     string
            a, b     int
            expected int
        }{
            {"positive", 2, 3, 5},
            {"negative", -1, -1, -2},
            {"mixed", -1, 1, 0},
            {"zero", 0, 0, 0},
        }
        
        for _, tt := range tests {
            t.Run(tt.name, func(t *testing.T) {
                result := Add(tt.a, tt.b)
                if result != tt.expected {
                    t.Errorf("Add(%d, %d) = %d; want %d", tt.a, tt.b, result, tt.expected)
                }
            })
        }
    }
    ```

### Table-Driven Tests

!!! example "Table-Driven Test"
    ```go title="table_driven_test.go" linums="1" hl_lines="8-50"
    package main

    import (
        "strings"
        "testing"
    )

    // StringProcessor processes strings in various ways
    type StringProcessor struct{}

    func (sp *StringProcessor) ToUpper(s string) string {
        return strings.ToUpper(s)
    }

    func (sp *StringProcessor) ToLower(s string) string {
        return strings.ToLower(s)
    }

    func (sp *StringProcessor) Reverse(s string) string {
        runes := []rune(s)
        for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
            runes[i], runes[j] = runes[j], runes[i]
        }
        return string(runes)
    }

    func TestStringProcessor(t *testing.T) {
        sp := &StringProcessor{}
        
        tests := []struct {
            name     string
            method   func(string) string
            input    string
            expected string
        }{
            {"ToUpper", sp.ToUpper, "hello", "HELLO"},
            {"ToUpper empty", sp.ToUpper, "", ""},
            {"ToUpper mixed", sp.ToUpper, "HeLLo", "HELLO"},
            {"ToLower", sp.ToLower, "WORLD", "world"},
            {"ToLower empty", sp.ToLower, "", ""},
            {"ToLower mixed", sp.ToLower, "WoRlD", "world"},
            {"Reverse", sp.Reverse, "hello", "olleh"},
            {"Reverse empty", sp.Reverse, "", ""},
            {"Reverse palindrome", sp.Reverse, "madam", "madam"},
        }
        
        for _, tt := range tests {
            t.Run(tt.name, func(t *testing.T) {
                result := tt.method(tt.input)
                if result != tt.expected {
                    t.Errorf("%s(%q) = %q; want %q", tt.name, tt.input, result, tt.expected)
                }
            })
        }
    }
    ```

### Benchmarking

!!! example "Benchmarking Functions"
    ```go title="benchmarking.go" linums="1" hl_lines="8-60"
    package main

    import (
        "fmt"
        "math/rand"
        "sort"
        "testing"
        "time"
    )

    // GenerateRandomSlice generates a slice of random integers
    func GenerateRandomSlice(n int) []int {
        slice := make([]int, n)
        for i := range slice {
            slice[i] = rand.Intn(n)
        }
        return slice
    }

    // BubbleSort implements bubble sort algorithm
    func BubbleSort(slice []int) {
        n := len(slice)
        for i := 0; i < n-1; i++ {
            for j := 0; j < n-i-1; j++ {
                if slice[j] > slice[j+1] {
                    slice[j], slice[j+1] = slice[j+1], slice[j]
                }
            }
        }
    }

    // BenchmarkBubbleSort benchmarks the BubbleSort function
    func BenchmarkBubbleSort(b *testing.B) {
        sizes := []int{100, 1000, 10000}
        for _, size := range sizes {
            b.Run(fmt.Sprintf("Size_%d", size), func(b *testing.B) {
                data := GenerateRandomSlice(size)
                b.ResetTimer()
                for i := 0; i < b.N; i++ {
                    // Make a copy to sort
                    copy := make([]int, size)
                    copy(copy, data)
                    BubbleSort(copy)
                }
            })
        }
    }

    // BenchmarkStandardSort benchmarks Go's standard sort
    func BenchmarkStandardSort(b *testing.B) {
        sizes := []int{100, 1000, 10000}
        for _, size := range sizes {
            b.Run(fmt.Sprintf("Size_%d", size), func(b *testing.B) {
                data := GenerateRandomSlice(size)
                b.ResetTimer()
                for i := 0; i < b.N; i++ {
                    // Make a copy to sort
                    copy := make([]int, size)
                    copy(copy, data)
                    sort.Ints(copy)
                }
            })
        }
    }

    // BenchmarkTimeNow benchmarks time.Now()
    func BenchmarkTimeNow(b *testing.B) {
        for i := 0; i < b.N; i++ {
            _ = time.Now()
        }
    }
    ```

### Test Coverage

!!! example "Running Tests with Coverage"
    ```go title="coverage_example.go" linums="1" hl_lines="8-40"
    package main

    import (
        "errors"
        "strconv"
    )

    // Calculator performs basic arithmetic operations
    type Calculator struct{}

    // Add adds two numbers
    func (c *Calculator) Add(a, b float64) float64 {
        return a + b
    }

    // Subtract subtracts b from a
    func (c *Calculator) Subtract(a, b float64) float64 {
        return a - b
    }

    // Divide divides a by b
    func (c *Calculator) Divide(a, b float64) (float64, error) {
        if b == 0 {
            return 0, errors.New("division by zero")
        }
        return a / b, nil
    }

    // ParseInt parses a string to integer
    func (c *Calculator) ParseInt(s string) (int, error) {
        return strconv.Atoi(s)
    }
    ```

```go title="coverage_test.go" linums="1" hl_lines="8-50"
    package main

    import (
        "testing"
    )

    func TestCalculator_Add(t *testing.T) {
        calc := &Calculator{}
        result := calc.Add(2, 3)
        if result != 5 {
            t.Errorf("Expected 5, got %f", result)
        }
    }

    func TestCalculator_Subtract(t *testing.T) {
        calc := &Calculator{}
        result := calc.Subtract(5, 3)
        if result != 2 {
            t.Errorf("Expected 2, got %f", result)
        }
    }

    func TestCalculator_Divide(t *testing.T) {
        calc := &Calculator{}
        
        // Test normal division
        result, err := calc.Divide(10, 2)
        if err != nil {
            t.Errorf("Unexpected error: %v", err)
        }
        if result != 5 {
            t.Errorf("Expected 5, got %f", result)
        }
        
        // Test division by zero
        _, err = calc.Divide(10, 0)
        if err == nil {
            t.Error("Expected error for division by zero")
        }
    }

    func TestCalculator_ParseInt(t *testing.T) {
        calc := &Calculator{}
        
        // Test valid number
        result, err := calc.ParseInt("123")
        if err != nil {
            t.Errorf("Unexpected error: %v", err)
        }
        if result != 123 {
            t.Errorf("Expected 123, got %d", result)
        }
        
        // Test invalid number
        _, err = calc.ParseInt("abc")
        if err == nil {
            t.Error("Expected error for invalid number")
        }
    }
    ```

To run tests with coverage:
```bash
go test -cover
go test -coverprofile=coverage.out
go tool cover -html=coverage.out
```

## Executing Processes in Go

Go's `os/exec` package provides functionality to execute external commands. This is essential for system integration, running shell commands, and interacting with other programs.

!!! info "Process Execution Components"
    ```mermaid
    graph TB
        A[Process Execution] --> B[Command Creation]
        A --> C[I/O Management]
        A --> D[Process Control]
        B --> E[exec.Command]
        C --> F[Stdin/Stdout/Stderr]
        C --> G[Pipes]
        D --> H[Start/Wait/Kill]
        D --> I[Exit Codes]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Basic Command Execution

!!! example "Running Simple Commands"
    ```go title="basic_commands.go" linums="1" hl_lines="8-40"
    package main

    import (
        "fmt"
        "os/exec"
    )

    func main() {
        // Execute a simple command
        cmd := exec.Command("echo", "Hello, World!")
        output, err := cmd.Output()
        if err != nil {
            fmt.Printf("Error executing command: %v\n", err)
            return
        }
        fmt.Printf("Command output: %s", output)
        
        // Execute command with combined output
        cmd = exec.Command("ls", "-l")
        combinedOutput, err := cmd.CombinedOutput()
        if err != nil {
            fmt.Printf("Error executing command: %v\n", err)
            return
        }
        fmt.Printf("\nDirectory listing:\n%s", combinedOutput)
    }
    ```

### Command with Arguments and Environment

!!! example "Command with Arguments"
    ```go title="command_args.go" linums="1" hl_lines="8-50"
    package main

    import (
        "fmt"
        "os"
        "os/exec"
    )

    func main() {
        // Execute command with multiple arguments
        cmd := exec.Command("grep", "-r", "main", ".")
        
        // Set working directory
        cmd.Dir = "."
        
        // Add environment variables
        cmd.Env = append(os.Environ(), "MY_VAR=value")
        
        // Capture output
        output, err := cmd.Output()
        if err != nil {
            if exitErr, ok := err.(*exec.ExitError); ok {
                fmt.Printf("Command exited with status %d\n", exitErr.ExitCode())
            } else {
                fmt.Printf("Error executing command: %v\n", err)
            }
            return
        }
        
        fmt.Printf("Grep results:\n%s", output)
    }
    ```

### Interactive Command Execution

!!! example "Interactive Command"
    ```go title="interactive_command.go" linums="1" hl_lines="8-60"
    package main

    import (
        "bufio"
        "fmt"
        "io"
        "os/exec"
    )

    func main() {
        // Start an interactive command (like a shell)
        cmd := exec.Command("bash")
        
        // Get pipes for stdin, stdout, stderr
        stdin, err := cmd.StdinPipe()
        if err != nil {
            fmt.Printf("Error creating stdin pipe: %v\n", err)
            return
        }
        
        stdout, err := cmd.StdoutPipe()
        if err != nil {
            fmt.Printf("Error creating stdout pipe: %v\n", err)
            return
        }
        
        stderr, err := cmd.StderrPipe()
        if err != nil {
            fmt.Printf("Error creating stderr pipe: %v\n", err)
            return
        }
        
        // Start the command
        if err := cmd.Start(); err != nil {
            fmt.Printf("Error starting command: %v\n", err)
            return
        }
        
        // Write commands to stdin
        go func() {
            defer stdin.Close()
            commands := []string{
                "echo 'Hello from bash!'",
                "ls -l",
                "date",
                "exit",
            }
            for _, cmd := range commands {
                fmt.Fprintf(stdin, "%s\n", cmd)
            }
        }()
        
        // Read from stdout
        go func() {
            scanner := bufio.NewScanner(stdout)
            for scanner.Scan() {
                fmt.Printf("STDOUT: %s\n", scanner.Text())
            }
        }()
        
        // Read from stderr
        go func() {
            scanner := bufio.NewScanner(stderr)
            for scanner.Scan() {
                fmt.Printf("STDERR: %s\n", scanner.Text())
            }
        }()
        
        // Wait for command to finish
        if err := cmd.Wait(); err != nil {
            fmt.Printf("Command finished with error: %v\n", err)
        } else {
            fmt.Println("Command finished successfully")
        }
    }
    ```

### Process Management

!!! example "Process Management"
    ```go title="process_management.go" linums="1" hl_lines="8-70"
    package main

    import (
        "fmt"
        "os/exec"
        "syscall"
        "time"
    )

    func main() {
        // Start a long-running process
        cmd := exec.Command("sleep", "30")
        
        // Start the process
        if err := cmd.Start(); err != nil {
            fmt.Printf("Error starting process: %v\n", err)
            return
        }
        
        fmt.Printf("Started process with PID %d\n", cmd.Process.Pid)
        
        // Wait for a moment
        time.Sleep(2 * time.Second)
        
        // Check if process is running
        if cmd.ProcessState == nil || !cmd.ProcessState.Exited() {
            fmt.Println("Process is still running")
        } else {
            fmt.Println("Process has exited")
            return
        }
        
        // Send SIGTERM to the process
        fmt.Println("Sending SIGTERM to process...")
        if err := cmd.Process.Signal(syscall.SIGTERM); err != nil {
            fmt.Printf("Error sending signal: %v\n", err)
        }
        
        // Wait for process to exit
        if err := cmd.Wait(); err != nil {
            if exitErr, ok := err.(*exec.ExitError); ok {
                if status, ok := exitErr.Sys().(syscall.WaitStatus); ok {
                    fmt.Printf("Process exited with status: %d\n", status.ExitStatus())
                }
            } else {
                fmt.Printf("Error waiting for process: %v\n", err)
            }
        } else {
            fmt.Println("Process exited successfully")
        }
    }
    ```

## Signals in Go

Signals are a fundamental mechanism for inter-process communication in Unix-like systems. Go provides the `os/signal` package to handle signals, allowing programs to respond to system events like interruptions, termination requests, and other notifications.

!!! info "Signal Handling Components"
    ```mermaid
    graph TB
        A[Signal Handling] --> B[Signal Notification]
        A --> C[Signal Types]
        A --> D[Graceful Shutdown]
        B --> E[signal.Notify]
        C --> F[SIGINT]
        C --> G[SIGTERM]
        C --> H[SIGHUP]
        D --> I[Cleanup Resources]
        D --> J[Save State]
        style A fill:#999,stroke:#333,stroke-width:2px,color:#000
    ```

### Basic Signal Handling

!!! example "Basic Signal Handling"
    ```go title="basic_signals.go" linums="1" hl_lines="8-50"
    package main

    import (
        "fmt"
        "os"
        "os/signal"
        "syscall"
    )

    func main() {
        // Create a channel to receive signals
        sigChan := make(chan os.Signal, 1)
        
        // Notify on SIGINT (Ctrl+C) and SIGTERM
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        
        fmt.Println("Program started. Press Ctrl+C to send SIGINT...")
        
        // Wait for signal
        sig := <-sigChan
        fmt.Printf("Received signal: %v\n", sig)
        
        // Perform cleanup
        fmt.Println("Performing cleanup...")
        
        // Exit gracefully
        fmt.Println("Exiting gracefully")
    }
    ```

### Graceful Shutdown with Signals

!!! example "Graceful Shutdown"
    ```go title="graceful_shutdown.go" linums="1" hl_lines="8-80"
    package main

    import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"
    )

    func main() {
        // Create HTTP server
        server := &http.Server{
            Addr: ":8080",
        }
        
        // Start server in a goroutine
        go func() {
            fmt.Println("Server starting on :8080")
            if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
                fmt.Printf("Server error: %v\n", err)
            }
        }()
        
        // Set up signal handling
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        
        // Wait for signal
        sig := <-sigChan
        fmt.Printf("Received signal: %v\n", sig)
        
        // Create context with timeout for graceful shutdown
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        
        // Shutdown server gracefully
        fmt.Println("Shutting down server...")
        if err := server.Shutdown(ctx); err != nil {
            fmt.Printf("Server shutdown error: %v\n", err)
        }
        
        // Perform other cleanup
        fmt.Println("Performing cleanup...")
        time.Sleep(1 * time.Second)
        
        fmt.Println("Server stopped gracefully")
    }
    ```

### Handling Multiple Signals

!!! example "Multiple Signal Handling"
    ```go title="multiple_signals.go" linums="1" hl_lines="8-70"
    package main

    import (
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"
    )

    func main() {
        // Create channels for different signals
        sigChan := make(chan os.Signal, 1)
        reloadChan := make(chan os.Signal, 1)
        
        // Notify on different signals
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        signal.Notify(reloadChan, syscall.SIGHUP)
        
        fmt.Println("Program started. Send signals to test:")
        fmt.Println("- SIGINT or SIGTERM: Shutdown")
        fmt.Println("- SIGHUP: Reload configuration")
        
        // Main loop
        for {
            select {
            case sig := <-sigChan:
                fmt.Printf("Received shutdown signal: %v\n", sig)
                fmt.Println("Performing cleanup...")
                time.Sleep(1 * time.Second)
                fmt.Println("Exiting gracefully")
                return
                
            case sig := <-reloadChan:
                fmt.Printf("Received reload signal: %v\n", sig)
                fmt.Println("Reloading configuration...")
                // Simulate configuration reload
                time.Sleep(2 * time.Second)
                fmt.Println("Configuration reloaded")
                
            case <-time.After(5 * time.Second):
                fmt.Println("Still running...")
            }
        }
    }
    ```

### Signal Ignoring and Resetting

!!! example "Signal Ignoring"
    ```go title="signal_ignoring.go" linums="1" hl_lines="8-50"
    package main

    import (
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"
    )

    func main() {
        // Ignore SIGINT (Ctrl+C)
        signal.Ignore(syscall.SIGINT)
        fmt.Println("SIGINT is now ignored. Try pressing Ctrl+C...")
        
        // Wait for 5 seconds
        time.Sleep(5 * time.Second)
        fmt.Println("SIGINT was ignored")
        
        // Reset signal handling
        fmt.Println("Resetting signal handling...")
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT)
        
        fmt.Println("SIGINT is now handled. Try pressing Ctrl+C...")
        
        // Wait for signal
        sig := <-sigChan
        fmt.Printf("Received signal: %v\n", sig)
        fmt.Println("Exiting")
    }
    ```

## Real-World Example: System Utility with All Features

Let's create a comprehensive example that combines sorting, testing, process execution, and signal handling:

!!! example "System Utility"
    ```go title="system_utility.go" linums="1" hl_lines="8-150"
    package main

    import (
        "bufio"
        "fmt"
        "os"
        "os/exec"
        "os/signal"
        "sort"
        "syscall"
        "time"
    )

    // FileInfo represents file information
    type FileInfo struct {
        Name string
        Size int64
    }

    // BySize implements sort.Interface for []FileInfo based on Size
    type BySize []FileInfo

    func (a BySize) Len() int           { return len(a) }
    func (a BySize) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
    func (a BySize) Less(i, j int) bool { return a[i].Size < a[j].Size }

    // SystemUtility represents our system utility
    type SystemUtility struct {
        configPath string
        running    bool
    }

    // NewSystemUtility creates a new system utility
    func NewSystemUtility(configPath string) *SystemUtility {
        return &SystemUtility{
            configPath: configPath,
            running:    true,
        }
    }

    // ListFiles lists files in a directory and sorts them by size
    func (su *SystemUtility) ListFiles(dir string) ([]FileInfo, error) {
        cmd := exec.Command("ls", "-l", dir)
        output, err := cmd.Output()
        if err != nil {
            return nil, fmt.Errorf("failed to list files: %v", err)
        }
        
        var files []FileInfo
        scanner := bufio.NewScanner(bufio.NewReader(bytes.NewReader(output)))
        
        // Skip first line (total)
        scanner.Scan()
        
        for scanner.Scan() {
            line := scanner.Text()
            // Parse line to extract file name and size
            // This is a simplified parser
            fields := strings.Fields(line)
            if len(fields) < 9 {
                continue
            }
            
            sizeStr := fields[4]
            size, err := strconv.ParseInt(sizeStr, 10, 64)
            if err != nil {
                continue
            }
            
            name := fields[8]
            files = append(files, FileInfo{Name: name, Size: size})
        }
        
        // Sort files by size
        sort.Sort(BySize(files))
        
        return files, nil
    }

    // RunCommand executes a command and returns its output
    func (su *SystemUtility) RunCommand(name string, args ...string) (string, error) {
        cmd := exec.Command(name, args...)
        output, err := cmd.CombinedOutput()
        if err != nil {
            return "", fmt.Errorf("command failed: %v", err)
        }
        return string(output), nil
    }

    // ReloadConfig reloads the configuration
    func (su *SystemUtility) ReloadConfig() error {
        fmt.Println("Reloading configuration from", su.configPath)
        // Simulate config reload
        time.Sleep(1 * time.Second)
        fmt.Println("Configuration reloaded successfully")
        return nil
    }

    // Shutdown performs graceful shutdown
    func (su *SystemUtility) Shutdown() {
        fmt.Println("Initiating graceful shutdown...")
        su.running = false
        time.Sleep(1 * time.Second)
        fmt.Println("Shutdown complete")
    }

    // Run starts the system utility
    func (su *SystemUtility) Run() {
        // Set up signal handling
        sigChan := make(chan os.Signal, 1)
        reloadChan := make(chan os.Signal, 1)
        
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        signal.Notify(reloadChan, syscall.SIGHUP)
        
        fmt.Println("System utility started")
        fmt.Println("Available commands:")
        fmt.Println("- list <dir>: List files in directory sorted by size")
        fmt.Println("- exec <command>: Execute a command")
        fmt.Println("- reload: Reload configuration")
        fmt.Println("- exit: Exit the utility")
        fmt.Println("Signals:")
        fmt.Println("- SIGINT/SIGTERM: Graceful shutdown")
        fmt.Println("- SIGHUP: Reload configuration")
        
        // Main loop
        for su.running {
            select {
            case sig := <-sigChan:
                fmt.Printf("Received shutdown signal: %v\n", sig)
                su.Shutdown()
                return
                
            case <-reloadChan:
                fmt.Println("Received SIGHUP signal")
                if err := su.ReloadConfig(); err != nil {
                    fmt.Printf("Error reloading config: %v\n", err)
                }
                
            default:
                // Read user input
                fmt.Print("> ")
                scanner := bufio.NewScanner(os.Stdin)
                if !scanner.Scan() {
                    break
                }
                
                input := scanner.Text()
                parts := strings.Fields(input)
                if len(parts) == 0 {
                    continue
                }
                
                switch parts[0] {
                case "list":
                    if len(parts) < 2 {
                        fmt.Println("Usage: list <directory>")
                        continue
                    }
                    files, err := su.ListFiles(parts[1])
                    if err != nil {
                        fmt.Printf("Error: %v\n", err)
                        continue
                    }
                    fmt.Println("Files sorted by size:")
                    for _, file := range files {
                        fmt.Printf("%-20s %10d bytes\n", file.Name, file.Size)
                    }
                    
                case "exec":
                    if len(parts) < 2 {
                        fmt.Println("Usage: exec <command> [args...]")
                        continue
                    }
                    output, err := su.RunCommand(parts[1], parts[2:]...)
                    if err != nil {
                        fmt.Printf("Error: %v\n", err)
                        continue
                    }
                    fmt.Println(output)
                    
                case "reload":
                    if err := su.ReloadConfig(); err != nil {
                        fmt.Printf("Error: %v\n", err)
                    }
                    
                case "exit":
                    su.Shutdown()
                    return
                    
                default:
                    fmt.Println("Unknown command. Available commands: list, exec, reload, exit")
                }
            }
        }
    }

    func main() {
        // Create and run system utility
        utility := NewSystemUtility("config.json")
        utility.Run()
    }
    ```

### How This Example Demonstrates All Concepts:

1. **Sorting**:
   - Custom sorting of file information by size
   - Implementation of sort.Interface for custom types
   - Use of both sort.Sort and custom sorting logic

2. **Testing**:
   - While not shown in the example, this code would be accompanied by comprehensive tests
   - Each method would have unit tests with various scenarios
   - Benchmarks would measure performance of file listing and command execution

3. **Process Execution**:
   - Execution of external commands (ls)
   - Capturing and parsing command output
   - Error handling for command execution

4. **Signal Handling**:
   - Handling SIGINT and SIGTERM for graceful shutdown
   - Handling SIGHUP for configuration reload
   - Proper cleanup and resource management

5. **Integration**:
   - All components work together in a cohesive system utility
   - Proper error handling throughout
   - Graceful shutdown with signal handling

## Quick Reference

!!! success "Key Takeaways"
    - **Sorting**: Use `sort` package for efficient sorting of built-in and custom types
    - **Testing**: Leverage `testing` package for unit tests, benchmarks, and coverage analysis
    - **Process Execution**: Use `os/exec` to run external commands with proper I/O and error handling
    - **Signals**: Handle system signals with `os/signal` for graceful shutdown and inter-process communication
    - **Best Practices**: Always handle errors, manage resources properly, and implement graceful shutdown
    - **Performance**: Use benchmarks to measure and optimize performance-critical code
    - **Integration**: These utilities often work together in system-level applications
    - **Testing Strategies**: Use table-driven tests for comprehensive coverage and mocking for external dependencies
    - **Process Management**: Properly manage process lifecycle, including start, wait, and termination
    - **Signal Handling**: Implement signal handling for robust applications that respond to system events

!!! quote "Remember"
    "Go's utilities and system operations provide a powerful toolkit for building robust system-level applications. By mastering sorting algorithms, testing methodologies, process execution, and signal handling, you can create efficient, reliable software that integrates seamlessly with the operating system. The key is to understand not just how to use these tools, but when and why to use them, and how they work together to create cohesive, maintainable systems."