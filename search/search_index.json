{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>About Go</p> <p>\"Go will be the server language of the future.\" - Tobias L\u00fctke, Shopify</p> <p>What is Go?</p> <p>Go (or Golang) is a modern, open-source programming language created by Google engineers  Robert Griesemer, Rob Pike, and Ken Thompson. Launched in 2009 and publicly  released in 2012, Go bridges the gap between:</p> <ul> <li>High-performance statically typed languages (like C++)</li> <li>Developer-friendly dynamic languages (like Python)</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#simplicity-and-readability","title":"Simplicity and Readability","text":"<p>Clean and Simple</p> <ul> <li>Only 25 keywords in total</li> <li>Easy to learn and read</li> <li>Built-in <code>gofmt</code> tool for consistent formatting</li> <li>Reduces cognitive load on developers</li> </ul>"},{"location":"#strong-typing-with-inference","title":"Strong Typing with Inference","text":"<p>Type System</p> <pre><code>// Explicit typing\nvar age int = 25\n\n// Type inference\nname := \"Go\"  // Compiler infers string type\n</code></pre> <p>Go combines safety with convenience through its smart type system.</p>"},{"location":"#excellent-concurrency-support","title":"Excellent Concurrency Support","text":"<p>Built for Modern Computing</p> GoroutinesChannels <p>Lightweight threads that make concurrent programming simple: <pre><code>go function()  // Runs in background\n</code></pre></p> <p>Type-safe communication between goroutines: <pre><code>ch := make(chan string)\nch &lt;- \"message\"  // Send\nmsg := &lt;-ch     // Receive\n</code></pre></p>"},{"location":"#fast-compilation","title":"Fast Compilation","text":"<p>Speed Features</p> <ul> <li>Smart dependency management</li> <li>Optimized build system</li> <li>Quick compile times even for large projects</li> <li>Enhanced developer productivity</li> </ul>"},{"location":"#garbage-collection","title":"Garbage Collection","text":"<p>Memory Management</p> <ul> <li>Automatic memory management</li> <li>Efficient garbage collector</li> <li>No manual memory allocation/deallocation</li> <li>Optimized for performance</li> </ul>"},{"location":"#rich-standard-library","title":"Rich Standard Library","text":"<p>Built-in Packages</p> <ul> <li>Networking</li> <li>Cryptography</li> <li>HTTP servers</li> <li>JSON/XML processing</li> <li>Testing frameworks</li> <li>And much more!</li> </ul>"},{"location":"#cross-platform-compilation","title":"Cross-Platform Compilation","text":"<p>Build Once, Run Anywhere</p> <pre><code># Build for Windows from Linux\nGOOS=windows GOARCH=amd64 go build\n\n# Build for Mac from Linux\nGOOS=darwin GOARCH=amd64 go build\n</code></pre>"},{"location":"#perfect-use-cases","title":"Perfect Use Cases","text":"<p>Where Go Shines</p> Cloud NativeNetwork ServicesCLI ToolsMicroservices <p></p> <ul> <li>Powers Docker and Kubernetes</li> <li>Excellent for cloud infrastructure</li> <li>Built for scalability</li> <li>Container-friendly design</li> </ul> <ul> <li>High-performance servers</li> <li>Real-time applications</li> <li>API services</li> <li>Web servers</li> </ul> <p><pre><code>// Single binary output\npackage main\nfunc main() {\n    // Your CLI tool\n}\n</code></pre> - Dependency-free binaries - Cross-platform support - Fast execution - Easy distribution</p> <ul> <li>Quick startup time</li> <li>Low memory footprint</li> <li>Built-in HTTP support</li> <li>Easy deployment</li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>Go Proverb</p> <p>\"Less is exponentially more\" - Rob Pike</p> <p>Design Principles</p> <ul> <li> Simplicity over complexity</li> <li> Clarity over cleverness</li> <li> Practicality over theory</li> <li> Performance without obscurity</li> </ul> <p>Go 1.18+ added generics while maintaining these core values!</p>"},{"location":"#community-and-ecosystem","title":"Community and Ecosystem","text":"<p>Growing Community</p> BackingMajor Users <ul> <li>Supported by Google</li> <li>Open governance model</li> <li>Active community input</li> <li>Regular releases</li> </ul> <ul> <li></li> <li></li> <li></li> </ul>"},{"location":"#ready-to-start","title":"Ready to Start?","text":"<p>Next Steps</p> <ol> <li>Install Go</li> <li>Try Hello World</li> <li>Explore the documentation</li> <li>Join the community</li> </ol> <p>Final Thought</p> <p>Go represents the future of systems programming - combining performance,  simplicity, and developer productivity. Whether you're building microservices,  cloud infrastructure, or command-line tools, Go provides the perfect balance  of power and ease of use.</p>"},{"location":"1.%20Basics/1.%20Hello-World/","title":"Go: Hello World!","text":"<p>Overview</p> <p>Learn how to write and run your first Go program. This guide covers the essential concepts of creating a simple \"Hello, World!\" application in Go, a modern programming language known for its simplicity and efficiency.</p> <p>Prerequisites</p> <p>Before starting, ensure you have:</p> <ul> <li>Go installed on your system</li> <li>A text editor or IDE</li> <li>Basic understanding of using the terminal</li> </ul>"},{"location":"1.%20Basics/1.%20Hello-World/#checking-your-go-installation","title":"Checking Your Go Installation","text":"<p>First, verify that Go is properly installed on your system by running this command in your terminal:</p> <pre><code>go version\n</code></pre> <p>You should see output similar to this:</p> Terminal Output<pre><code>#$ go version \ngo1.25.1 X:nodwarf5 linux/amd64\n</code></pre> <p>Not Installed?</p> <p>If you see a \"command not found\" error, you'll need to download and install Go first.</p>"},{"location":"1.%20Basics/1.%20Hello-World/#writing-your-first-go-program","title":"Writing Your First Go Program","text":"<p>Let's create a simple program that prints \"Hello, World!\" to the console.</p> Step 1: Create FileStep 2: Add Code <p>Open a directory of your choice in your terminal and Create a new file named <code>hello.go</code> in your preferred directory. If you are on linux you can type <code>touch hello.go</code> in your terminal.</p> <p>Copy this code into your <code>hello.go</code> file:</p> hello.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}\n</code></pre>"},{"location":"1.%20Basics/1.%20Hello-World/#understanding-the-code","title":"Understanding the Code","text":"<p>Let's break down each component of our program:</p> <p>Code Structure</p> Package DeclarationImport StatementMain Function <pre><code>package main\n</code></pre> <ul> <li>Every Go program starts with a package declaration</li> <li><code>main</code> package creates an executable program</li> <li>Other packages create reusable libraries</li> </ul> <pre><code>import \"fmt\"\n</code></pre> <ul> <li>Imports the formatting package <code>fmt</code></li> <li>Provides functions for input/output</li> <li>Essential for console interaction</li> </ul> <pre><code>func main() {\n    fmt.Println(\"Hello, World!\")\n}\n</code></pre> <ul> <li>Entry point of the program</li> <li><code>fmt.Println()</code> prints text and adds a newline</li> <li>Program execution starts here</li> </ul> <p>If you have noticed in the program, the line <code>fmt.Println(\"Hello, World!\")</code>, you may wonder why the <code>Println</code> function is in all caps. This is because <code>Println</code> is a function from the <code>fmt</code> package that is used to print text to the console. The <code>fmt</code> package is part of the Go standard library and provides functions for formatted I/O. The <code>Println</code> function is one of the most commonly used functions in the <code>fmt</code> package. It stands for \"Print Line\" and is used to print text to the console with a newline at the end. The <code>Println</code> function is case-sensitive and must be written in all caps, that way the Go compiler knows that you are referring to the <code>Println</code> function from the <code>fmt</code> package.</p>"},{"location":"1.%20Basics/1.%20Hello-World/#running-our-program","title":"Running Our Program","text":"<p>There are two ways to run your Go program. Let's explore both methods:</p> Method 1: Direct ExecutionMethod 2: Build &amp; Execute <p>Use <code>go run</code> to compile and execute in one step: Terminal<pre><code>go run hello.go\n</code></pre></p> Output<pre><code>Hello, World!\n</code></pre> <p>Quick Development</p> <p>This method is perfect for development and testing as it's faster for quick iterations.</p> <p>1\ufe0f\u20e3 First, compile the program: Terminal<pre><code>go build hello.go\n</code></pre></p> <p>2\ufe0f\u20e3 Then run the executable: Terminal - Linux/macOS<pre><code>./hello\n</code></pre> Terminal - Windows<pre><code>hello.exe\n</code></pre></p> <p>Production Use</p> <p>This method creates an executable file that you can distribute and run without Go installed.</p>"},{"location":"1.%20Basics/1.%20Hello-World/#print-functions","title":"Print Functions","text":"<p>Go provides several ways to output text. Here are some variations of our Hello World program:</p> <p>Print Variations</p> Using fmt.PrintfMultiple Print Statements hello.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Printf(\"Hello, World!\\n\")  // Formatted print\n}\n</code></pre> <p>Tip</p> <p><code>Printf</code> allows formatted strings using placeholders like <code>%s</code>, <code>%d</code>, etc.</p> hello.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Print(\"Hello, \")     // Prints without newline\n    fmt.Println(\"World!\")    // Prints with newline\n}\n</code></pre> <p>Tip</p> <p>Combine <code>Print</code> and <code>Println</code> for flexible output formatting.</p>"},{"location":"1.%20Basics/1.%20Hello-World/#whats-next","title":"What's Next?","text":"<p>Congratulations!</p> <p>You've successfully written and run your first Go program! Here's what you've learned:</p> <ul> <li>Setting up Go</li> <li>Creating a Go source file</li> <li>Understanding basic Go syntax</li> <li>Running Go programs</li> <li>Using different print functions</li> </ul> <p>Next Steps</p> <p>Ready to learn more? Continue exploring:</p> <ul> <li>Go data types and variables</li> <li>Control structures (if, for, switch)</li> <li>Functions and packages</li> </ul>"},{"location":"1.%20Basics/10.%20Range/","title":"Go Range: Iteration Mastery","text":"<p>Overview</p> <p>Master Go's powerful <code>range</code> keyword for elegant iteration across all data structures. This comprehensive guide covers range patterns for arrays, slices, strings, maps, and channels, building upon our understanding of Go's collection types and control flow.</p> <p>Key Points</p> <ul> <li>Universal iteration keyword for all Go collections</li> <li>Returns different values based on data structure type</li> <li>Supports index-only, value-only, and both patterns</li> <li>Essential for idiomatic Go iteration</li> <li>Memory-efficient and performance-optimized</li> </ul>"},{"location":"1.%20Basics/10.%20Range/#understanding-range-in-go","title":"Understanding Range in Go","text":"<p>The <code>range</code> keyword is Go's universal iterator, providing a clean and consistent way to traverse collections. It adapts to different data structures while maintaining a uniform syntax pattern.</p> <p>Range Return Values</p> <pre><code>graph TD\n    A[range keyword] --&gt; B[Arrays/Slices]\n    A --&gt; C[Strings]\n    A --&gt; D[Maps]\n    A --&gt; E[Channels]\n    B --&gt; F[index, value]\n    C --&gt; G[byte_index, rune]\n    D --&gt; H[key, value]\n    E --&gt; I[value only]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000\n    style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px\n    style E fill:#fff3e0,stroke:#e65100,stroke-width:2px</code></pre>"},{"location":"1.%20Basics/10.%20Range/#range-with-arrays-and-slices","title":"Range with Arrays and Slices","text":"<p>Arrays and slices are the most common targets for range iteration, providing both index and value access.</p>"},{"location":"1.%20Basics/10.%20Range/#basic-array-and-slice-iteration","title":"Basic Array and Slice Iteration","text":"<p>Array and Slice Range Patterns</p> Index and ValueIndex OnlyValue Only array_slice_range.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fruits := []string{\"apple\", \"banana\", \"cherry\", \"date\"}\n\n    // Iterate with both index and value\n    for index, fruit := range fruits {\n        fmt.Printf(\"Index %d: %s\\n\", index, fruit)\n    }\n\n    // Output:\n    // Index 0: apple\n    // Index 1: banana\n    // Index 2: cherry\n    // Index 3: date\n}\n</code></pre> index_only.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{10, 20, 30, 40, 50}\n\n    // Iterate over indices only\n    for index := range numbers {\n        fmt.Printf(\"Index: %d, Value: %d\\n\", index, numbers[index])\n    }\n\n    // Useful for modifying elements in place\n    for i := range numbers {\n        numbers[i] *= 2  // Double each value\n    }\n\n    fmt.Printf(\"Doubled: %v\\n\", numbers)\n}\n</code></pre> value_only.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := []int{95, 87, 92, 78, 89}\n\n    // Iterate over values only (ignore index)\n    total := 0\n    for _, score := range scores {\n        total += score\n    }\n\n    average := float64(total) / float64(len(scores))\n    fmt.Printf(\"Average score: %.2f\\n\", average)\n    // Output: Average score: 88.20\n}\n</code></pre>"},{"location":"1.%20Basics/10.%20Range/#range-with-strings","title":"Range with Strings","text":"<p>String iteration with range provides access to Unicode runes, making it perfect for international text processing.</p>"},{"location":"1.%20Basics/10.%20Range/#string-iteration-patterns","title":"String Iteration Patterns","text":"<p>String Range Operations</p> Character and PositionCharacters OnlyUnicode Processing string_range.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    text := \"Hello, \u4e16\u754c!\"\n\n    // Iterate over byte index and rune\n    for byteIndex, char := range text {\n        fmt.Printf(\"Byte %d: %c (Unicode: U+%04X)\\n\", byteIndex, char, char)\n    }\n\n    // Output:\n    // Byte 0: H (Unicode: U+0048)\n    // Byte 1: e (Unicode: U+0065)\n    // ...\n    // Byte 7: \u4e16 (Unicode: U+4E16)\n    // Byte 10: \u754c (Unicode: U+754C)\n}\n</code></pre> chars_only.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    greeting := \"Go\u8bed\u8a00\u7f16\u7a0b\"\n\n    // Iterate over characters only\n    fmt.Print(\"Characters: \")\n    for _, char := range greeting {\n        fmt.Printf(\"%c \", char)\n    }\n    fmt.Println()\n\n    // Output: Characters: G o \u8bed \u8a00 \u7f16 \u7a0b\n}\n</code></pre> unicode_processing.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"unicode\"\n)\n\nfunc main() {\n    text := \"Hello123\u4e16\u754c!\"\n\n    // Categorize characters\n    for _, char := range text {\n        switch {\n        case unicode.IsLetter(char):\n            fmt.Printf(\"%c is a letter\\n\", char)\n        case unicode.IsDigit(char):\n            fmt.Printf(\"%c is a digit\\n\", char)\n        case unicode.IsPunct(char):\n            fmt.Printf(\"%c is punctuation\\n\", char)\n        }\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/10.%20Range/#range-with-maps","title":"Range with Maps","text":"<p>Map iteration provides access to key-value pairs, with flexible patterns for different use cases.</p>"},{"location":"1.%20Basics/10.%20Range/#map-iteration-techniques","title":"Map Iteration Techniques","text":"<p>Map Range Patterns</p> Keys and ValuesKeys OnlyValues Only map_range.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    inventory := map[string]int{\n        \"apples\": 50, \"bananas\": 30, \"oranges\": 25,\n    }\n\n    // Iterate over keys and values\n    for item, count := range inventory {\n        fmt.Printf(\"%s: %d in stock\\n\", item, count)\n    }\n\n    // Note: Map iteration order is not guaranteed\n}\n</code></pre> keys_only.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    settings := map[string]bool{\n        \"debug\": true, \"verbose\": false, \"logging\": true,\n    }\n\n    // Collect all setting names\n    var settingNames []string\n    for setting := range settings {\n        settingNames = append(settingNames, setting)\n    }\n\n    fmt.Printf(\"Available settings: %v\\n\", settingNames)\n}\n</code></pre> values_only.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := map[string]int{\n        \"Alice\": 95, \"Bob\": 87, \"Charlie\": 92,\n    }\n\n    // Calculate total score\n    total := 0\n    for _, score := range scores {\n        total += score\n    }\n\n    fmt.Printf(\"Total score: %d\\n\", total)\n}\n</code></pre>"},{"location":"1.%20Basics/10.%20Range/#advanced-range-techniques","title":"Advanced Range Techniques","text":""},{"location":"1.%20Basics/10.%20Range/#modifying-collections-during-iteration","title":"Modifying Collections During Iteration","text":"<p>Safe Modification Patterns</p> In-Place Slice ModificationFiltering with RangeNested Structure Iteration slice_modification.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n\n    // Safe: Modify elements using index\n    for i := range numbers {\n        numbers[i] = numbers[i] * numbers[i]  // Square each number\n    }\n\n    fmt.Printf(\"Squared: %v\\n\", numbers)\n    // Output: Squared: [1 4 9 16 25]\n}\n</code></pre> filtering.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Filter even numbers\n    var evens []int\n    for _, num := range numbers {\n        if num%2 == 0 {\n            evens = append(evens, num)\n        }\n    }\n\n    fmt.Printf(\"Even numbers: %v\\n\", evens)\n}\n</code></pre> nested_iteration.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    matrix := [][]int{\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9},\n    }\n\n    // Iterate over 2D slice\n    for rowIdx, row := range matrix {\n        for colIdx, value := range row {\n            fmt.Printf(\"matrix[%d][%d] = %d\\n\", rowIdx, colIdx, value)\n        }\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/10.%20Range/#channel-iteration","title":"Channel Iteration","text":"<p>Channel Range Patterns</p> Basic Channel IterationProducer-Consumer Pattern channel_range.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    ch := make(chan int, 3)\n\n    // Send values and close\n    ch &lt;- 1\n    ch &lt;- 2\n    ch &lt;- 3\n    close(ch)\n\n    // Range automatically stops when channel is closed\n    for value := range ch {\n        fmt.Printf(\"Received: %d\\n\", value)\n    }\n\n    // Output:\n    // Received: 1\n    // Received: 2\n    // Received: 3\n}\n</code></pre> producer_consumer.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    ch := make(chan string, 2)\n\n    // Producer goroutine\n    go func() {\n        defer close(ch)\n        for i := 1; i &lt;= 3; i++ {\n            ch &lt;- fmt.Sprintf(\"message-%d\", i)\n        }\n    }()\n\n    // Consumer using range\n    for message := range ch {\n        fmt.Printf(\"Processing: %s\\n\", message)\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/10.%20Range/#best-practices-and-performance","title":"Best Practices and Performance","text":"<p>Range Best Practices</p> <ol> <li> <p>Use Blank Identifier Wisely <pre><code>// Good: Only get what you need\nfor i := range slice { /* index only */ }\nfor _, v := range slice { /* value only */ }\n\n// Avoid: Unnecessary assignments\nfor i, _ := range slice { /* wasteful */ }\n</code></pre></p> </li> <li> <p>Understand Value Copying <pre><code>// Values are copied - modifications won't affect original\nfor _, item := range items {\n    item.field = \"changed\"  // Won't change original\n}\n\n// Use index for modifications\nfor i := range items {\n    items[i].field = \"changed\"  // Will change original\n}\n</code></pre></p> </li> <li> <p>Handle Map Iteration Order <pre><code>// Don't rely on iteration order\nfor key, value := range myMap {\n    // Order is not guaranteed\n}\n\n// Sort keys if order matters\nkeys := make([]string, 0, len(myMap))\nfor k := range myMap {\n    keys = append(keys, k)\n}\nsort.Strings(keys)\n</code></pre></p> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Loop Variable Capture: In goroutines, capture loop variables properly</li> <li>Slice Modification: Don't modify slice length during iteration</li> <li>String vs Bytes: Range over strings gives runes, not bytes</li> <li>Map Order: Never rely on map iteration order</li> </ul>"},{"location":"1.%20Basics/10.%20Range/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>Universal Syntax: <code>for key, value := range collection</code></li> <li>Flexible Patterns: Use <code>_</code> to ignore unneeded values</li> <li>Type-Specific Returns: Different collections return different value types</li> <li>Safe Iteration: Range handles bounds checking automatically</li> <li>Unicode Aware: String iteration properly handles Unicode runes</li> <li>Performance: Efficient iteration without manual index management</li> </ol> <p>Remember</p> <p>\"Range is Go's universal iterator. Master its patterns for each collection type, understand value copying semantics, and always use the blank identifier for values you don't need. When in doubt, range it out!\"</p>"},{"location":"1.%20Basics/11.%20Functions/","title":"Go Functions: Building Blocks of Code","text":"<p>Overview</p> <p>Master Go's powerful function system for creating modular, reusable code. This comprehensive guide covers function definitions, parameters, return values, variadic functions, and advanced concepts, building upon our understanding of Go's type system and control flow.</p> <p>Key Points</p> <ul> <li>Functions are first-class citizens in Go</li> <li>Support multiple return values and named returns</li> <li>Variadic functions for flexible parameter lists</li> <li>Function types and higher-order functions</li> <li>Closures and anonymous functions</li> </ul>"},{"location":"1.%20Basics/11.%20Functions/#understanding-functions-in-go","title":"Understanding Functions in Go","text":"<p>Functions are the fundamental building blocks of Go programs, providing code organization, reusability, and modularity. Go's function system is both powerful and elegant, supporting advanced features while maintaining simplicity.</p> <p>Function Architecture</p> <pre><code>graph TD\n    A[Go Function] --&gt; B[Parameters]\n    A --&gt; C[Return Values]\n    A --&gt; D[Function Body]\n    B --&gt; E[Named Parameters]\n    B --&gt; F[Variadic Parameters]\n    C --&gt; G[Single Return]\n    C --&gt; H[Multiple Returns]\n    C --&gt; I[Named Returns]\n    D --&gt; J[Local Variables]\n    D --&gt; K[Closures]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000\n    style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px</code></pre>"},{"location":"1.%20Basics/11.%20Functions/#basic-function-definitions","title":"Basic Function Definitions","text":"<p>Go functions use the <code>func</code> keyword and support various parameter and return patterns.</p>"},{"location":"1.%20Basics/11.%20Functions/#function-declaration-patterns","title":"Function Declaration Patterns","text":"<p>Basic Function Syntax</p> Simple FunctionsNo Return ValueComplex Parameters basic_functions.go<pre><code>package main\n\nimport \"fmt\"\n\n// Basic function with parameters and return value\nfunc add(a int, b int) int {\n    return a + b\n}\n\n// Function with same-type parameters (shorthand)\nfunc multiply(x, y int) int {\n    return x * y\n}\n\n// Function without parameters\nfunc greet() string {\n    return \"Hello, World!\"\n}\n\nfunc main() {\n    sum := add(5, 3)\n    product := multiply(4, 7)\n    message := greet()\n\n    fmt.Printf(\"Sum: %d, Product: %d\\n\", sum, product)\n    fmt.Printf(\"Message: %s\\n\", message)\n}\n</code></pre> void_functions.go<pre><code>package main\n\nimport \"fmt\"\n\n// Function that performs action without returning value\nfunc printInfo(name string, age int) {\n    fmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n}\n\n// Function with no parameters and no return\nfunc sayHello() {\n    fmt.Println(\"Hello from Go!\")\n}\n\nfunc main() {\n    printInfo(\"Alice\", 25)\n    sayHello()\n\n    // Output:\n    // Name: Alice, Age: 25\n    // Hello from Go!\n}\n</code></pre> complex_params.go<pre><code>package main\n\nimport \"fmt\"\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\n// Function with struct parameter\nfunc describePerson(p Person) string {\n    return fmt.Sprintf(\"%s is %d years old\", p.Name, p.Age)\n}\n\n// Function with slice parameter\nfunc sumSlice(numbers []int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}\n\nfunc main() {\n    person := Person{Name: \"Bob\", Age: 30}\n    description := describePerson(person)\n\n    numbers := []int{1, 2, 3, 4, 5}\n    total := sumSlice(numbers)\n\n    fmt.Println(description)\n    fmt.Printf(\"Sum: %d\\n\", total)\n}\n</code></pre>"},{"location":"1.%20Basics/11.%20Functions/#multiple-return-values","title":"Multiple Return Values","text":"<p>Go's support for multiple return values is one of its most distinctive features, enabling elegant error handling and data processing.</p>"},{"location":"1.%20Basics/11.%20Functions/#multiple-return-patterns","title":"Multiple Return Patterns","text":"<p>Multiple Return Values</p> Basic Multiple ReturnsNamed Return ValuesIgnoring Return Values multiple_returns.go<pre><code>package main\n\nimport \"fmt\"\n\n// Function returning multiple values\nfunc divmod(a, b int) (int, int) {\n    quotient := a / b\n    remainder := a % b\n    return quotient, remainder\n}\n\n// Function with error handling pattern\nfunc safeDivide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, fmt.Errorf(\"division by zero\")\n    }\n    return a / b, nil\n}\n\nfunc main() {\n    q, r := divmod(17, 5)\n    fmt.Printf(\"17 \u00f7 5 = %d remainder %d\\n\", q, r)\n\n    result, err := safeDivide(10, 2)\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n    } else {\n        fmt.Printf(\"Result: %.2f\\n\", result)\n    }\n}\n</code></pre> named_returns.go<pre><code>package main\n\nimport \"fmt\"\n\n// Named return values for clarity\nfunc rectangle(length, width float64) (area, perimeter float64) {\n    area = length * width\n    perimeter = 2 * (length + width)\n    return  // naked return\n}\n\n// Named returns with early return\nfunc processNumber(n int) (result int, isEven bool) {\n    if n &lt; 0 {\n        result = 0\n        isEven = false\n        return\n    }\n\n    result = n * n\n    isEven = n%2 == 0\n    return\n}\n\nfunc main() {\n    a, p := rectangle(5.0, 3.0)\n    fmt.Printf(\"Rectangle: Area=%.1f, Perimeter=%.1f\\n\", a, p)\n\n    res, even := processNumber(4)\n    fmt.Printf(\"Number 4: Square=%d, Even=%t\\n\", res, even)\n}\n</code></pre> ignore_returns.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc main() {\n    // Ignore error return value (not recommended)\n    value, _ := strconv.Atoi(\"123\")\n    fmt.Printf(\"Parsed value: %d\\n\", value)\n\n    // Ignore first return value\n    _, remainder := divmod(17, 5)\n    fmt.Printf(\"Remainder only: %d\\n\", remainder)\n\n    // Use all return values\n    quotient, remainder2 := divmod(20, 3)\n    fmt.Printf(\"20 \u00f7 3 = %d remainder %d\\n\", quotient, remainder2)\n}\n\nfunc divmod(a, b int) (int, int) {\n    return a / b, a % b\n}\n</code></pre>"},{"location":"1.%20Basics/11.%20Functions/#variadic-functions","title":"Variadic Functions","text":"<p>Variadic functions accept a variable number of arguments, providing flexibility for functions that need to process multiple values.</p>"},{"location":"1.%20Basics/11.%20Functions/#variadic-function-patterns","title":"Variadic Function Patterns","text":"<p>Variadic Functions</p> Basic VariadicSlice Expansion variadic_basic.go<pre><code>package main\n\nimport \"fmt\"\n\n// Variadic function with int parameters\nfunc sum(numbers ...int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}\n\n// Variadic function with string parameters\nfunc concatenate(separator string, words ...string) string {\n    result := \"\"\n    for i, word := range words {\n        if i &gt; 0 {\n            result += separator\n        }\n        result += word\n    }\n    return result\n}\n\nfunc main() {\n    // Call with different numbers of arguments\n    fmt.Printf(\"Sum of no numbers: %d\\n\", sum())\n    fmt.Printf(\"Sum of 1,2,3: %d\\n\", sum(1, 2, 3))\n    fmt.Printf(\"Sum of 1,2,3,4,5: %d\\n\", sum(1, 2, 3, 4, 5))\n\n    // Variadic with other parameters\n    sentence := concatenate(\" \", \"Go\", \"is\", \"awesome\")\n    fmt.Printf(\"Sentence: %s\\n\", sentence)\n}\n</code></pre> slice_expansion.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc average(numbers ...float64) float64 {\n    if len(numbers) == 0 {\n        return 0\n    }\n\n    total := 0.0\n    for _, num := range numbers {\n        total += num\n    }\n    return total / float64(len(numbers))\n}\n\nfunc main() {\n    // Direct arguments\n    avg1 := average(1.0, 2.0, 3.0, 4.0, 5.0)\n    fmt.Printf(\"Average (direct): %.2f\\n\", avg1)\n\n    // Slice expansion with ...\n    scores := []float64{85.5, 92.0, 78.5, 96.0, 88.5}\n    avg2 := average(scores...)\n    fmt.Printf(\"Average (slice): %.2f\\n\", avg2)\n}\n</code></pre>"},{"location":"1.%20Basics/11.%20Functions/#advanced-function-concepts","title":"Advanced Function Concepts","text":""},{"location":"1.%20Basics/11.%20Functions/#function-types-and-higher-order-functions","title":"Function Types and Higher-Order Functions","text":"<p>Function Types</p> Function VariablesAnonymous FunctionsClosures function_variables.go<pre><code>package main\n\nimport \"fmt\"\n\n// Define function type\ntype MathOperation func(int, int) int\n\n// Functions that match the type\nfunc add(a, b int) int { return a + b }\nfunc multiply(a, b int) int { return a * b }\n\n// Higher-order function\nfunc calculate(op MathOperation, x, y int) int {\n    return op(x, y)\n}\n\nfunc main() {\n    // Assign functions to variables\n    var operation MathOperation\n\n    operation = add\n    result1 := calculate(operation, 5, 3)\n    fmt.Printf(\"Addition: %d\\n\", result1)\n\n    operation = multiply\n    result2 := calculate(operation, 5, 3)\n    fmt.Printf(\"Multiplication: %d\\n\", result2)\n}\n</code></pre> anonymous_functions.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Anonymous function assigned to variable\n    square := func(x int) int {\n        return x * x\n    }\n\n    // Anonymous function called immediately\n    result := func(a, b int) int {\n        return a*a + b*b\n    }(3, 4)\n\n    fmt.Printf(\"Square of 5: %d\\n\", square(5))\n    fmt.Printf(\"Sum of squares: %d\\n\", result)\n\n    // Anonymous function in slice\n    operations := []func(int, int) int{\n        func(a, b int) int { return a + b },\n        func(a, b int) int { return a - b },\n        func(a, b int) int { return a * b },\n    }\n\n    for i, op := range operations {\n        fmt.Printf(\"Operation %d: %d\\n\", i, op(10, 5))\n    }\n}\n</code></pre> closures.go<pre><code>package main\n\nimport \"fmt\"\n\n// Function that returns a closure\nfunc makeCounter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\n// Closure with parameters\nfunc makeMultiplier(factor int) func(int) int {\n    return func(x int) int {\n        return x * factor\n    }\n}\n\nfunc main() {\n    // Each counter has its own state\n    counter1 := makeCounter()\n    counter2 := makeCounter()\n\n    fmt.Printf(\"Counter1: %d\\n\", counter1()) // 1\n    fmt.Printf(\"Counter1: %d\\n\", counter1()) // 2\n    fmt.Printf(\"Counter2: %d\\n\", counter2()) // 1\n\n    // Closure with captured variable\n    double := makeMultiplier(2)\n    triple := makeMultiplier(3)\n\n    fmt.Printf(\"Double 5: %d\\n\", double(5))   // 10\n    fmt.Printf(\"Triple 5: %d\\n\", triple(5))   // 15\n}\n</code></pre>"},{"location":"1.%20Basics/11.%20Functions/#recursive-functions","title":"Recursive Functions","text":"<p>Recursion Patterns</p> Basic RecursionTail Recursion recursion_basic.go<pre><code>package main\n\nimport \"fmt\"\n\n// Classic factorial function\nfunc factorial(n int) int {\n    if n &lt;= 1 {\n        return 1\n    }\n    return n * factorial(n-1)\n}\n\n// Fibonacci sequence\nfunc fibonacci(n int) int {\n    if n &lt;= 1 {\n        return n\n    }\n    return fibonacci(n-1) + fibonacci(n-2)\n}\n\nfunc main() {\n    fmt.Printf(\"Factorial of 5: %d\\n\", factorial(5))\n\n    fmt.Print(\"Fibonacci sequence: \")\n    for i := 0; i &lt; 10; i++ {\n        fmt.Printf(\"%d \", fibonacci(i))\n    }\n    fmt.Println()\n}\n</code></pre> tail_recursion.go<pre><code>package main\n\nimport \"fmt\"\n\n// Tail-recursive factorial with accumulator\nfunc factorialTail(n, acc int) int {\n    if n &lt;= 1 {\n        return acc\n    }\n    return factorialTail(n-1, n*acc)\n}\n\n// Helper function for clean interface\nfunc factorial(n int) int {\n    return factorialTail(n, 1)\n}\n\n// Tail-recursive sum\nfunc sumRange(start, end, acc int) int {\n    if start &gt; end {\n        return acc\n    }\n    return sumRange(start+1, end, acc+start)\n}\n\nfunc main() {\n    fmt.Printf(\"Factorial of 10: %d\\n\", factorial(10))\n    fmt.Printf(\"Sum 1 to 100: %d\\n\", sumRange(1, 100, 0))\n}\n</code></pre>"},{"location":"1.%20Basics/11.%20Functions/#best-practices-and-performance","title":"Best Practices and Performance","text":"<p>Function Best Practices</p> <ol> <li> <p>Clear Function Names <pre><code>// Good: Descriptive names\nfunc calculateTotalPrice(items []Item) float64 { ... }\nfunc validateEmailAddress(email string) bool { ... }\n\n// Avoid: Unclear names\nfunc calc(x []Item) float64 { ... }\nfunc check(s string) bool { ... }\n</code></pre></p> </li> <li> <p>Error Handling Pattern <pre><code>// Standard Go error handling\nfunc processFile(filename string) ([]byte, error) {\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read %s: %w\", filename, err)\n    }\n    return data, nil\n}\n</code></pre></p> </li> <li> <p>Function Size and Responsibility <pre><code>// Good: Single responsibility\nfunc validateInput(input string) error { ... }\nfunc processData(data []byte) Result { ... }\nfunc saveResult(result Result) error { ... }\n\n// Avoid: Functions doing too much\nfunc validateProcessAndSave(input string) error { ... }\n</code></pre></p> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Ignoring Errors: Always handle error return values</li> <li>Deep Recursion: Be aware of stack overflow with deep recursion</li> <li>Closure Variable Capture: Understand variable capture in loops</li> <li>Named Return Confusion: Use named returns judiciously</li> </ul>"},{"location":"1.%20Basics/11.%20Functions/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>Function Syntax: <code>func name(params) returns { body }</code></li> <li>Multiple Returns: Go's signature feature for error handling</li> <li>Variadic Functions: Use <code>...type</code> for variable arguments</li> <li>First-Class Functions: Assign to variables, pass as parameters</li> <li>Closures: Functions that capture surrounding variables</li> <li>Error Handling: Use <code>(result, error)</code> pattern consistently</li> </ol> <p>Remember</p> <p>\"Functions are the building blocks of Go programs. Write small, focused functions with clear names and proper error handling. Embrace multiple return values and use variadic functions when appropriate. When in doubt, keep it simple and readable!\"</p>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/","title":"Go Control Flow: Defer, Panic, Recover, and Exit","text":"<p>Overview</p> <p>Master Go's advanced control flow mechanisms for robust error handling and resource management. This comprehensive guide covers defer statements, panic/recover patterns, and program termination, building upon our understanding of functions and error handling.</p> <p>Key Points</p> <ul> <li>Defer ensures cleanup code execution</li> <li>Panic/recover provides exception-like error handling</li> <li>Exit terminates programs with status codes</li> <li>Essential for resource management and error recovery</li> <li>Critical for writing robust Go applications</li> </ul>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#understanding-control-flow-in-go","title":"Understanding Control Flow in Go","text":"<p>Go provides several mechanisms for controlling program execution flow beyond basic conditionals and loops. These advanced features enable elegant resource management and error handling patterns.</p> <p>Control Flow Mechanisms</p> <pre><code>graph TD\n    A[Control Flow] --&gt; B[defer]\n    A --&gt; C[panic]\n    A --&gt; D[recover]\n    A --&gt; E[exit]\n    B --&gt; F[Resource Cleanup]\n    B --&gt; G[LIFO Execution]\n    C --&gt; H[Error Propagation]\n    C --&gt; I[Stack Unwinding]\n    D --&gt; J[Error Recovery]\n    D --&gt; K[Graceful Handling]\n    E --&gt; L[Program Termination]\n    E --&gt; M[Status Codes]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000\n    style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#ffebee,stroke:#c62828,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px\n    style E fill:#fff3e0,stroke:#e65100,stroke-width:2px</code></pre>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#defer-guaranteed-cleanup","title":"Defer: Guaranteed Cleanup","text":"<p>The <code>defer</code> statement schedules function calls to execute when the surrounding function returns, ensuring cleanup code runs regardless of how the function exits.</p>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#basic-defer-patterns","title":"Basic Defer Patterns","text":"<p>Defer Fundamentals</p> Basic Defer UsageResource ManagementMultiple Defers basic_defer.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc demonstrateDefer() {\n    fmt.Println(\"Start of function\")\n\n    // Defer statements execute in LIFO order\n    defer fmt.Println(\"First defer\")\n    defer fmt.Println(\"Second defer\")\n    defer fmt.Println(\"Third defer\")\n\n    fmt.Println(\"End of function\")\n}\n\nfunc main() {\n    demonstrateDefer()\n\n    // Output:\n    // Start of function\n    // End of function\n    // Third defer\n    // Second defer\n    // First defer\n}\n</code></pre> resource_cleanup.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc processFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()  // Guaranteed cleanup\n\n    // Process file content\n    fmt.Printf(\"Processing file: %s\\n\", filename)\n\n    // File will be closed even if an error occurs\n    return nil\n}\n\nfunc main() {\n    err := processFile(\"example.txt\")\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n    }\n}\n</code></pre> multiple_defers.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc complexOperation() {\n    fmt.Println(\"Starting complex operation\")\n\n    // Setup resources\n    defer fmt.Println(\"Cleanup: Database connection\")\n    defer fmt.Println(\"Cleanup: Network connection\")\n    defer fmt.Println(\"Cleanup: File handles\")\n\n    // Simulate work\n    fmt.Println(\"Performing work...\")\n\n    // All defers execute in reverse order\n    fmt.Println(\"Work completed\")\n}\n\nfunc main() {\n    complexOperation()\n\n    // Output:\n    // Starting complex operation\n    // Performing work...\n    // Work completed\n    // Cleanup: File handles\n    // Cleanup: Network connection\n    // Cleanup: Database connection\n}\n</code></pre>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#advanced-defer-techniques","title":"Advanced Defer Techniques","text":"<p>Advanced Defer Patterns</p> Defer with VariablesDefer for Timing defer_variables.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc deferWithVariables() {\n    x := 10\n\n    // Arguments evaluated immediately\n    defer fmt.Printf(\"Deferred: x = %d\\n\", x)\n\n    x = 20\n    fmt.Printf(\"Current: x = %d\\n\", x)\n\n    // x in defer is still 10 (captured at defer time)\n}\n\nfunc deferWithClosure() {\n    x := 10\n\n    // Closure captures variable by reference\n    defer func() {\n        fmt.Printf(\"Closure: x = %d\\n\", x)\n    }()\n\n    x = 20\n    fmt.Printf(\"Current: x = %d\\n\", x)\n\n    // x in closure is 20 (current value)\n}\n\nfunc main() {\n    fmt.Println(\"=== Defer with Variables ===\")\n    deferWithVariables()\n\n    fmt.Println(\"\\n=== Defer with Closure ===\")\n    deferWithClosure()\n}\n</code></pre> defer_timing.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc timeFunction(name string) func() {\n    start := time.Now()\n    return func() {\n        fmt.Printf(\"%s took %v\\n\", name, time.Since(start))\n    }\n}\n\nfunc expensiveOperation() {\n    defer timeFunction(\"expensiveOperation\")()\n\n    // Simulate work\n    time.Sleep(100 * time.Millisecond)\n    fmt.Println(\"Operation completed\")\n}\n\nfunc main() {\n    expensiveOperation()\n\n    // Output:\n    // Operation completed\n    // expensiveOperation took ~100ms\n}\n</code></pre>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#panic-exception-like-error-handling","title":"Panic: Exception-Like Error Handling","text":"<p>Panic stops normal execution and begins unwinding the stack, executing deferred functions along the way.</p>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#panic-patterns","title":"Panic Patterns","text":"<p>Panic Mechanisms</p> Basic PanicPanic with Custom Types basic_panic.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc riskyFunction(value int) {\n    defer fmt.Println(\"Cleanup in riskyFunction\")\n\n    if value &lt; 0 {\n        panic(\"negative value not allowed\")\n    }\n\n    fmt.Printf(\"Processing value: %d\\n\", value)\n}\n\nfunc main() {\n    defer fmt.Println(\"Main function cleanup\")\n\n    fmt.Println(\"Starting program\")\n    riskyFunction(5)   // Works fine\n    riskyFunction(-1)  // Causes panic\n\n    fmt.Println(\"This won't be reached\")\n}\n</code></pre> custom_panic.go<pre><code>package main\n\nimport \"fmt\"\n\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error in %s: %s\", e.Field, e.Message)\n}\n\nfunc validateAge(age int) {\n    if age &lt; 0 {\n        panic(ValidationError{\n            Field:   \"age\",\n            Message: \"cannot be negative\",\n        })\n    }\n    if age &gt; 150 {\n        panic(ValidationError{\n            Field:   \"age\", \n            Message: \"unrealistic value\",\n        })\n    }\n}\n\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Printf(\"Caught panic: %v\\n\", r)\n        }\n    }()\n\n    validateAge(-5)  // Will panic\n}\n</code></pre>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#recover-graceful-error-recovery","title":"Recover: Graceful Error Recovery","text":"<p>Recover regains control of a panicking goroutine, allowing graceful error handling and program continuation.</p>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#recover-patterns","title":"Recover Patterns","text":"<p>Recovery Mechanisms</p> Basic RecoveryServer Error RecoveryTyped Recovery basic_recover.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc safeDivide(a, b float64) (result float64, err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"division error: %v\", r)\n        }\n    }()\n\n    if b == 0 {\n        panic(\"division by zero\")\n    }\n\n    result = a / b\n    return\n}\n\nfunc main() {\n    // Safe division that handles panic\n    result, err := safeDivide(10, 2)\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n    } else {\n        fmt.Printf(\"Result: %.2f\\n\", result)\n    }\n\n    // Division by zero - recovered\n    result, err = safeDivide(10, 0)\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n    } else {\n        fmt.Printf(\"Result: %.2f\\n\", result)\n    }\n}\n</code></pre> server_recovery.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n)\n\nfunc handleRequest(requestID int) {\n    defer func() {\n        if r := recover(); r != nil {\n            log.Printf(\"Request %d panicked: %v\", requestID, r)\n            // Log error, send error response, etc.\n        }\n    }()\n\n    // Simulate request processing\n    if requestID == 13 {\n        panic(\"unlucky request number\")\n    }\n\n    fmt.Printf(\"Successfully processed request %d\\n\", requestID)\n}\n\nfunc main() {\n    // Process multiple requests\n    for i := 10; i &lt;= 15; i++ {\n        handleRequest(i)\n    }\n\n    fmt.Println(\"Server continues running...\")\n}\n</code></pre> typed_recovery.go<pre><code>package main\n\nimport \"fmt\"\n\ntype NetworkError struct {\n    Code    int\n    Message string\n}\n\nfunc (e NetworkError) Error() string {\n    return fmt.Sprintf(\"network error %d: %s\", e.Code, e.Message)\n}\n\nfunc networkOperation() error {\n    defer func() {\n        if r := recover(); r != nil {\n            // Type assertion on recovered value\n            if netErr, ok := r.(NetworkError); ok {\n                fmt.Printf(\"Recovered network error: %v\\n\", netErr)\n            } else {\n                fmt.Printf(\"Recovered unknown error: %v\\n\", r)\n                panic(r) // Re-panic if not our error type\n            }\n        }\n    }()\n\n    // Simulate network error\n    panic(NetworkError{Code: 500, Message: \"connection timeout\"})\n}\n\nfunc main() {\n    err := networkOperation()\n    if err != nil {\n        fmt.Printf(\"Function returned error: %v\\n\", err)\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#exit-program-termination","title":"Exit: Program Termination","text":"<p>The <code>os.Exit</code> function terminates the program immediately with a specified exit code.</p>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#exit-patterns","title":"Exit Patterns","text":"<p>Program Termination</p> Basic ExitGraceful Shutdown basic_exit.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    fmt.Println(\"Starting program\")\n\n    // Check some condition\n    if len(os.Args) &lt; 2 {\n        fmt.Println(\"Error: Missing required argument\")\n        os.Exit(1)  // Exit with error code\n    }\n\n    fmt.Printf(\"Processing argument: %s\\n\", os.Args[1])\n    fmt.Println(\"Program completed successfully\")\n    os.Exit(0)  // Exit with success code\n}\n</code></pre> graceful_shutdown.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n)\n\nfunc cleanup() {\n    fmt.Println(\"Performing cleanup...\")\n    // Close files, connections, etc.\n}\n\nfunc main() {\n    // Setup signal handling for graceful shutdown\n    c := make(chan os.Signal, 1)\n    signal.Notify(c, os.Interrupt, syscall.SIGTERM)\n\n    go func() {\n        &lt;-c\n        fmt.Println(\"\\nReceived shutdown signal\")\n        cleanup()\n        os.Exit(0)\n    }()\n\n    fmt.Println(\"Program running... Press Ctrl+C to exit\")\n\n    // Simulate work\n    select {} // Block forever\n}\n</code></pre>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#best-practices-and-performance","title":"Best Practices and Performance","text":"<p>Control Flow Best Practices</p> <ol> <li> <p>Defer for Resource Management <pre><code>// Good: Always defer cleanup\nfunc processFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()  // Guaranteed cleanup\n\n    // Process file...\n    return nil\n}\n</code></pre></p> </li> <li> <p>Recover Only When Necessary <pre><code>// Good: Specific recovery for known panics\ndefer func() {\n    if r := recover(); r != nil {\n        if err, ok := r.(MyError); ok {\n            // Handle specific error\n        } else {\n            panic(r) // Re-panic unknown errors\n        }\n    }\n}()\n</code></pre></p> </li> <li> <p>Use Exit Codes Appropriately <pre><code>// Standard exit codes\nconst (\n    ExitSuccess = 0\n    ExitError   = 1\n    ExitUsage   = 2\n)\n\nif invalidInput {\n    fmt.Fprintf(os.Stderr, \"Invalid input\\n\")\n    os.Exit(ExitUsage)\n}\n</code></pre></p> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Defer in Loops: Be careful with defer in loops (memory accumulation)</li> <li>Panic for Control Flow: Don't use panic for normal error handling</li> <li>Ignoring Recovery: Always check if recovery is needed</li> <li>Exit vs Return: Use os.Exit sparingly, prefer returning errors</li> </ul>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>Defer: Use for cleanup, executes in LIFO order</li> <li>Panic: For unrecoverable errors, unwinds stack</li> <li>Recover: Catch panics in deferred functions only</li> <li>Exit: Immediate termination with status codes</li> <li>Resource Management: Always defer cleanup operations</li> <li>Error Handling: Prefer errors over panic for expected failures</li> </ol> <p>Remember</p> <p>\"Control flow mechanisms are powerful tools for robust Go programs. Use defer for guaranteed cleanup, panic/recover for exceptional situations, and exit for program termination. Always prefer explicit error handling over panic for expected error conditions!\"</p>"},{"location":"1.%20Basics/13.%20Init/","title":"Go Init Functions: Package Initialization","text":"<p>Overview</p> <p>Master Go's <code>init</code> function for package initialization and setup tasks. This comprehensive guide covers init function behavior, execution order, practical use cases, and best practices, building upon our understanding of packages and program structure.</p> <p>Key Points</p> <ul> <li>Init functions run automatically before main</li> <li>Multiple init functions per package allowed</li> <li>Execution order follows import dependencies</li> <li>Perfect for one-time setup and configuration</li> <li>Cannot be called directly or have parameters</li> </ul>"},{"location":"1.%20Basics/13.%20Init/#understanding-init-functions-in-go","title":"Understanding Init Functions in Go","text":"<p>The <code>init</code> function is Go's mechanism for package-level initialization, providing a way to perform setup tasks that must occur before the package is used.</p> <p>Init Function Lifecycle</p> <pre><code>graph TD\n    A[Program Start] --&gt; B[Import Packages]\n    B --&gt; C[Initialize Variables]\n    C --&gt; D[Execute init Functions]\n    D --&gt; E[Run main Function]\n\n    D --&gt; F[Package A init]\n    D --&gt; G[Package B init]\n    D --&gt; H[Main Package init]\n\n    F --&gt; I[Variable Declarations]\n    F --&gt; J[init Function 1]\n    F --&gt; K[init Function 2]\n\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000\n    style D fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style E fill:#f3e5f5,stroke:#4a148c,stroke-width:2px</code></pre>"},{"location":"1.%20Basics/13.%20Init/#basic-init-function-patterns","title":"Basic Init Function Patterns","text":"<p>Init functions provide automatic initialization without explicit calls, making them perfect for setup tasks.</p>"},{"location":"1.%20Basics/13.%20Init/#fundamental-init-usage","title":"Fundamental Init Usage","text":"<p>Basic Init Functions</p> Simple InitializationMultiple Init FunctionsPackage-Level Setup basic_init.go<pre><code>package main\n\nimport \"fmt\"\n\nvar globalVar string\n\n// Init function runs before main\nfunc init() {\n    globalVar = \"Initialized in init\"\n    fmt.Println(\"Init function executed\")\n}\n\nfunc main() {\n    fmt.Println(\"Main function started\")\n    fmt.Printf(\"Global variable: %s\\n\", globalVar)\n\n    // Output:\n    // Init function executed\n    // Main function started\n    // Global variable: Initialized in init\n}\n</code></pre> multiple_init.go<pre><code>package main\n\nimport \"fmt\"\n\nvar counter int\n\n// First init function\nfunc init() {\n    counter++\n    fmt.Printf(\"Init 1: counter = %d\\n\", counter)\n}\n\n// Second init function\nfunc init() {\n    counter++\n    fmt.Printf(\"Init 2: counter = %d\\n\", counter)\n}\n\nfunc main() {\n    fmt.Printf(\"Main: counter = %d\\n\", counter)\n\n    // Output:\n    // Init 1: counter = 1\n    // Init 2: counter = 2\n    // Main: counter = 2\n}\n</code></pre> package_setup.go<pre><code>package config\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nvar (\n    DatabaseURL string\n    APIKey      string\n    Debug       bool\n)\n\nfunc init() {\n    // Load configuration from environment\n    DatabaseURL = os.Getenv(\"DATABASE_URL\")\n    if DatabaseURL == \"\" {\n        DatabaseURL = \"localhost:5432\"\n    }\n\n    APIKey = os.Getenv(\"API_KEY\")\n    if APIKey == \"\" {\n        panic(\"API_KEY environment variable required\")\n    }\n\n    Debug = os.Getenv(\"DEBUG\") == \"true\"\n\n    fmt.Println(\"Configuration loaded successfully\")\n}\n</code></pre>"},{"location":"1.%20Basics/13.%20Init/#init-function-execution-order","title":"Init Function Execution Order","text":"<p>Understanding execution order is crucial for proper initialization dependencies.</p>"},{"location":"1.%20Basics/13.%20Init/#execution-order-patterns","title":"Execution Order Patterns","text":"<p>Execution Order Examples</p> Single Package OrderMulti-Package Dependencies single_package_order.go<pre><code>package main\n\nimport \"fmt\"\n\nvar a = initVar(\"a\")\nvar b = initVar(\"b\")\n\nfunc initVar(name string) string {\n    fmt.Printf(\"Initializing variable %s\\n\", name)\n    return name\n}\n\nfunc init() {\n    fmt.Println(\"First init function\")\n}\n\nvar c = initVar(\"c\")\n\nfunc init() {\n    fmt.Println(\"Second init function\")\n}\n\nfunc main() {\n    fmt.Println(\"Main function\")\n    fmt.Printf(\"Variables: %s, %s, %s\\n\", a, b, c)\n\n    // Output:\n    // Initializing variable a\n    // Initializing variable b\n    // Initializing variable c\n    // First init function\n    // Second init function\n    // Main function\n    // Variables: a, b, c\n}\n</code></pre> package_a/init.go<pre><code>package a\n\nimport \"fmt\"\n\nfunc init() {\n    fmt.Println(\"Package A init\")\n}\n\nfunc GetMessage() string {\n    return \"Hello from package A\"\n}\n</code></pre> package_b/init.go<pre><code>package b\n\nimport (\n    \"fmt\"\n    \"./package_a\"\n)\n\nfunc init() {\n    fmt.Println(\"Package B init\")\n    fmt.Println(\"Using:\", a.GetMessage())\n}\n</code></pre> main.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"./package_a\"\n    \"./package_b\"\n)\n\nfunc init() {\n    fmt.Println(\"Main package init\")\n}\n\nfunc main() {\n    fmt.Println(\"Main function\")\n\n    // Output:\n    // Package A init\n    // Package B init\n    // Using: Hello from package A\n    // Main package init\n    // Main function\n}\n</code></pre>"},{"location":"1.%20Basics/13.%20Init/#practical-init-use-cases","title":"Practical Init Use Cases","text":"<p>Init functions excel at setup tasks that need to happen once per package import.</p>"},{"location":"1.%20Basics/13.%20Init/#common-init-patterns","title":"Common Init Patterns","text":"<p>Practical Applications</p> Database Connection PoolLogger ConfigurationFeature Flag Registration database_init.go<pre><code>package database\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    _ \"github.com/lib/pq\"  // PostgreSQL driver\n)\n\nvar DB *sql.DB\n\nfunc init() {\n    var err error\n\n    // Get connection string from environment\n    connStr := os.Getenv(\"DATABASE_URL\")\n    if connStr == \"\" {\n        connStr = \"postgres://user:password@localhost/dbname?sslmode=disable\"\n    }\n\n    // Initialize database connection\n    DB, err = sql.Open(\"postgres\", connStr)\n    if err != nil {\n        log.Fatal(\"Failed to connect to database:\", err)\n    }\n\n    // Test connection\n    if err = DB.Ping(); err != nil {\n        log.Fatal(\"Database ping failed:\", err)\n    }\n\n    fmt.Println(\"Database connection established\")\n}\n\nfunc GetDB() *sql.DB {\n    return DB\n}\n</code></pre> logger_init.go<pre><code>package logger\n\nimport (\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nvar (\n    InfoLogger    *log.Logger\n    WarningLogger *log.Logger\n    ErrorLogger   *log.Logger\n)\n\nfunc init() {\n    // Create or open log file\n    logFile, err := os.OpenFile(\"app.log\", \n        os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n    if err != nil {\n        log.Fatal(\"Failed to open log file:\", err)\n    }\n\n    // Create multi-writer for console and file\n    multiWriter := io.MultiWriter(os.Stdout, logFile)\n\n    // Initialize loggers with different prefixes\n    InfoLogger = log.New(multiWriter, \"INFO: \", \n        log.Ldate|log.Ltime|log.Lshortfile)\n    WarningLogger = log.New(multiWriter, \"WARNING: \", \n        log.Ldate|log.Ltime|log.Lshortfile)\n    ErrorLogger = log.New(multiWriter, \"ERROR: \", \n        log.Ldate|log.Ltime|log.Lshortfile)\n}\n</code></pre> features_init.go<pre><code>package features\n\nimport \"fmt\"\n\ntype Feature struct {\n    Name    string\n    Enabled bool\n}\n\nvar registry = make(map[string]*Feature)\n\nfunc init() {\n    // Register default features\n    registerFeature(\"new_ui\", false)\n    registerFeature(\"beta_api\", false)\n    registerFeature(\"advanced_search\", true)\n    registerFeature(\"dark_mode\", true)\n\n    fmt.Printf(\"Registered %d features\\n\", len(registry))\n}\n\nfunc registerFeature(name string, enabled bool) {\n    registry[name] = &amp;Feature{\n        Name:    name,\n        Enabled: enabled,\n    }\n}\n\nfunc IsEnabled(name string) bool {\n    if feature, exists := registry[name]; exists {\n        return feature.Enabled\n    }\n    return false\n}\n</code></pre>"},{"location":"1.%20Basics/13.%20Init/#best-practices-and-performance","title":"Best Practices and Performance","text":"<p>Init Function Best Practices</p> <ol> <li> <p>Keep Init Functions Simple <pre><code>// Good: Simple initialization\nfunc init() {\n    config.Load()\n    logger.Setup()\n}\n\n// Avoid: Complex logic in init\nfunc init() {\n    // Avoid heavy computation or complex business logic\n}\n</code></pre></p> </li> <li> <p>Handle Errors Appropriately <pre><code>func init() {\n    if err := setupCriticalResource(); err != nil {\n        log.Fatal(\"Critical initialization failed:\", err)\n    }\n}\n</code></pre></p> </li> <li> <p>Use Init for Package-Level Setup Only <pre><code>// Good: Package-level configuration\nfunc init() {\n    http.DefaultClient.Timeout = 30 * time.Second\n}\n\n// Avoid: Application-specific logic\nfunc init() {\n    // Don't put main application logic here\n}\n</code></pre></p> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Order Dependencies: Don't rely on init order between packages</li> <li>Heavy Operations: Avoid time-consuming operations in init</li> <li>Global State: Be careful with global variable initialization</li> <li>Testing Issues: Init functions run during tests too</li> </ul>"},{"location":"1.%20Basics/13.%20Init/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>Automatic Execution: Init runs before main, no explicit calls</li> <li>Multiple Functions: Can have multiple init functions per package</li> <li>Execution Order: Variables first, then init functions, then main</li> <li>Use Cases: Configuration, connections, registrations, setup</li> <li>Best Practices: Keep simple, handle errors, package-level only</li> <li>Testing: Remember init functions run during tests</li> </ol> <p>Remember</p> <p>\"Init functions are Go's way of ensuring proper package initialization. Use them for essential setup tasks that must happen before your package is used. Keep them simple, handle errors gracefully, and remember they run automatically - no calls required!\"</p>"},{"location":"1.%20Basics/2.%20Go-Compiler/","title":"Understanding the Go Compiler","text":"<p>Overview</p> <p>Discover how Go transforms your source code into executable programs through its powerful compiler toolchain. This guide extends our Hello World tutorial by diving deep into the compilation process.</p> <p>Key Points</p> <ul> <li>Go is a compiled language</li> <li>Source code \u2192 Machine code transformation</li> <li>Multiple ways to build and run programs</li> <li>Optimized for performance</li> </ul>"},{"location":"1.%20Basics/2.%20Go-Compiler/#revisit-two-ways-to-run-go-programs","title":"Revisit: Two Ways to Run Go Programs","text":"1. Build Then Run2. Direct Execution <p><pre><code>#$ go build hello.go\n./hello\n</code></pre> Perfect for production deployments</p> <p><pre><code>#$ go run hello.go\n</code></pre> Ideal for development</p>"},{"location":"1.%20Basics/2.%20Go-Compiler/#understanding-the-compiler","title":"Understanding the Compiler","text":"<p>What is the Go Compiler?</p> <p>The Go compiler transforms your source code into machine-executable programs through a sophisticated pipeline:</p> <pre><code>graph LR\n    A[Source Code] --&gt; B[Parsing]\n    B --&gt; C[Type Checking]\n    C --&gt; D[Optimization]\n    D --&gt; E[Code Generation]\n    E --&gt; F[Binary Executable]\n    style A fill:#999,stroke:#fff,stroke-width:2px,color:#000\n    style F fill:#999,stroke:#fff,stroke-width:2px,color:#fff</code></pre> <ol> <li>Parsing<ul> <li>Reads source code</li> <li>Creates Abstract Syntax Tree (AST)</li> </ul> </li> <li>Type Checking<ul> <li>Verifies type correctness</li> <li>Ensures type safety</li> </ul> </li> <li>Optimization<ul> <li>Improves performance</li> <li>Reduces code size</li> </ul> </li> <li>Code Generation<ul> <li>Produces machine code</li> <li>Target platform specific</li> </ul> </li> </ol> <p>One of the key insight here is that, go uses 'utf-8' encoding stream to convert our program from human readable code to machine readable code. I have written a blog post on this same topic on C. You can check it here. Though you will understand the entire low level operation on C which is based on ASCII. </p>"},{"location":"1.%20Basics/2.%20Go-Compiler/#building-with-go-build","title":"Building with <code>go build</code>","text":"<p>Basic Usage</p> Command Syntax<pre><code>go build [options] [packages]\n</code></pre> Simple BuildOutput Location <pre><code>go build hello.go\n</code></pre> <ul> <li>\ud83d\udc27 Linux/macOS: <code>hello</code></li> <li>\ud83e\ude9f Windows: <code>hello.exe</code> ( windows binary executable is denoted by <code>.exe</code> extension )</li> </ul>"},{"location":"1.%20Basics/2.%20Go-Compiler/#running-your-program","title":"Running Your Program","text":"<p>Executing the Binary</p> Linux/macOSWindows <pre><code>./hello\n</code></pre> <pre><code>hello.exe\n</code></pre>"},{"location":"1.%20Basics/2.%20Go-Compiler/#why-use-go-build","title":"Why Use <code>go build</code>?","text":"<p>Key Benefits</p> <ol> <li> <p>Performance</p> <ul> <li>Pre-compiled for speed</li> <li>No runtime compilation</li> </ul> </li> <li> <p>Distribution</p> <ul> <li>Share binaries, not source</li> <li>Professional software delivery</li> </ul> </li> <li> <p>Zero Delay</p> <ul> <li>No compilation at runtime</li> <li>Instant startup</li> </ul> </li> <li> <p>Self-Contained</p> <ul> <li>Statically linked by default</li> <li>No external dependencies</li> </ul> </li> </ol>"},{"location":"1.%20Basics/2.%20Go-Compiler/#cross-platform-support","title":"Cross-Platform Support","text":"<p>Build for Any Platform</p> Cross-Compilation Commands<pre><code># \ud83e\ude9f Build for Windows\nGOOS=windows GOARCH=amd64 go build hello.go\n\n# \ud83c\udf4e Build for macOS\nGOOS=darwin GOARCH=amd64 go build hello.go\n\n# \ud83d\udc27 Build for Linux\nGOOS=linux GOARCH=amd64 go build hello.go\n</code></pre> <p>Build once, run anywhere!</p>"},{"location":"1.%20Basics/2.%20Go-Compiler/#quick-development-with-go-run","title":"Quick Development with <code>go run</code>","text":"<p>What is <code>go run</code>?</p> <p>A powerful command that combines compilation and execution in one step - perfect for development!</p>"},{"location":"1.%20Basics/2.%20Go-Compiler/#how-it-works","title":"How it Works","text":"<p>Behind the Scenes</p> <pre><code>sequenceDiagram\n    participant D as Developer\n    participant G as go run\n    participant T as Temp Dir\n    participant E as Executable\n    D-&gt;&gt;G: go run hello.go\n    G-&gt;&gt;T: 1. Create temp dir\n    G-&gt;&gt;T: 2. Compile program\n    T-&gt;&gt;E: 3. Create executable\n    E-&gt;&gt;D: 4. Run &amp; show output\n    G-&gt;&gt;T: 5. Clean up</code></pre>"},{"location":"1.%20Basics/2.%20Go-Compiler/#quick-start","title":"Quick Start","text":"<p>Basic Usage</p> Command Syntax<pre><code>go run [options] [go files] [arguments]\n</code></pre> Run Single FileRun Multiple Files <p><pre><code>go run hello.go\n</code></pre> Output<pre><code>Hello, World! \n</code></pre></p> <pre><code>go run main.go utils.go\n</code></pre>"},{"location":"1.%20Basics/2.%20Go-Compiler/#advantages-limitations","title":"Advantages &amp; Limitations","text":"<p>Advantages</p> <ul> <li> <p>Quick &amp; Easy</p> <ul> <li>One command does it all</li> <li>Perfect for rapid testing</li> </ul> </li> <li> <p>Clean Workspace</p> <ul> <li>No leftover binaries</li> <li>Automatic cleanup</li> </ul> </li> <li> <p>Fast Development</p> <ul> <li>Instant feedback</li> <li>Great for iterations</li> </ul> </li> </ul> <p>Limitations</p> <ul> <li> <p>Slower Start</p> <ul> <li>Compiles each time</li> <li>Not for production</li> </ul> </li> <li> <p>No Artifacts</p> <ul> <li>No reusable binaries</li> <li>Requires Go installation</li> </ul> </li> </ul>"},{"location":"1.%20Basics/2.%20Go-Compiler/#conclusion-build-vs-run","title":"Conclusion: Build vs Run","text":"<p>Feature Comparison</p> Feature <code>go build</code> <code>go run</code> Output  Executable  Temporary Speed  Faster  Slower Usage  Production  Development Steps  Multiple  Single Portable  Yes  Needs Go"},{"location":"1.%20Basics/2.%20Go-Compiler/#best-practices","title":"Best Practices","text":"<p>When to Use What</p> <code>go build</code><code>go run</code> <ol> <li> <p>Production Deployment</p> <ul> <li>Ready for release</li> <li>Final binaries</li> </ul> </li> <li> <p>CLI Tools</p> <ul> <li>Distributable utilities</li> <li>Standalone apps</li> </ul> </li> <li> <p>Performance Critical</p> <ul> <li>Fast startup needed</li> <li>Resource intensive</li> </ul> </li> <li> <p>Cross-Platform</p> <ul> <li>Multiple OS targets</li> <li>Wide distribution</li> </ul> </li> </ol> <ol> <li> <p>Development</p> <ul> <li>Active coding</li> <li>Quick testing</li> </ul> </li> <li> <p>Experiments</p> <ul> <li>Code snippets</li> <li>Quick prototypes</li> </ul> </li> <li> <p>Learning</p> <ul> <li>Tutorials</li> <li>Examples</li> </ul> </li> <li> <p>Scripts</p> <ul> <li>One-time tasks</li> <li>Quick automations</li> </ul> </li> </ol>"},{"location":"1.%20Basics/2.%20Go-Compiler/#advanced-techniques","title":"Advanced Techniques","text":"<p>Power User Features</p> Custom Output NameVersion InformationMultiple Files <p><pre><code>go build -o myapp hello.go\n</code></pre> Choose your own executable name!</p> <p><pre><code>go build -ldflags=\"-X main.Version=1.0.0\" hello.go\n</code></pre> Embed version info at compile time!</p> <p><pre><code># Run specific files\ngo run file1.go file2.go file3.go\n\n# Run entire package\ngo run .\n</code></pre> Handle complex projects!</p>"},{"location":"1.%20Basics/2.%20Go-Compiler/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li> <p> <code>go build</code></p> <ul> <li>Production ready</li> <li>Distributable binaries</li> <li>Maximum performance</li> </ul> </li> <li> <p> <code>go run</code></p> <ul> <li>Rapid development</li> <li>Quick testing</li> <li>Learning and exploration</li> </ul> </li> <li> <p> Choose Wisely</p> <ul> <li>Consider your use case</li> <li>Think about your audience</li> <li>Plan for distribution</li> </ul> </li> </ol> <p>Remember</p> <p>\"The right tool for the right job makes all the difference.\"</p>"},{"location":"1.%20Basics/3.%20Standard%20Library/","title":"Exploring the Go Standard Library","text":"<p>Overview</p> <p>Dive into the Go standard library, a powerful collection of packages that provides a vast array of functionalities out of the box. This guide extends our basic Go tutorials by exploring the rich ecosystem of packages available to every Go developer.</p> <p>Key Points</p> <ul> <li>Go's standard library is comprehensive and well-designed</li> <li>Provides ready-to-use solutions for common programming tasks</li> <li>Eliminates the need for external dependencies in many cases</li> <li>Follows Go's philosophy of simplicity and clarity</li> </ul>"},{"location":"1.%20Basics/3.%20Standard%20Library/#what-is-the-standard-library","title":"What is the Standard Library?","text":"<p>The Go standard library is a collection of packages that are included with every Go installation. It provides a rich set of tools for common programming tasks, from handling I/O to networking and text manipulation.</p> <p>Why it Matters</p> <ul> <li>Efficiency: No need to write common functionalities from scratch.</li> <li>Reliability: Packages are well-tested and maintained by the Go team.</li> <li>Consistency: Provides a standard way of performing common tasks.</li> </ul> <p>The standard library is structured as a hierarchy of packages, each serving a specific purpose:</p> <pre><code>graph LR\n    A[Standard Library] --&gt; B[Text Processing]\n    A --&gt; C[I/O Operations]\n    A --&gt; D[Networking]\n    A --&gt; E[Concurrency]\n    A --&gt; F[Data Structures]\n    A --&gt; G[Cryptography]\n    A --&gt; H[Operating System]\n    B --&gt; B1[fmt]\n    B --&gt; B2[strings]\n    B --&gt; B3[strconv]\n    B --&gt; B4[regexp]\n    C --&gt; C1[io]\n    C --&gt; C2[bufio]\n    C --&gt; C3[os]\n    D --&gt; D1[net]\n    D --&gt; D2[net/http]\n    E --&gt; E1[sync]\n    E --&gt; E2[context]\n    F --&gt; F1[container/list]\n    F --&gt; F2[container/heap]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000</code></pre>"},{"location":"1.%20Basics/3.%20Standard%20Library/#navigating-the-standard-library","title":"Navigating the Standard Library","text":"<p>The standard library is organized into packages, each focusing on a specific area of functionality. Understanding this organization helps you quickly find the tools you need.</p>"},{"location":"1.%20Basics/3.%20Standard%20Library/#key-categories","title":"Key Categories","text":"<p>Commonly Used Packages</p> Text ProcessingI/ONetworkingConcurrencyData Structures <ul> <li><code>fmt</code>: Formatted I/O (printing, scanning).</li> <li><code>strings</code>: String manipulation functions.</li> <li><code>strconv</code>: String conversions to and from basic data types.</li> <li><code>regexp</code>: Regular expression support.</li> <li><code>encoding/json</code>: JSON encoding and decoding.</li> <li><code>encoding/xml</code>: XML encoding and decoding.</li> <li><code>text/template</code>: Template generation for text output.</li> </ul> <ul> <li><code>io</code>: Core I/O interfaces.</li> <li><code>bufio</code>: Buffered I/O for improved performance.</li> <li><code>os</code>: Platform-independent operating system functions.</li> <li><code>io/ioutil</code>: Convenience I/O utilities.</li> <li><code>filepath</code>: Platform-independent path manipulation.</li> </ul> <ul> <li><code>net</code>: Networking primitives (TCP/IP, UDP, etc.).</li> <li><code>net/http</code>: HTTP client and server implementations.</li> <li><code>net/url</code>: URL parsing and querying.</li> <li><code>net/mail</code>: Mail message parsing.</li> </ul> <ul> <li><code>sync</code>: Synchronization primitives like mutexes and waitgroups.</li> <li><code>context</code>: Managing deadlines, cancellation signals, and other request-scoped values.</li> <li><code>atomic</code>: Low-level atomic memory primitives.</li> <li><code>time</code>: Time measurement and display.</li> </ul> <ul> <li><code>container/list</code>: Doubly-linked lists.</li> <li><code>container/heap</code>: Heap implementation.</li> <li><code>container/ring</code>: Circular lists.</li> </ul>"},{"location":"1.%20Basics/3.%20Standard%20Library/#code-examples","title":"Code Examples","text":"<p>Let's see some of these packages in action with practical examples.</p> <p>Code Snippets</p> <code>fmt</code><code>strings</code><code>net/http</code><code>sync</code> <p>The <code>fmt</code> package is one of a Go developer's best friends for formatted I/O.</p> fmt_example.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Go\"\n    year := 2009\n    fmt.Printf(\"%s was released in %d\\n\", name, year)\n\n    // Using formatted verbs\n    pi := 3.14159\n    fmt.Printf(\"Pi is approximately %.2f\\n\", pi)\n\n    // Using Println for automatic line breaks\n    fmt.Println(\"Hello,\", \"world!\")\n}\n</code></pre> <p>The <code>strings</code> package provides a rich set of functions for string manipulation.</p> strings_example.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    phrase := \"Go is awesome!\"\n    fmt.Println(\"Uppercase:\", strings.ToUpper(phrase))\n    fmt.Println(\"Contains 'awesome':\", strings.Contains(phrase, \"awesome\"))\n\n    // Splitting strings\n    csv := \"apple,banana,cherry\"\n    fruits := strings.Split(csv, \",\")\n    fmt.Println(\"Fruits:\", fruits)\n\n    // Joining strings\n    words := []string{\"Go\", \"is\", \"fun\"}\n    sentence := strings.Join(words, \" \")\n    fmt.Println(\"Sentence:\", sentence)\n}\n</code></pre> <p>With <code>net/http</code>, you can create a simple web server in just a few lines of code.</p> http_server.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprint(w, \"Hello, Web!\")\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", helloHandler)\n    fmt.Println(\"Server starting on port 8080...\")\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre> <p>The <code>sync</code> package provides basic synchronization primitives.</p> sync_example.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc worker(id int, wg *sync.WaitGroup) {\n    defer wg.Done()\n    fmt.Printf(\"Worker %d starting\\n\", id)\n    time.Sleep(time.Second)\n    fmt.Printf(\"Worker %d done\\n\", id)\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n\n    for i := 1; i &lt;= 5; i++ {\n        wg.Add(1)\n        go worker(i, &amp;wg)\n    }\n\n    wg.Wait()\n    fmt.Println(\"All workers completed\")\n}\n</code></pre>"},{"location":"1.%20Basics/3.%20Standard%20Library/#mastering-import-statements","title":"Mastering <code>import</code> Statements","text":"<p>To use a package from the standard library (or any other package), you need to <code>import</code> it. Understanding the different ways to import packages is crucial for effective Go programming.</p>"},{"location":"1.%20Basics/3.%20Standard%20Library/#basic-import","title":"Basic Import","text":"<p>You can import a single package like this:</p> <pre><code>import \"fmt\"\n</code></pre>"},{"location":"1.%20Basics/3.%20Standard%20Library/#factored-imports","title":"Factored Imports","text":"<p>For multiple packages, it's idiomatic to use a factored import statement:</p> factored_import.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"strings\"\n)\n\nfunc main() {\n    fmt.Println(math.Pi)\n    fmt.Println(strings.ToUpper(\"hello\"))\n}\n</code></pre>"},{"location":"1.%20Basics/3.%20Standard%20Library/#import-aliasing","title":"Import Aliasing","text":"<p>If you need to import a package with a conflicting name or want to use a shorter name, you can use an alias:</p> aliased_import.go<pre><code>package main\n\nimport (\n    f \"fmt\" // f is now an alias for the fmt package\n)\n\nfunc main() {\n    f.Println(\"Hello from an alias!\")\n}\n</code></pre>"},{"location":"1.%20Basics/3.%20Standard%20Library/#side-effect-imports","title":"Side-effect Imports","text":"<p>Sometimes you need to import a package solely for its side effects (e.g., initializing a database driver). In this case, you can use the blank identifier <code>_</code>:</p> side_effect_import.go<pre><code>package main\n\nimport (\n    \"database/sql\"\n    _ \"github.com/go-sql-driver/mysql\" // The driver is registered as a side effect\n)\n\nfunc main() {\n    // Your database logic here\n}\n</code></pre>"},{"location":"1.%20Basics/3.%20Standard%20Library/#import-methods-comparison","title":"Import Methods Comparison","text":"<p>Import Types and Their Use Cases</p> Import Type Syntax Use Case Example Single <code>import \"fmt\"</code> Simple programs with few dependencies Basic \"Hello World\" Factored <code>import (&lt;br&gt;  \"fmt\"&lt;br&gt;  \"math\"&lt;br&gt;)</code> Most programs with multiple dependencies Standard practice Aliased <code>import f \"fmt\"</code> Resolving conflicts or shortening names <code>import t \"time\"</code> Side-effect <code>import _ \"driver\"</code> Registering drivers or initialization Database drivers"},{"location":"1.%20Basics/3.%20Standard%20Library/#best-practices","title":"Best Practices","text":"<p>Organize Your Imports</p> <p>It's a common convention to group imports into three categories, separated by a blank line: 1.  Standard library packages 2.  Third-party packages 3.  Internal project packages</p> <pre><code>import (\n    \"fmt\"\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n\n    \"my-project/internal/models\"\n)\n</code></pre> <p>Working with the Standard Library</p> <ol> <li> <p>Read the Documentation</p> <ul> <li>Official Go docs are excellent</li> <li>Package documentation includes examples</li> <li>Use <code>go doc</code> command for quick reference</li> </ul> </li> <li> <p>Explore Before Creating</p> <ul> <li>Check if functionality already exists</li> <li>Standard library is well-optimized</li> <li>Avoid reinventing the wheel</li> </ul> </li> <li> <p>Keep Dependencies Minimal</p> <ul> <li>Prefer standard library over third-party</li> <li>Reduces security risks</li> <li>Simplifies maintenance</li> </ul> </li> <li> <p>Experiment with Examples</p> <ul> <li>Try out package examples</li> <li>Modify them to understand behavior</li> <li>Build confidence before implementation</li> </ul> </li> </ol> <p>Common Pitfalls</p> <ul> <li> <p> Ignoring Package Idioms</p> <ul> <li>Each package has design patterns</li> <li>Using them incorrectly leads to bugs</li> <li>Read package documentation carefully</li> </ul> </li> <li> <p> Overusing Aliases</p> <ul> <li>Makes code harder to understand</li> <li>Only use when necessary</li> <li>Stick to standard package names when possible</li> </ul> </li> </ul>"},{"location":"1.%20Basics/3.%20Standard%20Library/#advanced-techniques","title":"Advanced Techniques","text":"<p>Power User Features</p> Conditional ImportsPackage DocumentationExploring Package Source <p>Use build tags to import packages only in specific environments:</p> <pre><code>// +build linux\n\npackage main\n\nimport (\n    \"fmt\"\n    \"syscall\" // Only available on Unix-like systems\n)\n\nfunc main() {\n    fmt.Println(\"Running on a Unix-like system\")\n}\n</code></pre> <p>Generate documentation for your own packages:</p> <pre><code># Generate documentation for a package\ngo doc fmt\n\n# Start a local documentation server\ngodoc -http=:6060\n</code></pre> <p>View the source code of standard library packages:</p> <pre><code># Find the source location of a package\ngo fmt -print fmt\n\n# Navigate to the source directory\ncd $(go env GOROOT)/src/fmt\n</code></pre>"},{"location":"1.%20Basics/3.%20Standard%20Library/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li> <p>Standard Library</p> <ul> <li>Comprehensive and well-designed</li> <li>First choice for common functionality</li> <li>Reduces external dependencies</li> </ul> </li> <li> <p>Importing Packages</p> <ul> <li>Use factored imports for multiple packages</li> <li>Organize imports by category</li> <li>Use aliases and side-effect imports when needed</li> </ul> </li> <li> <p>Exploration</p> <ul> <li>Read official documentation</li> <li>Experiment with examples</li> <li>Check source code for deeper understanding</li> </ul> </li> </ol> <p>Remember</p> <p>\"The standard library is Go's killer feature. It's comprehensive, consistent, and well-designed. Make it your first stop when solving any problem.\"</p>"},{"location":"1.%20Basics/4.%20Data-Types/","title":"Go Data Types: Variables, Constants &amp; Operations","text":"<p>Overview</p> <p>Master Go's type system, from basic data types to variables, constants, and arithmetic operations. This comprehensive guide covers everything you need to know about working with data in Go, building upon our foundation from Hello World and compiler basics.</p> <p>Key Points</p> <ul> <li>Go is statically typed with compile-time type checking</li> <li>Rich set of built-in types for different use cases</li> <li>Powerful variable declaration and initialization patterns</li> <li>Constants provide compile-time guarantees</li> <li>Type-safe arithmetic operations</li> </ul>"},{"location":"1.%20Basics/4.%20Data-Types/#understanding-gos-type-system","title":"Understanding Go's Type System","text":"<p>Go is a statically typed language, meaning every variable has a specific type known at compile time. This provides safety, performance, and clarity in your programs.</p> <p>Type Categories</p> <pre><code>graph LR\n    A[Go Data Types] --&gt; B[Basic Types]\n    A --&gt; C[Composite Types]\n    A --&gt; D[Reference Types]\n    A --&gt; E[Interface Types]\n    B --&gt; B1[Numeric]\n    B --&gt; B2[String]\n    B --&gt; B3[Boolean]\n    B1 --&gt; B1a[Integers]\n    B1 --&gt; B1b[Floating Point]\n    B1 --&gt; B1c[Complex]\n    C --&gt; C1[Arrays]\n    C --&gt; C2[Structs]\n    D --&gt; D1[Slices]\n    D --&gt; D2[Maps]\n    D --&gt; D3[Channels]\n    D --&gt; D4[Pointers]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#variables-storing-and-managing-data","title":"Variables: Storing and Managing Data","text":"<p>Variables are named storage locations that hold values of a specific type. Go provides several ways to declare and initialize variables.</p>"},{"location":"1.%20Basics/4.%20Data-Types/#variable-declaration-methods","title":"Variable Declaration Methods","text":"<p>Declaration Patterns</p> Method 1: var with TypeMethod 2: var with InitializationMethod 3: Short Declaration explicit_types.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var name string\n    var age int\n    var isStudent bool\n\n    fmt.Printf(\"Name: %s, Age: %d, Student: %t\\n\", name, age, isStudent)\n    // Output: Name: , Age: 0, Student: false\n}\n</code></pre> <p>Zero Values</p> <p>Variables declared without initialization get their type's zero value automatically.</p> var_init.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var name string = \"Alice\"\n    var age int = 25\n    var isStudent bool = true\n\n    fmt.Printf(\"Name: %s, Age: %d, Student: %t\\n\", name, age, isStudent)\n    // Output: Name: Alice, Age: 25, Student: true\n}\n</code></pre> short_declaration.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Bob\"        // Type inferred as string\n    age := 30           // Type inferred as int\n    isStudent := false  // Type inferred as bool\n\n    fmt.Printf(\"Name: %s, Age: %d, Student: %t\\n\", name, age, isStudent)\n    // Output: Name: Bob, Age: 30, Student: false\n}\n</code></pre> <p>Most Common</p> <p>Short declaration (<code>:=</code>) is the most commonly used method in Go. But please be minded that it is used when we know the value of the variable and it cannot be assigned as a global variable. If you do, you will get an error.</p>"},{"location":"1.%20Basics/4.%20Data-Types/#multiple-variable-declaration","title":"Multiple Variable Declaration","text":"<p>Declaring Multiple Variables</p> Grouped DeclarationMultiple Assignment grouped_vars.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var (\n        name     string = \"Charlie\"\n        age      int    = 35\n        salary   float64 = 75000.50\n        isActive bool   = true\n    )\n\n    fmt.Printf(\"Employee: %s, Age: %d, Salary: %.2f, Active: %t\\n\",\n        name, age, salary, isActive)\n}\n</code></pre> multiple_assignment.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name, age, city := \"Diana\", 28, \"New York\"\n    var i int;\n    var first, second, third bool\n\n    fmt.Printf(\"Name: %s, Age: %d, City: %s\\n\", name, age, city)\n    // Output: Name: Diana, Age: 28, City: New York\n    fmt.Println(i, first, second, third)\n    // Output: 0, false, false, false\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#variable-naming-conventions","title":"Variable Naming Conventions","text":"<p>Go Naming Best Practices</p> <ol> <li> <p>CamelCase: Use camelCase for variable names     <pre><code>firstName := \"John\"\nlastName := \"Doe\"\nphoneNumber := \"123-456-7890\"\n</code></pre></p> </li> <li> <p>Descriptive Names: Choose meaningful names     <pre><code>// Good\nuserAge := 25\ntotalPrice := 99.99\n\n// Avoid\na := 25\ntp := 99.99\n</code></pre></p> </li> <li> <p>Short Names for Short Scope: Use short names for limited scope     <pre><code>for i := 0; i &lt; 10; i++ {  // 'i' is fine for loop counter\n    // ...\n}\n</code></pre></p> </li> <li> <p>Exported vs Unexported: Capitalization determines visibility     <pre><code>var PublicVariable = \"visible outside package\"\nvar privateVariable = \"only visible within package\"\n</code></pre></p> </li> </ol>"},{"location":"1.%20Basics/4.%20Data-Types/#basic-data-types-deep-dive","title":"Basic Data Types Deep Dive","text":""},{"location":"1.%20Basics/4.%20Data-Types/#integer-types","title":"Integer Types","text":"<p>Go provides a rich set of integer types for different use cases and memory requirements.</p> <p>Integer Type Reference</p> Type Size Range Use Case <code>int8</code> 8 bits -128 to 127 Small signed values <code>int16</code> 16 bits -32,768 to 32,767 Medium signed values <code>int32</code> 32 bits -2.1B to 2.1B Large signed values <code>int64</code> 64 bits -9.2E18 to 9.2E18 Very large signed values <code>uint8</code> 8 bits 0 to 255 Small unsigned values <code>uint16</code> 16 bits 0 to 65,535 Medium unsigned values <code>uint32</code> 32 bits 0 to 4.3B Large unsigned values <code>uint64</code> 64 bits 0 to 1.8E19 Very large unsigned values <code>int</code> Platform 32 or 64 bits General purpose <code>uint</code> Platform 32 or 64 bits General unsigned <code>uintptr</code> Platform Pointer size Memory addresses <p>Integer Examples</p> Basic Integer UsageInteger Overflow Behavior integers.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Different integer types\n    var smallNum int8 = 127\n    var mediumNum int16 = 32767\n    var largeNum int32 = 2147483647\n    var veryLargeNum int64 = 9223372036854775807\n\n    // Platform-dependent int\n    var defaultInt int = 42\n\n    // Unsigned integers\n    var positiveNum uint8 = 255\n    var bigPositive uint32 = 4294967295\n\n    fmt.Printf(\"int8: %d\\n\", smallNum)\n    fmt.Printf(\"int16: %d\\n\", mediumNum)\n    fmt.Printf(\"int32: %d\\n\", largeNum)\n    fmt.Printf(\"int64: %d\\n\", veryLargeNum)\n    fmt.Printf(\"int: %d\\n\", defaultInt)\n    fmt.Printf(\"uint8: %d\\n\", positiveNum)\n    fmt.Printf(\"uint32: %d\\n\", bigPositive)\n}\n</code></pre> overflow.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var maxInt8 int8 = 127\n    fmt.Printf(\"Max int8: %d\\n\", maxInt8)\n\n    // This would cause overflow (compile-time error)\n    var overflow int8 = 128  // Error: constant 128 overflows int8\n\n    // Runtime overflow wraps around\n    maxInt8++\n    fmt.Printf(\"After increment: %d\\n\", maxInt8) // -128\n}\n</code></pre> <p>Keep these in mind. <code>int</code> can take both positive and negative numbers. So when we say <code>var max int8</code>, the varialbe <code>max</code> can hold value value from -128 to 127. So when we assign a positive value of 128 to a <code>int8</code> it gives us overflow. But if we use <code>var max uint8</code> we can have a number up to 0 - 255 as it can hold only positive numbers. </p> <p>If you think how it's calculated, computer architecture primarily have a base 2 system (0s and 1s). So when we say we have a integer with 8 representation as bits, we can have a value of 256, that is 2^8.</p>"},{"location":"1.%20Basics/4.%20Data-Types/#floating-point-types","title":"Floating-Point Types","text":"<p>Go provides two floating-point types for decimal numbers.</p> <p>Floating-Point Types</p> Type Size Precision Range <code>float32</code> 32 bits ~7 decimal digits \u00b11.18E-38 to \u00b13.4E38 <code>float64</code> 64 bits ~15 decimal digits \u00b12.23E-308 to \u00b11.8E308 Basic Float UsagePrecision Considerations floats.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var price float32 = 19.99\n    var pi float64 = 3.141592653589793\n\n    // Type inference defaults to float64\n    temperature := 23.5\n\n    fmt.Printf(\"Price: %.2f\\n\", price)\n    fmt.Printf(\"Pi: %.15f\\n\", pi)\n    fmt.Printf(\"Temperature: %.1f\u00b0C\\n\", temperature)\n\n    // Scientific notation\n    var scientific float64 = 1.23e-4\n    fmt.Printf(\"Scientific: %e\\n\", scientific)\n}\n</code></pre> precision.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var f32 float32 = 0.1\n    var f64 float64 = 0.1\n\n    // Floating-point precision differences\n    fmt.Printf(\"float32: %.20f\\n\", f32)\n    fmt.Printf(\"float64: %.20f\\n\", f64)\n    // float32: 0.10000000149011611938\n    // float64: 0.10000000000000000555\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#string-type","title":"String Type","text":"<p>Strings in Go are immutable sequences of bytes, typically containing UTF-8 encoded text.</p> <p>String Operations</p> Basic String UsageString Indexing and Slicing strings.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var greeting string = \"Hello, World!\"\n    name := \"Go\"\n\n    // String concatenation\n    message := greeting + \" Welcome to \" + name + \"!\"\n\n    // String length\n    fmt.Printf(\"Message: %s\\n\", message)\n    fmt.Printf(\"Length: %d bytes\\n\", len(message))\n\n    // Raw strings (backticks)\n    multiline := `This is a\n    multi-line\n    string`\n    fmt.Println(multiline)\n}\n</code></pre> string_slicing.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    text := \"Hello, Go!\"\n\n    // String indexing (returns byte values)\n    fmt.Printf(\"First byte: %c (%d)\\n\", text[0], text[0])\n    fmt.Printf(\"Last byte: %c (%d)\\n\", text[len(text)-1], text[len(text)-1])\n\n    // String slicing\n    fmt.Printf(\"Substring: %s\\n\", text[0:5])   // \"Hello\"\n    fmt.Printf(\"From index 7: %s\\n\", text[7:]) // \"Go!\"\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#boolean-type","title":"Boolean Type","text":"<p>The boolean type represents truth values: <code>true</code> or <code>false</code>.</p> <p>Boolean Usage</p> booleans.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var isActive bool = true\n    var isComplete bool = false\n\n    // Boolean operations\n    fmt.Printf(\"Active: %t\\n\", isActive)\n    fmt.Printf(\"Complete: %t\\n\", isComplete)\n\n    // Logical operations\n    fmt.Printf(\"AND: %t\\n\", isActive &amp;&amp; isComplete)  // false\n    fmt.Printf(\"OR: %t\\n\", isActive || isComplete)   // true\n    fmt.Printf(\"NOT: %t\\n\", !isActive)              // false\n\n    // Boolean in conditions\n    if isActive {\n        fmt.Println(\"System is running\")\n    }\n}\n</code></pre> <p>At default the bool variable will be assigned a value <code>false</code> and an integer variable will be assigned a value of <code>0</code>. String will be assigned a value <code>\"\"</code>. As you have guessed, the complex, and float data types will be assigned to zero value based on their represenation.</p>"},{"location":"1.%20Basics/4.%20Data-Types/#constants-immutable-values","title":"Constants: Immutable Values","text":"<p>Constants are immutable values known at compile time. They provide guarantees and optimizations. They are hard coded during the compile time.</p>"},{"location":"1.%20Basics/4.%20Data-Types/#constant-declaration","title":"Constant Declaration","text":"<p>Constant Types</p> Basic ConstantsTyped ConstantsConstant Groups constants.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    const pi = 3.14159\n    const greeting = \"Hello\"\n    const maxUsers = 1000\n    const isEnabled = true\n\n    fmt.Printf(\"Pi: %.5f\\n\", pi)\n    fmt.Printf(\"Greeting: %s\\n\", greeting)\n    fmt.Printf(\"Max Users: %d\\n\", maxUsers)\n    fmt.Printf(\"Enabled: %t\\n\", isEnabled)\n}\n</code></pre> typed_constants.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    const pi float64 = 3.14159265359\n    const name string = \"Go Language\"\n    const version int = 1\n    const stable bool = true\n\n    fmt.Printf(\"Language: %s v%d\\n\", name, version)\n    fmt.Printf(\"Pi: %.10f\\n\", pi)\n    fmt.Printf(\"Stable: %t\\n\", stable)\n}\n</code></pre> constant_groups.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    const (\n        StatusPending   = \"pending\"\n        StatusApproved  = \"approved\"\n        StatusRejected  = \"rejected\"\n        MaxRetries      = 3\n        TimeoutSeconds  = 30\n    )\n\n    fmt.Printf(\"Status: %s\\n\", StatusPending)\n    fmt.Printf(\"Max Retries: %d\\n\", MaxRetries)\n    fmt.Printf(\"Timeout: %d seconds\\n\", TimeoutSeconds)\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#enumerations-with-iota","title":"Enumerations with iota","text":"<p>Go doesn't have built-in enums, but you can create them using constants and <code>iota</code>.</p> <p>Using iota for Enumerations</p> Basic iota UsageAdvanced iota Patterns iota_basic.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    const (\n        Sunday = iota    // 0\n        Monday           // 1\n        Tuesday          // 2\n        Wednesday        // 3\n        Thursday         // 4\n        Friday           // 5\n        Saturday         // 6\n    )\n\n    fmt.Printf(\"Sunday: %d\\n\", Sunday)\n    fmt.Printf(\"Wednesday: %d\\n\", Wednesday)\n    fmt.Printf(\"Saturday: %d\\n\", Saturday)\n}\n</code></pre> iota_advanced.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    const (\n        _  = iota             // Skip 0\n        KB = 1 &lt;&lt; (10 * iota) // 1024\n        MB                    // 1048576\n        GB                    // 1073741824\n        TB                    // 1099511627776\n    )\n\n    fmt.Printf(\"1 KB = %d bytes\\n\", KB)\n    fmt.Printf(\"1 MB = %d bytes\\n\", MB)\n    fmt.Printf(\"1 GB = %d bytes\\n\", GB)\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>Go provides standard arithmetic operations with type safety and predictable behavior.</p>"},{"location":"1.%20Basics/4.%20Data-Types/#basic-arithmetic-operators","title":"Basic Arithmetic Operators","text":"<p>Arithmetic Operations</p> Basic OperationsAssignment OperatorsIncrement/Decrement arithmetic.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    a, b := 15, 4\n\n    fmt.Printf(\"a = %d, b = %d\\n\", a, b)\n    fmt.Printf(\"Addition: %d + %d = %d\\n\", a, b, a+b)\n    fmt.Printf(\"Subtraction: %d - %d = %d\\n\", a, b, a-b)\n    fmt.Printf(\"Multiplication: %d * %d = %d\\n\", a, b, a*b)\n    fmt.Printf(\"Division: %d / %d = %d\\n\", a, b, a/b)\n    fmt.Printf(\"Remainder: %d %% %d = %d\\n\", a, b, a%b)\n\n    // Floating-point division\n    fmt.Printf(\"Float Division: %.2f / %.2f = %.2f\\n\",\n        float64(a), float64(b), float64(a)/float64(b))\n}\n</code></pre> assignment_ops.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 10\n    fmt.Printf(\"Initial x: %d\\n\", x)\n\n    x += 5   // x = x + 5\n    fmt.Printf(\"After x += 5: %d\\n\", x)\n\n    x -= 3   // x = x - 3\n    fmt.Printf(\"After x -= 3: %d\\n\", x)\n\n    x *= 2   // x = x * 2\n    fmt.Printf(\"After x *= 2: %d\\n\", x)\n\n    x /= 4   // x = x / 4\n    fmt.Printf(\"After x /= 4: %d\\n\", x)\n}\n</code></pre> increment.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    counter := 5\n    fmt.Printf(\"Initial counter: %d\\n\", counter)\n\n    counter++  // Increment by 1\n    fmt.Printf(\"After counter++: %d\\n\", counter)\n\n    counter--  // Decrement by 1\n    fmt.Printf(\"After counter--: %d\\n\", counter)\n\n    // Note: ++counter and --counter are not valid in Go\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#type-conversions","title":"Type Conversions","text":"<p>Go requires explicit type conversions between different numeric types.</p> <p>Type Conversion Examples</p> Numeric ConversionsSafe Conversions conversions.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i int = 42\n    var f float64 = float64(i)  // int to float64\n    var u uint = uint(f)        // float64 to uint\n\n    fmt.Printf(\"int: %d\\n\", i)\n    fmt.Printf(\"float64: %.2f\\n\", f)\n    fmt.Printf(\"uint: %d\\n\", u)\n\n    // String conversions\n    var str string = fmt.Sprintf(\"%d\", i)\n    fmt.Printf(\"string: %s\\n\", str)\n}\n</code></pre> safe_conversions.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var bigNum int64 = 1000000\n\n    // Safe conversion (value fits)\n    var smallNum int32 = int32(bigNum)\n    fmt.Printf(\"Safe conversion: %d\\n\", smallNum)\n\n    // Potentially unsafe conversion\n    var veryBig int64 = 9223372036854775807\n    var truncated int32 = int32(veryBig)\n    fmt.Printf(\"Truncated: %d\\n\", truncated) // May lose data\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#advanced-type-concepts","title":"Advanced Type Concepts","text":""},{"location":"1.%20Basics/4.%20Data-Types/#type-aliases-and-definitions","title":"Type Aliases and Definitions","text":"<p>Custom Types</p> Type AliasesType Definitions type_alias.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    type UserID = int64    // Type alias\n    type Username = string // Type alias\n\n    var id UserID = 12345\n    var name Username = \"alice\"\n\n    fmt.Printf(\"User ID: %d\\n\", id)\n    fmt.Printf(\"Username: %s\\n\", name)\n\n    // Can use interchangeably with underlying type\n    var regularInt int64 = id\n    fmt.Printf(\"Regular int: %d\\n\", regularInt)\n}\n</code></pre> type_definition.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    type Temperature float64  // New type\n    type Distance int         // New type\n\n    var temp Temperature = 23.5\n    var dist Distance = 100\n\n    fmt.Printf(\"Temperature: %.1f\u00b0C\\n\", temp)\n    fmt.Printf(\"Distance: %d meters\\n\", dist)\n\n    // Cannot mix with underlying type without conversion\n    // var f float64 = temp  // Error!\n    var f float64 = float64(temp)  // OK\n    fmt.Printf(\"As float64: %.1f\\n\", f)\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#tip","title":"Tip:","text":"<p>To verify the data type of a variable we can use the following method, <code>%T</code>.</p> <pre><code>var f float64 = float64(temp)\nfmt.Println(\"%T\", f) // return float64\n</code></pre>"},{"location":"1.%20Basics/4.%20Data-Types/#best-practices","title":"Best Practices","text":"<p>Data Type Best Practices</p> <ol> <li> <p>Choose Appropriate Types</p> <ul> <li>Use <code>int</code> for general integer operations</li> <li>Use specific sizes (<code>int32</code>, <code>int64</code>) when needed</li> <li>Prefer <code>float64</code> over <code>float32</code> for precision</li> </ul> </li> <li> <p>Variable Naming</p> <ul> <li>Use descriptive names for clarity</li> <li>Follow Go naming conventions</li> <li>Use short names for limited scope</li> </ul> </li> <li> <p>Constants Over Variables</p> <ul> <li>Use constants for values that don't change</li> <li>Group related constants together</li> <li>Use <code>iota</code> for enumerations</li> </ul> </li> <li> <p>Type Safety</p> <ul> <li>Explicit type conversions prevent bugs</li> <li>Be careful with numeric overflow</li> <li>Validate conversions when necessary</li> </ul> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Integer Overflow: Be aware of type limits</li> <li>Float Precision: Floating-point arithmetic isn't exact</li> <li>Type Mixing: Go doesn't allow implicit conversions</li> <li>String Immutability: Strings can't be modified in place</li> </ul>"},{"location":"1.%20Basics/4.%20Data-Types/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>Variables: Multiple declaration methods (<code>:=</code> most common)</li> <li>Types: Rich set of numeric, string, and boolean types</li> <li>Constants: Immutable values with compile-time guarantees</li> <li>Operations: Type-safe arithmetic with explicit conversions</li> <li>Best Practices: Choose appropriate types and follow conventions</li> </ol> <p>Remember</p> <p>\"Go's type system is designed for clarity and safety. Embrace explicit conversions and descriptive naming for maintainable code.\"</p>"},{"location":"1.%20Basics/5.%20If-and%20While/","title":"Go Loops: For, While, and Control Flow","text":"<p>Overview</p> <p>Master Go's powerful loop constructs and control flow mechanisms. This comprehensive guide covers the versatile <code>for</code> loop, while-style loops, and essential control statements like <code>break</code> and <code>continue</code>, building upon our foundation of data types and variables.</p> <p>Key Points</p> <ul> <li>Go has only one loop construct: the <code>for</code> loop</li> <li>Multiple patterns: classic, while-style, infinite, and range loops</li> <li>Powerful control flow with <code>break</code> and <code>continue</code></li> <li>Clean and readable iteration patterns</li> <li>Efficient performance with proper loop design</li> </ul>"},{"location":"1.%20Basics/5.%20If-and%20While/#understanding-gos-loop-philosophy","title":"Understanding Go's Loop Philosophy","text":"<p>Go simplifies loop constructs by providing a single, versatile <code>for</code> loop that can handle all iteration needs. This design promotes consistency and reduces complexity.</p> <p>Loop Patterns in Go</p> <pre><code>graph TD\n    A[Go For Loop] --&gt; B[Classic For]\n    A --&gt; C[While-Style]\n    A --&gt; D[Infinite Loop]\n    A --&gt; E[Range Loop]\n    B --&gt; B1[Init; Condition; Post]\n    C --&gt; C1[Condition Only]\n    D --&gt; D1[No Conditions]\n    E --&gt; E1[Iterate Collections]\n    style A fill:#555,stroke:#333,stroke-width:2px,color:#000</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#classic-for-loop","title":"Classic For Loop","text":"<p>The classic <code>for</code> loop provides precise control over initialization, condition checking, and post-iteration operations.</p>"},{"location":"1.%20Basics/5.%20If-and%20While/#basic-structure","title":"Basic Structure","text":"<p>Classic For Loop Syntax</p> Standard PatternFlexible InitializationDifferent Step Sizes classic_for.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 0; i &lt; 5; i++ {\n        fmt.Printf(\"Iteration %d\\n\", i)\n    }\n\n    // Output:\n    // Iteration 0\n    // Iteration 1\n    // Iteration 2\n    // Iteration 3\n    // Iteration 4\n}\n</code></pre> <p>Three Components</p> <ol> <li>Init: <code>i := 0</code> - executed once before the loop</li> <li>Condition: <code>i &lt; 5</code> - checked before each iteration</li> <li>Post: <code>i++</code> - executed after each iteration</li> </ol> flexible_init.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Multiple variables in init\n    for i, j := 0, 10; i &lt; j; i, j = i+1, j-1 {\n        fmt.Printf(\"i=%d, j=%d\\n\", i, j)\n    }\n\n    // Output:\n    // i=0, j=10\n    // i=1, j=9\n    // i=2, j=8\n    // i=3, j=7\n    // i=4, j=6\n}\n</code></pre> step_sizes.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Increment by 2\n    fmt.Println(\"Even numbers:\")\n    for i := 0; i &lt;= 10; i += 2 {\n        fmt.Printf(\"%d \", i)\n    }\n    fmt.Println()\n\n    // Decrement\n    fmt.Println(\"Countdown:\")\n    for i := 5; i &gt;= 0; i-- {\n        fmt.Printf(\"%d \", i)\n    }\n    fmt.Println()\n\n    // Output:\n    // Even numbers: 0 2 4 6 8 10\n    // Countdown: 5 4 3 2 1 0\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#while-style-loops-simplified-iteration","title":"While-Style Loops: Simplified Iteration","text":"<p>Go's <code>for</code> loop can mimic traditional while loops by omitting the init and post statements.</p>"},{"location":"1.%20Basics/5.%20If-and%20While/#while-loop-pattern","title":"While Loop Pattern","text":"<p>While-Style Loops</p> Basic While PatternInput ProcessingCondition-Based Processing while_basic.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    i := 0\n    for i &lt; 5 {\n        fmt.Printf(\"Count: %d\\n\", i)\n        i++\n    }\n\n    // Output:\n    // Count: 0\n    // Count: 1\n    // Count: 2\n    // Count: 3\n    // Count: 4\n}\n</code></pre> <p>While Equivalent</p> <p>This is equivalent to <code>while (i &lt; 5)</code> in other languages.</p> input_processing.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var input string\n\n    for input != \"quit\" {\n        fmt.Print(\"Enter command (or 'quit' to exit): \")\n        fmt.Scanln(&amp;input)\n\n        if input != \"quit\" {\n            fmt.Printf(\"You entered: %s\\n\", input)\n        }\n    }\n\n    fmt.Println(\"Goodbye!\")\n}\n</code></pre> condition_based.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n)\n\nfunc main() {\n    target := 7\n    attempts := 0\n\n    for {\n        guess := rand.Intn(10) + 1\n        attempts++\n        fmt.Printf(\"Attempt %d: Guessed %d\\n\", attempts, guess)\n\n        if guess == target {\n            fmt.Printf(\"Found target %d in %d attempts!\\n\", target, attempts)\n            break\n        }\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#infinite-loops-continuous-processing","title":"Infinite Loops: Continuous Processing","text":"<p>Infinite loops are useful for servers, event handlers, and continuous processing scenarios.</p> <p>Infinite Loop Patterns</p> Basic Infinite LoopServer-Style Loop infinite_basic.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    counter := 0\n    for {\n        fmt.Printf(\"Running... %d\\n\", counter)\n        counter++\n\n        if counter &gt;= 3 {\n            fmt.Println(\"Breaking out of infinite loop\")\n            break\n        }\n    }\n}\n</code></pre> server_loop.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    fmt.Println(\"Server starting...\")\n\n    for {\n        // Simulate processing\n        fmt.Println(\"Processing request...\")\n        time.Sleep(1 * time.Second)\n\n        // In a real server, you'd handle actual requests here\n        // This example will run forever (Ctrl+C to stop)\n        break // Remove this to see infinite behavior\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#control-flow-break-and-continue","title":"Control Flow: Break and Continue","text":"<p>Control flow statements provide fine-grained control over loop execution.</p>"},{"location":"1.%20Basics/5.%20If-and%20While/#break-statement","title":"Break Statement","text":"<p>The <code>break</code> statement immediately exits the loop.</p> <p>Break Statement Usage</p> Simple BreakSearch and BreakNested Loop Break break_simple.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 0; i &lt; 10; i++ {\n        fmt.Printf(\"i = %d\\n\", i)\n\n        if i == 5 {\n            fmt.Println(\"Breaking at 5\")\n            break\n        }\n    }\n    fmt.Println(\"Loop ended\")\n\n    // Output:\n    // i = 0\n    // i = 1\n    // i = 2\n    // i = 3\n    // i = 4\n    // i = 5\n    // Breaking at 5\n    // Loop ended\n}\n</code></pre> search_break.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 3, 7, 9, 12, 15, 18}\n    target := 12\n\n    for i, num := range numbers {\n        if num == target {\n            fmt.Printf(\"Found %d at index %d\\n\", target, i)\n            break\n        }\n        fmt.Printf(\"Checking %d at index %d\\n\", num, i)\n    }\n}\n</code></pre> nested_break.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    found := false\n\n    for i := 0; i &lt; 3 &amp;&amp; !found; i++ {\n        for j := 0; j &lt; 3; j++ {\n            fmt.Printf(\"i=%d, j=%d\\n\", i, j)\n\n            if i == 1 &amp;&amp; j == 1 {\n                fmt.Println(\"Found target position!\")\n                found = true\n                break // Only breaks inner loop\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#continue-statement","title":"Continue Statement","text":"<p>The <code>continue</code> statement skips the rest of the current iteration and moves to the next one.</p> <p>Continue Statement Usage</p> Skip Even NumbersData ValidationError Handling continue_skip.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Odd numbers from 1 to 10:\")\n    for i := 1; i &lt;= 10; i++ {\n        if i%2 == 0 {\n            continue // Skip even numbers\n        }\n        fmt.Printf(\"%d \", i)\n    }\n    fmt.Println()\n\n    // Output: 1 3 5 7 9\n}\n</code></pre> data_validation.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    data := []int{1, -2, 3, 0, 5, -7, 8}\n\n    fmt.Println(\"Processing positive numbers:\")\n    for i, value := range data {\n        if value &lt;= 0 {\n            fmt.Printf(\"Skipping invalid value %d at index %d\\n\", value, i)\n            continue\n        }\n\n        // Process valid data\n        result := value * 2\n        fmt.Printf(\"Processed %d -&gt; %d\\n\", value, result)\n    }\n}\n</code></pre> error_handling.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc main() {\n    inputs := []string{\"1\", \"abc\", \"3\", \"def\", \"5\"}\n\n    for i, input := range inputs {\n        num, err := strconv.Atoi(input)\n        if err != nil {\n            fmt.Printf(\"Error converting '%s' at index %d: %v\\n\", input, i, err)\n            continue\n        }\n\n        fmt.Printf(\"Successfully converted '%s' to %d\\n\", input, num)\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#advanced-loop-patterns","title":"Advanced Loop Patterns","text":""},{"location":"1.%20Basics/5.%20If-and%20While/#labeled-breaks-and-continues","title":"Labeled Breaks and Continues","text":"<p>For complex nested loops, Go provides labeled breaks and continues.</p> <p>Labeled Control Flow</p> Labeled BreakLabeled Continue labeled_break.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Searching in 2D array:\")\n\nouter:\n    for i := 0; i &lt; 3; i++ {\n        for j := 0; j &lt; 3; j++ {\n            fmt.Printf(\"Checking position [%d][%d]\\n\", i, j)\n\n            if i == 1 &amp;&amp; j == 1 {\n                fmt.Println(\"Found target! Breaking out of both loops\")\n                break outer\n            }\n        }\n    }\n\n    fmt.Println(\"Search completed\")\n}\n</code></pre> labeled_continue.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Processing matrix rows:\")\n\nrowLoop:\n    for i := 0; i &lt; 3; i++ {\n        fmt.Printf(\"Processing row %d:\\n\", i)\n\n        for j := 0; j &lt; 3; j++ {\n            if j == 1 &amp;&amp; i%2 == 0 {\n                fmt.Printf(\"  Skipping rest of row %d\\n\", i)\n                continue rowLoop\n            }\n            fmt.Printf(\"  Processing element [%d][%d]\\n\", i, j)\n        }\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#loop-performance-optimization","title":"Loop Performance Optimization","text":"<p>Performance Considerations</p> Pre-calculate Loop BoundsMinimize Work in Loop performance_bounds.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Good: Calculate length once\n    length := len(data)\n    for i := 0; i &lt; length; i++ {\n        fmt.Printf(\"Processing %d\\n\", data[i])\n    }\n\n    // Even better: Use range for slices\n    for i, value := range data {\n        fmt.Printf(\"Index %d: %d\\n\", i, value)\n    }\n}\n</code></pre> minimize_work.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n\n    // Pre-calculate expensive operations\n    multiplier := 2\n    prefix := \"Number: \"\n\n    for _, num := range numbers {\n        result := num * multiplier\n        fmt.Printf(\"%s%d\\n\", prefix, result)\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#best-practices","title":"Best Practices","text":"<p>Loop Best Practices</p> <ol> <li> <p>Choose the Right Pattern</p> <ul> <li>Use classic <code>for</code> when you need precise control</li> <li>Use while-style for condition-based loops</li> <li>Use <code>range</code> for collections (covered in Range documentation)</li> </ul> </li> <li> <p>Control Flow Guidelines</p> <ul> <li>Use <code>break</code> to exit loops early</li> <li>Use <code>continue</code> to skip iterations</li> <li>Use labeled breaks/continues for nested loops</li> </ul> </li> <li> <p>Performance Tips</p> <ul> <li>Pre-calculate loop bounds when possible</li> <li>Minimize work inside loop bodies</li> <li>Consider loop unrolling for critical paths</li> </ul> </li> <li> <p>Readability</p> <ul> <li>Use descriptive variable names</li> <li>Keep loop bodies concise</li> <li>Comment complex loop logic</li> </ul> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Infinite Loops: Always ensure loop conditions can become false</li> <li>Off-by-One Errors: Be careful with <code>&lt;</code> vs <code>&lt;=</code> conditions</li> <li>Modifying Loop Variables: Avoid changing loop counters inside the loop body</li> <li>Nested Loop Complexity: Consider extracting inner loops into functions</li> </ul>"},{"location":"1.%20Basics/5.%20If-and%20While/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>Single Loop Construct: Go uses only <code>for</code> loops for all iteration needs</li> <li>Multiple Patterns: Classic, while-style, infinite, and range loops</li> <li>Control Flow: <code>break</code> and <code>continue</code> provide fine-grained control</li> <li>Labels: Use labeled breaks/continues for complex nested scenarios</li> <li>Performance: Choose appropriate patterns and optimize loop bodies</li> </ol> <p>Remember</p> <p>\"Go's unified loop approach promotes consistency and simplicity. Master the <code>for</code> loop patterns and you'll handle any iteration scenario efficiently.\"</p>"},{"location":"1.%20Basics/6.%20Conditionals/","title":"Go Conditionals: If-Else and Switch Mastery","text":"<p>Overview</p> <p>Master Go's conditional statements for intelligent decision-making in your programs. This comprehensive guide covers if-else statements, switch statements, and advanced conditional patterns, building upon our understanding of loops and data types.</p> <p>Key Points</p> <ul> <li>Clean and readable conditional syntax</li> <li>Powerful switch statements with multiple patterns</li> <li>Short variable declarations in conditions</li> <li>Type switches for interface handling</li> <li>Fallthrough control in switch cases</li> </ul>"},{"location":"1.%20Basics/6.%20Conditionals/#understanding-conditional-logic","title":"Understanding Conditional Logic","text":"<p>Conditional statements are the decision-making backbone of any program. Go provides elegant and powerful constructs for handling different execution paths.</p> <p>Conditional Constructs in Go</p> <pre><code>graph TD\n    A[Go Conditionals] --&gt; B[If-Else]\n    A --&gt; C[Switch]\n    B --&gt; B1[Basic If]\n    B --&gt; B2[If-Else]\n    B --&gt; B3[If-Else If]\n    B --&gt; B4[Short Declaration]\n    C --&gt; C1[Expression Switch]\n    C --&gt; C2[Type Switch]\n    C --&gt; C3[No Expression]\n    C --&gt; C4[Fallthrough]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#if-else-statements-basic-decision-making","title":"If-Else Statements: Basic Decision Making","text":"<p>The if-else family provides straightforward conditional execution based on boolean expressions.</p>"},{"location":"1.%20Basics/6.%20Conditionals/#basic-if-statement","title":"Basic If Statement","text":"<p>Simple If Statements</p> Basic IfMultiple ConditionsComparison Operators basic_if.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    temperature := 25\n\n    if temperature &gt; 20 {\n        fmt.Println(\"It's a warm day!\")\n    }\n\n    // Output: It's a warm day!\n}\n</code></pre> <p>Boolean Conditions</p> <p>The condition must evaluate to a boolean value (<code>true</code> or <code>false</code>).</p> multiple_conditions.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    age := 25\n    hasLicense := true\n\n    if age &gt;= 18 &amp;&amp; hasLicense {\n        fmt.Println(\"You can drive!\")\n    }\n\n    // Output: You can drive!\n}\n</code></pre> comparisons.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    score := 85\n\n    if score &gt;= 90 {\n        fmt.Println(\"Grade: A\")\n    }\n\n    if score &gt;= 80 &amp;&amp; score &lt; 90 {\n        fmt.Println(\"Grade: B\")\n    }\n\n    if score &lt; 60 {\n        fmt.Println(\"Grade: F\")\n    }\n\n    // Output: Grade: B\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#if-else-statement","title":"If-Else Statement","text":"<p>If-Else Patterns</p> Basic If-ElseIf-Else If ChainComplex Conditions if_else.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    number := 7\n\n    if number%2 == 0 {\n        fmt.Printf(\"%d is even\\n\", number)\n    } else {\n        fmt.Printf(\"%d is odd\\n\", number)\n    }\n\n    // Output: 7 is odd\n}\n</code></pre> if_else_if.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    grade := 85\n\n    if grade &gt;= 90 {\n        fmt.Println(\"Excellent!\")\n    } else if grade &gt;= 80 {\n        fmt.Println(\"Good job!\")\n    } else if grade &gt;= 70 {\n        fmt.Println(\"Not bad!\")\n    } else {\n        fmt.Println(\"Keep trying!\")\n    }\n\n    // Output: Good job!\n}\n</code></pre> complex_conditions.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    age := 25\n    income := 50000\n    creditScore := 720\n\n    if age &gt;= 18 &amp;&amp; income &gt;= 30000 &amp;&amp; creditScore &gt;= 650 {\n        fmt.Println(\"Loan approved!\")\n    } else if age &lt; 18 {\n        fmt.Println(\"Must be 18 or older\")\n    } else if income &lt; 30000 {\n        fmt.Println(\"Insufficient income\")\n    } else {\n        fmt.Println(\"Credit score too low\")\n    }\n\n    // Output: Loan approved!\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#short-variable-declaration-in-if","title":"Short Variable Declaration in If","text":"<p>Go allows you to declare and initialize variables within if statements, creating a limited scope.</p> <p>Short Declaration in If</p> Basic Short DeclarationError Handling PatternFunction Call in Condition short_declaration.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Variable declared in if statement\n    if x := 10; x &gt; 5 {\n        fmt.Printf(\"x is %d and greater than 5\\n\", x)\n    }\n    // x is not accessible here\n\n    // Output: x is 10 and greater than 5\n}\n</code></pre> <p>Scope Limitation</p> <p>Variables declared in if statements are only accessible within the if-else block.</p> error_handling.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc main() {\n    input := \"123\"\n\n    if num, err := strconv.Atoi(input); err != nil {\n        fmt.Printf(\"Error converting '%s': %v\\n\", input, err)\n    } else {\n        fmt.Printf(\"Successfully converted to %d\\n\", num)\n    }\n\n    // Output: Successfully converted to 123\n}\n</code></pre> function_call.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc getTemperature() int {\n    return 25\n}\n\nfunc main() {\n    // Call function and use result in condition\n    if temp := getTemperature(); temp &gt; 20 {\n        fmt.Printf(\"Temperature is %d\u00b0C - Nice weather!\\n\", temp)\n    } else {\n        fmt.Printf(\"Temperature is %d\u00b0C - A bit cold\\n\", temp)\n    }\n\n    // Output: Temperature is 25\u00b0C - Nice weather!\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#switch-statements-multi-way-branching","title":"Switch Statements: Multi-Way Branching","text":"<p>Switch statements provide an elegant way to handle multiple conditions and are more readable than long if-else chains.</p>"},{"location":"1.%20Basics/6.%20Conditionals/#expression-switch","title":"Expression Switch","text":"<p>Basic Switch Statements</p> Simple SwitchSwitch with ExpressionSwitch with Short Declaration simple_switch.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    day := \"Monday\"\n\n    switch day {\n    case \"Monday\":\n        fmt.Println(\"Start of the work week\")\n    case \"Friday\":\n        fmt.Println(\"TGIF!\")\n    case \"Saturday\", \"Sunday\":\n        fmt.Println(\"Weekend!\")\n    default:\n        fmt.Println(\"Regular weekday\")\n    }\n\n    // Output: Start of the work week\n}\n</code></pre> switch_expression.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    score := 85\n\n    switch {\n    case score &gt;= 90:\n        fmt.Println(\"Grade: A\")\n    case score &gt;= 80:\n        fmt.Println(\"Grade: B\")\n    case score &gt;= 70:\n        fmt.Println(\"Grade: C\")\n    case score &gt;= 60:\n        fmt.Println(\"Grade: D\")\n    default:\n        fmt.Println(\"Grade: F\")\n    }\n\n    // Output: Grade: B\n}\n</code></pre> switch_short_declaration.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    switch hour := time.Now().Hour(); {\n    case hour &lt; 12:\n        fmt.Println(\"Good morning!\")\n    case hour &lt; 17:\n        fmt.Println(\"Good afternoon!\")\n    case hour &lt; 21:\n        fmt.Println(\"Good evening!\")\n    default:\n        fmt.Println(\"Good night!\")\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#advanced-switch-patterns","title":"Advanced Switch Patterns","text":"<p>Advanced Switch Usage</p> Multiple Values per CaseFallthrough BehaviorSwitch on Function Results multiple_values.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    char := 'a'\n\n    switch char {\n    case 'a', 'e', 'i', 'o', 'u':\n        fmt.Printf(\"'%c' is a vowel\\n\", char)\n    case 'y':\n        fmt.Printf(\"'%c' is sometimes a vowel\\n\", char)\n    default:\n        fmt.Printf(\"'%c' is a consonant\\n\", char)\n    }\n\n    // Output: 'a' is a vowel\n}\n</code></pre> fallthrough.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    number := 2\n\n    switch number {\n    case 1:\n        fmt.Println(\"One\")\n        fallthrough\n    case 2:\n        fmt.Println(\"Two or after One\")\n        fallthrough\n    case 3:\n        fmt.Println(\"Three or after Two\")\n    default:\n        fmt.Println(\"Other number\")\n    }\n\n    // Output:\n    // Two or after One\n    // Three or after Two\n}\n</code></pre> function_results.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc classify(n int) string {\n    if n%2 == 0 {\n        return \"even\"\n    }\n    return \"odd\"\n}\n\nfunc main() {\n    number := 7\n\n    switch classify(number) {\n    case \"even\":\n        fmt.Printf(\"%d is an even number\\n\", number)\n    case \"odd\":\n        fmt.Printf(\"%d is an odd number\\n\", number)\n    default:\n        fmt.Printf(\"Unknown classification for %d\\n\", number)\n    }\n\n    // Output: 7 is an odd number\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#type-switch","title":"Type Switch","text":"<p>Type switches are a powerful feature for working with interfaces and determining the actual type of a value.</p> <p>Type Switch Patterns</p> Basic Type SwitchType Switch with Multiple Types type_switch.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc describe(i interface{}) {\n    fmt.Printf(\"Value: %v, \", i)\n\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Type: int, Double: %d\\n\", v*2)\n    case string:\n        fmt.Printf(\"Type: string, Length: %d\\n\", len(v))\n    case bool:\n        fmt.Printf(\"Type: bool, Negated: %t\\n\", !v)\n    default:\n        fmt.Printf(\"Type: %T (unknown)\\n\", v)\n    }\n}\n\nfunc main() {\n    describe(42)\n    describe(\"hello\")\n    describe(true)\n    describe(3.14)\n\n    // Output:\n    // Value: 42, Type: int, Double: 84\n    // Value: hello, Type: string, Length: 5\n    // Value: true, Type: bool, Negated: false\n    // Value: 3.14, Type: float64 (unknown)\n}\n</code></pre> multiple_types.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc processValue(i interface{}) {\n    fmt.Printf(\"Processing: %v -&gt; \", i)\n\n    switch v := i.(type) {\n    case int, int32, int64:\n        fmt.Printf(\"Integer type: %T\\n\", v)\n    case float32, float64:\n        fmt.Printf(\"Float type: %T\\n\", v)\n    case string:\n        fmt.Printf(\"String with %d characters\\n\", len(v))\n    case []int:\n        fmt.Printf(\"Integer slice with %d elements\\n\", len(v))\n    case nil:\n        fmt.Println(\"Nil value\")\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n\nfunc main() {\n    processValue(42)\n    processValue(3.14)\n    processValue(\"Go\")\n    processValue([]int{1, 2, 3})\n    processValue(nil)\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#advanced-conditional-patterns","title":"Advanced Conditional Patterns","text":""},{"location":"1.%20Basics/6.%20Conditionals/#conditional-expressions-and-operators","title":"Conditional Expressions and Operators","text":"<p>Logical Operators and Complex Conditions</p> Logical OperatorsShort-Circuit Evaluation logical_operators.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    age := 25\n    hasJob := true\n    creditScore := 750\n\n    // AND operator\n    if age &gt;= 18 &amp;&amp; hasJob &amp;&amp; creditScore &gt;= 700 {\n        fmt.Println(\"Eligible for premium loan\")\n    }\n\n    // OR operator\n    if age &lt; 18 || creditScore &lt; 600 {\n        fmt.Println(\"Not eligible for loan\")\n    } else {\n        fmt.Println(\"Basic loan eligibility met\")\n    }\n\n    // NOT operator\n    if !(age &lt; 18) {\n        fmt.Println(\"Adult\")\n    }\n\n    // Output:\n    // Eligible for premium loan\n    // Basic loan eligibility met\n    // Adult\n}\n</code></pre> short_circuit.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc expensiveCheck() bool {\n    fmt.Println(\"Expensive check called\")\n    return true\n}\n\nfunc main() {\n    condition := false\n\n    // expensiveCheck() won't be called due to short-circuit\n    if condition &amp;&amp; expensiveCheck() {\n        fmt.Println(\"Both conditions true\")\n    }\n\n    // expensiveCheck() will be called\n    if !condition || expensiveCheck() {\n        fmt.Println(\"At least one condition true\")\n    }\n\n    // Output:\n    // Expensive check called\n    // At least one condition true\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#nested-conditionals","title":"Nested Conditionals","text":"<p>Nested Conditional Patterns</p> Nested If-ElseGuard Clauses nested_conditionals.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    weather := \"sunny\"\n    temperature := 25\n\n    if weather == \"sunny\" {\n        if temperature &gt; 20 {\n            fmt.Println(\"Perfect day for outdoor activities!\")\n        } else {\n            fmt.Println(\"Sunny but a bit cold\")\n        }\n    } else if weather == \"rainy\" {\n        if temperature &gt; 15 {\n            fmt.Println(\"Warm rain - good for plants\")\n        } else {\n            fmt.Println(\"Cold and rainy - stay inside\")\n        }\n    } else {\n        fmt.Println(\"Weather conditions unclear\")\n    }\n\n    // Output: Perfect day for outdoor activities!\n}\n</code></pre> guard_clauses.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc processUser(name string, age int, email string) {\n    // Guard clauses for early returns\n    if name == \"\" {\n        fmt.Println(\"Error: Name cannot be empty\")\n        return\n    }\n\n    if age &lt; 0 || age &gt; 150 {\n        fmt.Println(\"Error: Invalid age\")\n        return\n    }\n\n    if email == \"\" {\n        fmt.Println(\"Error: Email cannot be empty\")\n        return\n    }\n\n    // Main processing logic\n    fmt.Printf(\"Processing user: %s, age %d, email %s\\n\", name, age, email)\n}\n\nfunc main() {\n    processUser(\"Alice\", 25, \"alice@example.com\")\n    processUser(\"\", 30, \"bob@example.com\")\n    processUser(\"Charlie\", -5, \"charlie@example.com\")\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#best-practices","title":"Best Practices","text":"<p>Conditional Best Practices</p> <ol> <li> <p>Prefer Switch Over Long If-Else Chains <pre><code>// Good: Use switch for multiple discrete values\nswitch status {\ncase \"pending\", \"processing\":\n    handleInProgress()\ncase \"completed\":\n    handleCompleted()\ncase \"failed\":\n    handleFailed()\n}\n\n// Avoid: Long if-else chains\nif status == \"pending\" || status == \"processing\" {\n    handleInProgress()\n} else if status == \"completed\" {\n    handleCompleted()\n} else if status == \"failed\" {\n    handleFailed()\n}\n</code></pre></p> </li> <li> <p>Use Short Variable Declaration for Error Handling <pre><code>if result, err := someOperation(); err != nil {\n    return err\n} else {\n    return result\n}\n</code></pre></p> </li> <li> <p>Leverage Type Switches for Interface Handling <pre><code>switch v := value.(type) {\ncase string:\n    return processString(v)\ncase int:\n    return processInt(v)\ndefault:\n    return processUnknown(v)\n}\n</code></pre></p> </li> <li> <p>Use Guard Clauses for Early Returns <pre><code>func validate(input string) error {\n    if input == \"\" {\n        return errors.New(\"input cannot be empty\")\n    }\n    if len(input) &gt; 100 {\n        return errors.New(\"input too long\")\n    }\n    // Continue with main logic\n    return nil\n}\n</code></pre></p> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Missing Default Cases: Always consider adding default cases in switch statements</li> <li>Complex Conditions: Break down complex boolean expressions for readability</li> <li>Deep Nesting: Avoid deeply nested conditionals; use guard clauses instead</li> <li>Fallthrough Confusion: Be explicit about fallthrough behavior in switch statements</li> </ul>"},{"location":"1.%20Basics/6.%20Conditionals/#performance-considerations","title":"Performance Considerations","text":"<p>Optimization Tips</p> Switch vs If-Else PerformanceEfficient Condition Ordering performance_comparison.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc processWithSwitch(value int) string {\n    // Generally faster for many discrete values\n    switch value {\n    case 1, 2, 3:\n        return \"low\"\n    case 4, 5, 6:\n        return \"medium\"\n    case 7, 8, 9:\n        return \"high\"\n    default:\n        return \"unknown\"\n    }\n}\n\nfunc processWithIfElse(value int) string {\n    // Better for range conditions\n    if value &gt;= 1 &amp;&amp; value &lt;= 3 {\n        return \"low\"\n    } else if value &gt;= 4 &amp;&amp; value &lt;= 6 {\n        return \"medium\"\n    } else if value &gt;= 7 &amp;&amp; value &lt;= 9 {\n        return \"high\"\n    } else {\n        return \"unknown\"\n    }\n}\n\nfunc main() {\n    fmt.Println(processWithSwitch(5))\n    fmt.Println(processWithIfElse(5))\n}\n</code></pre> condition_ordering.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc checkConditions(value int) string {\n    // Order conditions by likelihood (most common first)\n    if value &gt;= 0 &amp;&amp; value &lt;= 100 {  // Most common case\n        return \"normal range\"\n    } else if value &lt; 0 {            // Less common\n        return \"negative\"\n    } else {                         // Least common\n        return \"above range\"\n    }\n}\n\nfunc main() {\n    fmt.Println(checkConditions(50))\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>If-Else: Use for boolean conditions and ranges</li> <li>Switch: Prefer for discrete values and type checking</li> <li>Short Declaration: Leverage for scoped variables in conditions</li> <li>Type Switch: Essential for interface type determination</li> <li>Guard Clauses: Use for early returns and validation</li> <li>Performance: Consider condition ordering and switch vs if-else trade-offs</li> </ol> <p>Remember</p> <p>\"Choose the right conditional construct for the job. Switch for discrete values, if-else for ranges and complex boolean logic, and type switches for interface handling.\"</p>"},{"location":"1.%20Basics/7.%20Arrays/","title":"Go Arrays and the Blank Identifier","text":"<p>Overview</p> <p>Master Go's array fundamentals and the powerful blank identifier. This comprehensive guide covers fixed-size arrays, initialization patterns, and the versatile underscore (<code>_</code>) for ignoring values, building upon our understanding of data types and control structures.</p> <p>Key Points</p> <ul> <li>Arrays are fixed-size, value types in Go</li> <li>Array length is part of the type definition</li> <li>Multiple initialization and declaration patterns</li> <li>The blank identifier (<code>_</code>) for discarding unwanted values</li> <li>Arrays vs slices: when to use each</li> </ul>"},{"location":"1.%20Basics/7.%20Arrays/#understanding-arrays-in-go","title":"Understanding Arrays in Go","text":"<p>Arrays in Go are fundamental data structures that store a fixed number of elements of the same type. Unlike slices, arrays have a compile-time fixed size that becomes part of their type.</p> <p>Array Characteristics</p> <pre><code>graph TD\n    A[Go Arrays] --&gt; B[Fixed Size]\n    A --&gt; C[Value Type]\n    A --&gt; D[Same Element Type]\n    A --&gt; E[Zero-Indexed]\n    B --&gt; B1[Size in Type Definition]\n    C --&gt; C1[Copied on Assignment]\n    D --&gt; D1[Type Safety]\n    E --&gt; E1[Access by Index]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#array-declaration-and-initialization","title":"Array Declaration and Initialization","text":"<p>Go provides multiple ways to declare and initialize arrays, each suited for different scenarios.</p>"},{"location":"1.%20Basics/7.%20Arrays/#basic-declaration-patterns","title":"Basic Declaration Patterns","text":"<p>Array Declaration Methods</p> Zero Value DeclarationLiteral InitializationCompiler-Inferred Length zero_values.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Declare array with zero values\n    var numbers [5]int\n    var names [3]string\n\n    fmt.Printf(\"Numbers: %v\\n\", numbers)  // [0 0 0 0 0]\n    fmt.Printf(\"Names: %v\\n\", names)     // [\"\" \"\" \"\"]\n\n    // Zero values by type:\n    // int: 0, string: \"\", bool: false, float: 0.0\n}\n</code></pre> <p>Zero Values</p> <p>Arrays are automatically initialized with zero values for their element type.</p> literal_init.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Initialize with literal values\n    scores := [5]int{95, 87, 92, 78, 88}\n    cities := [3]string{\"New York\", \"London\", \"Tokyo\"}\n\n    fmt.Printf(\"Scores: %v\\n\", scores)\n    fmt.Printf(\"Cities: %v\\n\", cities)\n\n    // Output:\n    // Scores: [95 87 92 78 88]\n    // Cities: [New York London Tokyo]\n}\n</code></pre> inferred_length.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Let compiler determine length\n    primes := [...]int{2, 3, 5, 7, 11, 13}\n    vowels := [...]string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\n    fmt.Printf(\"Primes: %v (length: %d)\\n\", primes, len(primes))\n    fmt.Printf(\"Vowels: %v (length: %d)\\n\", vowels, len(vowels))\n\n    // Output:\n    // Primes: [2 3 5 7 11 13] (length: 6)\n    // Vowels: [a e i o u] (length: 5)\n}\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#advanced-initialization","title":"Advanced Initialization","text":"<p>Advanced Array Patterns</p> Partial InitializationMulti-dimensional Arrays partial_init.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Partial initialization (rest are zero values)\n    numbers := [10]int{1, 2, 3}  // [1 2 3 0 0 0 0 0 0 0]\n\n    // Specific index initialization\n    sparse := [5]int{1: 10, 3: 30}  // [0 10 0 30 0]\n\n    fmt.Printf(\"Numbers: %v\\n\", numbers)\n    fmt.Printf(\"Sparse: %v\\n\", sparse)\n}\n</code></pre> multidimensional.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 2D array (matrix)\n    matrix := [3][3]int{\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9},\n    }\n\n    // 3D array\n    cube := [2][2][2]int{\n        {{1, 2}, {3, 4}},\n        {{5, 6}, {7, 8}},\n    }\n\n    fmt.Printf(\"Matrix:\\n\")\n    for i := 0; i &lt; 3; i++ {\n        fmt.Printf(\"%v\\n\", matrix[i])\n    }\n\n    fmt.Printf(\"Cube: %v\\n\", cube)\n}\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#array-operations-and-access","title":"Array Operations and Access","text":""},{"location":"1.%20Basics/7.%20Arrays/#accessing-and-modifying-elements","title":"Accessing and Modifying Elements","text":"<p>Array Element Operations</p> Basic Access and ModificationBounds Checking array_access.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fruits := [4]string{\"apple\", \"banana\", \"orange\", \"grape\"}\n\n    // Access elements by index\n    fmt.Printf(\"First fruit: %s\\n\", fruits[0])\n    fmt.Printf(\"Last fruit: %s\\n\", fruits[len(fruits)-1])\n\n    // Modify elements\n    fruits[1] = \"mango\"\n    fmt.Printf(\"Modified array: %v\\n\", fruits)\n\n    // Array length\n    fmt.Printf(\"Array length: %d\\n\", len(fruits))\n\n    // Output:\n    // First fruit: apple\n    // Last fruit: grape\n    // Modified array: [apple mango orange grape]\n    // Array length: 4\n}\n</code></pre> bounds_checking.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := [3]int{10, 20, 30}\n\n    // Safe access\n    for i := 0; i &lt; len(numbers); i++ {\n        fmt.Printf(\"numbers[%d] = %d\\n\", i, numbers[i])\n    }\n\n    // This would cause a runtime panic:\n    // fmt.Println(numbers[5])  // index out of range\n\n    fmt.Println(\"Array access completed safely\")\n}\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#iterating-over-arrays","title":"Iterating Over Arrays","text":"<p>Array Iteration Patterns</p> Traditional For LoopRange Loop with Index and ValueRange Loop with Value Only traditional_loop.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    temperatures := [7]float64{22.5, 25.0, 23.8, 26.2, 24.1, 21.9, 23.3}\n\n    fmt.Println(\"Daily temperatures:\")\n    for i := 0; i &lt; len(temperatures); i++ {\n        fmt.Printf(\"Day %d: %.1f\u00b0C\\n\", i+1, temperatures[i])\n    }\n}\n</code></pre> range_loop.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    colors := [5]string{\"red\", \"green\", \"blue\", \"yellow\", \"purple\"}\n\n    fmt.Println(\"Colors with indices:\")\n    for index, color := range colors {\n        fmt.Printf(\"Index %d: %s\\n\", index, color)\n    }\n}\n</code></pre> value_only.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := [4]int{95, 87, 92, 78}\n    total := 0\n\n    for _, score := range scores {\n        total += score\n    }\n\n    average := float64(total) / float64(len(scores))\n    fmt.Printf(\"Average score: %.2f\\n\", average)\n\n    // Output: Average score: 88.00\n}\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#the-blank-identifier-ignoring-values","title":"The Blank Identifier: Ignoring Values","text":"<p>The blank identifier (<code>_</code>) is a powerful Go feature that allows you to discard values you don't need.</p>"},{"location":"1.%20Basics/7.%20Arrays/#understanding-the-blank-identifier","title":"Understanding the Blank Identifier","text":"<p>Blank Identifier Usage</p> Ignoring Array IndicesIgnoring Array ValuesFunction Return Values ignore_indices.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    products := [4]string{\"laptop\", \"mouse\", \"keyboard\", \"monitor\"}\n\n    fmt.Println(\"Product list:\")\n    for _, product := range products {\n        fmt.Printf(\"- %s\\n\", product)\n    }\n\n    // Output:\n    // Product list:\n    // - laptop\n    // - mouse\n    // - keyboard\n    // - monitor\n}\n</code></pre> ignore_values.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    data := [6]int{10, 20, 30, 40, 50, 60}\n\n    fmt.Println(\"Array indices:\")\n    for index, _ := range data {\n        fmt.Printf(\"Index: %d\\n\", index)\n    }\n\n    // More commonly written as:\n    fmt.Println(\"\\nArray indices (alternative):\")\n    for index := range data {\n        fmt.Printf(\"Index: %d\\n\", index)\n    }\n}\n</code></pre> function_returns.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc getArrayStats(arr [5]int) (int, float64, int) {\n    sum := 0\n    for _, v := range arr {\n        sum += v\n    }\n    return sum, float64(sum) / float64(len(arr)), len(arr)\n}\n\nfunc main() {\n    numbers := [5]int{10, 20, 30, 40, 50}\n\n    // Only interested in the sum, ignore average and length\n    sum, _, _ := getArrayStats(numbers)\n    fmt.Printf(\"Sum: %d\\n\", sum)\n\n    // Only interested in average\n    _, average, _ := getArrayStats(numbers)\n    fmt.Printf(\"Average: %.2f\\n\", average)\n}\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#array-characteristics-and-behavior","title":"Array Characteristics and Behavior","text":""},{"location":"1.%20Basics/7.%20Arrays/#arrays-as-value-types","title":"Arrays as Value Types","text":"<p>Value Type Behavior</p> Array CopyingFunction Parameters array_copying.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    original := [3]int{1, 2, 3}\n\n    // Arrays are copied by value\n    copy := original\n    copy[0] = 100\n\n    fmt.Printf(\"Original: %v\\n\", original)  // [1 2 3]\n    fmt.Printf(\"Copy: %v\\n\", copy)         // [100 2 3]\n\n    // Changes to copy don't affect original\n}\n</code></pre> function_params.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc modifyArray(arr [3]int) {\n    arr[0] = 999\n    fmt.Printf(\"Inside function: %v\\n\", arr)\n}\n\nfunc modifyArrayPointer(arr *[3]int) {\n    arr[0] = 999\n    fmt.Printf(\"Inside function (pointer): %v\\n\", *arr)\n}\n\nfunc main() {\n    numbers := [3]int{1, 2, 3}\n\n    fmt.Printf(\"Before function call: %v\\n\", numbers)\n    modifyArray(numbers)\n    fmt.Printf(\"After function call: %v\\n\", numbers)\n\n    fmt.Println(\"\\nUsing pointer:\")\n    modifyArrayPointer(&amp;numbers)\n    fmt.Printf(\"After pointer function call: %v\\n\", numbers)\n}\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#array-comparison","title":"Array Comparison","text":"<p>Comparing Arrays</p> Array Equality array_equality.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    arr1 := [3]int{1, 2, 3}\n    arr2 := [3]int{1, 2, 3}\n    arr3 := [3]int{1, 2, 4}\n\n    // Arrays can be compared with == and !=\n    fmt.Printf(\"arr1 == arr2: %t\\n\", arr1 == arr2)  // true\n    fmt.Printf(\"arr1 == arr3: %t\\n\", arr1 == arr3)  // false\n    fmt.Printf(\"arr1 != arr3: %t\\n\", arr1 != arr3)  // true\n\n    // Arrays of different sizes cannot be compared\n    // arr4 := [4]int{1, 2, 3, 4}\n    // fmt.Println(arr1 == arr4)  // Compile error\n}\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#best-practices-and-common-patterns","title":"Best Practices and Common Patterns","text":"<p>Array Best Practices</p> <ol> <li> <p>Choose Arrays When Size is Fixed <pre><code>// Good: Fixed configuration values\nconst maxRetries = 3\nvar retryDelays [maxRetries]time.Duration\n\n// Consider slices for dynamic data\nvar dynamicData []int\n</code></pre></p> </li> <li> <p>Use Range for Iteration <pre><code>// Preferred: Safe and idiomatic\nfor i, value := range array {\n    process(i, value)\n}\n\n// Avoid: Error-prone\nfor i := 0; i &lt; len(array); i++ {\n    process(i, array[i])\n}\n</code></pre></p> </li> <li> <p>Leverage the Blank Identifier <pre><code>// When you only need values\nfor _, value := range array {\n    process(value)\n}\n\n// When you only need indices\nfor index := range array {\n    processIndex(index)\n}\n</code></pre></p> </li> <li> <p>Consider Pointers for Large Arrays <pre><code>func processLargeArray(arr *[1000]int) {\n    // Avoids copying 1000 integers\n    for i, v := range arr {\n        // Process array elements\n        _ = i + v\n    }\n}\n</code></pre></p> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Array Size in Type: <code>[3]int</code> and <code>[4]int</code> are different types</li> <li>Value Semantics: Arrays are copied, not referenced</li> <li>Bounds Checking: Runtime panics for out-of-bounds access</li> <li>Function Parameters: Large arrays are expensive to copy</li> </ul>"},{"location":"1.%20Basics/7.%20Arrays/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>Fixed Size: Arrays have compile-time determined, fixed sizes</li> <li>Value Types: Arrays are copied when assigned or passed to functions</li> <li>Type Safety: Array length is part of the type definition</li> <li>Zero Values: Arrays are initialized with zero values for their element type</li> <li>Blank Identifier: Use <code>_</code> to ignore unwanted values in range loops</li> <li>Comparison: Arrays of the same type and size can be compared with <code>==</code> and <code>!=</code></li> </ol> <p>Remember</p> <p>\"Use arrays when you need fixed-size collections with value semantics. For dynamic collections, prefer slices. The blank identifier is your friend for ignoring unwanted values.\"</p>"},{"location":"1.%20Basics/8.%20Slices/","title":"Go Slices: Dynamic Arrays and Memory Management","text":"<p>Overview</p> <p>Master Go's most versatile data structure - slices. This comprehensive guide covers dynamic arrays, memory management, slice operations, and advanced techniques, building upon our understanding of arrays and data types.</p> <p>Key Points</p> <ul> <li>Slices are dynamic, resizable arrays</li> <li>Reference types with underlying array backing</li> <li>Powerful built-in functions: <code>append</code>, <code>copy</code>, <code>make</code></li> <li>Memory-efficient with capacity management</li> <li>Essential for most Go programming tasks</li> </ul>"},{"location":"1.%20Basics/8.%20Slices/#understanding-slices-in-go","title":"Understanding Slices in Go","text":"<p>Slices are Go's answer to dynamic arrays, providing flexibility and efficiency that fixed-size arrays cannot offer. They're reference types that point to underlying arrays with automatic memory management.</p> <p>Slice Architecture</p> <pre><code>graph TD\n    A[Go Slice] --&gt; B[Pointer to Array]\n    A --&gt; C[Length]\n    A --&gt; D[Capacity]\n    B --&gt; E[Underlying Array]\n    E --&gt; F[Element 0]\n    E --&gt; G[Element 1]\n    E --&gt; H[Element 2]\n    E --&gt; I[...]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000\n    style E fill:#e1f5fe,stroke:#01579b,stroke-width:2px</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#slice-creation-patterns","title":"Slice Creation Patterns","text":"<p>Go provides multiple ways to create slices, each suited for different scenarios and performance requirements.</p>"},{"location":"1.%20Basics/8.%20Slices/#slice-literals-and-declarations","title":"Slice Literals and Declarations","text":"<p>Basic Slice Creation</p> Slice LiteralsZero Value and Nil SlicesType Inference slice_literals.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Create slice with initial values\n    fruits := []string{\"apple\", \"banana\", \"orange\", \"grape\"}\n    numbers := []int{1, 2, 3, 4, 5}\n\n    fmt.Printf(\"Fruits: %v (len=%d, cap=%d)\\n\", fruits, len(fruits), cap(fruits))\n    fmt.Printf(\"Numbers: %v (len=%d, cap=%d)\\n\", numbers, len(numbers), cap(numbers))\n\n    // Output:\n    // Fruits: [apple banana orange grape] (len=4, cap=4)\n    // Numbers: [1 2 3 4 5] (len=5, cap=5)\n}\n</code></pre> zero_nil_slices.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Nil slice (zero value)\n    var nilSlice []int\n    fmt.Printf(\"Nil slice: %v (len=%d, cap=%d, nil=%t)\\n\",\n        nilSlice, len(nilSlice), cap(nilSlice), nilSlice == nil)\n\n    // Empty slice (not nil)\n    emptySlice := []int{}\n    fmt.Printf(\"Empty slice: %v (len=%d, cap=%d, nil=%t)\\n\",\n        emptySlice, len(emptySlice), cap(emptySlice), emptySlice == nil)\n\n    // Output:\n    // Nil slice: [] (len=0, cap=0, nil=true)\n    // Empty slice: [] (len=0, cap=0, nil=false)\n}\n</code></pre> type_inference.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Type inferred from elements\n    mixed := []interface{}{1, \"hello\", 3.14, true}\n\n    // Slice of slices\n    matrix := [][]int{{1, 2}, {3, 4}, {5, 6}}\n\n    fmt.Printf(\"Mixed: %v\\n\", mixed)\n    fmt.Printf(\"Matrix: %v\\n\", matrix)\n\n    // Output:\n    // Mixed: [1 hello 3.14 true]\n    // Matrix: [[1 2] [3 4] [5 6]]\n}\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#the-make-function","title":"The make Function","text":"<p>The <code>make</code> function provides precise control over slice length and capacity allocation.</p> <p>Using make for Slice Creation</p> Basic make UsagePre-allocation for Performance make_basic.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // make([]Type, length, capacity)\n    slice1 := make([]int, 5)      // length=5, capacity=5\n    slice2 := make([]int, 3, 10)  // length=3, capacity=10\n\n    fmt.Printf(\"slice1: %v (len=%d, cap=%d)\\n\", slice1, len(slice1), cap(slice1))\n    fmt.Printf(\"slice2: %v (len=%d, cap=%d)\\n\", slice2, len(slice2), cap(slice2))\n\n    // Output:\n    // slice1: [0 0 0 0 0] (len=5, cap=5)\n    // slice2: [0 0 0] (len=3, cap=10)\n}\n</code></pre> preallocation.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Pre-allocate for known capacity to avoid reallocations\n    expectedSize := 1000\n\n    // Efficient: pre-allocate capacity\n    efficientSlice := make([]int, 0, expectedSize)\n\n    // Less efficient: will cause multiple reallocations\n    inefficientSlice := []int{}\n\n    fmt.Printf(\"Efficient slice: len=%d, cap=%d\\n\",\n        len(efficientSlice), cap(efficientSlice))\n    fmt.Printf(\"Inefficient slice: len=%d, cap=%d\\n\",\n        len(inefficientSlice), cap(inefficientSlice))\n}\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#slicing-operations","title":"Slicing Operations","text":"<p>Create slices from existing arrays or slices using slice expressions.</p> <p>Slice Expressions</p> Basic SlicingFull Slice Expression basic_slicing.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    original := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    // slice[start:end] - end is exclusive\n    slice1 := original[2:6]    // [2, 3, 4, 5]\n    slice2 := original[:4]     // [0, 1, 2, 3]\n    slice3 := original[6:]     // [6, 7, 8, 9]\n    slice4 := original[:]      // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    fmt.Printf(\"slice1: %v\\n\", slice1)\n    fmt.Printf(\"slice2: %v\\n\", slice2)\n    fmt.Printf(\"slice3: %v\\n\", slice3)\n    fmt.Printf(\"slice4: %v\\n\", slice4)\n}\n</code></pre> full_slice_expression.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    original := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    // slice[start:end:capacity] - controls capacity\n    slice1 := original[2:6:8]  // start=2, end=6, cap=8-2=6\n    slice2 := original[1:4:6]  // start=1, end=4, cap=6-1=5\n\n    fmt.Printf(\"slice1: %v (len=%d, cap=%d)\\n\", slice1, len(slice1), cap(slice1))\n    fmt.Printf(\"slice2: %v (len=%d, cap=%d)\\n\", slice2, len(slice2), cap(slice2))\n\n    // Output:\n    // slice1: [2 3 4 5] (len=4, cap=6)\n    // slice2: [1 2 3] (len=3, cap=5)\n}\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#slice-operations-and-manipulation","title":"Slice Operations and Manipulation","text":""},{"location":"1.%20Basics/8.%20Slices/#accessing-and-modifying-elements","title":"Accessing and Modifying Elements","text":"<p>Element Operations</p> Basic Access and ModificationRange Iteration element_access.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    colors := []string{\"red\", \"green\", \"blue\", \"yellow\"}\n\n    // Access elements\n    fmt.Printf(\"First color: %s\\n\", colors[0])\n    fmt.Printf(\"Last color: %s\\n\", colors[len(colors)-1])\n\n    // Modify elements\n    colors[1] = \"purple\"\n    fmt.Printf(\"Modified slice: %v\\n\", colors)\n\n    // Safe access with bounds checking\n    if len(colors) &gt; 2 {\n        fmt.Printf(\"Third color: %s\\n\", colors[2])\n    }\n}\n</code></pre> range_iteration.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := []int{95, 87, 92, 78, 88}\n\n    // Iterate with index and value\n    for i, score := range scores {\n        fmt.Printf(\"Student %d: %d\\n\", i+1, score)\n    }\n\n    // Iterate values only\n    total := 0\n    for _, score := range scores {\n        total += score\n    }\n    fmt.Printf(\"Average: %.2f\\n\", float64(total)/float64(len(scores)))\n}\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#the-append-function","title":"The append Function","text":"<p>The <code>append</code> function is fundamental for growing slices dynamically.</p> <p>Append Operations</p> Basic AppendCapacity GrowthEfficient Append Patterns basic_append.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var numbers []int\n\n    // Append single elements\n    numbers = append(numbers, 1)\n    numbers = append(numbers, 2, 3, 4)\n\n    // Append another slice\n    moreNumbers := []int{5, 6, 7}\n    numbers = append(numbers, moreNumbers...)\n\n    fmt.Printf(\"Numbers: %v (len=%d, cap=%d)\\n\",\n        numbers, len(numbers), cap(numbers))\n\n    // Output: Numbers: [1 2 3 4 5 6 7] (len=7, cap=8)\n}\n</code></pre> capacity_growth.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var slice []int\n\n    // Observe capacity growth\n    for i := 0; i &lt; 10; i++ {\n        slice = append(slice, i)\n        fmt.Printf(\"len=%d, cap=%d, slice=%v\\n\",\n            len(slice), cap(slice), slice)\n    }\n\n    // Capacity typically doubles when exceeded\n    // Output shows: cap=1, 2, 4, 8, 16...\n}\n</code></pre> efficient_append.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Pre-allocate when size is known\n    expectedSize := 1000\n    slice := make([]int, 0, expectedSize)\n\n    // Efficient append within capacity\n    for i := 0; i &lt; expectedSize; i++ {\n        slice = append(slice, i)\n    }\n\n    fmt.Printf(\"Final: len=%d, cap=%d\\n\", len(slice), cap(slice))\n\n    // Append beyond capacity triggers reallocation\n    slice = append(slice, 1000)\n    fmt.Printf(\"After overflow: len=%d, cap=%d\\n\", len(slice), cap(slice))\n}\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#the-copy-function","title":"The copy Function","text":"<p>The <code>copy</code> function provides safe copying between slices.</p> <p>Copy Operations</p> Basic CopyPartial CopyOverlapping Copy basic_copy.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    source := []int{1, 2, 3, 4, 5}\n\n    // Create destination slice\n    dest := make([]int, len(source))\n\n    // Copy elements\n    copied := copy(dest, source)\n\n    fmt.Printf(\"Source: %v\\n\", source)\n    fmt.Printf(\"Destination: %v\\n\", dest)\n    fmt.Printf(\"Elements copied: %d\\n\", copied)\n\n    // Modify destination to show independence\n    dest[0] = 100\n    fmt.Printf(\"After modification - Source: %v, Dest: %v\\n\", source, dest)\n}\n</code></pre> partial_copy.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    source := []int{1, 2, 3, 4, 5, 6, 7, 8}\n\n    // Copy to smaller destination\n    smallDest := make([]int, 3)\n    copied1 := copy(smallDest, source)\n\n    // Copy from larger source to larger destination\n    largeDest := make([]int, 10)\n    copied2 := copy(largeDest, source)\n\n    fmt.Printf(\"Small dest: %v (copied %d)\\n\", smallDest, copied1)\n    fmt.Printf(\"Large dest: %v (copied %d)\\n\", largeDest, copied2)\n}\n</code></pre> overlapping_copy.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    slice := []int{1, 2, 3, 4, 5, 6}\n\n    // Copy within same slice (shift elements)\n    copy(slice[2:], slice[0:4])  // Copy [1,2,3,4] to positions 2-5\n\n    fmt.Printf(\"After overlapping copy: %v\\n\", slice)\n    // Output: After overlapping copy: [1 2 1 2 3 4]\n}\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#advanced-slice-techniques","title":"Advanced Slice Techniques","text":""},{"location":"1.%20Basics/8.%20Slices/#memory-management-and-performance","title":"Memory Management and Performance","text":"<p>Memory Optimization</p> Slice Memory SharingAvoiding Memory Leaks memory_sharing.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    original := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Slices share underlying array\n    slice1 := original[2:5]  // [3, 4, 5]\n    slice2 := original[4:7]  // [5, 6, 7]\n\n    fmt.Printf(\"Original: %v\\n\", original)\n    fmt.Printf(\"Slice1: %v\\n\", slice1)\n    fmt.Printf(\"Slice2: %v\\n\", slice2)\n\n    // Modifying slice1 affects original and potentially slice2\n    slice1[2] = 99  // Changes original[4] and slice2[0]\n\n    fmt.Printf(\"After modification:\\n\")\n    fmt.Printf(\"Original: %v\\n\", original)\n    fmt.Printf(\"Slice1: %v\\n\", slice1)\n    fmt.Printf(\"Slice2: %v\\n\", slice2)\n}\n</code></pre> memory_leaks.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc processLargeSlice() []int {\n    largeSlice := make([]int, 1000000)\n    // ... populate largeSlice ...\n\n    // BAD: Returns slice that holds reference to large array\n    // return largeSlice[0:10]\n\n    // GOOD: Copy to new slice to release large array\n    result := make([]int, 10)\n    copy(result, largeSlice[0:10])\n    return result\n}\n\nfunc main() {\n    small := processLargeSlice()\n    fmt.Printf(\"Small slice: %v (len=%d, cap=%d)\\n\",\n        small, len(small), cap(small))\n}\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#slice-manipulation-patterns","title":"Slice Manipulation Patterns","text":"<p>Common Patterns</p> Insert ElementRemove ElementFilter Slice insert_element.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc insertAt(slice []int, index, value int) []int {\n    // Grow slice by one element\n    slice = append(slice, 0)\n\n    // Shift elements to the right\n    copy(slice[index+1:], slice[index:])\n\n    // Insert new value\n    slice[index] = value\n    return slice\n}\n\nfunc main() {\n    numbers := []int{1, 2, 4, 5}\n    numbers = insertAt(numbers, 2, 3)\n    fmt.Printf(\"After insert: %v\\n\", numbers)  // [1 2 3 4 5]\n}\n</code></pre> remove_element.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc removeAt(slice []int, index int) []int {\n    // Shift elements to the left\n    copy(slice[index:], slice[index+1:])\n\n    // Shrink slice\n    return slice[:len(slice)-1]\n}\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n    numbers = removeAt(numbers, 2)\n    fmt.Printf(\"After remove: %v\\n\", numbers)  // [1 2 4 5]\n}\n</code></pre> filter_slice.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc filter(slice []int, predicate func(int) bool) []int {\n    result := make([]int, 0, len(slice))\n\n    for _, value := range slice {\n        if predicate(value) {\n            result = append(result, value)\n        }\n    }\n\n    return result\n}\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Filter even numbers\n    evens := filter(numbers, func(n int) bool { return n%2 == 0 })\n    fmt.Printf(\"Even numbers: %v\\n\", evens)  // [2 4 6 8 10]\n}\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#best-practices-and-performance","title":"Best Practices and Performance","text":"<p>Slice Best Practices</p> <ol> <li> <p>Pre-allocate When Size is Known <pre><code>// Good: Pre-allocate capacity\nslice := make([]int, 0, expectedSize)\n\n// Avoid: Multiple reallocations\nvar slice []int  // Will grow from 0 capacity\n</code></pre></p> </li> <li> <p>Use Full Slice Expression for Safety <pre><code>// Limits capacity to prevent accidental overwrites\nsafe := original[start:end:end]\n</code></pre></p> </li> <li> <p>Copy When You Need Independence <pre><code>// Create independent copy\nindependent := make([]Type, len(original))\ncopy(independent, original)\n</code></pre></p> </li> <li> <p>Avoid Memory Leaks with Large Slices <pre><code>// Copy small portion instead of keeping reference\nsmall := make([]Type, smallSize)\ncopy(small, large[start:end])\n</code></pre></p> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Slice Header Copying: Slices are reference types, assignments copy the header, not data</li> <li>Capacity Confusion: Length vs capacity - understand the difference</li> <li>Memory Leaks: Small slices can hold references to large underlying arrays</li> <li>Concurrent Access: Slices are not thread-safe without synchronization</li> </ul>"},{"location":"1.%20Basics/8.%20Slices/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>Creation: Use literals, <code>make()</code>, or slicing operations</li> <li>Growth: <code>append()</code> automatically manages capacity</li> <li>Copying: <code>copy()</code> for safe element transfer</li> <li>Memory: Understand underlying array sharing</li> <li>Performance: Pre-allocate capacity when size is known</li> <li>Safety: Use bounds checking and full slice expressions</li> </ol> <p>Remember</p> <p>\"Slices are the heart of Go collections. Master append, copy, and capacity management for efficient and safe code. When in doubt, copy for independence.\"</p>"},{"location":"1.%20Basics/9.%20Maps/","title":"Go Maps: Key-Value Data Structures","text":"<p>Overview</p> <p>Master Go's powerful map data structure for efficient key-value storage and retrieval. This comprehensive guide covers map creation, operations, iteration patterns, and advanced techniques, building upon our understanding of slices and data types.</p> <p>Key Points</p> <ul> <li>Maps are reference types with key-value associations</li> <li>Unordered collections with unique keys</li> <li>Built-in functions for efficient operations</li> <li>Comparable key types required</li> <li>Essential for lookups, caching, and data organization</li> </ul>"},{"location":"1.%20Basics/9.%20Maps/#understanding-maps-in-go","title":"Understanding Maps in Go","text":"<p>Maps are Go's built-in associative data structure, providing fast key-value lookups similar to hash tables or dictionaries in other languages. They're reference types that offer dynamic sizing and efficient operations.</p> <p>Map Architecture</p> <pre><code>graph TD\n    A[Go Map] --&gt; B[Hash Table]\n    B --&gt; C[Bucket 0]\n    B --&gt; D[Bucket 1]\n    B --&gt; E[Bucket N]\n    C --&gt; F[Key1: Value1]\n    C --&gt; G[Key2: Value2]\n    D --&gt; H[Key3: Value3]\n    E --&gt; I[...]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000\n    style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#map-creation-patterns","title":"Map Creation Patterns","text":"<p>Go provides multiple ways to create and initialize maps, each suited for different scenarios and use cases.</p>"},{"location":"1.%20Basics/9.%20Maps/#map-literals-and-declarations","title":"Map Literals and Declarations","text":"<p>Basic Map Creation</p> Map LiteralsEmpty Map DeclarationDifferent Key Types map_literals.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Create map with initial values\n    ages := map[string]int{\n        \"Alice\":   25,\n        \"Bob\":     30,\n        \"Charlie\": 35,\n    }\n\n    fmt.Printf(\"Ages: %v\\n\", ages)\n    fmt.Printf(\"Alice's age: %d\\n\", ages[\"Alice\"])\n\n    // Output:\n    // Ages: map[Alice:25 Bob:30 Charlie:35]\n    // Alice's age: 25\n}\n</code></pre> empty_maps.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Nil map (zero value)\n    var nilMap map[string]int\n    fmt.Printf(\"Nil map: %v (nil=%t)\\n\", nilMap, nilMap == nil)\n\n    // Empty map (not nil)\n    emptyMap := map[string]int{}\n    fmt.Printf(\"Empty map: %v (nil=%t)\\n\", emptyMap, emptyMap == nil)\n\n    // Output:\n    // Nil map: map[] (nil=true)\n    // Empty map: map[] (nil=false)\n}\n</code></pre> key_types.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // String keys\n    colors := map[string]string{\"red\": \"#FF0000\", \"green\": \"#00FF00\"}\n\n    // Integer keys\n    squares := map[int]int{1: 1, 2: 4, 3: 9, 4: 16}\n\n    // Boolean keys\n    flags := map[bool]string{true: \"enabled\", false: \"disabled\"}\n\n    fmt.Printf(\"Colors: %v\\n\", colors)\n    fmt.Printf(\"Squares: %v\\n\", squares)\n    fmt.Printf(\"Flags: %v\\n\", flags)\n}\n</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#the-make-function","title":"The make Function","text":"<p>Using make for Maps</p> Basic make UsageCapacity HintNil vs Empty Maps make_maps.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Create empty map with make\n    inventory := make(map[string]int)\n\n    // Add elements\n    inventory[\"apples\"] = 50\n    inventory[\"bananas\"] = 30\n    inventory[\"oranges\"] = 25\n\n    fmt.Printf(\"Inventory: %v\\n\", inventory)\n    fmt.Printf(\"Length: %d\\n\", len(inventory))\n\n    // Output:\n    // Inventory: map[apples:50 bananas:30 oranges:25]\n    // Length: 3\n}\n</code></pre> map_capacity.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Create map with capacity hint for performance\n    largeMap := make(map[int]string, 1000)\n\n    // Add some elements\n    for i := 0; i &lt; 5; i++ {\n        largeMap[i] = fmt.Sprintf(\"value_%d\", i)\n    }\n\n    fmt.Printf(\"Large map length: %d\\n\", len(largeMap))\n    // Output: Large map length: 5\n}\n</code></pre> nil_vs_empty.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Nil map (zero value)\n    var nilMap map[string]int\n\n    // Reading from nil map is safe\n    value := nilMap[\"key\"]  // Returns zero value\n    fmt.Printf(\"Value from nil map: %d\\n\", value)\n\n    // Writing to nil map causes panic\n    // nilMap[\"key\"] = 42  // panic: assignment to entry in nil map\n\n    // Must initialize before writing\n    nilMap = make(map[string]int)\n    nilMap[\"key\"] = 42\n    fmt.Printf(\"After initialization: %v\\n\", nilMap)\n}\n</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#map-operations-and-access","title":"Map Operations and Access","text":"<p>Maps support efficient operations for adding, updating, accessing, and deleting key-value pairs.</p>"},{"location":"1.%20Basics/9.%20Maps/#element-access-and-modification","title":"Element Access and Modification","text":"<p>Map Operations</p> Basic AccessSafe Key CheckingElement Deletion map_access.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := map[string]int{\n        \"Alice\": 95, \"Bob\": 87, \"Charlie\": 92,\n    }\n\n    // Access elements\n    fmt.Printf(\"Alice's score: %d\\n\", scores[\"Alice\"])\n\n    // Update existing element\n    scores[\"Alice\"] = 98\n\n    // Add new element\n    scores[\"Diana\"] = 89\n\n    fmt.Printf(\"Updated scores: %v\\n\", scores)\n}\n</code></pre> key_existence.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    inventory := map[string]int{\"apples\": 50, \"bananas\": 30}\n\n    // Check if key exists (comma ok idiom)\n    if count, exists := inventory[\"apples\"]; exists {\n        fmt.Printf(\"Apples in stock: %d\\n\", count)\n    }\n\n    // Check for non-existent key\n    if count, exists := inventory[\"oranges\"]; exists {\n        fmt.Printf(\"Oranges in stock: %d\\n\", count)\n    } else {\n        fmt.Println(\"Oranges not in inventory\")\n    }\n\n    // Direct access returns zero value for missing keys\n    fmt.Printf(\"Grapes count: %d\\n\", inventory[\"grapes\"])  // 0\n}\n</code></pre> map_deletion.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    users := map[int]string{\n        1: \"Alice\", 2: \"Bob\", 3: \"Charlie\", 4: \"Diana\",\n    }\n\n    fmt.Printf(\"Before deletion: %v\\n\", users)\n\n    // Delete element\n    delete(users, 2)  // Remove Bob\n\n    // Safe to delete non-existent key\n    delete(users, 999)\n\n    fmt.Printf(\"After deletion: %v\\n\", users)\n    fmt.Printf(\"Length: %d\\n\", len(users))\n}\n</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#map-iteration-patterns","title":"Map Iteration Patterns","text":"<p>Go provides the <code>range</code> keyword for iterating over maps, with different patterns for accessing keys, values, or both.</p> <p>Iteration Order</p> <p>Map iteration order is not guaranteed and may vary between program runs. This is intentional to prevent reliance on iteration order.</p>"},{"location":"1.%20Basics/9.%20Maps/#iteration-techniques","title":"Iteration Techniques","text":"<p>Map Iteration</p> Keys and ValuesKeys OnlyValues Only map_iteration.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    grades := map[string]int{\n        \"Alice\": 95, \"Bob\": 87, \"Charlie\": 92, \"Diana\": 89,\n    }\n\n    // Iterate over keys and values\n    for name, grade := range grades {\n        fmt.Printf(\"%s: %d\\n\", name, grade)\n    }\n\n    // Note: Map iteration order is not guaranteed\n}\n</code></pre> keys_only.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    inventory := map[string]int{\n        \"apples\": 50, \"bananas\": 30, \"oranges\": 25,\n    }\n\n    // Iterate over keys only\n    for item := range inventory {\n        fmt.Printf(\"Item: %s\\n\", item)\n    }\n}\n</code></pre> values_only.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := map[string]int{\n        \"Alice\": 95, \"Bob\": 87, \"Charlie\": 92,\n    }\n\n    // Iterate over values only (using blank identifier)\n    for _, score := range scores {\n        fmt.Printf(\"Score: %d\\n\", score)\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#advanced-map-techniques","title":"Advanced Map Techniques","text":""},{"location":"1.%20Basics/9.%20Maps/#complex-key-and-value-types","title":"Complex Key and Value Types","text":"<p>Advanced Map Types</p> Struct KeysSlice ValuesNested Maps struct_keys.go<pre><code>package main\n\nimport \"fmt\"\n\ntype Point struct {\n    X, Y int\n}\n\nfunc main() {\n    // Struct keys (must be comparable)\n    distances := map[Point]float64{\n        {0, 0}: 0.0,\n        {1, 1}: 1.414,\n        {3, 4}: 5.0,\n    }\n\n    origin := Point{0, 0}\n    fmt.Printf(\"Distance from origin: %.3f\\n\", distances[origin])\n}\n</code></pre> slice_values.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Map with slice values for grouping\n    categories := map[string][]string{\n        \"fruits\":     {\"apple\", \"banana\", \"orange\"},\n        \"vegetables\": {\"carrot\", \"broccoli\", \"spinach\"},\n        \"grains\":     {\"rice\", \"wheat\", \"oats\"},\n    }\n\n    // Add to existing slice\n    categories[\"fruits\"] = append(categories[\"fruits\"], \"grape\")\n\n    fmt.Printf(\"Fruits: %v\\n\", categories[\"fruits\"])\n}\n</code></pre> nested_maps.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Nested maps for complex data structures\n    studentGrades := map[string]map[string]int{\n        \"Alice\": {\"Math\": 95, \"Science\": 87, \"English\": 92},\n        \"Bob\":   {\"Math\": 78, \"Science\": 85, \"English\": 88},\n    }\n\n    // Access nested values\n    aliceMath := studentGrades[\"Alice\"][\"Math\"]\n    fmt.Printf(\"Alice's Math grade: %d\\n\", aliceMath)\n\n    // Add new student\n    studentGrades[\"Charlie\"] = map[string]int{\n        \"Math\": 90, \"Science\": 93, \"English\": 89,\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#common-map-patterns","title":"Common Map Patterns","text":"<p>Practical Patterns</p> Counting OccurrencesSet ImplementationGrouping Data counting.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    words := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"}\n\n    // Count word occurrences\n    counts := make(map[string]int)\n    for _, word := range words {\n        counts[word]++  // Zero value of int is 0\n    }\n\n    fmt.Printf(\"Word counts: %v\\n\", counts)\n    // Output: map[apple:3 banana:2 orange:1]\n}\n</code></pre> set_pattern.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Implement set using map[T]bool\n    uniqueItems := make(map[string]bool)\n\n    items := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"}\n\n    // Add items to set\n    for _, item := range items {\n        uniqueItems[item] = true\n    }\n\n    // Check membership\n    if uniqueItems[\"apple\"] {\n        fmt.Println(\"Apple is in the set\")\n    }\n\n    // Get all unique items\n    fmt.Print(\"Unique items: \")\n    for item := range uniqueItems {\n        fmt.Printf(\"%s \", item)\n    }\n    fmt.Println()\n}\n</code></pre> grouping.go<pre><code>package main\n\nimport \"fmt\"\n\ntype Person struct {\n    Name string\n    Age  int\n    City string\n}\n\nfunc main() {\n    people := []Person{\n        {\"Alice\", 25, \"NYC\"}, {\"Bob\", 30, \"LA\"}, {\"Charlie\", 35, \"NYC\"},\n    }\n\n    // Group people by city\n    byCity := make(map[string][]Person)\n    for _, person := range people {\n        byCity[person.City] = append(byCity[person.City], person)\n    }\n\n    for city, residents := range byCity {\n        fmt.Printf(\"%s: %d residents\\n\", city, len(residents))\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#best-practices-and-performance","title":"Best Practices and Performance","text":"<p>Map Best Practices</p> <ol> <li> <p>Initialize Before Use <pre><code>// Good: Initialize with make or literal\nm := make(map[string]int)\n// or\nm := map[string]int{}\n\n// Bad: Using nil map\nvar m map[string]int\nm[\"key\"] = value  // panic!\n</code></pre></p> </li> <li> <p>Use Comma Ok Idiom <pre><code>// Check key existence\nif value, exists := m[\"key\"]; exists {\n    // Key exists, use value\n}\n</code></pre></p> </li> <li> <p>Pre-allocate When Size is Known <pre><code>// Hint capacity for better performance\nm := make(map[string]int, expectedSize)\n</code></pre></p> </li> <li> <p>Handle Concurrent Access <pre><code>// Use sync.Map or mutex for concurrent access\nvar mu sync.RWMutex\n// or\nvar m sync.Map\n</code></pre></p> </li> </ol> <p>Common Pitfalls</p> <ul> <li>Nil Map Writes: Writing to nil map causes panic</li> <li>Iteration Order: Never rely on map iteration order</li> <li>Concurrent Access: Maps are not thread-safe</li> <li>Key Comparability: Only comparable types can be keys</li> </ul>"},{"location":"1.%20Basics/9.%20Maps/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ol> <li>Creation: Use literals, <code>make()</code>, or zero value (nil)</li> <li>Access: Direct access or comma ok idiom for safety</li> <li>Modification: Assignment for add/update, <code>delete()</code> for removal</li> <li>Iteration: Use <code>range</code> with various patterns</li> <li>Performance: O(1) average time complexity for operations</li> <li>Concurrency: Use synchronization for multi-goroutine access</li> </ol> <p>Remember</p> <p>\"Maps are Go's associative arrays. Master key-value operations, understand reference semantics, and always check for key existence when needed. When in doubt about concurrency, synchronize access.\"</p>"},{"location":"2.%20Intermediate/1.%20Closures/","title":"Go Closures: Functions with Captured Variables","text":"<p>Overview</p> <p>Master Go closures - functions that capture and maintain access to variables from their surrounding scope. This guide covers closure fundamentals, practical applications, and advanced patterns for building stateful functions and elegant solutions.</p> <p>Key Points</p> <ul> <li>Closures capture variables by reference, not by value</li> <li>Enable functions to maintain state between calls</li> <li>Essential for functional programming patterns</li> <li>Powerful tool for creating flexible, modular code</li> <li>Common in goroutines and callback functions</li> </ul>"},{"location":"2.%20Intermediate/1.%20Closures/#understanding-closures","title":"Understanding Closures","text":"<p>A closure is a function that references variables from outside its own scope. It \"closes over\" these variables, maintaining access to them even after the outer function has finished executing.</p> <p>Closure Components</p> <pre><code>graph LR\n    A[Closure] --&gt; B[Function Body]\n    A --&gt; C[Captured Variables]\n    A --&gt; D[Lexical Environment]\n    B --&gt; B1[Anonymous or Named]\n    C --&gt; C1[By Reference]\n    D --&gt; D1[Binding Context]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#basic-closure-mechanics","title":"Basic Closure Mechanics","text":"<p>Simple Closure</p> Variable CaptureMultiple VariablesClosure Factory basic_closure.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 10\n    increment := func() int {\n        x++\n        return x\n    }\n\n    fmt.Println(increment()) // 11\n    fmt.Println(increment()) // 12\n    fmt.Println(x)           // 12 (original variable modified)\n}\n</code></pre> multi_capture.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Counter\"\n    count := 0\n\n    counter := func() string {\n        count++\n        return fmt.Sprintf(\"%s: %d\", name, count)\n    }\n\n    fmt.Println(counter()) // Counter: 1\n    fmt.Println(counter()) // Counter: 2\n}\n</code></pre> closure_factory.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc createCounter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\nfunc main() {\n    c1 := createCounter()\n    c2 := createCounter()\n\n    fmt.Println(c1()) // 1\n    fmt.Println(c1()) // 2\n    fmt.Println(c2()) // 1 (independent counter)\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#key-characteristics-of-closures","title":"Key Characteristics of Closures","text":""},{"location":"2.%20Intermediate/1.%20Closures/#variable-capture-by-reference","title":"Variable Capture by Reference","text":"<p>Go closures capture variables by reference, meaning they share the same variable instance across multiple calls.</p> <p>Reference Capture Behavior</p> Shared StateLoop Variable CaptureModifying Captured Variables shared_state.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc counter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\nfunc main() {\n    c1 := counter()\n    fmt.Println(c1()) // 1\n    fmt.Println(c1()) // 2\n\n    c2 := counter()\n    fmt.Println(c2()) // 1 (independent instance)\n}\n</code></pre> loop_capture.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var funcs []func()\n\n    // Common pitfall: all closures capture same variable\n    for i := 0; i &lt; 3; i++ {\n        funcs = append(funcs, func() {\n            fmt.Println(\"Wrong:\", i) // Always prints 3\n        })\n    }\n\n    // Correct approach: capture loop variable\n    for i := 0; i &lt; 3; i++ {\n        i := i // Create new variable in loop scope\n        funcs = append(funcs, func() {\n            fmt.Println(\"Correct:\", i)\n        })\n    }\n}\n</code></pre> modify_captured.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    balance := 100.0\n\n    deposit := func(amount float64) {\n        balance += amount\n        fmt.Printf(\"Deposited %.2f, Balance: %.2f\\n\", amount, balance)\n    }\n\n    withdraw := func(amount float64) bool {\n        if balance &gt;= amount {\n            balance -= amount\n            fmt.Printf(\"Withdrew %.2f, Balance: %.2f\\n\", amount, balance)\n            return true\n        }\n        fmt.Printf(\"Insufficient funds. Balance: %.2f\\n\", balance)\n        return false\n    }\n\n    deposit(50.0)   // Deposited 50.00, Balance: 150.00\n    withdraw(75.0)  // Withdrew 75.00, Balance: 75.00\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#closure-scope-and-lifetime","title":"Closure Scope and Lifetime","text":"<p>Variables captured by closures remain accessible as long as the closure exists, extending their lifetime beyond the original scope.</p> <p>Variable Lifetime</p> Extended LifetimeShared State Pattern lifetime.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc createMultiplier(factor int) func(int) int {\n    // factor variable lifetime extended by closure\n    return func(x int) int {\n        return x * factor\n    }\n}\n\nfunc main() {\n    double := createMultiplier(2)\n    triple := createMultiplier(3)\n\n    // factor variables still accessible\n    fmt.Println(double(5))  // 10\n    fmt.Println(triple(4))  // 12\n}\n</code></pre> shared_state.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc createCounter() (func() int, func() int, func() int) {\n    count := 0\n\n    increment := func() int {\n        count++\n        return count\n    }\n\n    decrement := func() int {\n        count--\n        return count\n    }\n\n    get := func() int {\n        return count\n    }\n\n    return increment, decrement, get\n}\n\nfunc main() {\n    inc, dec, get := createCounter()\n\n    fmt.Println(inc()) // 1\n    fmt.Println(inc()) // 2\n    fmt.Println(dec()) // 1\n    fmt.Println(get()) // 1\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#closures-with-goroutines","title":"Closures with Goroutines","text":"<p>Closures are commonly used with goroutines, but variable capture requires careful attention.</p> <p>Common Goroutine Pitfall</p> <p>Loop variables are captured by reference, leading to unexpected behavior in concurrent code.</p> <p>Goroutine Patterns</p> Problem: Shared VariableSolution 1: Parameter PassingSolution 2: Variable Shadowing goroutine_problem.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    for i := 0; i &lt; 3; i++ {\n        go func() {\n            fmt.Println(\"Problem:\", i) // Likely prints 3, 3, 3\n        }()\n    }\n    time.Sleep(100 * time.Millisecond)\n}\n</code></pre> goroutine_solution1.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    for i := 0; i &lt; 3; i++ {\n        go func(val int) {\n            fmt.Println(\"Solution 1:\", val) // Prints 0, 1, 2\n        }(i)\n    }\n    time.Sleep(100 * time.Millisecond)\n}\n</code></pre> goroutine_solution2.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    for i := 0; i &lt; 3; i++ {\n        i := i // Shadow the loop variable\n        go func() {\n            fmt.Println(\"Solution 2:\", i) // Prints 0, 1, 2\n        }()\n    }\n    time.Sleep(100 * time.Millisecond)\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#common-use-cases-for-closures","title":"Common Use Cases for Closures","text":""},{"location":"2.%20Intermediate/1.%20Closures/#1-function-factories","title":"1. Function Factories","text":"<p>Creating specialized functions with pre-configured behavior:</p> <pre><code>func getGreeter(greeting string) func(string) string {\n    return func(name string) string {\n        return fmt.Sprintf(\"%s, %s!\", greeting, name)\n    }\n}\n\nfunc main() {\n    sayHello := getGreeter(\"Hello\")\n    sayHi := getGreeter(\"Hi\")\n\n    fmt.Println(sayHello(\"Alice\"))  // \"Hello, Alice!\"\n    fmt.Println(sayHi(\"Bob\"))       // \"Hi, Bob!\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#2-callbacks-and-event-handlers","title":"2. Callbacks and Event Handlers","text":"<p>Passing behavior as a parameter:</p> <pre><code>func processItems(items []int, callback func(int)) {\n    for _, item := range items {\n        callback(item)\n    }\n}\n\nfunc main() {\n    items := []int{1, 2, 3, 4, 5}\n\n    processItems(items, func(n int) {\n        if n%2 == 0 {\n            fmt.Println(n, \"is even\")\n        } else {\n            fmt.Println(n, \"is odd\")\n        }\n    })\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#middleware-and-decorators","title":"Middleware and Decorators","text":"<p>Closures enable elegant middleware patterns by wrapping existing functions with additional behavior.</p> <p>Decorator Patterns</p> Execution TimerError Handler execution_timer.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc logExecution(fn func()) func() {\n    return func() {\n        start := time.Now()\n        fn()\n        fmt.Printf(\"Function executed in %v\\n\", time.Since(start))\n    }\n}\n\nfunc main() {\n    task := logExecution(func() {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(\"Task completed\")\n    })\n\n    task() // Task completed, Function executed in ~100ms\n}\n</code></pre> error_handler.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc withErrorHandling(fn func() error) func() {\n    return func() {\n        if err := fn(); err != nil {\n            fmt.Printf(\"Error occurred: %v\\n\", err)\n        } else {\n            fmt.Println(\"Operation completed successfully\")\n        }\n    }\n}\n\nfunc main() {\n    riskyOperation := withErrorHandling(func() error {\n        // Simulate some operation that might fail\n        return nil // or return errors.New(\"something went wrong\")\n    })\n\n    riskyOperation()\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"2.%20Intermediate/1.%20Closures/#rate-limiting-with-closures","title":"Rate Limiting with Closures","text":"<p>Closures provide an elegant solution for implementing rate limiters and throttling mechanisms.</p> <p>Rate Limiter Implementation</p> Simple Rate Limiter rate_limiter.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc createRateLimiter(maxCalls int, duration time.Duration) func() bool {\n    calls := 0\n    resetTime := time.Now().Add(duration)\n\n    return func() bool {\n        now := time.Now()\n        if now.After(resetTime) {\n            calls = 0\n            resetTime = now.Add(duration)\n        }\n\n        if calls &lt; maxCalls {\n            calls++\n            return true\n        }\n        return false\n    }\n}\n\nfunc main() {\n    limiter := createRateLimiter(3, time.Second)\n\n    for i := 0; i &lt; 5; i++ {\n        if limiter() {\n            fmt.Printf(\"Request %d: Allowed\\n\", i+1)\n        } else {\n            fmt.Printf(\"Request %d: Rate limited\\n\", i+1)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/1.%20Closures/#memory-management","title":"Memory Management","text":"<p>Closures keep references to captured variables, which can affect garbage collection.</p> <p>Memory Considerations</p> <p>Be mindful of what variables your closures capture to avoid memory leaks.</p> <p>Memory Best Practices</p> Potential Memory IssueMemory Optimized memory_issue.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc createProcessors() []func() {\n    var processors []func()\n    largeData := make([]byte, 1024*1024) // 1MB\n\n    for i := 0; i &lt; 100; i++ {\n        processors = append(processors, func() {\n            // Captures entire largeData slice\n            fmt.Printf(\"Processing with data size: %d\\n\", len(largeData))\n        })\n    }\n    return processors\n}\n</code></pre> memory_optimized.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc createProcessors() []func() {\n    var processors []func()\n    dataSize := 1024 * 1024 // Capture only what you need\n\n    for i := 0; i &lt; 100; i++ {\n        processors = append(processors, func() {\n            // Only captures the integer, not the slice\n            fmt.Printf(\"Processing with data size: %d\\n\", dataSize)\n        })\n    }\n    return processors\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#loop-variable-capture","title":"Loop Variable Capture","text":"<p>Always be careful when creating closures inside loops.</p> <p>Loop Variable Patterns</p> Common MistakeCorrect Approach loop_mistake.go<pre><code>package main\n\nfunc createFunctions() []func() {\n    var funcs []func()\n    for i := 0; i &lt; 3; i++ {\n        funcs = append(funcs, func() {\n            fmt.Println(i) // Will print 3, 3, 3\n        })\n    }\n    return funcs\n}\n</code></pre> loop_correct.go<pre><code>package main\n\nfunc createFunctions() []func() {\n    var funcs []func()\n    for i := 0; i &lt; 3; i++ {\n        i := i // Create new variable in loop scope\n        funcs = append(funcs, func() {\n            fmt.Println(i) // Will print 0, 1, 2\n        })\n    }\n    return funcs\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#clean-api-design","title":"Clean API Design","text":"<p>Use closures to create intuitive and flexible APIs.</p> <p>API Design Patterns</p> Configuration Options config_options.go<pre><code>package main\n\nimport (\n    \"net/http\"\n    \"time\"\n)\n\nfunc WithTimeout(timeout time.Duration) func(*http.Client) {\n    return func(client *http.Client) {\n        client.Timeout = timeout\n    }\n}\n\nfunc WithRetries(retries int) func(*http.Client) {\n    return func(client *http.Client) {\n        // Configure retry logic\n    }\n}\n\nfunc MakeRequest(url string, options ...func(*http.Client)) error {\n    client := &amp;http.Client{}\n    for _, option := range options {\n        option(client)\n    }\n    // Make request with configured client\n    return nil\n}\n\nfunc main() {\n    // Clean, readable API\n    err := MakeRequest(\"https://api.example.com\",\n        WithTimeout(30*time.Second),\n        WithRetries(3))\n    _ = err\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ul> <li>State Preservation: Functions maintain state between calls</li> <li>Variable Capture: By reference, not by value</li> <li>Memory Awareness: Be mindful of what variables are captured</li> <li>Loop Variables: Use variable shadowing to avoid common pitfalls</li> <li>Clean APIs: Enable flexible configuration and option patterns</li> <li>Goroutine Safety: Consider thread safety when sharing state</li> </ul> <p>Remember</p> <p>\"Closures are particularly powerful in Go for creating stateful functions, middleware patterns, and elegant APIs. Use them wisely to write clean, maintainable code.\"</p>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/","title":"Text Embeddings in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#introduction-to-text-embeddings","title":"Introduction to Text Embeddings","text":"<p>Text embeddings are numerical representations of text data that capture semantic meaning. They transform words, sentences, or documents into dense vectors (arrays of numbers) where similar texts have similar vector representations. This enables machines to understand and process human language in a mathematical way.</p> <p>In Go, while we don't have native NLP capabilities like Python, we can leverage external APIs, pre-trained models, and specialized libraries to work with text embeddings effectively.</p>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#why-use-text-embeddings","title":"Why Use Text Embeddings?","text":"<ol> <li>Semantic Search: Find documents based on meaning rather than keywords</li> <li>Similarity Comparison: Measure how similar two texts are</li> <li>Classification: Categorize text based on content</li> <li>Clustering: Group similar documents together</li> <li>Recommendation Systems: Suggest similar content</li> <li>Anomaly Detection: Identify unusual text patterns</li> </ol>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#key-concepts","title":"Key Concepts","text":""},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#1-vector-representation","title":"1. Vector Representation","text":"<p>Text is converted into fixed-length vectors (typically 384, 768, or 1536 dimensions): <pre><code>type Embedding []float32\n\nfunc (e Embedding) Dimensions() int {\n    return len(e)\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#2-similarity-metrics","title":"2. Similarity Metrics","text":"<p>Common ways to measure similarity between embeddings: - Cosine Similarity: Measures angle between vectors (most common) - Euclidean Distance: Measures straight-line distance - Dot Product: Measures alignment of vectors</p> <pre><code>// Cosine similarity between two embeddings\nfunc CosineSimilarity(a, b Embedding) float64 {\n    if len(a) != len(b) {\n        panic(\"Embeddings must have same dimensions\")\n    }\n\n    var dotProduct, normA, normB float64\n\n    for i := range a {\n        dotProduct += float64(a[i]) * float64(b[i])\n        normA += float64(a[i]) * float64(a[i])\n        normB += float64(b[i]) * float64(b[i])\n    }\n\n    if normA == 0 || normB == 0 {\n        return 0\n    }\n\n    return dotProduct / (math.Sqrt(normA) * math.Sqrt(normB))\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#approaches-to-generate-embeddings-in-go","title":"Approaches to Generate Embeddings in Go","text":""},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#1-using-external-apis-recommended","title":"1. Using External APIs (Recommended)","text":"<p>Services like OpenAI, Cohere, and Hugging Face provide embedding APIs:</p> <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"os\"\n)\n\n// OpenAIEmbeddingRequest represents the request to OpenAI's embedding API\ntype OpenAIEmbeddingRequest struct {\n    Input          string `json:\"input\"`\n    Model          string `json:\"model\"`\n    EncodingFormat string `json:\"encoding_format,omitempty\"`\n}\n\n// OpenAIEmbeddingResponse represents the response from OpenAI's embedding API\ntype OpenAIEmbeddingResponse struct {\n    Data []struct {\n        Embedding []float32 `json:\"embedding\"`\n    } `json:\"data\"`\n}\n\n// GenerateEmbeddingUsingOpenAI generates an embedding using OpenAI's API\nfunc GenerateEmbeddingUsingOpenAI(text, apiKey string) ([]float32, error) {\n    reqBody := OpenAIEmbeddingRequest{\n        Input: text,\n        Model: \"text-embedding-ada-002\",\n    }\n\n    jsonData, err := json.Marshal(reqBody)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to marshal request: %v\", err)\n    }\n\n    req, err := http.NewRequest(\"POST\", \"https://api.openai.com/v1/embeddings\", bytes.NewBuffer(jsonData))\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create request: %v\", err)\n    }\n\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    req.Header.Set(\"Authorization\", \"Bearer \"+apiKey)\n\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to send request: %v\", err)\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        body, _ := io.ReadAll(resp.Body)\n        return nil, fmt.Errorf(\"API request failed with status %d: %s\", resp.StatusCode, string(body))\n    }\n\n    var result OpenAIEmbeddingResponse\n    if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil {\n        return nil, fmt.Errorf(\"failed to decode response: %v\", err)\n    }\n\n    if len(result.Data) == 0 {\n        return nil, fmt.Errorf(\"no embeddings returned\")\n    }\n\n    return result.Data[0].Embedding, nil\n}\n\nfunc main() {\n    apiKey := os.Getenv(\"OPENAI_API_KEY\")\n    if apiKey == \"\" {\n        fmt.Println(\"Please set OPENAI_API_KEY environment variable\")\n        return\n    }\n\n    text := \"Go is a statically typed, compiled programming language\"\n    embedding, err := GenerateEmbeddingUsingOpenAI(text, apiKey)\n    if err != nil {\n        fmt.Printf(\"Error generating embedding: %v\\n\", err)\n        return\n    }\n\n    fmt.Printf(\"Generated embedding with %d dimensions\\n\", len(embedding))\n    fmt.Printf(\"First 5 dimensions: %v\\n\", embedding[:5])\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#2-using-pre-trained-models-with-onnx","title":"2. Using Pre-trained Models with ONNX","text":"<p>For local processing without API calls:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"ort\"\n)\n\n// LoadSentenceTransformer loads a pre-trained sentence transformer model\nfunc LoadSentenceTransformer(modelPath string) (*ort.Session, error) {\n    return ort.NewSession(modelPath, nil)\n}\n\n// GenerateEmbeddingWithONNX generates embedding using ONNX model\nfunc GenerateEmbeddingWithONNX(session *ort.Session, text string) ([]float32, error) {\n    // Tokenization would happen here (simplified for example)\n    // In practice, you'd need a tokenizer compatible with your model\n\n    // Create input tensor (simplified)\n    inputShape := []int64{1, 1} // Batch size 1, sequence length 1\n    inputData := []int32{123}    // Example token ID\n\n    inputTensor, err := ort.NewTensor(ort.TensorTypeINT32, inputShape, inputData)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create input tensor: %v\", err)\n    }\n    defer inputTensor.Release()\n\n    // Run inference\n    output, err := session.Run(map[string]ort.Value{\"input_ids\": inputTensor})\n    if err != nil {\n        return nil, fmt.Errorf(\"inference failed: %v\", err)\n    }\n    defer output.Release()\n\n    // Extract embedding (simplified)\n    embeddingTensor := output[\"last_hidden_state\"].(*ort.Tensor)\n    embedding := embeddingTensor.GetData().([]float32)\n\n    return embedding, nil\n}\n\nfunc main() {\n    // This example requires the ONNX Runtime for Go and a pre-trained model\n    // In practice, you'd download a model like all-MiniLM-L6-v2.onnx\n\n    fmt.Println(\"ONNX-based embedding generation requires additional setup\")\n    fmt.Println(\"See: https://github.com/microsoft/onnxruntime\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#3-using-go-specific-libraries","title":"3. Using Go-specific Libraries","text":"<p>Some Go libraries provide embedding capabilities:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/kniren/gota/dataframe\"\n    \"github.com/sjwhitworth/golearn/base\"\n    \"github.com/sjwhitworth/golearn/knn\"\n)\n\n// Simple example using golearn for text classification\n// Note: This is a simplified example - real embedding generation would require more setup\nfunc main() {\n    // Load dataset (in practice, you'd use a text dataset)\n    rawData, err := base.ParseCSVToInstances(\"text_data.csv\", true)\n    if err != nil {\n        panic(err)\n    }\n\n    // Create a kNN classifier\n    cls := knn.NewKnnClassifier(\"euclidean\", \"linear\", 2)\n    cls.Fit(rawData)\n\n    // Make predictions (simplified)\n    fmt.Println(\"Text classification with golearn\")\n    fmt.Println(\"This example requires proper text preprocessing\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#real-world-example-semantic-search-engine","title":"Real-World Example: Semantic Search Engine","text":"<p>Let's build a complete semantic search system that: 1. Pre-computes embeddings for a document collection 2. Stores embeddings in a vector database 3. Searches for similar documents based on query meaning</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"math\"\n    \"os\"\n    \"sort\"\n    \"sync\"\n    \"time\"\n)\n\n// Document represents a text document with its embedding\ntype Document struct {\n    ID        string\n    Title     string\n    Content   string\n    Embedding []float32\n    Timestamp time.Time\n}\n\n// SearchResult represents a search result with similarity score\ntype SearchResult struct {\n    Document   Document\n    Similarity float64\n}\n\n// VectorDatabase stores and searches embeddings\ntype VectorDatabase struct {\n    documents []Document\n    mu        sync.RWMutex\n}\n\nfunc NewVectorDatabase() *VectorDatabase {\n    return &amp;VectorDatabase{\n        documents: make([]Document, 0),\n    }\n}\n\n// AddDocument adds a document to the database\nfunc (db *VectorDatabase) AddDocument(doc Document) {\n    db.mu.Lock()\n    defer db.mu.Unlock()\n    db.documents = append(db.documents, doc)\n}\n\n// Search finds similar documents based on embedding similarity\nfunc (db *VectorDatabase) Search(queryEmbedding []float32, limit int) []SearchResult {\n    db.mu.RLock()\n    defer db.mu.RUnlock()\n\n    var results []SearchResult\n\n    for _, doc := range db.documents {\n        similarity := CosineSimilarity(queryEmbedding, doc.Embedding)\n        results = append(results, SearchResult{\n            Document:   doc,\n            Similarity: similarity,\n        })\n    }\n\n    // Sort by similarity (descending)\n    sort.Slice(results, func(i, j int) bool {\n        return results[i].Similarity &gt; results[j].Similarity\n    })\n\n    if len(results) &gt; limit {\n        results = results[:limit]\n    }\n\n    return results\n}\n\n// SemanticSearchEngine handles the complete search workflow\ntype SemanticSearchEngine struct {\n    db         *VectorDatabase\n    apiKey     string\n    embeddingCache map[string][]float32\n    cacheMu    sync.RWMutex\n}\n\nfunc NewSemanticSearchEngine(apiKey string) *SemanticSearchEngine {\n    return &amp;SemanticSearchEngine{\n        db:         NewVectorDatabase(),\n        apiKey:     apiKey,\n        embeddingCache: make(map[string][]float32),\n    }\n}\n\n// IndexDocument generates embedding and adds to database\nfunc (se *SemanticSearchEngine) IndexDocument(id, title, content string) error {\n    // Check cache first\n    se.cacheMu.RLock()\n    if embedding, exists := se.embeddingCache[content]; exists {\n        se.cacheMu.RUnlock()\n        doc := Document{\n            ID:        id,\n            Title:     title,\n            Content:   content,\n            Embedding: embedding,\n            Timestamp: time.Now(),\n        }\n        se.db.AddDocument(doc)\n        return nil\n    }\n    se.cacheMu.RUnlock()\n\n    // Generate embedding\n    embedding, err := GenerateEmbeddingUsingOpenAI(content, se.apiKey)\n    if err != nil {\n        return fmt.Errorf(\"failed to generate embedding: %v\", err)\n    }\n\n    // Cache the embedding\n    se.cacheMu.Lock()\n    se.embeddingCache[content] = embedding\n    se.cacheMu.Unlock()\n\n    // Add to database\n    doc := Document{\n        ID:        id,\n        Title:     title,\n        Content:   content,\n        Embedding: embedding,\n        Timestamp: time.Now(),\n    }\n    se.db.AddDocument(doc)\n\n    return nil\n}\n\n// Search performs semantic search\nfunc (se *SemanticSearchEngine) Search(query string, limit int) ([]SearchResult, error) {\n    // Generate query embedding\n    queryEmbedding, err := GenerateEmbeddingUsingOpenAI(query, se.apiKey)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to generate query embedding: %v\", err)\n    }\n\n    // Search database\n    return se.db.Search(queryEmbedding, limit), nil\n}\n\n// SaveDatabase saves the database to a file\nfunc (se *SemanticSearchEngine) SaveDatabase(filename string) error {\n    se.db.mu.RLock()\n    defer se.db.mu.RUnlock()\n\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    encoder := json.NewEncoder(file)\n    return encoder.Encode(se.db.documents)\n}\n\n// LoadDatabase loads the database from a file\nfunc (se *SemanticSearchEngine) LoadDatabase(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    var documents []Document\n    decoder := json.NewDecoder(file)\n    if err := decoder.Decode(&amp;documents); err != nil {\n        return err\n    }\n\n    se.db.mu.Lock()\n    se.db.documents = documents\n    se.db.mu.Unlock()\n\n    return nil\n}\n\nfunc main() {\n    apiKey := os.Getenv(\"OPENAI_API_KEY\")\n    if apiKey == \"\" {\n        fmt.Println(\"Please set OPENAI_API_KEY environment variable\")\n        return\n    }\n\n    // Create search engine\n    engine := NewSemanticSearchEngine(apiKey)\n\n    // Index some documents\n    documents := []struct {\n        ID      string\n        Title   string\n        Content string\n    }{\n        {\n            ID:      \"1\",\n            Title:   \"Introduction to Go\",\n            Content: \"Go is a statically typed, compiled programming language designed at Google.\",\n        },\n        {\n            ID:      \"2\",\n            Title:   \"Concurrency in Go\",\n            Content: \"Go's concurrency primitives make it easy to write concurrent programs.\",\n        },\n        {\n            ID:      \"3\",\n            Title:   \"Go Garbage Collection\",\n            Content: \"Go has automatic garbage collection that manages memory allocation and release.\",\n        },\n        {\n            ID:      \"4\",\n            Title:   \"Python Programming\",\n            Content: \"Python is an interpreted, high-level, general-purpose programming language.\",\n        },\n        {\n            ID:      \"5\",\n            Title:   \"Machine Learning\",\n            Content: \"Machine learning is a method of data analysis that automates analytical model building.\",\n        },\n    }\n\n    fmt.Println(\"Indexing documents...\")\n    for _, doc := range documents {\n        if err := engine.IndexDocument(doc.ID, doc.Title, doc.Content); err != nil {\n            log.Printf(\"Error indexing document %s: %v\", doc.ID, err)\n        } else {\n            fmt.Printf(\"Indexed: %s\\n\", doc.Title)\n        }\n    }\n\n    // Save database\n    if err := engine.SaveDatabase(\"search_db.json\"); err != nil {\n        log.Printf(\"Error saving database: %v\", err)\n    }\n\n    // Perform searches\n    queries := []string{\n        \"programming language Google\",\n        \"automatic memory management\",\n        \"data analysis automation\",\n        \"concurrent programming\",\n    }\n\n    fmt.Println(\"\\nPerforming searches...\")\n    for _, query := range queries {\n        fmt.Printf(\"\\nQuery: %s\\n\", query)\n        results, err := engine.Search(query, 3)\n        if err != nil {\n            log.Printf(\"Search error: %v\", err)\n            continue\n        }\n\n        for i, result := range results {\n            fmt.Printf(\"%d. %s (Similarity: %.2f)\\n\", i+1, result.Document.Title, result.Similarity)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Document Indexing:</li> <li>Takes text documents and generates embeddings using OpenAI's API</li> <li>Stores documents with their embeddings in a vector database</li> <li> <p>Implements caching to avoid regenerating embeddings</p> </li> <li> <p>Semantic Search:</p> </li> <li>Converts user queries into embeddings</li> <li>Finds documents with similar embeddings using cosine similarity</li> <li> <p>Returns ranked results by similarity score</p> </li> <li> <p>Persistence:</p> </li> <li>Saves and loads the vector database to/from JSON files</li> <li>Maintains thread safety with mutex locks</li> </ol>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Content Recommendation Systems:</li> <li>Suggest similar articles or products</li> <li> <p>Personalize user experiences</p> </li> <li> <p>Document Management:</p> </li> <li>Organize large document collections</li> <li> <p>Find related documents automatically</p> </li> <li> <p>Customer Support:</p> </li> <li>Match user queries to relevant help articles</li> <li> <p>Automate ticket routing</p> </li> <li> <p>Research Tools:</p> </li> <li>Find similar research papers</li> <li>Discover connections between documents</li> </ol>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#best-practices-for-text-embeddings-in-go","title":"Best Practices for Text Embeddings in Go","text":""},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#1-choose-the-right-approach","title":"1. Choose the Right Approach","text":"<ul> <li>API-based: Best for accuracy and ease of use (OpenAI, Cohere)</li> <li>Local models: Best for privacy and low latency (ONNX, TensorFlow)</li> <li>Hybrid: Use APIs for development, local models for production</li> </ul>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#2-optimize-performance","title":"2. Optimize Performance","text":"<pre><code>// Batch embedding generation\nfunc BatchGenerateEmbeddings(texts []string, apiKey string) ([][]float32, error) {\n    // Implement batch API calls for efficiency\n    // This reduces API calls and improves throughput\n}\n\n// Parallel processing\nfunc ParallelIndexing(engine *SemanticSearchEngine, docs []Document) {\n    var wg sync.WaitGroup\n    for _, doc := range docs {\n        wg.Add(1)\n        go func(d Document) {\n            defer wg.Done()\n            engine.IndexDocument(d.ID, d.Title, d.Content)\n        }(doc)\n    }\n    wg.Wait()\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>func SafeEmbeddingGeneration(text, apiKey string) ([]float32, error) {\n    embedding, err := GenerateEmbeddingUsingOpenAI(text, apiKey)\n    if err != nil {\n        log.Printf(\"Embedding generation failed: %v\", err)\n        // Fallback to zero embedding or retry logic\n        return make([]float32, 1536), nil\n    }\n    return embedding, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#4-monitor-and-log","title":"4. Monitor and Log","text":"<pre><code>type EmbeddingMetrics struct {\n    TotalRequests int\n    FailedRequests int\n    AverageLatency time.Duration\n}\n\nfunc (m *EmbeddingMetrics) RecordRequest(start time.Time, err error) {\n    m.TotalRequests++\n    if err != nil {\n        m.FailedRequests++\n    }\n    m.AverageLatency = (m.AverageLatency*time.Duration(m.TotalRequests-1) + time.Since(start)) / \n                      time.Duration(m.TotalRequests)\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#conclusion","title":"Conclusion","text":"<p>Text embeddings are a powerful tool for adding semantic understanding to Go applications. While Go's NLP ecosystem isn't as mature as Python's, we can effectively leverage:</p> <ol> <li>External APIs for high-quality embeddings (OpenAI, Cohere)</li> <li>Pre-trained models with ONNX or TensorFlow for local processing</li> <li>Vector databases for efficient similarity search</li> <li>Caching and optimization techniques for performance</li> </ol> <p>The semantic search example demonstrates how to build a complete system that: - Indexes documents with embeddings - Performs meaning-based search - Handles persistence and concurrency - Provides a foundation for more advanced features</p> <p>Key takeaways: 1. Start with API-based solutions for simplicity 2. Implement proper error handling and monitoring 3. Use caching to optimize performance 4. Consider privacy and latency requirements 5. Build on top of existing libraries rather than reinventing the wheel</p> <p>As Go's machine learning ecosystem continues to grow, we can expect more native solutions for text embeddings and NLP tasks. For now, the combination of external APIs and careful implementation provides a robust approach to adding semantic capabilities to Go applications.</p>"},{"location":"2.%20Intermediate/11.%20Generics/","title":"Generics in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/11.%20Generics/#introduction-to-generics","title":"Introduction to Generics","text":"<p>Generics, introduced in Go 1.18, enable you to write flexible and reusable code by allowing functions and types to work with any data type while maintaining type safety. Before generics, Go developers often used interfaces and type assertions to achieve similar functionality, but this approach lacked compile-time type checking and could lead to runtime errors.</p> <p>Generics solve these problems by allowing you to define: - Type parameters: Placeholders for actual types - Type constraints: Rules that specify which types can be used - Generic functions and types: Code that works with multiple types</p>"},{"location":"2.%20Intermediate/11.%20Generics/#why-use-generics","title":"Why Use Generics?","text":"<ol> <li>Type Safety: Catch type errors at compile time</li> <li>Code Reusability: Write once, use with multiple types</li> <li>Performance: Avoid runtime type assertions and conversions</li> <li>Readability: Clearer intent than interface-based solutions</li> <li>Reduced Boilerplate: Eliminate repetitive code for different types</li> </ol>"},{"location":"2.%20Intermediate/11.%20Generics/#generic-functions","title":"Generic Functions","text":""},{"location":"2.%20Intermediate/11.%20Generics/#basic-syntax","title":"Basic Syntax","text":"<pre><code>func PrintSlice[T any](s []T) {\n    for _, v := range s {\n        fmt.Print(v, \" \")\n    }\n    fmt.Println()\n}\n\nfunc main() {\n    PrintSlice([]int{1, 2, 3})      // Works with int\n    PrintSlice([]string{\"a\", \"b\"}) // Works with string\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#type-parameters","title":"Type Parameters","text":"<ul> <li>Declared in square brackets <code>[]</code> before function parameters</li> <li>Can have multiple type parameters: <code>[T, U any]</code></li> <li>Conventionally use single capital letters (T, U, V, etc.)</li> </ul>"},{"location":"2.%20Intermediate/11.%20Generics/#type-constraints","title":"Type Constraints","text":"<p>Constraints specify what types can be used as type parameters:</p> <pre><code>// Using built-in constraints\nfunc SumNumbers[T int | float64](nums []T) T {\n    var sum T\n    for _, n := range nums {\n        sum += n\n    }\n    return sum\n}\n\nfunc main() {\n    fmt.Println(SumNumbers([]int{1, 2, 3}))     // 6\n    fmt.Println(SumNumbers([]float64{1.1, 2.2})) // 3.3\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#built-in-constraints","title":"Built-in Constraints","text":""},{"location":"2.%20Intermediate/11.%20Generics/#any","title":"<code>any</code>","text":"<p>Equivalent to <code>interface{}</code>, allows any type: <pre><code>func Identity[T any](x T) T {\n    return x\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/11.%20Generics/#comparable","title":"<code>comparable</code>","text":"<p>Types that support <code>==</code> and <code>!=</code> operators: <pre><code>func FindIndex[T comparable](s []T, target T) int {\n    for i, v := range s {\n        if v == target {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    fmt.Println(FindIndex([]int{1, 2, 3}, 2))     // 1\n    fmt.Println(FindIndex([]string{\"a\", \"b\"}, \"b\")) // 1\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/11.%20Generics/#custom-type-constraints","title":"Custom Type Constraints","text":""},{"location":"2.%20Intermediate/11.%20Generics/#using-interfaces","title":"Using Interfaces","text":"<pre><code>type Stringer interface {\n    String() string\n}\n\nfunc PrintStringers[T Stringer](s []T) {\n    for _, v := range s {\n        fmt.Println(v.String())\n    }\n}\n\ntype Person struct {\n    Name string\n}\n\nfunc (p Person) String() string {\n    return p.Name\n}\n\nfunc main() {\n    people := []Person{{\"Alice\"}, {\"Bob\"}}\n    PrintStringers(people) // Alice\\nBob\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#approximating-constraints","title":"Approximating Constraints","text":"<p>Use <code>~</code> to include types whose underlying type matches: <pre><code>type Number interface {\n    int | int8 | int16 | int32 | int64 | \n    float32 | float64\n}\n\nfunc Max[T Number](a, b T) T {\n    if a &gt; b {\n        return a\n    }\n    return b\n}\n\ntype MyInt int\n\nfunc main() {\n    fmt.Println(Max(10, 20))           // 20\n    fmt.Println(Max(MyInt(10), MyInt(20))) // 20\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/11.%20Generics/#generic-types","title":"Generic Types","text":""},{"location":"2.%20Intermediate/11.%20Generics/#generic-structs","title":"Generic Structs","text":"<pre><code>type Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    if len(s.items) == 0 {\n        var zero T\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\nfunc main() {\n    intStack := &amp;Stack[int]{}\n    intStack.Push(1)\n    intStack.Push(2)\n    fmt.Println(intStack.Pop()) // 2, true\n\n    stringStack := &amp;Stack[string]{}\n    stringStack.Push(\"a\")\n    stringStack.Push(\"b\")\n    fmt.Println(stringStack.Pop()) // \"b\", true\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#generic-slices-and-maps","title":"Generic Slices and Maps","text":"<pre><code>// Generic slice type\ntype Vector[T any] []T\n\nfunc (v *Vector[T]) Push(item T) {\n    *v = append(*v, item)\n}\n\n// Generic map type\ntype Cache[K comparable, V any] struct {\n    items map[K]V\n}\n\nfunc (c *Cache[K, V]) Set(key K, value V) {\n    if c.items == nil {\n        c.items = make(map[K]V)\n    }\n    c.items[key] = value\n}\n\nfunc (c *Cache[K, V]) Get(key K) (V, bool) {\n    value, exists := c.items[key]\n    return value, exists\n}\n\nfunc main() {\n    vec := Vector[int]{1, 2, 3}\n    vec.Push(4)\n    fmt.Println(vec) // [1 2 3 4]\n\n    cache := Cache[string, int]{}\n    cache.Set(\"age\", 30)\n    if age, ok := cache.Get(\"age\"); ok {\n        fmt.Println(age) // 30\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#advanced-generic-patterns","title":"Advanced Generic Patterns","text":""},{"location":"2.%20Intermediate/11.%20Generics/#generic-methods","title":"Generic Methods","text":"<pre><code>type Container[T any] struct {\n    value T\n}\n\nfunc (c Container[T]) Get() T {\n    return c.value\n}\n\nfunc (c *Container[T]) Set(value T) {\n    c.value = value\n}\n\nfunc main() {\n    intContainer := Container[int]{value: 42}\n    fmt.Println(intContainer.Get()) // 42\n\n    stringContainer := &amp;Container[string]{}\n    stringContainer.Set(\"hello\")\n    fmt.Println(stringContainer.Get()) // \"hello\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#type-sets","title":"Type Sets","text":"<p>Define constraints using type sets: <pre><code>type Ordered interface {\n    int | int8 | int16 | int32 | int64 |\n    uint | uint8 | uint16 | uint32 | uint64 |\n    float32 | float64 |\n    ~string\n}\n\nfunc Sort[T Ordered](s []T) {\n    sort.Slice(s, func(i, j int) bool {\n        return s[i] &lt; s[j]\n    })\n}\n\nfunc main() {\n    ints := []int{3, 1, 2}\n    Sort(ints)\n    fmt.Println(ints) // [1 2 3]\n\n    floats := []float64{3.3, 1.1, 2.2}\n    Sort(floats)\n    fmt.Println(floats) // [1.1 2.2 3.3]\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/11.%20Generics/#generic-channels","title":"Generic Channels","text":"<pre><code>func Process[T any](in &lt;-chan T, out chan&lt;- T, process func(T) T) {\n    for item := range in {\n        out &lt;- process(item)\n    }\n    close(out)\n}\n\nfunc main() {\n    in := make(chan int, 3)\n    out := make(chan int, 3)\n\n    go Process(in, out, func(x int) int {\n        return x * 2\n    })\n\n    in &lt;- 1\n    in &lt;- 2\n    in &lt;- 3\n    close(in)\n\n    for result := range out {\n        fmt.Println(result) // 2, 4, 6\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#real-world-example-generic-repository-pattern","title":"Real-World Example: Generic Repository Pattern","text":"<p>Let's build a complete CRUD repository pattern using generics:</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"sync\"\n)\n\n// Entity interface defines the basic contract for all entities\ntype Entity interface {\n    GetID() string\n    SetID(string)\n}\n\n// Repository interface defines the contract for repositories\ntype Repository[T Entity] interface {\n    Create(entity T) error\n    GetByID(id string) (T, error)\n    Update(entity T) error\n    Delete(id string) error\n    List() ([]T, error)\n}\n\n// InMemoryRepository implements Repository using in-memory storage\ntype InMemoryRepository[T Entity] struct {\n    items map[string]T\n    mu    sync.RWMutex\n}\n\nfunc NewInMemoryRepository[T Entity]() *InMemoryRepository[T] {\n    return &amp;InMemoryRepository[T]{\n        items: make(map[string]T),\n    }\n}\n\nfunc (r *InMemoryRepository[T]) Create(entity T) error {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n\n    id := entity.GetID()\n    if id == \"\" {\n        return errors.New(\"entity must have an ID\")\n    }\n\n    if _, exists := r.items[id]; exists {\n        return fmt.Errorf(\"entity with ID %s already exists\", id)\n    }\n\n    r.items[id] = entity\n    return nil\n}\n\nfunc (r *InMemoryRepository[T]) GetByID(id string) (T, error) {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n\n    entity, exists := r.items[id]\n    if !exists {\n        var zero T\n        return zero, fmt.Errorf(\"entity with ID %s not found\", id)\n    }\n\n    return entity, nil\n}\n\nfunc (r *InMemoryRepository[T]) Update(entity T) error {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n\n    id := entity.GetID()\n    if _, exists := r.items[id]; !exists {\n        return fmt.Errorf(\"entity with ID %s not found\", id)\n    }\n\n    r.items[id] = entity\n    return nil\n}\n\nfunc (r *InMemoryRepository[T]) Delete(id string) error {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n\n    if _, exists := r.items[id]; !exists {\n        return fmt.Errorf(\"entity with ID %s not found\", id)\n    }\n\n    delete(r.items, id)\n    return nil\n}\n\nfunc (r *InMemoryRepository[T]) List() ([]T, error) {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n\n    items := make([]T, 0, len(r.items))\n    for _, item := range r.items {\n        items = append(items, item)\n    }\n\n    return items, nil\n}\n\n// Service layer that uses the repository\ntype Service[T Entity] struct {\n    repo Repository[T]\n}\n\nfunc NewService[T Entity](repo Repository[T]) *Service[T] {\n    return &amp;Service[T]{repo: repo}\n}\n\nfunc (s *Service[T]) Create(entity T) error {\n    if entity.GetID() == \"\" {\n        return errors.New(\"entity must have an ID\")\n    }\n    return s.repo.Create(entity)\n}\n\nfunc (s *Service[T]) Get(id string) (T, error) {\n    return s.repo.GetByID(id)\n}\n\nfunc (s *Service[T]) Update(entity T) error {\n    if entity.GetID() == \"\" {\n        return errors.New(\"entity must have an ID\")\n    }\n    return s.repo.Update(entity)\n}\n\nfunc (s *Service[T]) Delete(id string) error {\n    if id == \"\" {\n        return errors.New(\"ID cannot be empty\")\n    }\n    return s.repo.Delete(id)\n}\n\nfunc (s *Service[T]) List() ([]T, error) {\n    return s.repo.List()\n}\n\n// Example entity implementations\ntype User struct {\n    ID    string\n    Name  string\n    Email string\n    Age   int\n}\n\nfunc (u User) GetID() string {\n    return u.ID\n}\n\nfunc (u *User) SetID(id string) {\n    u.ID = id\n}\n\ntype Product struct {\n    ID          string\n    Name        string\n    Description string\n    Price       float64\n}\n\nfunc (p Product) GetID() string {\n    return p.ID\n}\n\nfunc (p *Product) SetID(id string) {\n    p.ID = id\n}\n\nfunc main() {\n    // User repository and service\n    userRepo := NewInMemoryRepository[User]()\n    userService := NewService(userRepo)\n\n    // Create users\n    users := []User{\n        {ID: \"1\", Name: \"Alice\", Email: \"alice@example.com\", Age: 30},\n        {ID: \"2\", Name: \"Bob\", Email: \"bob@example.com\", Age: 25},\n    }\n\n    for _, user := range users {\n        if err := userService.Create(user); err != nil {\n            fmt.Printf(\"Error creating user: %v\\n\", err)\n        }\n    }\n\n    // List users\n    userList, err := userService.List()\n    if err != nil {\n        fmt.Printf(\"Error listing users: %v\\n\", err)\n    } else {\n        fmt.Println(\"Users:\")\n        for _, user := range userList {\n            fmt.Printf(\"- %s (%s, %d years)\\n\", user.Name, user.Email, user.Age)\n        }\n    }\n\n    // Get user by ID\n    user, err := userService.Get(\"1\")\n    if err != nil {\n        fmt.Printf(\"Error getting user: %v\\n\", err)\n    } else {\n        fmt.Printf(\"\\nRetrieved user: %+v\\n\", user)\n    }\n\n    // Update user\n    user.Name = \"Alice Smith\"\n    if err := userService.Update(user); err != nil {\n        fmt.Printf(\"Error updating user: %v\\n\", err)\n    }\n\n    // Product repository and service\n    productRepo := NewInMemoryRepository[Product]()\n    productService := NewService(productRepo)\n\n    // Create products\n    products := []Product{\n        {ID: \"p1\", Name: \"Laptop\", Description: \"High-performance laptop\", Price: 999.99},\n        {ID: \"p2\", Name: \"Mouse\", Description: \"Wireless mouse\", Price: 29.99},\n    }\n\n    for _, product := range products {\n        if err := productService.Create(product); err != nil {\n            fmt.Printf(\"Error creating product: %v\\n\", err)\n        }\n    }\n\n    // List products\n    productList, err := productService.List()\n    if err != nil {\n        fmt.Printf(\"Error listing products: %v\\n\", err)\n    } else {\n        fmt.Println(\"\\nProducts:\")\n        for _, product := range productList {\n            fmt.Printf(\"- %s: $%.2f\\n\", product.Name, product.Price)\n        }\n    }\n\n    // Delete product\n    if err := productService.Delete(\"p2\"); err != nil {\n        fmt.Printf(\"Error deleting product: %v\\n\", err)\n    }\n\n    // Verify deletion\n    productList, _ = productService.List()\n    fmt.Printf(\"\\nProducts after deletion: %d\\n\", len(productList))\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#how-this-example-demonstrates-generics","title":"How This Example Demonstrates Generics:","text":"<ol> <li>Generic Repository Interface:</li> <li><code>Repository[T Entity]</code> defines CRUD operations for any entity type</li> <li> <p>Type parameter <code>T</code> is constrained to implement <code>Entity</code></p> </li> <li> <p>Generic Implementation:</p> </li> <li><code>InMemoryRepository[T Entity]</code> implements the repository interface</li> <li> <p>Works with any type that satisfies the <code>Entity</code> constraint</p> </li> <li> <p>Generic Service Layer:</p> </li> <li><code>Service[T Entity]</code> provides business logic</li> <li> <p>Reuses the same pattern for different entity types</p> </li> <li> <p>Multiple Entity Types:</p> </li> <li><code>User</code> and <code>Product</code> both implement <code>Entity</code></li> <li>Same repository and service code works for both</li> </ol>"},{"location":"2.%20Intermediate/11.%20Generics/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Database Access Layers:</li> <li>Generic repositories for different models</li> <li> <p>Consistent CRUD operations across entities</p> </li> <li> <p>API Handlers:</p> </li> <li>Generic handlers for common operations</li> <li> <p>Type-safe request/response handling</p> </li> <li> <p>Caching Systems:</p> </li> <li>Generic cache implementations</li> <li> <p>Type-safe storage and retrieval</p> </li> <li> <p>Message Processing:</p> </li> <li>Generic message handlers</li> <li>Type-safe serialization/deserialization</li> </ol>"},{"location":"2.%20Intermediate/11.%20Generics/#best-practices-for-generics","title":"Best Practices for Generics","text":""},{"location":"2.%20Intermediate/11.%20Generics/#1-when-to-use-generics","title":"1. When to Use Generics","text":"<ul> <li>Use generics when:</li> <li>You need to work with multiple types in the same way</li> <li>You want compile-time type safety</li> <li>You're implementing data structures (stacks, queues, etc.)</li> <li> <p>You're creating utility functions (min, max, sort, etc.)</p> </li> <li> <p>Avoid generics when:</p> </li> <li>You're only working with one specific type</li> <li>The type-specific behavior is more important than reusability</li> <li>The code becomes less readable</li> </ul>"},{"location":"2.%20Intermediate/11.%20Generics/#2-naming-conventions","title":"2. Naming Conventions","text":"<ul> <li>Use single capital letters for type parameters (T, U, V)</li> <li>Use descriptive names when the meaning isn't obvious:   <pre><code>func Map[T, U any](s []T, f func(T) U) []U\n</code></pre></li> </ul>"},{"location":"2.%20Intermediate/11.%20Generics/#3-constraint-design","title":"3. Constraint Design","text":"<ul> <li>Keep constraints as small as possible</li> <li>Prefer <code>~</code> for underlying types when appropriate</li> <li>Use interfaces to define behavior constraints</li> </ul>"},{"location":"2.%20Intermediate/11.%20Generics/#4-performance-considerations","title":"4. Performance Considerations","text":"<ul> <li>Generics don't add runtime overhead</li> <li>The compiler generates specialized code for each type</li> <li>Monomorphization happens at compile time</li> </ul>"},{"location":"2.%20Intermediate/11.%20Generics/#5-error-handling","title":"5. Error Handling","text":"<ul> <li>Provide clear error messages for constraint violations</li> <li>Handle type-specific errors appropriately</li> </ul>"},{"location":"2.%20Intermediate/11.%20Generics/#common-patterns-with-generics","title":"Common Patterns with Generics","text":""},{"location":"2.%20Intermediate/11.%20Generics/#1-functional-utilities","title":"1. Functional Utilities","text":"<pre><code>func Map[T, U any](s []T, f func(T) U) []U {\n    result := make([]U, len(s))\n    for i, v := range s {\n        result[i] = f(v)\n    }\n    return result\n}\n\nfunc Filter[T any](s []T, f func(T) bool) []T {\n    result := make([]T, 0)\n    for _, v := range s {\n        if f(v) {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc Reduce[T, U any](s []T, init U, f func(U, T) U) U {\n    result := init\n    for _, v := range s {\n        result = f(result, v)\n    }\n    return result\n}\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n\n    // Map: square each number\n    squared := Map(numbers, func(x int) int { return x * x })\n    fmt.Println(squared) // [1 4 9 16 25]\n\n    // Filter: keep even numbers\n    evens := Filter(numbers, func(x int) bool { return x%2 == 0 })\n    fmt.Println(evens) // [2 4]\n\n    // Reduce: sum all numbers\n    sum := Reduce(numbers, 0, func(acc, x int) int { return acc + x })\n    fmt.Println(sum) // 15\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#2-generic-data-structures","title":"2. Generic Data Structures","text":"<pre><code>// Binary Search Tree\ntype TreeNode[T comparable] struct {\n    Value T\n    Left  *TreeNode[T]\n    Right *TreeNode[T]\n}\n\nfunc (n *TreeNode[T]) Insert(value T) {\n    if value &lt; n.Value {\n        if n.Left == nil {\n            n.Left = &amp;TreeNode[T]{Value: value}\n        } else {\n            n.Left.Insert(value)\n        }\n    } else {\n        if n.Right == nil {\n            n.Right = &amp;TreeNode[T]{Value: value}\n        } else {\n            n.Right.Insert(value)\n        }\n    }\n}\n\nfunc (n *TreeNode[T]) InOrder() []T {\n    var result []T\n    if n.Left != nil {\n        result = append(result, n.Left.InOrder()...)\n    }\n    result = append(result, n.Value)\n    if n.Right != nil {\n        result = append(result, n.Right.InOrder()...)\n    }\n    return result\n}\n\nfunc main() {\n    root := &amp;TreeNode[int]{Value: 5}\n    root.Insert(3)\n    root.Insert(7)\n    root.Insert(1)\n    root.Insert(9)\n\n    fmt.Println(root.InOrder()) // [1 3 5 7 9]\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#3-generic-pool-pattern","title":"3. Generic Pool Pattern","text":"<pre><code>type Pool[T any] struct {\n    items chan T\n    factory func() T\n}\n\nfunc NewPool[T any](size int, factory func() T) *Pool[T] {\n    p := &amp;Pool[T]{\n        items: make(chan T, size),\n        factory: factory,\n    }\n\n    for i := 0; i &lt; size; i++ {\n        p.items &lt;- factory()\n    }\n\n    return p\n}\n\nfunc (p *Pool[T]) Get() T {\n    select {\n    case item := &lt;-p.items:\n        return item\n    default:\n        return p.factory()\n    }\n}\n\nfunc (p *Pool[T]) Put(item T) {\n    select {\n    case p.items &lt;- item:\n        // Item returned to pool\n    default:\n        // Pool is full, discard item\n    }\n}\n\nfunc main() {\n    // Pool of buffers\n    bufferPool := NewPool(bytes.Buffer, 10, func() bytes.Buffer {\n        return bytes.Buffer{}\n    })\n\n    // Get buffer from pool\n    buf := bufferPool.Get()\n    buf.WriteString(\"hello\")\n    fmt.Println(buf.String()) // hello\n\n    // Return buffer to pool\n    bufferPool.Put(buf)\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#conclusion","title":"Conclusion","text":"<p>Generics in Go provide a powerful way to write flexible, reusable, and type-safe code. They enable you to:</p> <ol> <li>Eliminate Code Duplication:</li> <li>Write once, use with multiple types</li> <li> <p>Create generic data structures and algorithms</p> </li> <li> <p>Improve Type Safety:</p> </li> <li>Catch errors at compile time</li> <li> <p>Avoid runtime type assertions</p> </li> <li> <p>Enhance Performance:</p> </li> <li>No runtime overhead</li> <li> <p>Compiler optimizations</p> </li> <li> <p>Express Clear Intent:</p> </li> <li>Make code more readable</li> <li>Explicitly define type requirements</li> </ol> <p>The repository pattern example demonstrates how generics can create a robust, reusable foundation for data access layers that work with any entity type. By combining generics with interfaces, you can create flexible architectures that are both type-safe and maintainable.</p> <p>Key takeaways: 1. Use generics when you need to work with multiple types similarly 2. Design constraints carefully to balance flexibility and safety 3. Prefer generics over interface{} for type-safe operations 4. Leverage generics for data structures and utility functions 5. Combine generics with interfaces for maximum flexibility</p> <p>Generics represent a significant evolution in Go's type system, enabling more expressive and maintainable code while preserving the language's simplicity and performance characteristics.</p>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/","title":"Go Error Handling: Explicit and Idiomatic","text":"<p>Overview</p> <p>Master Go's explicit error handling approach. Learn error creation, custom error types, error wrapping, and best practices for building robust applications with clear error management.</p> <p>Key Points</p> <ul> <li>Errors are values, not exceptions</li> <li>Explicit error checking encourages robust code</li> <li>Custom error types provide rich context</li> <li>Error wrapping preserves error chains</li> <li>Sentinel errors enable error comparison</li> </ul>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#understanding-error-handling","title":"Understanding Error Handling","text":"<p>Go treats errors as ordinary values that must be explicitly checked and handled, making error cases visible in code.</p>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#the-basic-error-type","title":"The Basic Error Type","text":"<p>Go's built-in <code>error</code> type is an interface with a single method:</p> <pre><code>type error interface {\n    Error() string\n}\n</code></pre> <p>Any type that implements this <code>Error()</code> method can be used as an error.</p>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#creating-simple-errors","title":"Creating Simple Errors","text":"<pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc main() {\n    // Using errors.New()\n    err1 := errors.New(\"something went wrong\")\n    fmt.Println(err1) // \"something went wrong\"\n\n    // Using fmt.Errorf()\n    err2 := fmt.Errorf(\"invalid value: %d\", 42)\n    fmt.Println(err2) // \"invalid value: 42\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#1-basic-error-checking","title":"1. Basic Error Checking","text":"<p>The most common pattern is to check if an error is non-nil:</p> <pre><code>func divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"cannot divide by zero\")\n    }\n    return a / b, nil\n}\n\nfunc main() {\n    result, err := divide(10, 2)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Result:\", result) // 5\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#2-handling-errors-in-loops","title":"2. Handling Errors in Loops","text":"<pre><code>func processItems(items []string) error {\n    for _, item := range items {\n        if err := processItem(item); err != nil {\n            return fmt.Errorf(\"failed to process %s: %w\", item, err)\n        }\n    }\n    return nil\n}\n\nfunc processItem(item string) error {\n    // Simulate processing\n    if item == \"invalid\" {\n        return errors.New(\"invalid item\")\n    }\n    fmt.Println(\"Processed:\", item)\n    return nil\n}\n\nfunc main() {\n    items := []string{\"item1\", \"invalid\", \"item3\"}\n    err := processItems(items)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#3-sentinel-errors","title":"3. Sentinel Errors","text":"<p>Predefined error values that can be checked with <code>==</code>:</p> <pre><code>var ErrNotFound = errors.New(\"not found\")\n\nfunc findUser(id int) (*User, error) {\n    // Simulate database lookup\n    if id != 1 {\n        return nil, ErrNotFound\n    }\n    return &amp;User{ID: 1, Name: \"Alice\"}, nil\n}\n\nfunc main() {\n    user, err := findUser(2)\n    if err == ErrNotFound {\n        fmt.Println(\"User not found\")\n        return\n    }\n    if err != nil {\n        fmt.Println(\"Other error:\", err)\n        return\n    }\n    fmt.Println(\"Found user:\", user.Name)\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#custom-error-types","title":"Custom Error Types","text":""},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#basic-custom-error","title":"Basic Custom Error","text":"<pre><code>type ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error on field %s: %s\", e.Field, e.Message)\n}\n\nfunc validateEmail(email string) error {\n    if !strings.Contains(email, \"@\") {\n        return &amp;ValidationError{\n            Field:   \"email\",\n            Message: \"must contain @ symbol\",\n        }\n    }\n    return nil\n}\n\nfunc main() {\n    err := validateEmail(\"invalid-email\")\n    if err != nil {\n        fmt.Println(err) // \"validation error on field email: must contain @ symbol\"\n\n        // Type assertion to access custom fields\n        if ve, ok := err.(*ValidationError); ok {\n            fmt.Printf(\"Field: %s, Message: %s\\n\", ve.Field, ve.Message)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#error-types-with-additional-methods","title":"Error Types with Additional Methods","text":"<pre><code>type TimeoutError struct {\n    Operation string\n    Timeout   time.Duration\n}\n\nfunc (e *TimeoutError) Error() string {\n    return fmt.Sprintf(\"%s timed out after %v\", e.Operation, e.Timeout)\n}\n\nfunc (e *TimeoutError) Is(target error) bool {\n    _, ok := target.(*TimeoutError)\n    return ok\n}\n\nfunc (e *TimeoutError) Temporary() bool {\n    return true\n}\n\nfunc main() {\n    err := &amp;TimeoutError{\n        Operation: \"database query\",\n        Timeout:   5 * time.Second,\n    }\n\n    fmt.Println(err) // \"database query timed out after 5s\"\n\n    // Check if error is temporary\n    if te, ok := err.(interface{ Temporary() bool }); ok &amp;&amp; te.Temporary() {\n        fmt.Println(\"This is a temporary error\")\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#error-wrapping-and-unwrapping-go-113","title":"Error Wrapping and Unwrapping (Go 1.13+)","text":""},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#wrapping-errors","title":"Wrapping Errors","text":"<p>Add context to errors while preserving the original error:</p> <pre><code>func readFile(filename string) error {\n    _, err := os.Open(filename)\n    if err != nil {\n        return fmt.Errorf(\"failed to read file %s: %w\", filename, err)\n    }\n    return nil\n}\n\nfunc main() {\n    err := readFile(\"nonexistent.txt\")\n    if err != nil {\n        fmt.Println(err) // \"failed to read file nonexistent.txt: open nonexistent.txt: no such file or directory\"\n\n        // Unwrap the error\n        unwrapped := errors.Unwrap(err)\n        fmt.Println(unwrapped) // \"open nonexistent.txt: no such file or directory\"\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#checking-wrapped-errors","title":"Checking Wrapped Errors","text":"<p>Use <code>errors.Is()</code> and <code>errors.As()</code> to inspect wrapped errors:</p> <pre><code>var ErrPermission = errors.New(\"permission denied\")\n\nfunc accessFile(path string) error {\n    // Simulate permission error\n    return fmt.Errorf(\"access denied: %w\", ErrPermission)\n}\n\nfunc main() {\n    err := accessFile(\"/protected/file\")\n\n    // Check if error is or wraps ErrPermission\n    if errors.Is(err, ErrPermission) {\n        fmt.Println(\"Permission denied\")\n    }\n\n    // Check for specific error type\n    var pathError *os.PathError\n    if errors.As(err, &amp;pathError) {\n        fmt.Printf(\"Path error: %s\\n\", pathError.Path)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#best-practices-for-error-handling","title":"Best Practices for Error Handling","text":""},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#1-handle-errors-immediately","title":"1. Handle Errors Immediately","text":"<p>Check errors as soon as they're returned:</p> <pre><code>// Good\nfunc process() {\n    data, err := fetchData()\n    if err != nil {\n        log.Printf(\"Failed to fetch data: %v\", err)\n        return\n    }\n    // Use data\n}\n\n// Bad - error handling deferred\nfunc process() {\n    data, _ := fetchData() // Ignoring error!\n    // Use data - might panic or behave unexpectedly\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#2-add-context-when-wrapping","title":"2. Add Context When Wrapping","text":"<p>Provide meaningful context without losing the original error:</p> <pre><code>// Good\nfunc processUser(id int) error {\n    user, err := database.GetUser(id)\n    if err != nil {\n        return fmt.Errorf(\"processUser: failed to get user %d: %w\", id, err)\n    }\n    // Process user\n    return nil\n}\n\n// Bad - loses original error\nfunc processUser(id int) error {\n    user, err := database.GetUser(id)\n    if err != nil {\n        return errors.New(\"failed to get user\")\n    }\n    // Process user\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#3-use-error-types-for-programmatic-checks","title":"3. Use Error Types for Programmatic Checks","text":"<p>Custom error types enable precise error handling:</p> <pre><code>type RetryableError struct {\n    Err error\n}\n\nfunc (e *RetryableError) Error() string { return e.Err.Error() }\nfunc (e *RetryableError) Unwrap() error { return e.Err }\n\nfunc processWithRetry() error {\n    for i := 0; i &lt; 3; i++ {\n        err := doOperation()\n        if err == nil {\n            return nil\n        }\n        if errors.As(err, &amp;RetryableError{}) {\n            continue // Retry\n        }\n        return err // Non-retryable error\n    }\n    return fmt.Errorf(\"operation failed after 3 retries\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#4-document-error-behavior","title":"4. Document Error Behavior","text":"<p>Clearly document what errors a function can return:</p> <pre><code>// ParseInt parses a string into an integer.\n// Returns strconv.ErrSyntax if the string is not a valid integer,\n// or strconv.ErrRange if the integer is out of range.\nfunc ParseInt(s string) (int, error) {\n    // Implementation\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#common-error-handling-pitfalls","title":"Common Error Handling Pitfalls","text":""},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#1-ignoring-errors","title":"1. Ignoring Errors","text":"<p>Never ignore errors without a good reason:</p> <pre><code>// Bad\n_, _ = os.Open(\"file.txt\") // Error ignored\n\n// Good - at least log it\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n    log.Printf(\"Failed to open file: %v\", err)\n    return\n}\ndefer file.Close()\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#2-over-wrapping-errors","title":"2. Over-Wrapping Errors","text":"<p>Don't wrap errors unnecessarily:</p> <pre><code>// Bad - redundant wrapping\nfunc process() error {\n    err := doStep1()\n    if err != nil {\n        return fmt.Errorf(\"process: step1 failed: %w\", err)\n    }\n    err = doStep2()\n    if err != nil {\n        return fmt.Errorf(\"process: step2 failed: %w\", err)\n    }\n    return nil\n}\n\n// Good - wrap only at the top level\nfunc process() error {\n    if err := doStep1(); err != nil {\n        return err\n    }\n    if err := doStep2(); err != nil {\n        return err\n    }\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#3-using-errors-for-control-flow","title":"3. Using Errors for Control Flow","text":"<p>Don't use errors for normal control flow:</p> <pre><code>// Bad - using error for EOF\nfunc readItems(r io.Reader) ([]Item, error) {\n    var items []Item\n    for {\n        var item Item\n        err := binary.Read(r, binary.BigEndian, &amp;item)\n        if err != nil {\n            if err == io.EOF {\n                return items, nil // Normal end\n            }\n            return nil, err\n        }\n        items = append(items, item)\n    }\n}\n\n// Good - handle EOF separately\nfunc readItems(r io.Reader) ([]Item, error) {\n    var items []Item\n    for {\n        var item Item\n        err := binary.Read(r, binary.BigEndian, &amp;item)\n        if err != nil {\n            if err == io.EOF {\n                break // Normal end\n            }\n            return nil, err\n        }\n        items = append(items, item)\n    }\n    return items, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#real-world-example-robust-http-service-error-handling","title":"Real-World Example: Robust HTTP Service Error Handling","text":"<p>Let's build a complete HTTP service with comprehensive error handling:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n)\n\n// Custom error types\ntype ValidationError struct {\n    Field   string `json:\"field\"`\n    Message string `json:\"message\"`\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error: %s - %s\", e.Field, e.Message)\n}\n\ntype NotFoundError struct {\n    Resource string `json:\"resource\"`\n    ID       string `json:\"id\"`\n}\n\nfunc (e *NotFoundError) Error() string {\n    return fmt.Sprintf(\"%s not found: %s\", e.Resource, e.ID)\n}\n\ntype DatabaseError struct {\n    Operation string\n    Err       error\n}\n\nfunc (e *DatabaseError) Error() string {\n    return fmt.Sprintf(\"database error during %s: %v\", e.Operation, e.Err)\n}\n\nfunc (e *DatabaseError) Unwrap() error {\n    return e.Err\n}\n\n// API response structure\ntype APIResponse struct {\n    Success bool        `json:\"success\"`\n    Data    interface{} `json:\"data,omitempty\"`\n    Error   *APIError   `json:\"error,omitempty\"`\n}\n\ntype APIError struct {\n    Code    string      `json:\"code\"`\n    Message string      `json:\"message\"`\n    Details interface{} `json:\"details,omitempty\"`\n}\n\n// User model\ntype User struct {\n    ID    string `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\n// Database simulation\ntype Database struct {\n    users map[string]*User\n}\n\nfunc NewDatabase() *Database {\n    return &amp;Database{\n        users: map[string]*User{\n            \"1\": {ID: \"1\", Name: \"Alice\", Email: \"alice@example.com\"},\n            \"2\": {ID: \"2\", Name: \"Bob\", Email: \"bob@example.com\"},\n        },\n    }\n}\n\nfunc (db *Database) GetUser(id string) (*User, error) {\n    user, exists := db.users[id]\n    if !exists {\n        return nil, &amp;NotFoundError{Resource: \"user\", ID: id}\n    }\n    return user, nil\n}\n\nfunc (db *Database) CreateUser(user *User) error {\n    if user.ID == \"\" {\n        return &amp;ValidationError{Field: \"id\", Message: \"required\"}\n    }\n    if user.Name == \"\" {\n        return &amp;ValidationError{Field: \"name\", Message: \"required\"}\n    }\n    if user.Email == \"\" {\n        return &amp;ValidationError{Field: \"email\", Message: \"required\"}\n    }\n\n    if _, exists := db.users[user.ID]; exists {\n        return &amp;DatabaseError{\n            Operation: \"create user\",\n            Err:       fmt.Errorf(\"user already exists\"),\n        }\n    }\n\n    db.users[user.ID] = user\n    return nil\n}\n\n// Service layer\ntype UserService struct {\n    db *Database\n}\n\nfunc NewUserService(db *Database) *UserService {\n    return &amp;UserService{db: db}\n}\n\nfunc (s *UserService) GetUser(id string) (*User, error) {\n    if id == \"\" {\n        return nil, &amp;ValidationError{Field: \"id\", Message: \"required\"}\n    }\n\n    user, err := s.db.GetUser(id)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to get user: %w\", err)\n    }\n\n    return user, nil\n}\n\nfunc (s *UserService) CreateUser(user *User) error {\n    if err := validateUser(user); err != nil {\n        return fmt.Errorf(\"validation failed: %w\", err)\n    }\n\n    if err := s.db.CreateUser(user); err != nil {\n        return fmt.Errorf(\"failed to create user: %w\", err)\n    }\n\n    return nil\n}\n\nfunc validateUser(user *User) error {\n    if user.ID == \"\" {\n        return &amp;ValidationError{Field: \"id\", Message: \"required\"}\n    }\n    if user.Name == \"\" {\n        return &amp;ValidationError{Field: \"name\", Message: \"required\"}\n    }\n    if user.Email == \"\" {\n        return &amp;ValidationError{Field: \"email\", Message: \"required\"}\n    }\n    if !strings.Contains(user.Email, \"@\") {\n        return &amp;ValidationError{Field: \"email\", Message: \"invalid format\"}\n    }\n    return nil\n}\n\n// HTTP handlers\ntype UserHandler struct {\n    service *UserService\n}\n\nfunc NewUserHandler(service *UserService) *UserHandler {\n    return &amp;UserHandler{service: service}\n}\n\nfunc (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {\n    id := r.URL.Query().Get(\"id\")\n    if id == \"\" {\n        respondWithError(w, http.StatusBadRequest, \"missing id parameter\")\n        return\n    }\n\n    user, err := h.service.GetUser(id)\n    if err != nil {\n        var apiErr APIError\n\n        switch {\n        case errors.As(err, &amp;ValidationError{}):\n            apiErr = APIError{\n                Code:    \"VALIDATION_ERROR\",\n                Message: err.Error(),\n            }\n            respondWithError(w, http.StatusBadRequest, apiErr)\n        case errors.As(err, &amp;NotFoundError{}):\n            apiErr = APIError{\n                Code:    \"NOT_FOUND\",\n                Message: err.Error(),\n            }\n            respondWithError(w, http.StatusNotFound, apiErr)\n        default:\n            apiErr = APIError{\n                Code:    \"INTERNAL_ERROR\",\n                Message: \"failed to get user\",\n            }\n            respondWithError(w, http.StatusInternalServerError, apiErr)\n        }\n        return\n    }\n\n    respondWithJSON(w, http.StatusOK, APIResponse{\n        Success: true,\n        Data:    user,\n    })\n}\n\nfunc (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {\n    var user User\n    if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil {\n        respondWithError(w, http.StatusBadRequest, \"invalid request body\")\n        return\n    }\n\n    if err := h.service.CreateUser(&amp;user); err != nil {\n        var apiErr APIError\n\n        switch {\n        case errors.As(err, &amp;ValidationError{}):\n            var ve *ValidationError\n            if errors.As(err, &amp;ve) {\n                apiErr = APIError{\n                    Code:    \"VALIDATION_ERROR\",\n                    Message: \"validation failed\",\n                    Details: ve,\n                }\n            }\n            respondWithError(w, http.StatusBadRequest, apiErr)\n        case errors.As(err, &amp;DatabaseError{}):\n            apiErr = APIError{\n                Code:    \"DATABASE_ERROR\",\n                Message: \"failed to create user\",\n            }\n            respondWithError(w, http.StatusInternalServerError, apiErr)\n        default:\n            apiErr = APIError{\n                Code:    \"INTERNAL_ERROR\",\n                Message: \"failed to create user\",\n            }\n            respondWithError(w, http.StatusInternalServerError, apiErr)\n        }\n        return\n    }\n\n    respondWithJSON(w, http.StatusCreated, APIResponse{\n        Success: true,\n        Data:    user,\n    })\n}\n\n// Helper functions\nfunc respondWithError(w http.ResponseWriter, code int, err interface{}) {\n    var apiErr APIError\n\n    switch e := err.(type) {\n    case string:\n        apiErr = APIError{\n            Code:    \"UNKNOWN_ERROR\",\n            Message: e,\n        }\n    case APIError:\n        apiErr = e\n    default:\n        apiErr = APIError{\n            Code:    \"UNKNOWN_ERROR\",\n            Message: fmt.Sprintf(\"%v\", err),\n        }\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(code)\n    json.NewEncoder(w).Encode(APIResponse{\n        Success: false,\n        Error:   &amp;apiErr,\n    })\n}\n\nfunc respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(code)\n    json.NewEncoder(w).Encode(payload)\n}\n\n// Logging middleware\nfunc loggingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n\n        // Wrap the response writer to capture status code\n        lrw := &amp;loggingResponseWriter{w, http.StatusOK}\n\n        next.ServeHTTP(lrw, r)\n\n        log.Printf(\n            \"%s %s %d %v\",\n            r.Method,\n            r.URL.Path,\n            lrw.statusCode,\n            time.Since(start),\n        )\n    })\n}\n\ntype loggingResponseWriter struct {\n    http.ResponseWriter\n    statusCode int\n}\n\nfunc (lrw *loggingResponseWriter) WriteHeader(code int) {\n    lrw.statusCode = code\n    lrw.ResponseWriter.WriteHeader(code)\n}\n\nfunc main() {\n    // Setup dependencies\n    db := NewDatabase()\n    userService := NewUserService(db)\n    userHandler := NewUserHandler(userService)\n\n    // Setup routes\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/users\", userHandler.GetUser)\n    mux.HandleFunc(\"/users/create\", userHandler.CreateUser)\n\n    // Wrap with logging middleware\n    handler := loggingMiddleware(mux)\n\n    // Start server\n    port := os.Getenv(\"PORT\")\n    if port == \"\" {\n        port = \"8080\"\n    }\n\n    log.Printf(\"Server starting on port %s...\", port)\n    if err := http.ListenAndServe(\":\"+port, handler); err != nil {\n        log.Fatalf(\"Failed to start server: %v\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#how-this-example-demonstrates-error-handling","title":"How This Example Demonstrates Error Handling:","text":"<ol> <li>Layered Error Handling:</li> <li>Database layer returns specific error types</li> <li>Service layer adds context and wraps errors</li> <li> <p>Handler layer translates errors to HTTP responses</p> </li> <li> <p>Custom Error Types:</p> </li> <li><code>ValidationError</code> for input validation</li> <li><code>NotFoundError</code> for missing resources</li> <li> <p><code>DatabaseError</code> for database operations</p> </li> <li> <p>Error Wrapping:</p> </li> <li>Each layer adds context with <code>fmt.Errorf</code> and <code>%w</code></li> <li> <p>Original errors are preserved for inspection</p> </li> <li> <p>Error Translation:</p> </li> <li>Internal errors are translated to user-friendly API errors</li> <li> <p>HTTP status codes match error types</p> </li> <li> <p>Logging and Monitoring:</p> </li> <li>Middleware logs all requests with status codes</li> <li>Errors are logged with context</li> </ol>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>API Development:</li> <li>Consistent error responses across endpoints</li> <li>Proper HTTP status codes</li> <li> <p>Detailed error information for debugging</p> </li> <li> <p>Microservices:</p> </li> <li>Error propagation between services</li> <li>Structured error logging</li> <li> <p>Circuit breaker patterns</p> </li> <li> <p>Database Operations:</p> </li> <li>Handling connection errors</li> <li>Constraint violations</li> <li> <p>Transaction rollbacks</p> </li> <li> <p>User Input Validation:</p> </li> <li>Clear validation error messages</li> <li>Field-specific error details</li> <li>Internationalization support</li> </ol>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#conclusion","title":"Conclusion","text":"<p>Error handling is a critical aspect of Go programming that requires careful attention. By following Go's explicit error handling model, you can create more robust and maintainable applications. Key takeaways:</p> <ol> <li>Embrace Explicit Error Handling:</li> <li>Check errors immediately</li> <li>Don't ignore errors without reason</li> <li> <p>Make error paths visible in your code</p> </li> <li> <p>Use Custom Error Types:</p> </li> <li>Create specific error types for different failure modes</li> <li>Include relevant context in error types</li> <li> <p>Implement additional methods for programmatic checks</p> </li> <li> <p>Wrap Errors Thoughtfully:</p> </li> <li>Add context without losing the original error</li> <li>Use <code>fmt.Errorf</code> with <code>%w</code> for error wrapping</li> <li> <p>Avoid over-wrapping errors</p> </li> <li> <p>Handle Errors Appropriately:</p> </li> <li>Translate errors for different contexts (e.g., API responses)</li> <li>Log errors with sufficient context</li> <li> <p>Provide meaningful error messages to users</p> </li> <li> <p>Design Error-Resilient Systems:</p> </li> <li>Consider retry mechanisms for transient errors</li> <li>Implement graceful degradation</li> <li>Monitor error rates and patterns</li> </ol> <p>The HTTP service example demonstrates how to build a comprehensive error handling system that provides clear feedback to both developers and users while maintaining the integrity of the application. By following these patterns, you can create Go applications that handle failures gracefully and provide excellent debugging information when things go wrong.</p>"},{"location":"2.%20Intermediate/13.%20String-Functions/","title":"String Functions in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#introduction-to-string-functions-in-go","title":"Introduction to String Functions in Go","text":"<p>Go's <code>strings</code> package provides a rich set of functions for string manipulation. These functions are essential for text processing, input validation, data transformation, and many other common programming tasks. Understanding these functions is crucial for effective Go development.</p>"},{"location":"2.%20Intermediate/13.%20String-Functions/#basic-string-manipulation","title":"Basic String Manipulation","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#1-searching-within-strings","title":"1. Searching Within Strings","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    s := \"Hello, World! Welcome to Go programming.\"\n\n    // Contains - checks if substring exists\n    fmt.Println(strings.Contains(s, \"World\"))    // true\n    fmt.Println(strings.Contains(s, \"Python\"))  // false\n\n    // ContainsAny - checks if any character in the set exists\n    fmt.Println(strings.ContainsAny(s, \"abc\"))   // true (because of 'a' in \"Welcome\")\n    fmt.Println(strings.ContainsAny(s, \"xyz\"))   // false\n\n    // HasPrefix - checks if string starts with prefix\n    fmt.Println(strings.HasPrefix(s, \"Hello\"))   // true\n    fmt.Println(strings.HasPrefix(s, \"World\"))   // false\n\n    // HasSuffix - checks if string ends with suffix\n    fmt.Println(strings.HasSuffix(s, \"programming.\")) // true\n    fmt.Println(strings.HasSuffix(s, \"Go\"))       // false\n\n    // Index - returns first index of substring\n    fmt.Println(strings.Index(s, \"World\"))       // 7\n    fmt.Println(strings.Index(s, \"Python\"))      // -1 (not found)\n\n    // LastIndex - returns last index of substring\n    fmt.Println(strings.LastIndex(s, \"o\"))      // 29 (in \"programming\")\n\n    // IndexAny - returns index of any character in the set\n    fmt.Println(strings.IndexAny(s, \"aeiou\"))   // 1 (first 'e')\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#2-replacing-content","title":"2. Replacing Content","text":"<pre><code>func main() {\n    s := \"I like apples, apples are tasty.\"\n\n    // Replace - replaces n occurrences\n    fmt.Println(strings.Replace(s, \"apples\", \"oranges\", 1)) // \"I like oranges, apples are tasty.\"\n    fmt.Println(strings.Replace(s, \"apples\", \"oranges\", 2)) // \"I like oranges, oranges are tasty.\"\n    fmt.Println(strings.Replace(s, \"apples\", \"oranges\", -1)) // Replace all\n\n    // ReplaceAll - replaces all occurrences (Go 1.12+)\n    fmt.Println(strings.ReplaceAll(s, \"apples\", \"oranges\")) // \"I like oranges, oranges are tasty.\"\n\n    // Map - applies a function to each character\n    rot13 := func(r rune) rune {\n        switch {\n        case r &gt;= 'A' &amp;&amp; r &lt;= 'Z':\n            return 'A' + (r-'A'+13)%26\n        case r &gt;= 'a' &amp;&amp; r &lt;= 'z':\n            return 'a' + (r-'a'+13)%26\n        default:\n            return r\n        }\n    }\n    fmt.Println(strings.Map(rot13, \"Hello, World!\")) // \"Uryyb, Jbeyq!\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#3-splitting-and-joining","title":"3. Splitting and Joining","text":"<pre><code>func main() {\n    // Split - splits string by separator\n    s := \"a,b,c,d\"\n    parts := strings.Split(s, \",\")\n    fmt.Println(parts) // [a b c d]\n\n    // SplitN - splits into at most n parts\n    parts = strings.SplitN(s, \",\", 3)\n    fmt.Println(parts) // [a b c,d]\n\n    // SplitAfter - includes separator in parts\n    parts = strings.SplitAfter(s, \",\")\n    fmt.Println(parts) // [a, b, c, d]\n\n    // Fields - splits by whitespace\n    s2 := \"  Go   is  awesome  \"\n    fields := strings.Fields(s2)\n    fmt.Println(fields) // [Go is awesome]\n\n    // FieldsFunc - splits using custom function\n    // Split on any non-alphanumeric character\n    fieldsFunc := strings.FieldsFunc(s2, func(r rune) bool {\n        return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r)\n    })\n    fmt.Println(fieldsFunc) // [Go is awesome]\n\n    // Join - concatenates slice with separator\n    joined := strings.Join([]string{\"Go\", \"is\", \"awesome\"}, \" \")\n    fmt.Println(joined) // \"Go is awesome\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#case-conversion","title":"Case Conversion","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#1-changing-case","title":"1. Changing Case","text":"<pre><code>func main() {\n    s := \"Hello, World! 123\"\n\n    // ToLower - converts to lowercase\n    fmt.Println(strings.ToLower(s)) // \"hello, world! 123\"\n\n    // ToUpper - converts to uppercase\n    fmt.Println(strings.ToUpper(s)) // \"HELLO, WORLD! 123\"\n\n    // ToTitle - converts to title case (each word starts with uppercase)\n    fmt.Println(strings.ToTitle(\"hello world\")) // \"HELLO WORLD\"\n\n    // Title - converts to title case (first letter of each word uppercase)\n    fmt.Println(strings.Title(\"hello world\")) // \"Hello World\"\n\n    // ToLowerSpecial - handles special cases (e.g., Turkish)\n    fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, \"\u0130\")) // \"i\"\n\n    // ToUpperSpecial - handles special cases\n    fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, \"i\")) // \"\u0130\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#trimming-strings","title":"Trimming Strings","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#1-removing-characters-from-edges","title":"1. Removing Characters from Edges","text":"<pre><code>func main() {\n    s := \"!!!Hello, World!!!\"\n\n    // Trim - removes characters from both ends\n    fmt.Println(strings.Trim(s, \"!\")) // \"Hello, World\"\n\n    // TrimLeft - removes characters from left\n    fmt.Println(strings.TrimLeft(s, \"!\")) // \"Hello, World!!!\"\n\n    // TrimRight - removes characters from right\n    fmt.Println(strings.TrimRight(s, \"!\")) // \"!!!Hello, World\"\n\n    // TrimSpace - removes whitespace from both ends\n    s2 := \"  Hello, World  \"\n    fmt.Println(strings.TrimSpace(s2)) // \"Hello, World\"\n\n    // TrimPrefix - removes specific prefix\n    fmt.Println(strings.TrimPrefix(\"Hello, World\", \"Hello\")) // \", World\"\n\n    // TrimSuffix - removes specific suffix\n    fmt.Println(strings.TrimSuffix(\"Hello, World\", \"World\")) // \"Hello, \"\n\n    // TrimFunc - removes characters that satisfy a function\n    // Remove all non-alphanumeric characters from edges\n    trimmed := strings.TrimFunc(\"!!Hello, World!!\", func(r rune) bool {\n        return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r)\n    })\n    fmt.Println(trimmed) // \"Hello, World\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#comparison-functions","title":"Comparison Functions","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#1-comparing-strings","title":"1. Comparing Strings","text":"<pre><code>func main() {\n    // Compare - compares two strings lexicographically\n    fmt.Println(strings.Compare(\"a\", \"b\"))  // -1 (a &lt; b)\n    fmt.Println(strings.Compare(\"b\", \"a\"))  // 1 (b &gt; a)\n    fmt.Println(strings.Compare(\"a\", \"a\"))  // 0 (equal)\n\n    // EqualFold - case-insensitive comparison\n    fmt.Println(strings.EqualFold(\"Go\", \"go\")) // true\n    fmt.Println(strings.EqualFold(\"Go\", \"Java\")) // false\n\n    // Basic comparison operators (more idiomatic in Go)\n    fmt.Println(\"Go\" == \"go\")   // false (case-sensitive)\n    fmt.Println(\"Go\" == \"Go\")   // true\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#substring-functions","title":"Substring Functions","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#1-extracting-substrings","title":"1. Extracting Substrings","text":"<pre><code>func main() {\n    s := \"Hello, World!\"\n\n    // Slice - extracts substring (using byte indices)\n    // Note: Be careful with multi-byte characters!\n    sub := s[0:5]\n    fmt.Println(sub) // \"Hello\"\n\n    // For safe substring extraction with runes, convert to []rune first\n    runes := []rune(s)\n    subRunes := string(runes[7:12])\n    fmt.Println(subRunes) // \"World\"\n\n    // Clone - creates a copy of the string (Go 1.18+)\n    clone := strings.Clone(s)\n    fmt.Println(clone == s) // true (but different underlying memory)\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#counting-and-repeating","title":"Counting and Repeating","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#1-counting-occurrences","title":"1. Counting Occurrences","text":"<pre><code>func main() {\n    s := \"banana\"\n\n    // Count - counts non-overlapping occurrences\n    fmt.Println(strings.Count(s, \"a\"))  // 3\n    fmt.Println(strings.Count(s, \"na\")) // 2\n    fmt.Println(strings.Count(s, \"x\"))  // 0\n\n    // Repeat - repeats string n times\n    fmt.Println(strings.Repeat(\"Go\", 3)) // \"GoGoGo\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#efficient-string-building","title":"Efficient String Building","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#1-using-stringsbuilder","title":"1. Using strings.Builder","text":"<pre><code>func main() {\n    // Inefficient concatenation with +\n    s1 := \"Hello\"\n    s2 := \"World\"\n    result := s1 + \", \" + s2 + \"!\"\n    fmt.Println(result) // \"Hello, World!\"\n\n    // Efficient concatenation with strings.Builder\n    var builder strings.Builder\n\n    // WriteString - appends string\n    builder.WriteString(\"Hello\")\n    builder.WriteString(\", \")\n    builder.WriteString(\"World\")\n    builder.WriteString(\"!\")\n\n    fmt.Println(builder.String()) // \"Hello, World!\"\n\n    // Write - appends byte slice\n    builder.Reset() // Clear the builder\n    builder.Write([]byte{72, 101, 108, 108, 111}) // \"Hello\"\n    fmt.Println(builder.String())\n\n    // WriteByte - appends single byte\n    builder.WriteByte(32) // space\n    builder.WriteByte(87)  // 'W'\n    fmt.Println(builder.String()) // \"Hello W\"\n\n    // Grow - pre-allocates space\n    builder.Grow(100) // Ensure capacity for 100 more bytes\n    fmt.Printf(\"Builder length: %d, capacity: %d\\n\", builder.Len(), builder.Cap())\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#real-world-example-text-processing-utility","title":"Real-World Example: Text Processing Utility","text":"<p>Let's build a comprehensive text processing utility that demonstrates various string functions:</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"regexp\"\n    \"sort\"\n    \"strings\"\n    \"unicode\"\n)\n\n// TextProcessor provides various text processing functions\ntype TextProcessor struct {\n    input string\n}\n\nfunc NewTextProcessor(input string) *TextProcessor {\n    return &amp;TextProcessor{input: input}\n}\n\n// WordCount returns the number of words in the text\nfunc (tp *TextProcessor) WordCount() int {\n    return len(strings.Fields(tp.input))\n}\n\n// CharacterCount returns the number of characters (runes)\nfunc (tp *TextProcessor) CharacterCount() int {\n    return len([]rune(tp.input))\n}\n\n// LineCount returns the number of lines\nfunc (tp *TextProcessor) LineCount() int {\n    return len(strings.Split(tp.input, \"\\n\"))\n}\n\n// UniqueWords returns a sorted slice of unique words\nfunc (tp *TextProcessor) UniqueWords() []string {\n    words := strings.Fields(tp.input)\n    wordMap := make(map[string]bool)\n\n    for _, word := range words {\n        // Normalize word (lowercase, remove punctuation)\n        normalized := strings.ToLower(word)\n        normalized = strings.TrimFunc(normalized, func(r rune) bool {\n            return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r)\n        })\n        if normalized != \"\" {\n            wordMap[normalized] = true\n        }\n    }\n\n    unique := make([]string, 0, len(wordMap))\n    for word := range wordMap {\n        unique = append(unique, word)\n    }\n\n    sort.Strings(unique)\n    return unique\n}\n\n// FindSentences splits text into sentences\nfunc (tp *TextProcessor) FindSentences() []string {\n    // Simple sentence splitting on .!?\n    re := regexp.MustCompile(`[.!?]+[\\s]*`)\n    sentences := re.Split(tp.input, -1)\n\n    var result []string\n    for _, sentence := range sentences {\n        sentence = strings.TrimSpace(sentence)\n        if sentence != \"\" {\n            result = append(result, sentence)\n        }\n    }\n\n    return result\n}\n\n// ReplaceWords replaces all occurrences of oldWord with newWord\nfunc (tp *TextProcessor) ReplaceWords(oldWord, newWord string) string {\n    return strings.ReplaceAll(tp.input, oldWord, newWord)\n}\n\n// ToTitleCase converts text to title case\nfunc (tp *TextProcessor) ToTitleCase() string {\n    words := strings.Fields(tp.input)\n    for i, word := range words {\n        if len(word) &gt; 0 {\n            words[i] = strings.ToUpper(string(word[0])) + strings.ToLower(word[1:])\n        }\n    }\n    return strings.Join(words, \" \")\n}\n\n// RemoveExtraWhitespace normalizes whitespace\nfunc (tp *TextProcessor) RemoveExtraWhitespace() string {\n    // Replace multiple spaces with single space\n    re := regexp.MustCompile(`\\s+`)\n    result := re.ReplaceAllString(tp.input, \" \")\n\n    // Trim leading/trailing whitespace\n    return strings.TrimSpace(result)\n}\n\n// FindEmailAddresses extracts all email addresses\nfunc (tp *TextProcessor) FindEmailAddresses() []string {\n    // Simple email regex (not production-quality)\n    re := regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}`)\n    return re.FindAllString(tp.input, -1)\n}\n\n// GenerateSummary creates a summary of the first n words\nfunc (tp *TextProcessor) GenerateSummary(wordCount int) string {\n    words := strings.Fields(tp.input)\n    if len(words) &lt;= wordCount {\n        return tp.input\n    }\n\n    summary := strings.Join(words[:wordCount], \" \")\n    return summary + \"...\"\n}\n\n// AnalyzeSentiment simple sentiment analysis based on positive/negative words\nfunc (tp *TextProcessor) AnalyzeSentiment() string {\n    positiveWords := []string{\"good\", \"great\", \"excellent\", \"awesome\", \"happy\", \"love\"}\n    negativeWords := []string{\"bad\", \"terrible\", \"awful\", \"hate\", \"sad\", \"angry\"}\n\n    text := strings.ToLower(tp.input)\n\n    positiveCount := 0\n    negativeCount := 0\n\n    for _, word := range positiveWords {\n        positiveCount += strings.Count(text, word)\n    }\n\n    for _, word := range negativeWords {\n        negativeCount += strings.Count(text, word)\n    }\n\n    if positiveCount &gt; negativeCount {\n        return \"Positive\"\n    } else if negativeCount &gt; positiveCount {\n        return \"Negative\"\n    }\n    return \"Neutral\"\n}\n\nfunc main() {\n    // Sample text\n    sampleText := `Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.\nGo is amazing! I love working with Go. It's fast and efficient.\nThe Go community is great. For more information, visit golang.org or contact us at info@golang.org.\nThis is a test. This is only a test. Testing, testing, 1, 2, 3...`\n\n    processor := NewTextProcessor(sampleText)\n\n    // Basic statistics\n    fmt.Println(\"=== Text Analysis ===\")\n    fmt.Printf(\"Word count: %d\\n\", processor.WordCount())\n    fmt.Printf(\"Character count: %d\\n\", processor.CharacterCount())\n    fmt.Printf(\"Line count: %d\\n\", processor.LineCount())\n\n    // Unique words\n    fmt.Println(\"\\n=== Unique Words ===\")\n    uniqueWords := processor.UniqueWords()\n    fmt.Printf(\"Found %d unique words:\\n\", len(uniqueWords))\n    for i, word := range uniqueWords {\n        if i &gt;= 10 { // Show first 10\n            fmt.Println(\"...\")\n            break\n        }\n        fmt.Printf(\"- %s\\n\", word)\n    }\n\n    // Sentences\n    fmt.Println(\"\\n=== Sentences ===\")\n    sentences := processor.FindSentences()\n    for i, sentence := range sentences {\n        fmt.Printf(\"%d. %s\\n\", i+1, sentence)\n    }\n\n    // Email addresses\n    fmt.Println(\"\\n=== Email Addresses ===\")\n    emails := processor.FindEmailAddresses()\n    for _, email := range emails {\n        fmt.Printf(\"- %s\\n\", email)\n    }\n\n    // Text transformations\n    fmt.Println(\"\\n=== Text Transformations ===\")\n    fmt.Println(\"Original:\", sampleText[:50]+\"...\")\n    fmt.Println(\"Title Case:\", processor.ToTitleCase()[:50]+\"...\")\n    fmt.Println(\"Normalized Whitespace:\", processor.RemoveExtraWhitespace()[:50]+\"...\")\n\n    // Word replacement\n    fmt.Println(\"\\n=== Word Replacement ===\")\n    replaced := processor.ReplaceWords(\"Go\", \"Golang\")\n    fmt.Println(\"Replaced 'Go' with 'Golang':\", replaced[:50]+\"...\")\n\n    // Summary\n    fmt.Println(\"\\n=== Summary ===\")\n    summary := processor.GenerateSummary(10)\n    fmt.Println(\"First 10 words summary:\", summary)\n\n    // Sentiment analysis\n    fmt.Println(\"\\n=== Sentiment Analysis ===\")\n    sentiment := processor.AnalyzeSentiment()\n    fmt.Printf(\"Overall sentiment: %s\\n\", sentiment)\n\n    // Interactive mode\n    fmt.Println(\"\\n=== Interactive Mode ===\")\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for {\n        fmt.Print(\"\\nEnter text to analyze (or 'quit' to exit): \")\n        if !scanner.Scan() {\n            break\n        }\n\n        input := scanner.Text()\n        if input == \"quit\" {\n            break\n        }\n\n        if input == \"\" {\n            continue\n        }\n\n        processor = NewTextProcessor(input)\n        fmt.Printf(\"Words: %d, Characters: %d, Sentiment: %s\\n\",\n            processor.WordCount(),\n            processor.CharacterCount(),\n            processor.AnalyzeSentiment())\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#how-this-example-demonstrates-string-functions","title":"How This Example Demonstrates String Functions:","text":"<ol> <li>Basic String Operations:</li> <li><code>strings.Fields()</code> for word splitting</li> <li><code>strings.ToLower()</code> for case normalization</li> <li><code>strings.TrimFunc()</code> for punctuation removal</li> <li> <p><code>strings.ReplaceAll()</code> for word replacement</p> </li> <li> <p>Advanced Processing:</p> </li> <li>Regular expressions for pattern matching</li> <li><code>strings.TrimSpace()</code> for whitespace normalization</li> <li><code>strings.Join()</code> for string concatenation</li> <li> <p><code>strings.Count()</code> for word frequency analysis</p> </li> <li> <p>Text Analysis:</p> </li> <li>Sentence splitting with custom logic</li> <li>Email extraction with regex</li> <li>Sentiment analysis using word counting</li> <li> <p>Summary generation</p> </li> <li> <p>Efficient Processing:</p> </li> <li>Using maps for unique word tracking</li> <li>Sorting results for consistent output</li> <li>Handling Unicode characters properly</li> </ol>"},{"location":"2.%20Intermediate/13.%20String-Functions/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Content Management Systems:</li> <li>Text processing for blog posts</li> <li>Search functionality</li> <li> <p>Content summarization</p> </li> <li> <p>Data Cleaning:</p> </li> <li>Normalizing user input</li> <li>Removing unwanted characters</li> <li> <p>Standardizing text formats</p> </li> <li> <p>Natural Language Processing:</p> </li> <li>Tokenization</li> <li>Feature extraction</li> <li> <p>Text classification</p> </li> <li> <p>Log Analysis:</p> </li> <li>Parsing log files</li> <li>Extracting relevant information</li> <li>Generating reports</li> </ol>"},{"location":"2.%20Intermediate/13.%20String-Functions/#best-practices-for-string-functions","title":"Best Practices for String Functions","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#1-choose-the-right-function-for-the-job","title":"1. Choose the Right Function for the Job","text":"<pre><code>// Good - use Contains for simple checks\nif strings.Contains(email, \"@\") {\n    // Valid email format\n}\n\n// Bad - using Index for simple existence check\nif strings.Index(email, \"@\") != -1 {\n    // Less readable\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#2-be-careful-with-unicode","title":"2. Be Careful with Unicode","text":"<pre><code>// Bad - byte-based slicing can break multi-byte characters\ns := \"Hello, \u4e16\u754c\"\nsub := s[7:10] // Might break the Chinese character\n\n// Good - use rune-based slicing\nrunes := []rune(s)\nsub = string(runes[7:9]) // Safe\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#3-use-stringsbuilder-for-efficient-concatenation","title":"3. Use strings.Builder for Efficient Concatenation","text":"<pre><code>// Bad - creates many temporary strings\nvar result string\nfor i := 0; i &lt; 1000; i++ {\n    result += \"x\" // Allocates new string each time\n}\n\n// Good - efficient with Builder\nvar builder strings.Builder\nfor i := 0; i &lt; 1000; i++ {\n    builder.WriteByte('x')\n}\nresult := builder.String()\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#4-pre-compile-regular-expressions","title":"4. Pre-compile Regular Expressions","text":"<pre><code>// Bad - compiles regex on each call\nfunc extractEmails(text string) []string {\n    re := regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}`)\n    return re.FindAllString(text, -1)\n}\n\n// Good - compile once, reuse\nvar emailRegex = regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}`)\n\nfunc extractEmails(text string) []string {\n    return emailRegex.FindAllString(text, -1)\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#5-handle-edge-cases","title":"5. Handle Edge Cases","text":"<pre><code>// Good - handle empty strings and edge cases\nfunc safeSubstring(s string, start, end int) string {\n    if s == \"\" || start &lt; 0 || end &gt; len(s) || start &gt;= end {\n        return \"\"\n    }\n    return s[start:end]\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/13.%20String-Functions/#1-memory-allocation","title":"1. Memory Allocation","text":"<p>String operations in Go often create new strings. Be mindful of: - Concatenation in loops - Repeated transformations - Large string processing</p>"},{"location":"2.%20Intermediate/13.%20String-Functions/#2-unicode-awareness","title":"2. Unicode Awareness","text":"<p>Remember that Go strings are UTF-8 encoded: - Use <code>[]rune</code> for character-level operations - Be careful with byte-based indexing - Consider performance implications of Unicode processing</p>"},{"location":"2.%20Intermediate/13.%20String-Functions/#3-alternatives-for-large-data","title":"3. Alternatives for Large Data","text":"<p>For very large text processing: - Consider streaming with <code>bufio.Scanner</code> - Use <code>io.Reader</code> and <code>io.Writer</code> interfaces - Process in chunks rather than loading entire strings</p>"},{"location":"2.%20Intermediate/13.%20String-Functions/#conclusion","title":"Conclusion","text":"<p>The <code>strings</code> package in Go provides a comprehensive toolkit for text processing. Mastering these functions enables you to:</p> <ol> <li>Process Text Efficiently:</li> <li>Search, replace, and transform strings</li> <li>Handle Unicode correctly</li> <li> <p>Write performant string operations</p> </li> <li> <p>Build Robust Applications:</p> </li> <li>Validate user input</li> <li>Parse and format data</li> <li> <p>Implement text-based features</p> </li> <li> <p>Solve Real-World Problems:</p> </li> <li>Content management</li> <li>Data cleaning</li> <li>Log analysis</li> <li>Natural language processing</li> </ol> <p>Key takeaways: 1. Choose the right function for each task 2. Be Unicode-aware in all string operations 3. Use strings.Builder for efficient concatenation 4. Pre-compile regexes for repeated use 5. Handle edge cases gracefully</p> <p>The text processing utility example demonstrates how combining these functions can create powerful tools for analyzing and transforming text. By understanding and effectively using Go's string functions, you can write more efficient, readable, and maintainable code for any application that works with text data.</p>"},{"location":"2.%20Intermediate/14.%20String-Formatting/","title":"String Formatting in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/14.%20String-Formatting/#introduction-to-string-formatting","title":"Introduction to String Formatting","text":"<p>String formatting is the process of creating formatted strings by combining literal text with formatted values. In Go, the <code>fmt</code> package provides powerful formatting capabilities that allow you to control how values are represented as strings. This is essential for creating user-friendly output, logs, reports, and any application that needs to present data in a structured way.</p>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#basic-formatting-functions","title":"Basic Formatting Functions","text":""},{"location":"2.%20Intermediate/14.%20String-Formatting/#1-fmtsprintf-format-to-string","title":"1. <code>fmt.Sprintf</code> - Format to String","text":"<p>The most commonly used formatting function, which returns a formatted string:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    // Basic formatting\n    name := \"Alice\"\n    age := 30\n    formatted := fmt.Sprintf(\"Name: %s, Age: %d\", name, age)\n    fmt.Println(formatted) // \"Name: Alice, Age: 30\"\n\n    // Multiple values\n    item := \"Laptop\"\n    price := 999.99\n    inStock := true\n    formatted = fmt.Sprintf(\"Item: %s, Price: $%.2f, In Stock: %t\", item, price, inStock)\n    fmt.Println(formatted) // \"Item: Laptop, Price: $999.99, In Stock: true\"\n\n    // Date formatting\n    now := time.Now()\n    formatted = fmt.Sprintf(\"Current time: %s\", now.Format(\"2006-01-02 15:04:05\"))\n    fmt.Println(formatted) // \"Current time: 2023-11-15 14:30:45\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#2-fmtprintf-format-and-print","title":"2. <code>fmt.Printf</code> - Format and Print","text":"<p>Prints formatted text to standard output:</p> <pre><code>func main() {\n    // Direct printing\n    fmt.Printf(\"Hello, %s!\\n\", \"World\") // \"Hello, World!\"\n\n    // Multiple arguments\n    fmt.Printf(\"%s has %d apples\\n\", \"Bob\", 5) // \"Bob has 5 apples\"\n\n    // Without newline\n    fmt.Printf(\"Processing...\") // No newline\n    fmt.Printf(\"Done!\\n\")      // \"Processing...Done!\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#3-fmtfprintf-format-to-writer","title":"3. <code>fmt.Fprintf</code> - Format to Writer","text":"<p>Writes formatted text to any <code>io.Writer</code>:</p> <pre><code>import (\n    \"bytes\"\n    \"os\"\n)\n\nfunc main() {\n    // Write to buffer\n    var buf bytes.Buffer\n    fmt.Fprintf(&amp;buf, \"Error: %s occurred at %v\", \"timeout\", time.Now())\n    fmt.Println(buf.String())\n\n    // Write to file\n    file, err := os.Create(\"log.txt\")\n    if err != nil {\n        panic(err)\n    }\n    defer file.Close()\n\n    fmt.Fprintf(file, \"Log entry: %s\\n\", time.Now().Format(time.RFC3339))\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#formatting-verbs-reference","title":"Formatting Verbs Reference","text":""},{"location":"2.%20Intermediate/14.%20String-Formatting/#general-verbs","title":"General Verbs","text":"Verb Description Example <code>%v</code> Default format <code>fmt.Printf(\"%v\", 42)</code> \u2192 <code>42</code> <code>%+v</code> Adds struct field names <code>fmt.Printf(\"%+v\", p)</code> <code>%#v</code> Go syntax representation <code>fmt.Printf(\"%#v\", []int{1,2})</code> <code>%T</code> Type of value <code>fmt.Printf(\"%T\", 42)</code> \u2192 <code>int</code> <code>%%</code> Literal percent sign <code>fmt.Printf(\"%%\") \u2192</code>%`"},{"location":"2.%20Intermediate/14.%20String-Formatting/#integer-verbs","title":"Integer Verbs","text":"Verb Description Example <code>%b</code> Binary <code>fmt.Printf(\"%b\", 5)</code> \u2192 <code>101</code> <code>%c</code> Character <code>fmt.Printf(\"%c\", 65)</code> \u2192 <code>A</code> <code>%d</code> Decimal <code>fmt.Printf(\"%d\", 42)</code> \u2192 <code>42</code> <code>%o</code> Octal <code>fmt.Printf(\"%o\", 8)</code> \u2192 <code>10</code> <code>%O</code> Octal with 0o prefix <code>fmt.Printf(\"%O\", 8)</code> \u2192 <code>0o10</code> <code>%q</code> Single-quoted character <code>fmt.Printf(\"%q\", 'A')</code> \u2192 <code>'A'</code> <code>%x</code> Hexadecimal (lowercase) <code>fmt.Printf(\"%x\", 255)</code> \u2192 <code>ff</code> <code>%X</code> Hexadecimal (uppercase) <code>fmt.Printf(\"%X\", 255)</code> \u2192 <code>FF</code> <code>%U</code> Unicode format <code>fmt.Printf(\"%U\", 'A')</code> \u2192 <code>U+0041</code>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#floating-point-verbs","title":"Floating-Point Verbs","text":"Verb Description Example <code>%b</code> Scientific notation (binary exponent) <code>fmt.Printf(\"%b\", 3.14)</code> <code>%e</code> Scientific notation (lowercase e) <code>fmt.Printf(\"%e\", 3.14)</code> \u2192 <code>3.140000e+00</code> <code>%E</code> Scientific notation (uppercase E) <code>fmt.Printf(\"%E\", 3.14)</code> \u2192 <code>3.140000E+00</code> <code>%f</code> Decimal notation <code>fmt.Printf(\"%f\", 3.14)</code> \u2192 <code>3.140000</code> <code>%F</code> Same as %f <code>fmt.Printf(\"%F\", 3.14)</code> \u2192 <code>3.140000</code> <code>%g</code> %e for large exponents, %f otherwise <code>fmt.Printf(\"%g\", 3.14)</code> \u2192 <code>3.14</code> <code>%G</code> %E for large exponents, %F otherwise <code>fmt.Printf(\"%G\", 3.14)</code> \u2192 <code>3.14</code> <code>%x</code> Hexadecimal notation <code>fmt.Printf(\"%x\", 3.14)</code>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#string-and-byte-verbs","title":"String and Byte Verbs","text":"Verb Description Example <code>%s</code> String <code>fmt.Printf(\"%s\", \"hello\")</code> \u2192 <code>hello</code> <code>%q</code> Double-quoted string <code>fmt.Printf(\"%q\", \"hello\")</code> \u2192 <code>\"hello\"</code> <code>%x</code> Hexadecimal dump of bytes <code>fmt.Printf(\"%x\", \"hi\")</code> \u2192 <code>6869</code> <code>%X</code> Uppercase hexadecimal dump <code>fmt.Printf(\"%X\", \"hi\")</code> \u2192 <code>6869</code>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#boolean-and-pointer-verbs","title":"Boolean and Pointer Verbs","text":"Verb Description Example <code>%t</code> Boolean <code>fmt.Printf(\"%t\", true)</code> \u2192 <code>true</code> <code>%p</code> Pointer address <code>fmt.Printf(\"%p\", &amp;x)</code> \u2192 <code>0x1040a124</code>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#width-precision-and-flags","title":"Width, Precision, and Flags","text":""},{"location":"2.%20Intermediate/14.%20String-Formatting/#1-width-specification","title":"1. Width Specification","text":"<p>Controls the minimum width of the formatted value:</p> <pre><code>func main() {\n    // Integer width\n    fmt.Printf(\"|%5d|\\n\", 42)      // \"|   42|\"\n    fmt.Printf(\"|%-5d|\\n\", 42)     // \"|42   |\"\n\n    // String width\n    fmt.Printf(\"|%10s|\\n\", \"hi\")   // \"|        hi|\"\n    fmt.Printf(\"|%-10s|\\n\", \"hi\")  // \"|hi        |\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#2-precision-specification","title":"2. Precision Specification","text":"<p>Controls the number of decimal places for floats or maximum characters for strings:</p> <pre><code>func main() {\n    // Float precision\n    fmt.Printf(\"|%.2f|\\n\", 3.14159) // \"|3.14|\"\n    fmt.Printf(\"|%.4f|\\n\", 3.14159) // \"|3.1416|\"\n\n    // String precision\n    fmt.Printf(\"|%.3s|\\n\", \"hello\") // \"|hel|\"\n    fmt.Printf(\"|%.10s|\\n\", \"hi\")  // \"|hi        |\" (padded to width 10)\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#3-combined-width-and-precision","title":"3. Combined Width and Precision","text":"<pre><code>func main() {\n    // Float with width and precision\n    fmt.Printf(\"|%10.2f|\\n\", 3.14159) // \"|      3.14|\"\n    fmt.Printf(\"|%-10.2f|\\n\", 3.14159) // \"|3.14      |\"\n\n    // String with width and precision\n    fmt.Printf(\"|%10.3s|\\n\", \"hello\") // \"|       hel|\"\n    fmt.Printf(\"|%-10.3s|\\n\", \"hello\") // \"|hel       |\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#4-formatting-flags","title":"4. Formatting Flags","text":"Flag Description Example <code>+</code> Always show sign for numbers <code>fmt.Printf(\"%+d\", 42)</code> \u2192 <code>+42</code> <code>-</code> Left-justify within width <code>fmt.Printf(\"%-5d\", 42)</code> \u2192 <code>42</code> <code></code> Leave space for positive numbers <code>fmt.Printf(\"% d\", 42)</code> \u2192 <code>42</code> <code>0</code> Pad with zeros instead of spaces <code>fmt.Printf(\"%05d\", 42)</code> \u2192 <code>00042</code> <code>#</code> Alternate format <code>fmt.Printf(\"%#o\", 8)</code> \u2192 <code>010</code> <pre><code>func main() {\n    // Sign flag\n    fmt.Printf(\"With sign: %+d\\n\", 42)     // \"+42\"\n    fmt.Printf(\"With sign: %+d\\n\", -42)    // \"-42\"\n\n    // Space flag\n    fmt.Printf(\"Space: % d\\n\", 42)         // \" 42\"\n    fmt.Printf(\"Space: % d\\n\", -42)        // \"-42\"\n\n    // Zero padding\n    fmt.Printf(\"Zero pad: %05d\\n\", 42)     // \"00042\"\n\n    // Alternate format\n    fmt.Printf(\"Alternate: %#o\\n\", 8)      // \"010\"\n    fmt.Printf(\"Alternate: %#x\\n\", 255)    // \"0xff\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#custom-formatting","title":"Custom Formatting","text":""},{"location":"2.%20Intermediate/14.%20String-Formatting/#1-implementing-stringer-interface","title":"1. Implementing <code>Stringer</code> Interface","text":"<p>For custom string representation:</p> <pre><code>type Person struct {\n    Name string\n    Age  int\n}\n\nfunc (p Person) String() string {\n    return fmt.Sprintf(\"%s (%d years)\", p.Name, p.Age)\n}\n\nfunc main() {\n    p := Person{\"Alice\", 30}\n    fmt.Println(p) // Automatically calls String() method\n    fmt.Printf(\"%v\\n\", p) // Also uses String()\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#2-implementing-formatter-interface","title":"2. Implementing <code>Formatter</code> Interface","text":"<p>For more complex formatting control:</p> <pre><code>type Money float64\n\nfunc (m Money) Format(f fmt.State, verb rune) {\n    switch verb {\n    case 'f':\n        fmt.Fprintf(f, \"$%.2f\", float64(m))\n    case 'F':\n        fmt.Fprintf(f, \"$%.2f\", float64(m))\n    case 'v':\n        if f.Flag('+') {\n            fmt.Fprintf(f, \"Money(%v)\", float64(m))\n        } else {\n            fmt.Fprintf(f, \"$%.2f\", float64(m))\n        }\n    default:\n        fmt.Fprintf(f, \"%v\", float64(m))\n    }\n}\n\nfunc main() {\n    price := Money(19.99)\n    fmt.Printf(\"Price: %f\\n\", price)  // \"$19.99\"\n    fmt.Printf(\"Price: %+v\\n\", price) // \"Money(19.99)\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#common-formatting-patterns","title":"Common Formatting Patterns","text":""},{"location":"2.%20Intermediate/14.%20String-Formatting/#1-table-formatting","title":"1. Table Formatting","text":"<p>Creating aligned columns:</p> <pre><code>func main() {\n    // Header\n    fmt.Printf(\"%-15s %10s %10s\\n\", \"Name\", \"Age\", \"Score\")\n    fmt.Println(strings.Repeat(\"-\", 35))\n\n    // Data rows\n    fmt.Printf(\"%-15s %10d %10.1f\\n\", \"Alice\", 30, 95.5)\n    fmt.Printf(\"%-15s %10d %10.1f\\n\", \"Bob\", 25, 87.2)\n    fmt.Printf(\"%-15s %10d %10.1f\\n\", \"Charlie\", 35, 92.8)\n}\n</code></pre> <p>Output: <pre><code>Name            Age       Score\n-----------------------------------\nAlice            30       95.5\nBob              25       87.2\nCharlie          35       92.8\n</code></pre></p>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#2-number-formatting","title":"2. Number Formatting","text":"<p>Adding commas to large numbers:</p> <pre><code>func formatNumber(n int) string {\n    s := fmt.Sprintf(\"%d\", n)\n\n    // Add commas every 3 digits from the right\n    for i := len(s) - 3; i &gt; 0; i -= 3 {\n        s = s[:i] + \",\" + s[i:]\n    }\n\n    return s\n}\n\nfunc main() {\n    fmt.Println(formatNumber(1000))      // \"1,000\"\n    fmt.Println(formatNumber(1234567))   // \"1,234,567\"\n    fmt.Println(formatNumber(987654321)) // \"987,654,321\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#3-progress-bars","title":"3. Progress Bars","text":"<p>Creating simple progress indicators:</p> <pre><code>func printProgress(current, total int) {\n    percent := float64(current) / float64(total) * 100\n    barWidth := 50\n    filled := int(percent / 100 * float64(barWidth))\n\n    bar := strings.Repeat(\"=\", filled) + strings.Repeat(\" \", barWidth-filled)\n    fmt.Printf(\"\\r[%s] %.1f%% (%d/%d)\", bar, percent, current, total)\n}\n\nfunc main() {\n    total := 100\n    for i := 0; i &lt;= total; i++ {\n        printProgress(i, total)\n        time.Sleep(50 * time.Millisecond)\n    }\n    fmt.Println() // Newline after progress completes\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#4-logging-with-context","title":"4. Logging with Context","text":"<p>Structured log messages:</p> <pre><code>type Logger struct {\n    prefix string\n}\n\nfunc NewLogger(prefix string) *Logger {\n    return &amp;Logger{prefix: prefix}\n}\n\nfunc (l *Logger) Log(format string, args ...interface{}) {\n    timestamp := time.Now().Format(\"2006-01-02 15:04:05\")\n    message := fmt.Sprintf(format, args...)\n    fmt.Printf(\"[%s] %s: %s\\n\", timestamp, l.prefix, message)\n}\n\nfunc main() {\n    logger := NewLogger(\"APP\")\n    logger.Log(\"Starting application\")\n    logger.Log(\"Processing %d items\", 42)\n    logger.Log(\"Error: %s\", \"connection timeout\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#real-world-example-report-generator","title":"Real-World Example: Report Generator","text":"<p>Let's build a comprehensive report generator that demonstrates various formatting techniques:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"sort\"\n    \"strings\"\n    \"time\"\n)\n\n// ReportData represents the data for our report\ntype ReportData struct {\n    Title       string\n    GeneratedAt time.Time\n    Summary     SummaryStats\n    Sections    []ReportSection\n}\n\ntype SummaryStats struct {\n    TotalRecords int\n    SuccessCount int\n    ErrorCount   int\n    AverageValue float64\n}\n\ntype ReportSection struct {\n    Title   string\n    Entries []ReportEntry\n}\n\ntype ReportEntry struct {\n    ID       string\n    Name     string\n    Value    float64\n    Status   string\n    Category string\n}\n\n// ReportGenerator handles report generation\ntype ReportGenerator struct {\n    output io.Writer\n}\n\nfunc NewReportGenerator(w io.Writer) *ReportGenerator {\n    return &amp;ReportGenerator{output: w}\n}\n\nfunc (rg *ReportGenerator) GenerateReport(data ReportData) error {\n    rg.generateHeader(data)\n    rg.generateSummary(data.Summary)\n    rg.generateSections(data.Sections)\n    rg.generateFooter()\n    return nil\n}\n\nfunc (rg *ReportGenerator) generateHeader(data ReportData) {\n    // Title with underline\n    rg.writeln(data.Title)\n    rg.writeln(strings.Repeat(\"=\", len(data.Title)))\n    rg.writeln(\"\")\n\n    // Metadata\n    rg.writeln(fmt.Sprintf(\"Generated: %s\", data.GeneratedAt.Format(\"2006-01-02 15:04:05\")))\n    rg.writeln(\"\")\n}\n\nfunc (rg *ReportGenerator) generateSummary(summary SummaryStats) {\n    rg.writeln(\"Summary\")\n    rg.writeln(strings.Repeat(\"-\", 7))\n    rg.writeln(\"\")\n\n    // Summary statistics\n    rg.writeln(fmt.Sprintf(\"Total Records: %s\", rg.formatNumber(summary.TotalRecords)))\n    rg.writeln(fmt.Sprintf(\"Successful: %s (%.1f%%)\", \n        rg.formatNumber(summary.SuccessCount), \n        float64(summary.SuccessCount)/float64(summary.TotalRecords)*100))\n    rg.writeln(fmt.Sprintf(\"Errors: %s (%.1f%%)\", \n        rg.formatNumber(summary.ErrorCount), \n        float64(summary.ErrorCount)/float64(summary.TotalRecords)*100))\n    rg.writeln(fmt.Sprintf(\"Average Value: %s\", rg.formatCurrency(summary.AverageValue)))\n    rg.writeln(\"\")\n}\n\nfunc (rg *ReportGenerator) generateSections(sections []ReportSection) {\n    for _, section := range sections {\n        rg.generateSection(section)\n    }\n}\n\nfunc (rg *ReportGenerator) generateSection(section ReportSection) {\n    // Section title\n    rg.writeln(section.Title)\n    rg.writeln(strings.Repeat(\"-\", len(section.Title)))\n    rg.writeln(\"\")\n\n    // Table header\n    rg.writeln(fmt.Sprintf(\"%-10s %-20s %15s %-10s %s\", \n        \"ID\", \"Name\", \"Value\", \"Status\", \"Category\"))\n    rg.writeln(strings.Repeat(\"-\", 70))\n\n    // Sort entries by value (descending)\n    entries := make([]ReportEntry, len(section.Entries))\n    copy(entries, section.Entries)\n    sort.Slice(entries, func(i, j int) bool {\n        return entries[i].Value &gt; entries[j].Value\n    })\n\n    // Table rows\n    for _, entry := range entries {\n        statusColor := \"\"\n        if entry.Status == \"Success\" {\n            statusColor = \"\\033[32m\" // Green\n        } else if entry.Status == \"Error\" {\n            statusColor = \"\\033[31m\" // Red\n        }\n        resetColor := \"\\033[0m\"\n\n        rg.writeln(fmt.Sprintf(\"%-10s %-20s %15s %s%-10s%s %s\", \n            entry.ID,\n            entry.Name,\n            rg.formatCurrency(entry.Value),\n            statusColor,\n            entry.Status,\n            resetColor,\n            entry.Category))\n    }\n\n    rg.writeln(\"\")\n}\n\nfunc (rg *ReportGenerator) generateFooter() {\n    rg.writeln(strings.Repeat(\"=\", 50))\n    rg.writeln(\"End of Report\")\n}\n\nfunc (rg *ReportGenerator) write(s string) {\n    fmt.Fprint(rg.output, s)\n}\n\nfunc (rg *ReportGenerator) writeln(s string) {\n    fmt.Fprintln(rg.output, s)\n}\n\nfunc (rg *ReportGenerator) formatNumber(n int) string {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := len(s) - 3; i &gt; 0; i -= 3 {\n        s = s[:i] + \",\" + s[i:]\n    }\n    return s\n}\n\nfunc (rg *ReportGenerator) formatCurrency(amount float64) string {\n    return fmt.Sprintf(\"$%s%.2f\", rg.formatNumber(int(amount)), amount-float64(int(amount)))\n}\n\nfunc main() {\n    // Sample data\n    data := ReportData{\n        Title:       \"Quarterly Sales Report\",\n        GeneratedAt: time.Now(),\n        Summary: SummaryStats{\n            TotalRecords: 1250,\n            SuccessCount: 1187,\n            ErrorCount:   63,\n            AverageValue: 2475.50,\n        },\n        Sections: []ReportSection{\n            {\n                Title: \"Top Performers\",\n                Entries: []ReportEntry{\n                    {\"001\", \"Product A\", 5000.00, \"Success\", \"Electronics\"},\n                    {\"002\", \"Product B\", 4500.00, \"Success\", \"Electronics\"},\n                    {\"003\", \"Product C\", 3200.00, \"Success\", \"Clothing\"},\n                    {\"004\", \"Product D\", 2800.00, \"Error\", \"Electronics\"},\n                    {\"005\", \"Product E\", 2100.00, \"Success\", \"Clothing\"},\n                },\n            },\n            {\n                Title: \"New Products\",\n                Entries: []ReportEntry{\n                    {\"006\", \"Product F\", 1500.00, \"Success\", \"Home\"},\n                    {\"007\", \"Product G\", 1200.00, \"Error\", \"Home\"},\n                    {\"008\", \"Product H\", 900.00, \"Success\", \"Garden\"},\n                },\n            },\n        },\n    }\n\n    // Generate report to stdout\n    generator := NewReportGenerator(os.Stdout)\n    if err := generator.GenerateReport(data); err != nil {\n        fmt.Printf(\"Error generating report: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    // Also generate to file\n    file, err := os.Create(\"report.txt\")\n    if err != nil {\n        fmt.Printf(\"Error creating file: %v\\n\", err)\n        return\n    }\n    defer file.Close()\n\n    fileGenerator := NewReportGenerator(file)\n    if err := fileGenerator.GenerateReport(data); err != nil {\n        fmt.Printf(\"Error generating file report: %v\\n\", err)\n    }\n\n    fmt.Println(\"\\nReport generated successfully!\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#how-this-example-demonstrates-string-formatting","title":"How This Example Demonstrates String Formatting:","text":"<ol> <li>Structured Output:</li> <li>Uses <code>fmt.Sprintf</code> for building formatted strings</li> <li>Implements consistent formatting patterns</li> <li> <p>Creates aligned tables with precise spacing</p> </li> <li> <p>Custom Formatting Functions:</p> </li> <li><code>formatNumber</code> adds commas to large numbers</li> <li><code>formatCurrency</code> properly formats monetary values</li> <li> <p>Color codes status indicators</p> </li> <li> <p>Layout Control:</p> </li> <li>Uses width specifications for column alignment</li> <li>Implements headers and footers with consistent styling</li> <li> <p>Creates visual separators with repeated characters</p> </li> <li> <p>Data Presentation:</p> </li> <li>Formats percentages with decimal precision</li> <li>Handles different data types appropriately</li> <li>Sorts and presents data in a readable format</li> </ol>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Business Reporting:</li> <li>Financial reports with formatted numbers</li> <li>Sales summaries with percentages</li> <li> <p>Performance metrics with visual indicators</p> </li> <li> <p>Logging Systems:</p> </li> <li>Structured log messages with timestamps</li> <li>Contextual information formatting</li> <li> <p>Error reporting with consistent format</p> </li> <li> <p>User Interfaces:</p> </li> <li>Command-line table displays</li> <li>Progress indicators</li> <li> <p>Formatted data presentation</p> </li> <li> <p>Data Export:</p> </li> <li>CSV/TSV generation with proper formatting</li> <li>Report generation for printing</li> <li>Email notifications with formatted content</li> </ol>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#best-practices-for-string-formatting","title":"Best Practices for String Formatting","text":""},{"location":"2.%20Intermediate/14.%20String-Formatting/#1-choose-the-right-function","title":"1. Choose the Right Function","text":"<ul> <li>Use <code>fmt.Sprintf</code> when you need a string</li> <li>Use <code>fmt.Printf</code> for direct output</li> <li>Use <code>fmt.Fprintf</code> for writing to files or other writers</li> </ul>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#2-be-consistent","title":"2. Be Consistent","text":"<ul> <li>Establish formatting standards for your project</li> <li>Use consistent date/time formats</li> <li>Maintain alignment in table outputs</li> </ul>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#3-handle-internationalization","title":"3. Handle Internationalization","text":"<ul> <li>Be careful with hardcoded formats</li> <li>Consider using localization packages for multi-language apps</li> <li>Avoid assumptions about number/date formats</li> </ul>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#4-performance-considerations","title":"4. Performance Considerations","text":"<ul> <li>Pre-allocate strings when possible</li> <li>Use <code>strings.Builder</code> for complex string building</li> <li>Avoid excessive formatting in tight loops</li> </ul>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#5-error-handling","title":"5. Error Handling","text":"<ul> <li>Always check errors from formatting functions</li> <li>Provide meaningful error messages</li> <li>Handle edge cases gracefully</li> </ul>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#performance-tips","title":"Performance Tips","text":""},{"location":"2.%20Intermediate/14.%20String-Formatting/#1-avoid-repeated-formatting","title":"1. Avoid Repeated Formatting","text":"<pre><code>// Bad - formats on each iteration\nfor i := 0; i &lt; 1000; i++ {\n    msg := fmt.Sprintf(\"Processing item %d\", i)\n    // ...\n}\n\n// Good - reuse format string\nformat := \"Processing item %d\"\nfor i := 0; i &lt; 1000; i++ {\n    msg := fmt.Sprintf(format, i)\n    // ...\n}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#2-use-stringsbuilder-for-complex-building","title":"2. Use strings.Builder for Complex Building","text":"<pre><code>// Bad - creates many temporary strings\nvar result string\nfor _, item := range items {\n    result += fmt.Sprintf(\"%s: %v\\n\", item.Name, item.Value)\n}\n\n// Good - efficient with Builder\nvar builder strings.Builder\nfor _, item := range items {\n    fmt.Fprintf(&amp;builder, \"%s: %v\\n\", item.Name, item.Value)\n}\nresult := builder.String()\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#3-cache-format-strings","title":"3. Cache Format Strings","text":"<pre><code>// Cache commonly used format strings\nvar (\n    logFormat    = \"[%s] %s: %s\"\n    errorFormat  = \"ERROR: %s (code: %d)\"\n    tableFormat  = \"%-20s %10s %15s\"\n)\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#conclusion","title":"Conclusion","text":"<p>String formatting is a fundamental skill in Go that enables you to:</p> <ol> <li>Create Professional Output:</li> <li>Well-formatted reports and tables</li> <li>User-friendly command-line interfaces</li> <li> <p>Consistent log messages</p> </li> <li> <p>Present Data Effectively:</p> </li> <li>Format numbers with appropriate precision</li> <li>Display dates and times consistently</li> <li> <p>Create aligned and readable output</p> </li> <li> <p>Build Robust Applications:</p> </li> <li>Handle different data types gracefully</li> <li>Implement custom formatting for complex types</li> <li>Create maintainable and consistent output</li> </ol> <p>The report generator example demonstrates how combining various formatting techniques can create professional, readable output for real-world applications. By mastering Go's string formatting capabilities, you can build applications that communicate clearly with users and present data in the most effective way.</p> <p>Key takeaways: 1. Use the right formatting function for each use case 2. Leverage width, precision, and flags for control 3. Implement custom formatting for complex types 4. Follow consistent patterns throughout your application 5. Consider performance for formatting-intensive operations</p> <p>String formatting is more than just concatenating values\u2014it's about presenting information in a way that's clear, consistent, and professional. Mastering these skills will significantly improve the quality and usability of your Go applications.</p>"},{"location":"2.%20Intermediate/15.%20Text-Templates/","title":"Text Templates in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#introduction-to-text-templates","title":"Introduction to Text Templates","text":"<p>Go's <code>text/template</code> package provides a powerful templating system for generating textual output. Templates allow you to define reusable text patterns with placeholders that get filled in with data at runtime. This is particularly useful for generating HTML, configuration files, emails, code, and any other text-based output.</p>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#why-use-templates","title":"Why Use Templates?","text":"<ul> <li>Separation of Concerns: Keep presentation logic separate from business logic</li> <li>Reusability: Define templates once and use them with different data</li> <li>Maintainability: Easier to update presentation without changing code</li> <li>Safety: Automatic escaping and structured data handling</li> </ul>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#basic-template-syntax","title":"Basic Template Syntax","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#1-actions","title":"1. Actions","text":"<p>Templates use double curly braces <code>{{</code> and <code>}}</code> to delimit actions:</p> <pre><code>package main\n\nimport (\n    \"os\"\n    \"text/template\"\n)\n\nfunc main() {\n    // Simple template with a variable\n    tmpl := `Hello, {{.Name}}!`\n\n    // Data to populate the template\n    data := struct {\n        Name string\n    }{\n        Name: \"Alice\",\n    }\n\n    // Parse and execute the template\n    t := template.Must(template.New(\"greeting\").Parse(tmpl))\n    t.Execute(os.Stdout, data) // Output: Hello, Alice!\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#2-variables-and-pipelines","title":"2. Variables and Pipelines","text":"<ul> <li><code>{{.}}</code> refers to the current data object</li> <li><code>{{.Field}}</code> accesses a field of a struct</li> <li><code>{{.Method}}</code> calls a method</li> <li>Pipelines use <code>|</code> to chain operations</li> </ul> <pre><code>func main() {\n    tmpl := `{{.Name}} is {{.Age}} years old. In 5 years: {{add .Age 5}}`\n\n    data := struct {\n        Name string\n        Age  int\n    }{\n        Name: \"Bob\",\n        Age:  30,\n    }\n\n    // Create a template with a custom function\n    funcMap := template.FuncMap{\n        \"add\": func(a, b int) int { return a + b },\n    }\n\n    t := template.Must(template.New(\"age\").Funcs(funcMap).Parse(tmpl))\n    t.Execute(os.Stdout, data)\n    // Output: Bob is 30 years old. In 5 years: 35\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#template-creation-and-execution","title":"Template Creation and Execution","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#1-parsing-templates","title":"1. Parsing Templates","text":"<pre><code>// Parse a single template\nt1, err := template.New(\"template1\").Parse(\"Hello, {{.}}\")\nif err != nil {\n    panic(err)\n}\n\n// Parse multiple templates\nt2, err := template.ParseFiles(\"header.tmpl\", \"footer.tmpl\")\nif err != nil {\n    panic(err)\n}\n\n// Parse from string\nt3 := template.Must(template.New(\"inline\").Parse(\"Value: {{.Value}}\"))\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#2-executing-templates","title":"2. Executing Templates","text":"<pre><code>// Execute to io.Writer\nerr := t.Execute(os.Stdout, data)\nif err != nil {\n    panic(err)\n}\n\n// Execute to string\nvar buf bytes.Buffer\nerr = t.Execute(&amp;buf, data)\nresult := buf.String()\n\n// Execute with specific template name (for multiple templates)\nerr = t.ExecuteTemplate(os.Stdout, \"header\", data)\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#data-structures-for-templates","title":"Data Structures for Templates","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#1-using-structs","title":"1. Using Structs","text":"<pre><code>type User struct {\n    Name    string\n    Age     int\n    Email   string\n    Active  bool\n}\n\nfunc main() {\n    tmpl := `\nUser: {{.Name}}\nAge: {{.Age}}\nEmail: {{.Email}}\nStatus: {{if .Active}}Active{{else}}Inactive{{end}}\n`\n\n    user := User{\n        Name:   \"Charlie\",\n        Age:    25,\n        Email:  \"charlie@example.com\",\n        Active: true,\n    }\n\n    t := template.Must(template.New(\"user\").Parse(tmpl))\n    t.Execute(os.Stdout, user)\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#2-using-maps","title":"2. Using Maps","text":"<pre><code>func main() {\n    tmpl := `{{.name}} lives in {{.city}}`\n\n    data := map[string]string{\n        \"name\": \"Diana\",\n        \"city\": \"New York\",\n    }\n\n    t := template.Must(template.New(\"location\").Parse(tmpl))\n    t.Execute(os.Stdout, data) // Diana lives in New York\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#3-using-slices","title":"3. Using Slices","text":"<pre><code>func main() {\n    tmpl := `{{range .}}{{.}} {{end}}`\n\n    items := []string{\"apple\", \"banana\", \"cherry\"}\n\n    t := template.Must(template.New(\"list\").Parse(tmpl))\n    t.Execute(os.Stdout, items) // apple banana cherry \n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#control-structures","title":"Control Structures","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#1-conditionals","title":"1. Conditionals","text":"<pre><code>func main() {\n    tmpl := `\n{{if .Admin}}\n    Welcome, Administrator!\n{{else if .User}}\n    Welcome, {{.User}}!\n{{else}}\n    Please log in.\n{{end}}\n`\n\n    data := map[string]interface{}{\n        \"Admin\": false,\n        \"User\":  \"Alice\",\n    }\n\n    t := template.Must(template.New(\"auth\").Parse(tmpl))\n    t.Execute(os.Stdout, data)\n    // Output:\n    // Welcome, Alice!\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#2-loops-with-range","title":"2. Loops with <code>range</code>","text":"<pre><code>func main() {\n    tmpl := `\nUsers:\n{{range .}}\n    - {{.Name}} ({{.Age}})\n{{end}}\n`\n\n    type User struct {\n        Name string\n        Age  int\n    }\n\n    users := []User{\n        {\"Alice\", 30},\n        {\"Bob\", 25},\n        {\"Charlie\", 35},\n    }\n\n    t := template.Must(template.New(\"users\").Parse(tmpl))\n    t.Execute(os.Stdout, users)\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#3-with-for-context","title":"3. <code>with</code> for Context","text":"<pre><code>func main() {\n    tmpl := `\n{{with .User}}\n    Name: {{.Name}}\n    Email: {{.Email}}\n{{end}}\n`\n\n    data := struct {\n        User *struct {\n            Name  string\n            Email string\n        }\n    }{\n        User: &amp;struct {\n            Name  string\n            Email string\n        }{\n            Name:  \"David\",\n            Email: \"david@example.com\",\n        },\n    }\n\n    t := template.Must(template.New(\"with\").Parse(tmpl))\n    t.Execute(os.Stdout, data)\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#template-functions","title":"Template Functions","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#1-built-in-functions","title":"1. Built-in Functions","text":"<pre><code>func main() {\n    tmpl := `\nString: {{.Text | upper}}\nLength: {{.Text | len}}\nWord count: {{.Text | wordCount}}\nHTML escaped: {{.HTML | html}}\nURL escaped: {{.URL | urlquery}}\n`\n\n    funcMap := template.FuncMap{\n        \"upper\":     strings.ToUpper,\n        \"wordCount\": func(s string) int { return len(strings.Fields(s)) },\n    }\n\n    data := struct {\n        Text string\n        HTML string\n        URL  string\n    }{\n        Text: \"hello world\",\n        HTML: \"&lt;script&gt;alert('xss')&lt;/script&gt;\",\n        URL:  \"search?q=go templates\",\n    }\n\n    t := template.Must(template.New(\"funcs\").Funcs(funcMap).Parse(tmpl))\n    t.Execute(os.Stdout, data)\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#2-custom-functions","title":"2. Custom Functions","text":"<pre><code>// Define custom functions\nfunc formatPrice(price float64) string {\n    return fmt.Sprintf(\"$%.2f\", price)\n}\n\nfunc formatDate(t time.Time) string {\n    return t.Format(\"2006-01-02\")\n}\n\nfunc main() {\n    funcMap := template.FuncMap{\n        \"formatPrice\": formatPrice,\n        \"formatDate\":  formatDate,\n    }\n\n    tmpl := `\nProduct: {{.Name}}\nPrice: {{.Price | formatPrice}}\nCreated: {{.Created | formatDate}}\n`\n\n    data := struct {\n        Name    string\n        Price   float64\n        Created time.Time\n    }{\n        Name:    \"Laptop\",\n        Price:   999.99,\n        Created: time.Now(),\n    }\n\n    t := template.Must(template.New(\"product\").Funcs(funcMap).Parse(tmpl))\n    t.Execute(os.Stdout, data)\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#template-composition","title":"Template Composition","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#1-template-inheritance-with-block-and-define","title":"1. Template Inheritance with <code>block</code> and <code>define</code>","text":"<pre><code>// base.tmpl\n{{define \"base\"}}&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{{block \"title\" .}}Default Title{{end}}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    {{block \"content\" .}}{{end}}\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n\n// page.tmpl\n{{define \"title\"}}Home Page{{end}}\n{{define \"content\"}}&lt;h1&gt;Welcome!&lt;/h1&gt;{{end}}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#2-template-composition-in-code","title":"2. Template Composition in Code","text":"<pre><code>func main() {\n    // Parse base template\n    base := `{{define \"base\"}}Base: {{block \"content\" .}}Default{{end}}{{end}}`\n    t := template.Must(template.New(\"base\").Parse(base))\n\n    // Add child template\n    child := `{{define \"content\"}}Child Content{{end}}`\n    t = template.Must(t.Parse(child))\n\n    // Execute base template\n    t.ExecuteTemplate(os.Stdout, \"base\", nil)\n    // Output: Base: Child Content\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#error-handling","title":"Error Handling","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#1-common-template-errors","title":"1. Common Template Errors","text":"<pre><code>func main() {\n    // Missing field in template\n    tmpl := `Hello, {{.NonExistentField}}!`\n    t, err := template.New(\"error\").Parse(tmpl)\n    if err != nil {\n        fmt.Println(\"Parse error:\", err)\n        return\n    }\n\n    // This will execute without error but output \"Hello, &lt;no value&gt;!\"\n    err = t.Execute(os.Stdout, struct{}{})\n    if err != nil {\n        fmt.Println(\"Execute error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#2-safe-template-execution","title":"2. Safe Template Execution","text":"<pre><code>func safeExecute(tmplStr string, data interface{}) error {\n    t, err := template.New(\"safe\").Parse(tmplStr)\n    if err != nil {\n        return fmt.Errorf(\"template parse error: %w\", err)\n    }\n\n    if err := t.Execute(os.Stdout, data); err != nil {\n        return fmt.Errorf(\"template execute error: %w\", err)\n    }\n\n    return nil\n}\n\nfunc main() {\n    err := safeExecute(\"Hello, {{.Name}}!\", map[string]string{\"Name\": \"Eve\"})\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#real-world-example-html-report-generator","title":"Real-World Example: HTML Report Generator","text":"<p>Let's build a comprehensive HTML report generator using templates:</p> <pre><code>package main\n\nimport (\n    \"html/template\"\n    \"os\"\n    \"time\"\n)\n\n// Data structures\ntype Report struct {\n    Title       string\n    GeneratedAt time.Time\n    Summary     Summary\n    Sections    []Section\n}\n\ntype Summary struct {\n    TotalItems   int\n    SuccessCount int\n    ErrorCount   int\n}\n\ntype Section struct {\n    Title   string\n    Items   []Item\n}\n\ntype Item struct {\n    ID          string\n    Name        string\n    Value       float64\n    Status      string\n    Description string\n}\n\n// Template definitions\nconst baseTemplate = `&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{{.Title}} - Report&lt;/title&gt;\n    &lt;style&gt;\n        body { font-family: Arial, sans-serif; margin: 40px; }\n        .header { border-bottom: 2px solid #333; padding-bottom: 10px; }\n        .summary { background: #f5f5f5; padding: 15px; margin: 20px 0; }\n        .section { margin: 30px 0; }\n        .section h2 { color: #333; }\n        table { width: 100%; border-collapse: collapse; }\n        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }\n        th { background-color: #f2f2f2; }\n        .success { color: green; }\n        .error { color: red; }\n        .footer { margin-top: 40px; font-size: 0.8em; color: #666; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    {{template \"content\" .}}\n    &lt;div class=\"footer\"&gt;\n        Generated on {{.GeneratedAt.Format \"2006-01-02 15:04:05\"}}\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;`\n\nconst contentTemplate = `{{define \"content\"}}\n&lt;div class=\"header\"&gt;\n    &lt;h1&gt;{{.Title}}&lt;/h1&gt;\n&lt;/div&gt;\n\n&lt;div class=\"summary\"&gt;\n    &lt;h2&gt;Summary&lt;/h2&gt;\n    &lt;p&gt;Total Items: {{.Summary.TotalItems}}&lt;/p&gt;\n    &lt;p&gt;Successful: &lt;span class=\"success\"&gt;{{.Summary.SuccessCount}}&lt;/span&gt;&lt;/p&gt;\n    &lt;p&gt;Errors: &lt;span class=\"error\"&gt;{{.Summary.ErrorCount}}&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n\n{{range .Sections}}\n&lt;div class=\"section\"&gt;\n    &lt;h2&gt;{{.Title}}&lt;/h2&gt;\n    &lt;table&gt;\n        &lt;thead&gt;\n            &lt;tr&gt;\n                &lt;th&gt;ID&lt;/th&gt;\n                &lt;th&gt;Name&lt;/th&gt;\n                &lt;th&gt;Value&lt;/th&gt;\n                &lt;th&gt;Status&lt;/th&gt;\n                &lt;th&gt;Description&lt;/th&gt;\n            &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n            {{range .Items}}\n            &lt;tr&gt;\n                &lt;td&gt;{{.ID}}&lt;/td&gt;\n                &lt;td&gt;{{.Name}}&lt;/td&gt;\n                &lt;td&gt;${{formatCurrency .Value}}&lt;/td&gt;\n                &lt;td class=\"{{if eq .Status \"Success\"}}success{{else}}error{{end}}\"&gt;\n                    {{.Status}}\n                &lt;/td&gt;\n                &lt;td&gt;{{.Description}}&lt;/td&gt;\n            &lt;/tr&gt;\n            {{end}}\n        &lt;/tbody&gt;\n    &lt;/table&gt;\n&lt;/div&gt;\n{{end}}\n{{end}}`\n\n// Custom functions\nvar funcMap = template.FuncMap{\n    \"formatCurrency\": func(value float64) string {\n        return fmt.Sprintf(\"%.2f\", value)\n    },\n    \"eq\": func(a, b interface{}) bool {\n        return a == b\n    },\n}\n\nfunc main() {\n    // Create template\n    t := template.Must(template.New(\"base\").Funcs(funcMap).Parse(baseTemplate))\n    t = template.Must(t.Parse(contentTemplate))\n\n    // Sample data\n    report := Report{\n        Title:       \"Monthly Sales Report\",\n        GeneratedAt: time.Now(),\n        Summary: Summary{\n            TotalItems:   10,\n            SuccessCount: 8,\n            ErrorCount:   2,\n        },\n        Sections: []Section{\n            {\n                Title: \"Electronics\",\n                Items: []Item{\n                    {\"E001\", \"Laptop\", 999.99, \"Success\", \"High-performance laptop\"},\n                    {\"E002\", \"Mouse\", 25.50, \"Success\", \"Wireless mouse\"},\n                    {\"E003\", \"Keyboard\", 45.00, \"Error\", \"Out of stock\"},\n                },\n            },\n            {\n                Title: \"Clothing\",\n                Items: []Item{\n                    {\"C001\", \"T-Shirt\", 19.99, \"Success\", \"Cotton t-shirt\"},\n                    {\"C002\", \"Jeans\", 49.99, \"Success\", \"Denim jeans\"},\n                    {\"C003\", \"Jacket\", 89.99, \"Error\", \"Size not available\"},\n                },\n            },\n        },\n    }\n\n    // Execute template\n    file, err := os.Create(\"report.html\")\n    if err != nil {\n        panic(err)\n    }\n    defer file.Close()\n\n    err = t.Execute(file, report)\n    if err != nil {\n        panic(err)\n    }\n\n    println(\"Report generated successfully: report.html\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Template Structure:</li> <li>Base template with HTML structure and CSS</li> <li>Content template with report-specific markup</li> <li> <p>Template inheritance using <code>define</code> and <code>template</code></p> </li> <li> <p>Data Organization:</p> </li> <li>Structured data with nested types</li> <li>Clear separation between different report sections</li> <li> <p>Consistent data model for all items</p> </li> <li> <p>Custom Functions:</p> </li> <li><code>formatCurrency</code> for monetary values</li> <li> <p><code>eq</code> for equality comparison in templates</p> </li> <li> <p>Styling and Presentation:</p> </li> <li>Embedded CSS for consistent styling</li> <li>Conditional coloring based on status</li> <li>Responsive table layout</li> </ol>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Web Applications:</li> <li>Dynamic HTML generation</li> <li>Email templates</li> <li> <p>PDF report generation</p> </li> <li> <p>Configuration Management:</p> </li> <li>Generate config files from templates</li> <li>Environment-specific configurations</li> <li> <p>Infrastructure as Code templates</p> </li> <li> <p>Code Generation:</p> </li> <li>Boilerplate code generation</li> <li>API client generation</li> <li> <p>Database model generation</p> </li> <li> <p>Documentation:</p> </li> <li>API documentation</li> <li>User guides</li> <li>Release notes</li> </ol>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#1-template-organization","title":"1. Template Organization","text":"<ul> <li>Keep templates separate from application logic</li> <li>Use a consistent naming convention</li> <li>Organize templates in a directory structure</li> </ul>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#2-data-design","title":"2. Data Design","text":"<ul> <li>Use simple, flat data structures when possible</li> <li>Avoid complex logic in templates</li> <li>Prepare data before passing to templates</li> </ul>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#3-security","title":"3. Security","text":"<ul> <li>Always use automatic escaping for HTML</li> <li>Validate data before template execution</li> <li>Be careful with user-generated content</li> </ul>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#4-performance","title":"4. Performance","text":"<ul> <li>Parse templates once, execute many times</li> <li>Cache compiled templates</li> <li>Avoid heavy computation in template functions</li> </ul>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#5-error-handling","title":"5. Error Handling","text":"<ul> <li>Check template parsing errors</li> <li>Handle execution errors gracefully</li> <li>Provide meaningful error messages</li> </ul>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"2.%20Intermediate/15.%20Text-Templates/#1-template-reuse-with-partial-templates","title":"1. Template Reuse with Partial Templates","text":"<pre><code>// Define a partial template\nconst partial = `{{define \"userCard\"}}\n&lt;div class=\"user-card\"&gt;\n    &lt;h3&gt;{{.Name}}&lt;/h3&gt;\n    &lt;p&gt;{{.Email}}&lt;/p&gt;\n&lt;/div&gt;\n{{end}}`\n\n// Use in multiple templates\nconst page1 = `{{template \"userCard\" .User}}`\nconst page2 = `Users: {{range .Users}}{{template \"userCard\" .}}{{end}}`\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#2-dynamic-template-loading","title":"2. Dynamic Template Loading","text":"<pre><code>func loadTemplates(pattern string) (*template.Template, error) {\n    tmpl := template.New(\"main\").Funcs(funcMap)\n\n    files, err := filepath.Glob(pattern)\n    if err != nil {\n        return nil, err\n    }\n\n    for _, file := range files {\n        content, err := os.ReadFile(file)\n        if err != nil {\n            return nil, err\n        }\n\n        name := filepath.Base(file)\n        _, err = tmpl.New(name).Parse(string(content))\n        if err != nil {\n            return nil, err\n        }\n    }\n\n    return tmpl, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#3-template-testing","title":"3. Template Testing","text":"<pre><code>func TestTemplate(t *testing.T) {\n    tmpl := `Hello, {{.Name}}!`\n    data := struct{ Name string }{Name: \"Test\"}\n\n    result, err := executeTemplate(tmpl, data)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    expected := \"Hello, Test!\"\n    if result != expected {\n        t.Errorf(\"Expected %q, got %q\", expected, result)\n    }\n}\n\nfunc executeTemplate(tmplStr string, data interface{}) (string, error) {\n    t := template.Must(template.New(\"test\").Parse(tmplStr))\n    var buf bytes.Buffer\n    err := t.Execute(&amp;buf, data)\n    return buf.String(), err\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#conclusion","title":"Conclusion","text":"<p>Go's <code>text/template</code> package provides a powerful and flexible system for generating textual output. By mastering templates, you can:</p> <ol> <li>Separate Concerns:</li> <li>Keep presentation logic separate from business logic</li> <li>Maintain clean, organized code</li> <li> <p>Make applications easier to maintain</p> </li> <li> <p>Create Reusable Components:</p> </li> <li>Define templates once, use everywhere</li> <li>Build template libraries for common patterns</li> <li> <p>Share templates across projects</p> </li> <li> <p>Generate Dynamic Content:</p> </li> <li>Create personalized emails</li> <li>Generate configuration files</li> <li> <p>Build dynamic web pages</p> </li> <li> <p>Ensure Consistency:</p> </li> <li>Maintain consistent formatting</li> <li>Apply branding automatically</li> <li>Reduce human error in output generation</li> </ol> <p>The HTML report generator example demonstrates how templates can be used to create complex, professional-looking documents with minimal code. By combining templates with Go's strong typing and performance characteristics, you can build robust applications that generate high-quality textual output efficiently.</p> <p>Key takeaways: 1. Start simple with basic templates and gradually add complexity 2. Organize templates logically for maintainability 3. Use custom functions to extend template capabilities 4. Handle errors properly at both parse and execute time 5. Test templates to ensure they work as expected</p> <p>Templates are a fundamental tool in the Go ecosystem, essential for any application that needs to generate text-based output. Mastering them will significantly improve your ability to build flexible, maintainable Go applications.</p>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/","title":"Regular Expressions in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#introduction-to-regular-expressions","title":"Introduction to Regular Expressions","text":"<p>Regular expressions (regex) are sequences of characters that define search patterns. Go's <code>regexp</code> package provides powerful regex capabilities based on the RE2 library, offering fast, safe, and efficient pattern matching. Regular expressions are essential for text processing, validation, parsing, and data extraction.</p>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#basic-pattern-matching","title":"Basic Pattern Matching","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#1-simple-pattern-matching","title":"1. Simple Pattern Matching","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc main() {\n    // Check if a string contains a pattern\n    matched, err := regexp.MatchString(\"Go\", \"I love Go programming\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Contains 'Go':\", matched) // true\n\n    // Case-insensitive matching\n    matched, _ = regexp.MatchString(`(?i)go`, \"I LOVE GO\")\n    fmt.Println(\"Contains 'go' (case-insensitive):\", matched) // true\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#2-character-classes-and-quantifiers","title":"2. Character Classes and Quantifiers","text":"<pre><code>func main() {\n    // Character classes\n    patterns := []string{\n        `[aeiou]`,    // Any vowel\n        `[A-Z]`,      // Any uppercase letter\n        `[0-9]`,      // Any digit\n        `[^0-9]`,     // Any non-digit\n        `\\d`,         // Digit (same as [0-9])\n        `\\w`,         // Word character (alphanumeric + underscore)\n        `\\s`,         // Whitespace character\n    }\n\n    testStr := \"Hello World 123!\"\n    for _, pattern := range patterns {\n        matched, _ := regexp.MatchString(pattern, testStr)\n        fmt.Printf(\"Pattern %q matches: %v\\n\", pattern, matched)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#compiling-regular-expressions","title":"Compiling Regular Expressions","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#1-pre-compiling-patterns","title":"1. Pre-compiling Patterns","text":"<p>For better performance, especially when using the same pattern multiple times:</p> <pre><code>func main() {\n    // Compile a regex pattern\n    re, err := regexp.Compile(`\\d+`) // One or more digits\n    if err != nil {\n        fmt.Println(\"Compilation error:\", err)\n        return\n    }\n\n    // Use the compiled regex\n    fmt.Println(\"Matches digits:\", re.MatchString(\"abc123def\")) // true\n    fmt.Println(\"Matches digits:\", re.MatchString(\"abcdef\"))    // false\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#2-using-mustcompile-for-known-patterns","title":"2. Using MustCompile for Known Patterns","text":"<p>When you're sure the pattern is valid (e.g., hardcoded patterns):</p> <pre><code>func main() {\n    // MustCompile panics on invalid patterns\n    re := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)\n\n    emails := []string{\n        \"user@example.com\",\n        \"invalid-email\",\n        \"another.user@domain.co.uk\",\n    }\n\n    for _, email := range emails {\n        if re.MatchString(email) {\n            fmt.Printf(\"Valid email: %s\\n\", email)\n        } else {\n            fmt.Printf(\"Invalid email: %s\\n\", email)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#finding-matches","title":"Finding Matches","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#1-finding-all-matches","title":"1. Finding All Matches","text":"<pre><code>func main() {\n    re := regexp.MustCompile(`\\b\\d+\\b`) // Whole numbers only\n    text := \"I have 2 apples and 15 oranges\"\n\n    // Find all matches\n    matches := re.FindAllString(text, -1) // -1 for all matches\n    fmt.Println(\"All numbers:\", matches) // [2 15]\n\n    // Find first match only\n    firstMatch := re.FindString(text)\n    fmt.Println(\"First number:\", firstMatch) // 2\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#2-finding-match-positions","title":"2. Finding Match Positions","text":"<pre><code>func main() {\n    re := regexp.MustCompile(`Go`)\n    text := \"Go is great. Go is efficient.\"\n\n    // Find all matches with positions\n    matches := re.FindAllStringIndex(text, -1)\n    for _, match := range matches {\n        fmt.Printf(\"Found 'Go' at positions %d-%d\\n\", match[0], match[1])\n    }\n    // Output:\n    // Found 'Go' at positions 0-2\n    // Found 'Go' at positions 13-15\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#3-finding-submatches-groups","title":"3. Finding Submatches (Groups)","text":"<pre><code>func main() {\n    // Extract date components\n    re := regexp.MustCompile(`(\\d{4})-(\\d{2})-(\\d{2})`)\n    text := \"Date: 2023-11-15\"\n\n    // Find submatches\n    matches := re.FindStringSubmatch(text)\n    if len(matches) &gt; 0 {\n        fmt.Println(\"Full match:\", matches[0]) // 2023-11-15\n        fmt.Println(\"Year:\", matches[1])       // 2023\n        fmt.Println(\"Month:\", matches[2])      // 11\n        fmt.Println(\"Day:\", matches[3])        // 15\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#replacing-text","title":"Replacing Text","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#1-simple-replacement","title":"1. Simple Replacement","text":"<pre><code>func main() {\n    re := regexp.MustCompile(`apple`)\n    text := \"I have an apple and another apple\"\n\n    // Replace all occurrences\n    result := re.ReplaceAllString(text, \"orange\")\n    fmt.Println(result) // I have an orange and another orange\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#2-using-functions-for-replacement","title":"2. Using Functions for Replacement","text":"<pre><code>func main() {\n    re := regexp.MustCompile(`\\b(\\w+)\\b`)\n    text := \"hello world\"\n\n    // Convert to uppercase using a function\n    result := re.ReplaceAllStringFunc(text, strings.ToUpper)\n    fmt.Println(result) // HELLO WORLD\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#3-using-match-groups-in-replacement","title":"3. Using Match Groups in Replacement","text":"<pre><code>func main() {\n    // Swap first and last name\n    re := regexp.MustCompile(`(\\w+)\\s+(\\w+)`)\n    text := \"John Doe\"\n\n    // Use $1, $2 for groups\n    result := re.ReplaceAllString(text, \"$2, $1\")\n    fmt.Println(result) // Doe, John\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#splitting-strings","title":"Splitting Strings","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#1-splitting-by-pattern","title":"1. Splitting by Pattern","text":"<pre><code>func main() {\n    re := regexp.MustCompile(`\\s*,\\s*`) // Split by comma with optional whitespace\n    text := \"apple, banana, cherry,  date\"\n\n    // Split the string\n    parts := re.Split(text, -1)\n    fmt.Println(parts) // [apple banana cherry date]\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#2-limiting-splits","title":"2. Limiting Splits","text":"<pre><code>func main() {\n    re := regexp.MustCompile(`\\s+`)\n    text := \"Split   this   string\"\n\n    // Split into at most 3 parts\n    parts := re.Split(text, 3)\n    fmt.Println(parts) // [Split this string]\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#1-lookarounds","title":"1. Lookarounds","text":"<pre><code>func main() {\n    // Positive lookahead: password must contain digit\n    re := regexp.MustCompile(`^(?=.*\\d).+$`)\n    fmt.Println(\"Pass123:\", re.MatchString(\"Pass123\")) // true\n    fmt.Println(\"Password:\", re.MatchString(\"Password\")) // false\n\n    // Negative lookahead: password must not contain 'admin'\n    re = regexp.MustCompile(`^(?!.*admin).+$`)\n    fmt.Println(\"user123:\", re.MatchString(\"user123\")) // true\n    fmt.Println(\"admin123:\", re.MatchString(\"admin123\")) // false\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#2-non-capturing-groups","title":"2. Non-capturing Groups","text":"<pre><code>func main() {\n    // Using (?:...) for non-capturing groups\n    re := regexp.MustCompile(`(?:https?|ftp)://([^/]+)`)\n    url := \"https://example.com/path\"\n\n    matches := re.FindStringSubmatch(url)\n    if len(matches) &gt; 1 {\n        fmt.Println(\"Domain:\", matches[1]) // example.com\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#3-greedy-vs-lazy-matching","title":"3. Greedy vs. Lazy Matching","text":"<pre><code>func main() {\n    text := \"&lt;div&gt;First&lt;/div&gt;&lt;div&gt;Second&lt;/div&gt;\"\n\n    // Greedy match (default)\n    re := regexp.MustCompile(`&lt;div&gt;.*&lt;/div&gt;`)\n    fmt.Println(\"Greedy:\", re.FindString(text)) // &lt;div&gt;First&lt;/div&gt;&lt;div&gt;Second&lt;/div&gt;\n\n    // Lazy match (non-greedy)\n    re = regexp.MustCompile(`&lt;div&gt;.*?&lt;/div&gt;`)\n    fmt.Println(\"Lazy:\", re.FindString(text)) // &lt;div&gt;First&lt;/div&gt;\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#common-patterns-and-examples","title":"Common Patterns and Examples","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#1-email-validation","title":"1. Email Validation","text":"<pre><code>func validateEmail(email string) bool {\n    re := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)\n    return re.MatchString(email)\n}\n\nfunc main() {\n    emails := []string{\n        \"user@example.com\",\n        \"user.name@domain.co.uk\",\n        \"invalid-email\",\n        \"@domain.com\",\n    }\n\n    for _, email := range emails {\n        fmt.Printf(\"%s: %v\\n\", email, validateEmail(email))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#2-url-extraction","title":"2. URL Extraction","text":"<pre><code>func extractURLs(text string) []string {\n    // Simplified URL pattern\n    re := regexp.MustCompile(`https?://[^\\s]+`)\n    return re.FindAllString(text, -1)\n}\n\nfunc main() {\n    text := `Visit https://example.com or http://test.org for more info.`\n    urls := extractURLs(text)\n    fmt.Println(\"URLs found:\", urls)\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#3-phone-number-formatting","title":"3. Phone Number Formatting","text":"<pre><code>func formatPhoneNumber(phone string) string {\n    // Remove all non-digits\n    re := regexp.MustCompile(`[^\\d]`)\n    digits := re.ReplaceAllString(phone, \"\")\n\n    // Format as (XXX) XXX-XXXX\n    if len(digits) == 10 {\n        return fmt.Sprintf(\"(%s) %s-%s\", digits[0:3], digits[3:6], digits[6:])\n    }\n    return phone\n}\n\nfunc main() {\n    phones := []string{\n        \"1234567890\",\n        \"(123) 456-7890\",\n        \"123-456-7890\",\n    }\n\n    for _, phone := range phones {\n        fmt.Printf(\"%s -&gt; %s\\n\", phone, formatPhoneNumber(phone))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#real-world-example-log-parser","title":"Real-World Example: Log Parser","text":"<p>Let's build a comprehensive log parser that extracts structured information from log entries:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n)\n\n// LogEntry represents a parsed log entry\ntype LogEntry struct {\n    Timestamp time.Time\n    Level     string\n    Message   string\n    IP        string\n    UserID    string\n    Status    int\n}\n\n// LogParser handles log parsing with regex\ntype LogParser struct {\n    // Patterns for different log formats\n    patterns map[string]*regexp.Regexp\n}\n\nfunc NewLogParser() *LogParser {\n    return &amp;LogParser{\n        patterns: map[string]*regexp.Regexp{\n            \"apache\": regexp.MustCompile(`^(\\S+) \\S+ \\S+ \\[([\\w:/]+\\s[+\\-]\\d{4})\\] \"(\\S+) (\\S+) (\\S+)\" (\\d{3}) (\\d+|-)`),\n            \"nginx\":  regexp.MustCompile(`^(\\S+) - - \\[([\\w:/]+\\s[+\\-]\\d{4})\\] \"(\\S+) (\\S+) (\\S+)\" (\\d{3}) (\\d+|-) \"([^\"]*)\" \"([^\"]*)\"`),\n            \"custom\": regexp.MustCompile(`^(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) \\[(\\w+)\\] (.+?) (?:user:(\\S+))? (?:ip:(\\S+))? (?:status:(\\d+))?$`),\n        },\n    }\n}\n\nfunc (lp *LogParser) ParseLog(line string, format string) (*LogEntry, error) {\n    re, exists := lp.patterns[format]\n    if !exists {\n        return nil, fmt.Errorf(\"unknown log format: %s\", format)\n    }\n\n    matches := re.FindStringSubmatch(line)\n    if matches == nil {\n        return nil, fmt.Errorf(\"line doesn't match format: %s\", line)\n    }\n\n    entry := &amp;LogEntry{}\n\n    switch format {\n    case \"apache\":\n        // Apache log format: IP - - [timestamp] \"method path protocol\" status size\n        entry.IP = matches[1]\n        entry.Timestamp = parseApacheTime(matches[2])\n        entry.Message = fmt.Sprintf(\"%s %s %s\", matches[3], matches[4], matches[5])\n        entry.Status = parseInt(matches[6])\n        entry.Level = getLogLevel(entry.Status)\n\n    case \"nginx\":\n        // Nginx log format (extended)\n        entry.IP = matches[1]\n        entry.Timestamp = parseApacheTime(matches[2])\n        entry.Message = fmt.Sprintf(\"%s %s %s\", matches[3], matches[4], matches[5])\n        entry.Status = parseInt(matches[6])\n        entry.Level = getLogLevel(entry.Status)\n\n    case \"custom\":\n        // Custom format: timestamp [level] message user:user_id ip:ip status:status\n        entry.Timestamp = parseCustomTime(matches[1])\n        entry.Level = matches[2]\n        entry.Message = matches[3]\n        entry.UserID = matches[4]\n        entry.IP = matches[5]\n        if matches[6] != \"\" {\n            entry.Status = parseInt(matches[6])\n        }\n    }\n\n    return entry, nil\n}\n\n// Helper functions\nfunc parseApacheTime(ts string) time.Time {\n    // Parse Apache timestamp format: 10/Oct/2000:13:55:36 -0700\n    layout := \"02/Jan/2006:15:04:05 -0700\"\n    t, _ := time.Parse(layout, ts)\n    return t\n}\n\nfunc parseCustomTime(ts string) time.Time {\n    // Parse custom timestamp format: 2023-11-15 14:30:45\n    layout := \"2006-01-02 15:04:05\"\n    t, _ := time.Parse(layout, ts)\n    return t\n}\n\nfunc parseInt(s string) int {\n    i, _ := strconv.Atoi(s)\n    return i\n}\n\nfunc getLogLevel(status int) string {\n    if status &gt;= 500 {\n        return \"ERROR\"\n    } else if status &gt;= 400 {\n        return \"WARN\"\n    } else if status &gt;= 300 {\n        return \"INFO\"\n    }\n    return \"DEBUG\"\n}\n\nfunc main() {\n    parser := NewLogParser()\n\n    // Sample log lines\n    logLines := []struct {\n        line   string\n        format string\n    }{\n        {\n            `127.0.0.1 - - [10/Oct/2023:13:55:36 -0700] \"GET /index.html HTTP/1.1\" 200 2326`,\n            \"apache\",\n        },\n        {\n            `192.168.1.1 - - [10/Oct/2023:13:56:01 -0700] \"POST /api/users HTTP/1.1\" 404 1234`,\n            \"apache\",\n        },\n        {\n            `2023-11-15 14:30:45 [INFO] User login successful user:123 ip:192.168.1.100 status:200`,\n            \"custom\",\n        },\n        {\n            `2023-11-15 14:31:02 [ERROR] Database connection failed status:500`,\n            \"custom\",\n        },\n    }\n\n    for _, logData := range logLines {\n        entry, err := parser.ParseLog(logData.line, logData.format)\n        if err != nil {\n            fmt.Printf(\"Error parsing log: %v\\n\", err)\n            continue\n        }\n\n        fmt.Printf(\"Parsed Entry:\\n\")\n        fmt.Printf(\"  Timestamp: %s\\n\", entry.Timestamp.Format(\"2006-01-02 15:04:05\"))\n        fmt.Printf(\"  Level: %s\\n\", entry.Level)\n        fmt.Printf(\"  Message: %s\\n\", entry.Message)\n        if entry.IP != \"\" {\n            fmt.Printf(\"  IP: %s\\n\", entry.IP)\n        }\n        if entry.UserID != \"\" {\n            fmt.Printf(\"  User ID: %s\\n\", entry.UserID)\n        }\n        if entry.Status != 0 {\n            fmt.Printf(\"  Status: %d\\n\", entry.Status)\n        }\n        fmt.Println()\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Multiple Log Formats:</li> <li>Supports Apache, Nginx, and custom log formats</li> <li>Each format has its own regex pattern</li> <li> <p>Flexible parsing based on format type</p> </li> <li> <p>Structured Data Extraction:</p> </li> <li>Extracts timestamps, IP addresses, user IDs</li> <li>Parses HTTP status codes</li> <li> <p>Determines log levels based on status</p> </li> <li> <p>Helper Functions:</p> </li> <li>Time parsing for different formats</li> <li>Integer conversion for status codes</li> <li> <p>Log level determination</p> </li> <li> <p>Error Handling:</p> </li> <li>Graceful handling of parsing errors</li> <li>Clear error messages for debugging</li> </ol>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Log Analysis:</li> <li>Parse application logs</li> <li>Extract metrics and statistics</li> <li> <p>Identify error patterns</p> </li> <li> <p>Security Monitoring:</p> </li> <li>Detect suspicious IP addresses</li> <li>Identify failed login attempts</li> <li> <p>Monitor for unusual activity</p> </li> <li> <p>Data Processing:</p> </li> <li>Extract structured data from text</li> <li>Transform unstructured logs to JSON</li> <li>Feed data into analytics systems</li> </ol>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#1-pre-compile-patterns","title":"1. Pre-compile Patterns","text":"<pre><code>// Good: Pre-compile for reuse\nvar emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)\n\nfunc validateEmail(email string) bool {\n    return emailRegex.MatchString(email)\n}\n\n// Bad: Compile on every call\nfunc validateEmailBad(email string) bool {\n    re, _ := regexp.Compile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)\n    return re.MatchString(email)\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#2-use-specific-patterns","title":"2. Use Specific Patterns","text":"<pre><code>// Good: Specific pattern\nre := regexp.MustCompile(`^user_\\d+$`)\n\n// Bad: Too general pattern\nre = regexp.MustCompile(`user.*`)\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#3-avoid-catastrophic-backtracking","title":"3. Avoid Catastrophic Backtracking","text":"<pre><code>// Dangerous: Nested quantifiers can cause exponential backtracking\nre := regexp.MustCompile(`(a+)+`)\n\n// Better: More specific pattern\nre = regexp.MustCompile(`a+`)\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/16.%20Regular-Expression/#1-write-readable-patterns","title":"1. Write Readable Patterns","text":"<pre><code>// Use comments and raw strings for complex patterns\npattern := `^\n    (\\d{4})-  # Year\n    (\\d{2})-  # Month\n    (\\d{2})   # Day\n$`\nre := regexp.MustCompile(pattern)\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#2-test-your-patterns","title":"2. Test Your Patterns","text":"<pre><code>func TestEmailRegex(t *testing.T) {\n    tests := []struct {\n        email string\n        valid bool\n    }{\n        {\"user@example.com\", true},\n        {\"invalid-email\", false},\n        {\"@domain.com\", false},\n    }\n\n    for _, test := range tests {\n        result := validateEmail(test.email)\n        if result != test.valid {\n            t.Errorf(\"Email %s: expected %v, got %v\", test.email, test.valid, result)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>func safeFindString(re *regexp.Regexp, str string) string {\n    match := re.FindString(str)\n    if match == \"\" {\n        return \"default\"\n    }\n    return match\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#conclusion","title":"Conclusion","text":"<p>Regular expressions are a powerful tool for text processing in Go. The <code>regexp</code> package provides efficient and safe regex operations based on RE2. By mastering regular expressions, you can:</p> <ol> <li>Extract and Validate Data:</li> <li>Parse structured text like logs, emails, URLs</li> <li>Validate user input</li> <li> <p>Extract specific information from documents</p> </li> <li> <p>Transform Text:</p> </li> <li>Replace patterns dynamically</li> <li>Reformat strings</li> <li> <p>Clean and normalize data</p> </li> <li> <p>Build Powerful Text Processing Tools:</p> </li> <li>Log analyzers</li> <li>Data scrapers</li> <li>Input validators</li> </ol> <p>The log parser example demonstrates how regex can be used to build sophisticated text processing systems that handle multiple formats and extract structured information efficiently.</p> <p>Key takeaways: 1. Pre-compile regex patterns for better performance 2. Use specific patterns to avoid false matches 3. Test your patterns thoroughly with various inputs 4. Handle errors gracefully when patterns don't match 5. Be mindful of performance with complex patterns</p> <p>Regular expressions are an essential skill for any Go developer working with text processing, data validation, or parsing tasks. With practice, you'll be able to write efficient and reliable regex patterns for any text processing need.</p>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/","title":"Time and Epoch in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#introduction-to-time-handling-in-go","title":"Introduction to Time Handling in Go","text":"<p>Go's <code>time</code> package provides comprehensive functionality for measuring and displaying time. Understanding how to work with time is crucial for logging, scheduling, caching, and many other common programming tasks. This guide covers time representation, formatting, epoch time, and time operations.</p>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#basic-time-representation","title":"Basic Time Representation","text":""},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#1-the-timetime-type","title":"1. The <code>time.Time</code> Type","text":"<p>The <code>time.Time</code> type represents an instant in time with nanosecond precision:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    // Get current time\n    now := time.Now()\n    fmt.Printf(\"Current time: %v\\n\", now)\n    fmt.Printf(\"Type: %T\\n\", now)\n\n    // Create a specific time\n    t := time.Date(2023, time.November, 15, 14, 30, 0, 0, time.UTC)\n    fmt.Printf(\"Specific time: %v\\n\", t)\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#2-time-components","title":"2. Time Components","text":"<p>Access individual components of a time:</p> <pre><code>func main() {\n    t := time.Now()\n\n    fmt.Printf(\"Year: %d\\n\", t.Year())\n    fmt.Printf(\"Month: %d\\n\", t.Month())    // Month as int (1-12)\n    fmt.Printf(\"Month: %s\\n\", t.Month().String()) // Month as string\n    fmt.Printf(\"Day: %d\\n\", t.Day())\n    fmt.Printf(\"Hour: %d\\n\", t.Hour())\n    fmt.Printf(\"Minute: %d\\n\", t.Minute())\n    fmt.Printf(\"Second: %d\\n\", t.Second())\n    fmt.Printf(\"Nanosecond: %d\\n\", t.Nanosecond())\n    fmt.Printf(\"Weekday: %s\\n\", t.Weekday())\n    fmt.Printf(\"Year day: %d\\n\", t.YearDay())\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#epoch-time-unix-timestamp","title":"Epoch Time (Unix Timestamp)","text":""},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#1-converting-to-unix-timestamp","title":"1. Converting to Unix Timestamp","text":"<p>Epoch time (Unix timestamp) represents seconds since January 1, 1970 UTC:</p> <pre><code>func main() {\n    now := time.Now()\n\n    // Unix timestamp in seconds\n    unixSec := now.Unix()\n    fmt.Printf(\"Unix timestamp (seconds): %d\\n\", unixSec)\n\n    // Unix timestamp in milliseconds\n    unixMilli := now.UnixMilli()\n    fmt.Printf(\"Unix timestamp (milliseconds): %d\\n\", unixMilli)\n\n    // Unix timestamp in microseconds\n    unixMicro := now.UnixMicro()\n    fmt.Printf(\"Unix timestamp (microseconds): %d\\n\", unixMicro)\n\n    // Unix timestamp in nanoseconds\n    unixNano := now.UnixNano()\n    fmt.Printf(\"Unix timestamp (nanoseconds): %d\\n\", unixNano)\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#2-creating-time-from-unix-timestamp","title":"2. Creating Time from Unix Timestamp","text":"<pre><code>func main() {\n    // From seconds\n    t1 := time.Unix(1699999999, 0)\n    fmt.Printf(\"From seconds: %v\\n\", t1)\n\n    // From milliseconds\n    t2 := time.Unix(0, 1699999999000000000)\n    fmt.Printf(\"From nanoseconds: %v\\n\", t2)\n\n    // Current timestamp and back\n    now := time.Now()\n    timestamp := now.Unix()\n    reconstructed := time.Unix(timestamp, 0)\n    fmt.Printf(\"Original: %v\\n\", now)\n    fmt.Printf(\"Reconstructed: %v\\n\", reconstructed)\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#time-formatting-and-parsing","title":"Time Formatting and Parsing","text":""},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#1-formatting-time","title":"1. Formatting Time","text":"<p>Go uses a unique reference time for formatting: <code>Mon Jan 2 15:04:05 MST 2006</code></p> <pre><code>func main() {\n    t := time.Now()\n\n    // Predefined formats\n    fmt.Println(\"RFC1123:\", t.Format(time.RFC1123))\n    fmt.Println(\"RFC3339:\", t.Format(time.RFC3339))\n    fmt.Println(\"Kitchen:\", t.Format(time.Kitchen))\n\n    // Custom formats\n    fmt.Println(\"Custom:\", t.Format(\"2006-01-02 15:04:05\"))\n    fmt.Println(\"Custom:\", t.Format(\"Jan 2, 2006 at 3:04pm\"))\n    fmt.Println(\"Custom:\", t.Format(\"02/01/2006\")) // DD/MM/YYYY\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#2-parsing-time","title":"2. Parsing Time","text":"<p>Parse strings into time using the same reference format:</p> <pre><code>func main() {\n    // Parse with predefined layouts\n    t1, err := time.Parse(time.RFC3339, \"2023-11-15T14:30:00Z\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Parsed RFC3339:\", t1)\n\n    // Parse with custom layout\n    t2, err := time.Parse(\"2006-01-02\", \"2023-11-15\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Parsed custom:\", t2)\n\n    // Parse with time zone\n    t3, err := time.Parse(\"2006-01-02 15:04:05 -0700\", \"2023-11-15 14:30:00 -0500\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Parsed with timezone:\", t3)\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#time-operations","title":"Time Operations","text":""},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#1-time-arithmetic","title":"1. Time Arithmetic","text":"<pre><code>func main() {\n    now := time.Now()\n\n    // Add duration\n    later := now.Add(24 * time.Hour) // Add 24 hours\n    fmt.Printf(\"24 hours later: %v\\n\", later)\n\n    // Subtract duration\n    earlier := now.Add(-7 * 24 * time.Hour) // Subtract 7 days\n    fmt.Printf(\"7 days earlier: %v\\n\", earlier)\n\n    // Add specific units\n    nextYear := now.AddDate(1, 0, 0) // Add 1 year\n    nextMonth := now.AddDate(0, 1, 0) // Add 1 month\n    nextDay := now.AddDate(0, 0, 1)   // Add 1 day\n\n    fmt.Printf(\"Next year: %v\\n\", nextYear)\n    fmt.Printf(\"Next month: %v\\n\", nextMonth)\n    fmt.Printf(\"Next day: %v\\n\", nextDay)\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#2-time-comparison","title":"2. Time Comparison","text":"<pre><code>func main() {\n    t1 := time.Date(2023, time.November, 15, 12, 0, 0, 0, time.UTC)\n    t2 := time.Date(2023, time.November, 15, 14, 0, 0, 0, time.UTC)\n    t3 := time.Date(2023, time.November, 15, 12, 0, 0, 0, time.UTC)\n\n    // Before and After\n    fmt.Printf(\"t1 before t2: %v\\n\", t1.Before(t2)) // true\n    fmt.Printf(\"t1 after t2: %v\\n\", t1.After(t2))   // false\n\n    // Equal\n    fmt.Printf(\"t1 equal t3: %v\\n\", t1.Equal(t3)) // true\n\n    // Sub returns duration between times\n    duration := t2.Sub(t1)\n    fmt.Printf(\"Duration between t2 and t1: %v\\n\", duration)\n    fmt.Printf(\"Duration in hours: %.2f\\n\", duration.Hours())\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#3-time-difference","title":"3. Time Difference","text":"<pre><code>func main() {\n    start := time.Now()\n\n    // Simulate some work\n    time.Sleep(100 * time.Millisecond)\n\n    end := time.Now()\n\n    elapsed := end.Sub(start)\n    fmt.Printf(\"Elapsed time: %v\\n\", elapsed)\n    fmt.Printf(\"Elapsed milliseconds: %d\\n\", elapsed.Milliseconds())\n    fmt.Printf(\"Elapsed microseconds: %d\\n\", elapsed.Microseconds())\n    fmt.Printf(\"Elapsed nanoseconds: %d\\n\", elapsed.Nanoseconds())\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#duration","title":"Duration","text":""},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#1-working-with-durations","title":"1. Working with Durations","text":"<p><code>time.Duration</code> represents the elapsed time between two instants:</p> <pre><code>func main() {\n    // Creating durations\n    d1 := 2 * time.Hour\n    d2 := 30 * time.Minute\n    d3 := 1000 * time.Millisecond\n    d4 := 500 * time.Microsecond\n    d5 := 200 * time.Nanosecond\n\n    fmt.Printf(\"2 hours: %v\\n\", d1)\n    fmt.Printf(\"30 minutes: %v\\n\", d2)\n    fmt.Printf(\"1000 milliseconds: %v\\n\", d3)\n    fmt.Printf(\"500 microseconds: %v\\n\", d4)\n    fmt.Printf(\"200 nanoseconds: %v\\n\", d5)\n\n    // Duration arithmetic\n    total := d1 + d2\n    fmt.Printf(\"2 hours + 30 minutes: %v\\n\", total)\n\n    // Duration conversion\n    fmt.Printf(\"2 hours in minutes: %.0f\\n\", d1.Minutes())\n    fmt.Printf(\"2 hours in seconds: %.0f\\n\", d1.Seconds())\n    fmt.Printf(\"1000ms in seconds: %.3f\\n\", d3.Seconds())\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#2-parsing-durations","title":"2. Parsing Durations","text":"<pre><code>func main() {\n    // Parse duration from string\n    d1, err := time.ParseDuration(\"1h30m\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Parsed duration: %v\\n\", d1)\n\n    d2, err := time.ParseDuration(\"100ms\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Parsed duration: %v\\n\", d2)\n\n    // Valid duration units: ns, us, ms, s, m, h\n    durations := []string{\n        \"1ns\", \"1us\", \"1ms\", \"1s\", \"1m\", \"1h\",\n        \"1h30m\", \"1.5h\", \"90m\", \"3600s\",\n    }\n\n    for _, dStr := range durations {\n        d, err := time.ParseDuration(dStr)\n        if err != nil {\n            fmt.Printf(\"Error parsing %q: %v\\n\", dStr, err)\n        } else {\n            fmt.Printf(\"%q = %v\\n\", dStr, d)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#time-zones-and-locations","title":"Time Zones and Locations","text":""},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#1-working-with-time-zones","title":"1. Working with Time Zones","text":"<pre><code>func main() {\n    // Get current time in different time zones\n    now := time.Now()\n\n    // UTC\n    utc := now.UTC()\n    fmt.Printf(\"UTC: %v\\n\", utc)\n\n    // Local time zone\n    local := now.Local()\n    fmt.Printf(\"Local: %v\\n\", local)\n\n    // Specific time zones\n    locations := []string{\n        \"America/New_York\",\n        \"Europe/London\",\n        \"Asia/Tokyo\",\n        \"Australia/Sydney\",\n    }\n\n    for _, locName := range locations {\n        loc, err := time.LoadLocation(locName)\n        if err != nil {\n            fmt.Printf(\"Error loading location %s: %v\\n\", locName, err)\n            continue\n        }\n\n        t := now.In(loc)\n        fmt.Printf(\"%s: %v\\n\", locName, t)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#2-creating-time-with-time-zones","title":"2. Creating Time with Time Zones","text":"<pre><code>func main() {\n    // Create time in specific time zone\n    loc, err := time.LoadLocation(\"America/New_York\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    // Create time in New York\n    nyTime := time.Date(2023, time.November, 15, 14, 30, 0, 0, loc)\n    fmt.Printf(\"New York time: %v\\n\", nyTime)\n\n    // Convert to UTC\n    utcTime := nyTime.UTC()\n    fmt.Printf(\"UTC time: %v\\n\", utcTime)\n\n    // Convert to another time zone\n    tokyoLoc, _ := time.LoadLocation(\"Asia/Tokyo\")\n    tokyoTime := nyTime.In(tokyoLoc)\n    fmt.Printf(\"Tokyo time: %v\\n\", tokyoTime)\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#real-world-example-event-scheduler","title":"Real-World Example: Event Scheduler","text":"<p>Let's build a comprehensive event scheduler that demonstrates various time operations:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"time\"\n)\n\n// Event represents a scheduled event\ntype Event struct {\n    ID          string\n    Title       string\n    Description string\n    StartTime   time.Time\n    EndTime     time.Time\n    Location    string\n    TimeZone    *time.Location\n}\n\n// EventScheduler manages events\ntype EventScheduler struct {\n    events []Event\n}\n\nfunc NewEventScheduler() *EventScheduler {\n    return &amp;EventScheduler{\n        events: make([]Event, 0),\n    }\n}\n\nfunc (es *EventScheduler) AddEvent(event Event) error {\n    // Validate event times\n    if event.EndTime.Before(event.StartTime) {\n        return fmt.Errorf(\"end time cannot be before start time\")\n    }\n\n    es.events = append(es.events, event)\n    return nil\n}\n\nfunc (es *EventScheduler) GetUpcomingEvents(limit int) []Event {\n    now := time.Now()\n    var upcoming []Event\n\n    for _, event := range es.events {\n        if event.StartTime.After(now) {\n            upcoming = append(upcoming, event)\n        }\n    }\n\n    // Sort by start time\n    sort.Slice(upcoming, func(i, j int) bool {\n        return upcoming[i].StartTime.Before(upcoming[j].StartTime)\n    })\n\n    if len(upcoming) &gt; limit {\n        upcoming = upcoming[:limit]\n    }\n\n    return upcoming\n}\n\nfunc (es *EventScheduler) GetEventsInDateRange(start, end time.Time) []Event {\n    var eventsInRange []Event\n\n    for _, event := range es.events {\n        if (event.StartTime.Equal(start) || event.StartTime.After(start)) &amp;&amp;\n            (event.StartTime.Equal(end) || event.StartTime.Before(end)) {\n            eventsInRange = append(eventsInRange, event)\n        }\n    }\n\n    return eventsInRange\n}\n\nfunc (es *EventScheduler) GetEventsByLocation(location string) []Event {\n    var eventsByLocation []Event\n\n    for _, event := range es.events {\n        if event.Location == location {\n            eventsByLocation = append(eventsByLocation, event)\n        }\n    }\n\n    return eventsByLocation\n}\n\nfunc (es *EventScheduler) GetEventDuration(eventID string) (time.Duration, error) {\n    for _, event := range es.events {\n        if event.ID == eventID {\n            return event.EndTime.Sub(event.StartTime), nil\n        }\n    }\n    return 0, fmt.Errorf(\"event not found\")\n}\n\nfunc (es *EventScheduler) RescheduleEvent(eventID string, newStart, newEnd time.Time) error {\n    for i, event := range es.events {\n        if event.ID == eventID {\n            if newEnd.Before(newStart) {\n                return fmt.Errorf(\"end time cannot be before start time\")\n            }\n\n            es.events[i].StartTime = newStart\n            es.events[i].EndTime = newEnd\n            return nil\n        }\n    }\n    return fmt.Errorf(\"event not found\")\n}\n\nfunc (es *EventScheduler) ConvertEventTimezone(eventID string, newLoc *time.Location) (*Event, error) {\n    for _, event := range es.events {\n        if event.ID == eventID {\n            // Create a copy of the event\n            newEvent := event\n            newEvent.StartTime = event.StartTime.In(newLoc)\n            newEvent.EndTime = event.EndTime.In(newLoc)\n            newEvent.TimeZone = newLoc\n            return &amp;newEvent, nil\n        }\n    }\n    return nil, fmt.Errorf(\"event not found\")\n}\n\nfunc (es *EventScheduler) PrintEvents() {\n    fmt.Println(\"\\n=== All Events ===\")\n    for _, event := range es.events {\n        fmt.Printf(\"\\nID: %s\\n\", event.ID)\n        fmt.Printf(\"Title: %s\\n\", event.Title)\n        fmt.Printf(\"Description: %s\\n\", event.Description)\n        fmt.Printf(\"Start: %v\\n\", event.StartTime)\n        fmt.Printf(\"End: %v\\n\", event.EndTime)\n        fmt.Printf(\"Duration: %v\\n\", event.EndTime.Sub(event.StartTime))\n        fmt.Printf(\"Location: %s\\n\", event.Location)\n        if event.TimeZone != nil {\n            fmt.Printf(\"Time Zone: %s\\n\", event.TimeZone)\n        }\n    }\n}\n\nfunc main() {\n    // Create scheduler\n    scheduler := NewEventScheduler()\n\n    // Load time zones\n    nyLoc, _ := time.LoadLocation(\"America/New_York\")\n    tokyoLoc, _ := time.LoadLocation(\"Asia/Tokyo\")\n\n    // Create events\n    events := []Event{\n        {\n            ID:          \"1\",\n            Title:       \"Team Meeting\",\n            Description: \"Weekly team sync\",\n            StartTime:   time.Date(2023, time.November, 20, 10, 0, 0, 0, nyLoc),\n            EndTime:     time.Date(2023, time.November, 20, 11, 0, 0, 0, nyLoc),\n            Location:    \"Conference Room A\",\n            TimeZone:    nyLoc,\n        },\n        {\n            ID:          \"2\",\n            Title:       \"Lunch with Client\",\n            Description: \"Discuss project requirements\",\n            StartTime:   time.Date(2023, time.November, 20, 12, 30, 0, 0, nyLoc),\n            EndTime:     time.Date(2023, time.November, 20, 14, 0, 0, 0, nyLoc),\n            Location:    \"Restaurant Downtown\",\n            TimeZone:    nyLoc,\n        },\n        {\n            ID:          \"3\",\n            Title:       \"Project Deadline\",\n            Description: \"Submit final deliverables\",\n            StartTime:   time.Date(2023, time.November, 25, 17, 0, 0, 0, nyLoc),\n            EndTime:     time.Date(2023, time.November, 25, 18, 0, 0, 0, nyLoc),\n            Location:    \"Office\",\n            TimeZone:    nyLoc,\n        },\n    }\n\n    // Add events\n    for _, event := range events {\n        if err := scheduler.AddEvent(event); err != nil {\n            fmt.Printf(\"Error adding event: %v\\n\", err)\n        }\n    }\n\n    // Print all events\n    scheduler.PrintEvents()\n\n    // Get upcoming events\n    fmt.Println(\"\\n=== Upcoming Events ===\")\n    upcoming := scheduler.GetUpcomingEvents(5)\n    for _, event := range upcoming {\n        fmt.Printf(\"- %s at %v\\n\", event.Title, event.StartTime)\n    }\n\n    // Get events in date range\n    fmt.Println(\"\\n=== Events in Date Range ===\")\n    start := time.Date(2023, time.November, 20, 0, 0, 0, 0, time.UTC)\n    end := time.Date(2023, time.November, 21, 0, 0, 0, 0, time.UTC)\n    eventsInRange := scheduler.GetEventsInDateRange(start, end)\n    for _, event := range eventsInRange {\n        fmt.Printf(\"- %s on %v\\n\", event.Title, event.StartTime)\n    }\n\n    // Get event duration\n    fmt.Println(\"\\n=== Event Durations ===\")\n    duration, err := scheduler.GetEventDuration(\"1\")\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n    } else {\n        fmt.Printf(\"Team meeting duration: %v\\n\", duration)\n    }\n\n    // Convert event timezone\n    fmt.Println(\"\\n=== Timezone Conversion ===\")\n    convertedEvent, err := scheduler.ConvertEventTimezone(\"1\", tokyoLoc)\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n    } else {\n        fmt.Printf(\"Team meeting in Tokyo time:\\n\")\n        fmt.Printf(\"Start: %v\\n\", convertedEvent.StartTime)\n        fmt.Printf(\"End: %v\\n\", convertedEvent.EndTime)\n    }\n\n    // Reschedule event\n    fmt.Println(\"\\n=== Rescheduling Event ===\")\n    newStart := time.Date(2023, time.November, 20, 9, 0, 0, 0, nyLoc)\n    newEnd := time.Date(2023, time.November, 20, 10, 30, 0, 0, nyLoc)\n    err = scheduler.RescheduleEvent(\"1\", newStart, newEnd)\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n    } else {\n        fmt.Println(\"Event rescheduled successfully\")\n        scheduler.PrintEvents()\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Event Management:</li> <li>Create, store, and manage events with time zones</li> <li>Validate event times (end after start)</li> <li> <p>Support multiple time zones</p> </li> <li> <p>Query Operations:</p> </li> <li>Get upcoming events sorted by time</li> <li>Filter events by date range</li> <li> <p>Find events by location</p> </li> <li> <p>Time Operations:</p> </li> <li>Calculate event durations</li> <li>Convert between time zones</li> <li> <p>Reschedule events</p> </li> <li> <p>Time Zone Handling:</p> </li> <li>Store events with specific time zones</li> <li>Convert times between zones</li> <li>Display times in local format</li> </ol>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Calendar Applications:</li> <li>Personal or shared calendars</li> <li>Meeting scheduling</li> <li> <p>Reminder systems</p> </li> <li> <p>Booking Systems:</p> </li> <li>Hotel reservations</li> <li>Flight bookings</li> <li> <p>Appointment scheduling</p> </li> <li> <p>Monitoring Systems:</p> </li> <li>Scheduled maintenance</li> <li>Alert timing</li> <li> <p>Report generation</p> </li> <li> <p>Distributed Systems:</p> </li> <li>Coordinating events across time zones</li> <li>Logging with timestamps</li> <li>Expiring cache entries</li> </ol>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#best-practices-for-time-handling","title":"Best Practices for Time Handling","text":""},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#1-always-use-utc-for-storage","title":"1. Always Use UTC for Storage","text":"<pre><code>// Good: Store times in UTC\nfunc SaveToDatabase(t time.Time) {\n    utcTime := t.UTC()\n    // Save utcTime to database\n}\n\n// Bad: Store local time\nfunc SaveToDatabaseBad(t time.Time) {\n    // Save t directly - might cause issues with time zones\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#2-be-explicit-about-time-zones","title":"2. Be Explicit About Time Zones","text":"<pre><code>// Good: Specify time zone\nt := time.Date(2023, time.November, 15, 12, 0, 0, 0, time.UTC)\n\n// Bad: Assume local time zone\nt := time.Date(2023, time.November, 15, 12, 0, 0, 0, time.Local)\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#3-use-duration-for-time-intervals","title":"3. Use Duration for Time Intervals","text":"<pre><code>// Good: Use duration\ntimeout := 30 * time.Second\n\n// Bad: Use magic numbers\ntimeout := 30000000000 // 30 seconds in nanoseconds\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#4-handle-time-parsing-errors","title":"4. Handle Time Parsing Errors","text":"<pre><code>func parseTime(layout, value string) (time.Time, error) {\n    t, err := time.Parse(layout, value)\n    if err != nil {\n        return time.Time{}, fmt.Errorf(\"invalid time format: %w\", err)\n    }\n    return t, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#5-use-consistent-time-formats","title":"5. Use Consistent Time Formats","text":"<pre><code>const (\n    APILayout     = \"2006-01-02T15:04:05Z\"\n    DatabaseLayout = \"2006-01-02 15:04:05.999999999-07:00\"\n    DisplayLayout  = \"Jan 2, 2006 at 3:04pm\"\n)\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#1-avoid-repeated-time-zone-loading","title":"1. Avoid Repeated Time Zone Loading","text":"<pre><code>// Good: Load time zone once\nvar nyLoc *time.Location\n\nfunc init() {\n    nyLoc, _ = time.LoadLocation(\"America/New_York\")\n}\n\nfunc getNYTime() time.Time {\n    return time.Now().In(nyLoc)\n}\n\n// Bad: Load time zone on every call\nfunc getNYTimeBad() time.Time {\n    nyLoc, _ := time.LoadLocation(\"America/New_York\")\n    return time.Now().In(nyLoc)\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#2-use-timeafter-for-delays","title":"2. Use <code>time.After</code> for Delays","text":"<pre><code>// Good: Use time.After\nselect {\ncase &lt;-time.After(5 * time.Second):\n    fmt.Println(\"Timeout\")\ncase result := &lt;-ch:\n    fmt.Println(\"Received:\", result)\n}\n\n// Bad: Use time.Sleep in goroutine\ngo func() {\n    time.Sleep(5 * time.Second)\n    fmt.Println(\"Timeout\")\n}()\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#conclusion","title":"Conclusion","text":"<p>Time handling is a critical aspect of many Go applications. The <code>time</code> package provides comprehensive tools for:</p> <ol> <li>Representing Time:</li> <li>Precise time representation with nanosecond accuracy</li> <li>Support for time zones and locations</li> <li> <p>Easy access to time components</p> </li> <li> <p>Working with Epoch Time:</p> </li> <li>Convert between time and Unix timestamps</li> <li>Handle different precision levels (seconds, milliseconds, etc.)</li> <li> <p>Reconstruct time from timestamps</p> </li> <li> <p>Formatting and Parsing:</p> </li> <li>Flexible formatting with reference time</li> <li>Parse various time formats</li> <li> <p>Handle time zones in formatting</p> </li> <li> <p>Time Operations:</p> </li> <li>Arithmetic operations (add, subtract)</li> <li>Comparisons (before, after, equal)</li> <li> <p>Duration calculations</p> </li> <li> <p>Time Zone Management:</p> </li> <li>Convert between time zones</li> <li>Load specific time zone information</li> <li>Handle daylight saving time automatically</li> </ol> <p>The event scheduler example demonstrates how to build a practical application that handles complex time operations, including time zone conversions, event scheduling, and time-based queries. By mastering Go's time package, you can build reliable applications that work correctly across different time zones and handle time-related operations efficiently.</p> <p>Key takeaways: 1. Use UTC for internal storage and convert to local time for display 2. Be explicit about time zones to avoid ambiguity 3. Handle time parsing errors gracefully 4. Use durations for time intervals 5. Consider performance when working with time zones</p> <p>Time handling might seem simple, but it's full of edge cases (leap seconds, daylight saving time, time zone changes). Go's <code>time</code> package handles most of these complexities for you, making it easier to write correct time-related code.</p>"},{"location":"2.%20Intermediate/18.%20Random-Number/","title":"Random Numbers in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/18.%20Random-Number/#introduction-to-random-number-generation","title":"Introduction to Random Number Generation","text":"<p>Random numbers are essential for many applications including games, simulations, cryptography, statistical sampling, and more. Go provides two main packages for random number generation: - <code>math/rand</code>: Pseudorandom number generation suitable for simulations, games, and non-cryptographic purposes - <code>crypto/rand</code>: Cryptographically secure random number generation for security-sensitive applications</p>"},{"location":"2.%20Intermediate/18.%20Random-Number/#basic-random-number-generation","title":"Basic Random Number Generation","text":""},{"location":"2.%20Intermediate/18.%20Random-Number/#1-simple-random-numbers","title":"1. Simple Random Numbers","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n)\n\nfunc main() {\n    // Generate random integers\n    fmt.Println(\"Random integer:\", rand.Int())        // Random non-negative integer\n    fmt.Println(\"Random int31:\", rand.Int31())       // Random 31-bit integer\n    fmt.Println(\"Random int63:\", rand.Int63())       // Random 63-bit integer\n    fmt.Println(\"Random uint32:\", rand.Uint32())     // Random 32-bit unsigned integer\n    fmt.Println(\"Random float64:\", rand.Float64())   // Random float64 in [0.0, 1.0)\n    fmt.Println(\"Random float32:\", rand.Float32())   // Random float32 in [0.0, 1.0)\n\n    // Generate random numbers in a specific range\n    fmt.Println(\"Random intn(10):\", rand.Intn(10))  // Random integer in [0, 10)\n    fmt.Println(\"Random int31n(10):\", rand.Int31n(10)) // Random 31-bit integer in [0, 10)\n    fmt.Println(\"Random int63n(10):\", rand.Int63n(10)) // Random 63-bit integer in [0, 10)\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#2-seeding-the-random-number-generator","title":"2. Seeding the Random Number Generator","text":"<p>By default, the random number generator produces the same sequence of numbers each time. To get different sequences, you need to seed it:</p> <pre><code>func main() {\n    // Without seeding - same sequence every time\n    fmt.Println(\"Without seeding:\")\n    for i := 0; i &lt; 3; i++ {\n        fmt.Println(rand.Intn(100))\n    }\n\n    // With seeding - different sequence each run\n    fmt.Println(\"\\nWith seeding:\")\n    rand.Seed(time.Now().UnixNano()) // Seed with current time\n    for i := 0; i &lt; 3; i++ {\n        fmt.Println(rand.Intn(100))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#generating-random-numbers-in-a-range","title":"Generating Random Numbers in a Range","text":""},{"location":"2.%20Intermediate/18.%20Random-Number/#1-integer-range","title":"1. Integer Range","text":"<pre><code>// Generate random integer in [min, max]\nfunc randomInt(min, max int) int {\n    return min + rand.Intn(max-min+1)\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    // Generate random numbers between 50 and 100\n    for i := 0; i &lt; 5; i++ {\n        fmt.Printf(\"Random between 50-100: %d\\n\", randomInt(50, 100))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#2-float-range","title":"2. Float Range","text":"<pre><code>// Generate random float64 in [min, max)\nfunc randomFloat(min, max float64) float64 {\n    return min + rand.Float64()*(max-min)\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    // Generate random floats between 1.0 and 10.0\n    for i := 0; i &lt; 5; i++ {\n        fmt.Printf(\"Random float 1.0-10.0: %.2f\\n\", randomFloat(1.0, 10.0))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#working-with-different-data-types","title":"Working with Different Data Types","text":""},{"location":"2.%20Intermediate/18.%20Random-Number/#1-random-booleans","title":"1. Random Booleans","text":"<pre><code>func randomBool() bool {\n    return rand.Intn(2) == 1\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    for i := 0; i &lt; 5; i++ {\n        fmt.Printf(\"Random boolean: %t\\n\", randomBool())\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#2-random-strings","title":"2. Random Strings","text":"<pre><code>const charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\nfunc randomString(length int) string {\n    b := make([]byte, length)\n    for i := range b {\n        b[i] = charset[rand.Intn(len(charset))]\n    }\n    return string(b)\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    // Generate random strings of different lengths\n    fmt.Println(\"Random string (8):\", randomString(8))\n    fmt.Println(\"Random string (16):\", randomString(16))\n    fmt.Println(\"Random string (32):\", randomString(32))\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#3-random-bytes","title":"3. Random Bytes","text":"<pre><code>func randomBytes(length int) []byte {\n    b := make([]byte, length)\n    rand.Read(b) // Fill slice with random bytes\n    return b\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    // Generate random byte slices\n    bytes := randomBytes(16)\n    fmt.Printf(\"Random bytes: %x\\n\", bytes)\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#cryptographically-secure-random-numbers","title":"Cryptographically Secure Random Numbers","text":""},{"location":"2.%20Intermediate/18.%20Random-Number/#1-using-cryptorand","title":"1. Using crypto/rand","text":"<p>For security-sensitive applications like generating tokens, keys, or passwords:</p> <pre><code>package main\n\nimport (\n    \"crypto/rand\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"math/big\"\n)\n\nfunc main() {\n    // Generate random integer\n    n, _ := rand.Int(rand.Reader, big.NewInt(1000))\n    fmt.Println(\"Secure random int:\", n)\n\n    // Generate random bytes\n    bytes := make([]byte, 32)\n    _, err := rand.Read(bytes)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Secure random bytes: %x\\n\", bytes)\n\n    // Generate random hex string\n    hexStr := hex.EncodeToString(bytes)\n    fmt.Println(\"Secure random hex:\", hexStr)\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#2-secure-random-string-generation","title":"2. Secure Random String Generation","text":"<pre><code>const secureCharset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()\"\n\nfunc secureRandomString(length int) (string, error) {\n    b := make([]byte, length)\n\n    // Read random bytes\n    _, err := rand.Read(b)\n    if err != nil {\n        return \"\", err\n    }\n\n    // Map bytes to charset\n    for i := range b {\n        b[i] = secureCharset[b[i]%byte(len(secureCharset))]\n    }\n\n    return string(b), nil\n}\n\nfunc main() {\n    // Generate secure random strings\n    for i := 8; i &lt;= 32; i += 8 {\n        str, err := secureRandomString(i)\n        if err != nil {\n            fmt.Println(\"Error:\", err)\n            continue\n        }\n        fmt.Printf(\"Secure random string (%d): %s\\n\", i, str)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#shuffling-and-sampling","title":"Shuffling and Sampling","text":""},{"location":"2.%20Intermediate/18.%20Random-Number/#1-shuffling-a-slice","title":"1. Shuffling a Slice","text":"<pre><code>func main() {\n    rand.Seed(time.Now().UnixNano())\n\n    // Create a slice\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n    fmt.Println(\"Original:\", numbers)\n\n    // Shuffle the slice\n    rand.Shuffle(len(numbers), func(i, j int) {\n        numbers[i], numbers[j] = numbers[j], numbers[i]\n    })\n    fmt.Println(\"Shuffled:\", numbers)\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#2-random-sampling","title":"2. Random Sampling","text":"<pre><code>// Sample n items from a slice without replacement\nfunc sample[T any](slice []T, n int) []T {\n    if n &gt; len(slice) {\n        n = len(slice)\n    }\n\n    // Create a copy to avoid modifying original\n    sample := make([]T, n)\n    copy(sample, slice)\n\n    // Shuffle the sample\n    rand.Shuffle(len(sample), func(i, j int) {\n        sample[i], sample[j] = sample[j], sample[i]\n    })\n\n    return sample[:n]\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    // Sample from a slice\n    words := []string{\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\"}\n    fmt.Println(\"Sample 3 words:\", sample(words, 3))\n    fmt.Println(\"Sample 5 words:\", sample(words, 5))\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#3-weighted-random-selection","title":"3. Weighted Random Selection","text":"<pre><code>type WeightedItem struct {\n    Item   interface{}\n    Weight int\n}\n\nfunc weightedRandom(items []WeightedItem) interface{} {\n    // Calculate total weight\n    totalWeight := 0\n    for _, item := range items {\n        totalWeight += item.Weight\n    }\n\n    // Generate random number up to total weight\n    r := rand.Intn(totalWeight)\n\n    // Find the item\n    runningWeight := 0\n    for _, item := range items {\n        runningWeight += item.Weight\n        if r &lt; runningWeight {\n            return item.Item\n        }\n    }\n\n    return items[len(items)-1].Item\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    // Define weighted items\n    items := []WeightedItem{\n        {\"Apple\", 10},\n        {\"Banana\", 30},\n        {\"Cherry\", 60},\n    }\n\n    // Test weighted selection\n    counts := make(map[string]int)\n    for i := 0; i &lt; 1000; i++ {\n        item := weightedRandom(items).(string)\n        counts[item]++\n    }\n\n    fmt.Println(\"Weighted random selection results:\")\n    for item, count := range counts {\n        fmt.Printf(\"%s: %d\\n\", item, count)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#random-distributions","title":"Random Distributions","text":""},{"location":"2.%20Intermediate/18.%20Random-Number/#1-normal-distribution","title":"1. Normal Distribution","text":"<pre><code>// Generate normally distributed random number (Box-Muller transform)\nfunc normalRandom(mean, stdDev float64) float64 {\n    u1 := rand.Float64()\n    u2 := rand.Float64()\n\n    // Box-Muller transform\n    z0 := math.Sqrt(-2*math.Log(u1)) * math.Cos(2*math.Pi*u2)\n    return z0*stdDev + mean\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    // Generate normally distributed numbers\n    fmt.Println(\"Normal distribution (mean=0, std=1):\")\n    for i := 0; i &lt; 10; i++ {\n        fmt.Printf(\"%.4f\\n\", normalRandom(0, 1))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#2-exponential-distribution","title":"2. Exponential Distribution","text":"<pre><code>// Generate exponentially distributed random number\nfunc exponentialRandom(lambda float64) float64 {\n    return -math.Log(1-rand.Float64()) / lambda\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    // Generate exponentially distributed numbers\n    fmt.Println(\"Exponential distribution (lambda=1.0):\")\n    for i := 0; i &lt; 10; i++ {\n        fmt.Printf(\"%.4f\\n\", exponentialRandom(1.0))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#real-world-example-dice-game-simulator","title":"Real-World Example: Dice Game Simulator","text":"<p>Let's build a comprehensive dice game simulator that demonstrates various random number concepts:</p> <pre><code>package main\n\nimport (\n    \"crypto/rand\"\n    \"fmt\"\n    \"math/big\"\n    \"math/rand\"\n    \"time\"\n)\n\n// Dice represents a multi-sided die\ntype Dice struct {\n    Sides int\n}\n\n// Roll simulates rolling the dice\nfunc (d *Dice) Roll() int {\n    return rand.Intn(d.Sides) + 1\n}\n\n// DiceGame represents a dice game\ntype DiceGame struct {\n    Dice       []Dice\n    Players    []Player\n    Round      int\n    MaxRounds int\n}\n\n// Player represents a game player\ntype Player struct {\n    Name   string\n    Score  int\n    Wins   int\n    IsHuman bool\n}\n\n// NewDiceGame creates a new dice game\nfunc NewDiceGame(playerNames []string, diceSides []int, maxRounds int) *DiceGame {\n    game := &amp;DiceGame{\n        MaxRounds: maxRounds,\n        Round:     1,\n    }\n\n    // Create dice\n    for _, sides := range diceSides {\n        game.Dice = append(game.Dice, Dice{Sides: sides})\n    }\n\n    // Create players\n    for i, name := range playerNames {\n        game.Players = append(game.Players, Player{\n            Name:   name,\n            IsHuman: i == 0, // First player is human\n        })\n    }\n\n    return game\n}\n\n// PlayRound plays one round of the game\nfunc (g *DiceGame) PlayRound() {\n    fmt.Printf(\"\\n=== Round %d ===\\n\", g.Round)\n\n    for i := range g.Players {\n        player := &amp;g.Players[i]\n        roundScore := 0\n\n        fmt.Printf(\"%s's turn:\\n\", player.Name)\n\n        // Roll each die\n        for j, die := range g.Dice {\n            roll := die.Roll()\n            roundScore += roll\n            fmt.Printf(\"  Die %d (d%d): %d\\n\", j+1, die.Sides, roll)\n        }\n\n        player.Score += roundScore\n        fmt.Printf(\"  Round score: %d, Total score: %d\\n\", roundScore, player.Score)\n    }\n\n    g.Round++\n}\n\n// GetWinner returns the player with the highest score\nfunc (g *DiceGame) GetWinner() *Player {\n    winner := &amp;g.Players[0]\n    for _, player := range g.Players {\n        if player.Score &gt; winner.Score {\n            winner = &amp;player\n        }\n    }\n    return winner\n}\n\n// Play plays the entire game\nfunc (g *DiceGame) Play() {\n    fmt.Println(\"Starting Dice Game!\")\n    fmt.Printf(\"Players: %v\\n\", getPlayerNames(g.Players))\n    fmt.Printf(\"Dice: %v\\n\", getDiceSides(g.Dice))\n    fmt.Printf(\"Max rounds: %d\\n\", g.MaxRounds)\n\n    for g.Round &lt;= g.MaxRounds {\n        g.PlayRound()\n    }\n\n    // Announce winner\n    winner := g.GetWinner()\n    winner.Wins++\n    fmt.Printf(\"\\n=== Game Over ===\\n\")\n    fmt.Printf(\"Winner: %s with %d points!\\n\", winner.Name, winner.Score)\n\n    // Show final scores\n    fmt.Println(\"\\nFinal Scores:\")\n    for _, player := range g.Players {\n        fmt.Printf(\"%s: %d points\\n\", player.Name, player.Score)\n    }\n}\n\n// Helper functions\nfunc getPlayerNames(players []Player) []string {\n    names := make([]string, len(players))\n    for i, player := range players {\n        names[i] = player.Name\n    }\n    return names\n}\n\nfunc getDiceSides(dice []Dice) []int {\n    sides := make([]int, len(dice))\n    for i, die := range dice {\n        sides[i] = die.Sides\n    }\n    return sides\n}\n\n// MonteCarloSimulation runs multiple game simulations\ntype MonteCarloSimulation struct {\n    GameConfig struct {\n        PlayerNames []string\n        DiceSides   []int\n        MaxRounds   int\n    }\n    NumSimulations int\n}\n\nfunc NewMonteCarloSimulation(numSimulations int, playerNames []string, diceSides []int, maxRounds int) *MonteCarloSimulation {\n    return &amp;MonteCarloSimulation{\n        NumSimulations: numSimulations,\n        GameConfig: struct {\n            PlayerNames []string\n            DiceSides   []int\n            MaxRounds   int\n        }{\n            PlayerNames: playerNames,\n            DiceSides:   diceSides,\n            MaxRounds:   maxRounds,\n        },\n    }\n}\n\nfunc (mcs *MonteCarloSimulation) Run() map[string]int {\n    winCounts := make(map[string]int)\n\n    for i := 0; i &lt; mcs.NumSimulations; i++ {\n        // Create a new game for each simulation\n        game := NewDiceGame(\n            mcs.GameConfig.PlayerNames,\n            mcs.GameConfig.DiceSides,\n            mcs.GameConfig.MaxRounds,\n        )\n\n        // Play the game\n        for game.Round &lt;= game.MaxRounds {\n            game.PlayRound()\n        }\n\n        // Record winner\n        winner := game.GetWinner()\n        winCounts[winner.Name]++\n    }\n\n    return winCounts\n}\n\n// SecureRandomToken generates a cryptographically secure random token\nfunc SecureRandomToken(length int) (string, error) {\n    b := make([]byte, length)\n    _, err := rand.Read(b)\n    if err != nil {\n        return \"\", err\n    }\n    return hex.EncodeToString(b)[:length], nil\n}\n\nfunc main() {\n    // Seed the random number generator\n    rand.Seed(time.Now().UnixNano())\n\n    // Play a single game\n    fmt.Println(\"=== Single Game ===\")\n    playerNames := []string{\"Alice\", \"Bob\", \"Charlie\"}\n    diceSides := []int{6, 6, 20} // Two d6 and one d20\n    maxRounds := 5\n\n    game := NewDiceGame(playerNames, diceSides, maxRounds)\n    game.Play()\n\n    // Run Monte Carlo simulation\n    fmt.Println(\"\\n=== Monte Carlo Simulation ===\")\n    simulation := NewMonteCarloSimulation(1000, playerNames, diceSides, maxRounds)\n    winCounts := simulation.Run()\n\n    fmt.Printf(\"Win probabilities after %d simulations:\\n\", simulation.NumSimulations)\n    for name, wins := range winCounts {\n        probability := float64(wins) / float64(simulation.NumSimulations) * 100\n        fmt.Printf(\"%s: %.1f%% (%d wins)\\n\", name, probability, wins)\n    }\n\n    // Generate secure random tokens\n    fmt.Println(\"\\n=== Secure Random Tokens ===\")\n    for i := 16; i &lt;= 64; i += 16 {\n        token, err := SecureRandomToken(i)\n        if err != nil {\n            fmt.Printf(\"Error generating token: %v\\n\", err)\n            continue\n        }\n        fmt.Printf(\"Token (%d): %s\\n\", i, token)\n    }\n\n    // Demonstrate weighted random selection\n    fmt.Println(\"\\n=== Weighted Random Selection ===\")\n    loot := []WeightedItem{\n        {\"Common Sword\", 60},\n        {\"Rare Shield\", 30},\n        {\"Epic Armor\", 9},\n        {\"Legendary Sword\", 1},\n    }\n\n    drops := make(map[string]int)\n    for i := 0; i &lt; 1000; i++ {\n        item := weightedRandom(loot).(string)\n        drops[item]++\n    }\n\n    fmt.Println(\"Loot drop rates:\")\n    for item, count := range drops {\n        rate := float64(count) / 10 // Convert to percentage\n        fmt.Printf(\"%s: %.1f%%\\n\", item, rate)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Dice Game Simulation:</li> <li>Models a multi-player dice game with different die types</li> <li>Tracks scores across multiple rounds</li> <li> <p>Determines the winner based on total score</p> </li> <li> <p>Monte Carlo Simulation:</p> </li> <li>Runs thousands of game simulations</li> <li>Calculates win probabilities for each player</li> <li> <p>Demonstrates statistical analysis of random events</p> </li> <li> <p>Secure Random Generation:</p> </li> <li>Generates cryptographically secure tokens</li> <li>Uses <code>crypto/rand</code> for security-sensitive applications</li> <li> <p>Shows proper error handling</p> </li> <li> <p>Weighted Random Selection:</p> </li> <li>Implements loot drop system with different rarities</li> <li>Demonstrates probability-based selection</li> <li>Shows statistical distribution of results</li> </ol>"},{"location":"2.%20Intermediate/18.%20Random-Number/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Gaming:</li> <li>Dice games and card games</li> <li>Loot drop systems</li> <li> <p>Procedural content generation</p> </li> <li> <p>Simulations:</p> </li> <li>Monte Carlo methods for risk analysis</li> <li>Scientific simulations</li> <li> <p>Financial modeling</p> </li> <li> <p>Security:</p> </li> <li>Generating secure tokens and passwords</li> <li>Cryptographic key generation</li> <li> <p>Session identifiers</p> </li> <li> <p>Data Analysis:</p> </li> <li>Random sampling for statistics</li> <li>A/B testing</li> <li>Machine learning (e.g., random forests)</li> </ol>"},{"location":"2.%20Intermediate/18.%20Random-Number/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/18.%20Random-Number/#1-always-seed-the-random-generator","title":"1. Always Seed the Random Generator","text":"<pre><code>// Good: Seed with current time\nfunc init() {\n    rand.Seed(time.Now().UnixNano())\n}\n\n// Bad: No seeding - same sequence every time\nfunc badRandom() {\n    fmt.Println(rand.Intn(100)) // Always same value\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#2-use-cryptorand-for-security","title":"2. Use crypto/rand for Security","text":"<pre><code>// Good: Use crypto/rand for security\nfunc generateToken() (string, error) {\n    b := make([]byte, 32)\n    _, err := rand.Read(b)\n    if err != nil {\n        return \"\", err\n    }\n    return hex.EncodeToString(b), nil\n}\n\n// Bad: Use math/rand for security\nfunc generateTokenBad() string {\n    b := make([]byte, 32)\n    rand.Read(b) // Not cryptographically secure\n    return hex.EncodeToString(b)\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#3-handle-range-correctly","title":"3. Handle Range Correctly","text":"<pre><code>// Good: Correct range [min, max]\nfunc randomInt(min, max int) int {\n    return min + rand.Intn(max-min+1)\n}\n\n// Bad: Off-by-one error\nfunc randomIntBad(min, max int) int {\n    return min + rand.Intn(max-min) // Excludes max\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#4-reuse-random-sources","title":"4. Reuse Random Sources","text":"<pre><code>// Good: Create once, reuse many times\nvar globalRand = rand.New(rand.NewSource(time.Now().UnixNano()))\n\nfunc randomInt() int {\n    return globalRand.Intn(100)\n}\n\n// Bad: Create new source each time\nfunc randomIntBad() int {\n    r := rand.New(rand.NewSource(time.Now().UnixNano()))\n    return r.Intn(100)\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/18.%20Random-Number/#1-use-randread-for-bulk-random-data","title":"1. Use rand.Read for Bulk Random Data","text":"<pre><code>// Good: Use rand.Read for bulk data\nfunc randomBytes(n int) []byte {\n    b := make([]byte, n)\n    rand.Read(b)\n    return b\n}\n\n// Bad: Generate byte by byte\nfunc randomBytesBad(n int) []byte {\n    b := make([]byte, n)\n    for i := range b {\n        b[i] = byte(rand.Intn(256))\n    }\n    return b\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#2-pre-allocate-for-random-strings","title":"2. Pre-allocate for Random Strings","text":"<pre><code>// Good: Pre-allocate slice\nfunc randomString(n int) string {\n    b := make([]byte, n)\n    for i := range b {\n        b[i] = charset[rand.Intn(len(charset))]\n    }\n    return string(b)\n}\n\n// Bad: String concatenation\nfunc randomStringBad(n int) string {\n    var s string\n    for i := 0; i &lt; n; i++ {\n        s += string(charset[rand.Intn(len(charset))])\n    }\n    return s\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#conclusion","title":"Conclusion","text":"<p>Random number generation is a fundamental tool in Go programming with applications across many domains. By understanding both <code>math/rand</code> and <code>crypto/rand</code>, you can:</p> <ol> <li>Generate Random Data:</li> <li>Integers, floats, and booleans</li> <li>Strings and byte slices</li> <li> <p>Custom data structures</p> </li> <li> <p>Implement Random Algorithms:</p> </li> <li>Shuffling and sampling</li> <li>Weighted selection</li> <li> <p>Monte Carlo simulations</p> </li> <li> <p>Build Secure Applications:</p> </li> <li>Generate tokens and passwords</li> <li>Create cryptographic keys</li> <li> <p>Implement secure protocols</p> </li> <li> <p>Create Engaging Experiences:</p> </li> <li>Games and simulations</li> <li>Procedural content</li> <li>Randomized user interfaces</li> </ol> <p>The dice game simulator demonstrates how to combine various random number concepts to build a complete application that includes both simple random generation and complex statistical analysis. By following best practices and choosing the right package for your needs, you can implement robust and efficient random number generation in your Go applications.</p> <p>Key takeaways: 1. Use <code>math/rand</code> for simulations, games, and non-cryptographic purposes 2. Use <code>crypto/rand</code> for security-sensitive applications 3. Always seed your random generator for different sequences 4. Handle ranges correctly to avoid off-by-one errors 5. Consider performance when generating large amounts of random data</p> <p>Random numbers might seem simple, but they're a powerful tool when used correctly. With Go's excellent random number generation capabilities, you can build everything from simple games to complex cryptographic systems.</p>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/","title":"Number Parsing in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/19.%20Number-Parsing/#introduction-to-number-parsing","title":"Introduction to Number Parsing","text":"<p>Number parsing is the process of converting string representations of numbers into their corresponding numeric types. In Go, this is a common operation when dealing with user input, configuration files, network protocols, and data interchange formats. Go provides robust built-in functions for parsing numbers with proper error handling.</p>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#basic-integer-parsing","title":"Basic Integer Parsing","text":""},{"location":"2.%20Intermediate/19.%20Number-Parsing/#1-parsing-integers","title":"1. Parsing Integers","text":"<p>The <code>strconv</code> package provides functions for parsing integers from strings:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc main() {\n    // ParseInt with base 10\n    i, err := strconv.ParseInt(\"123\", 10, 64)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Parsed int64: %d, type: %T\\n\", i, i)\n\n    // ParseInt with different bases\n    bases := []int{2, 8, 10, 16}\n    numbers := []string{\"1010\", \"755\", \"123\", \"FF\"}\n\n    for i := range bases {\n        n, err := strconv.ParseInt(numbers[i], bases[i], 64)\n        if err != nil {\n            fmt.Printf(\"Error parsing %s in base %d: %v\\n\", numbers[i], bases[i], err)\n            continue\n        }\n        fmt.Printf(\"%s (base %d) = %d (decimal)\\n\", numbers[i], bases[i], n)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#2-parsing-with-specific-bit-sizes","title":"2. Parsing with Specific Bit Sizes","text":"<pre><code>func main() {\n    // Parse to int8\n    i8, err := strconv.ParseInt(\"127\", 10, 8)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"int8: %d\\n\", int8(i8))\n    }\n\n    // Parse to int16\n    i16, err := strconv.ParseInt(\"32767\", 10, 16)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"int16: %d\\n\", int16(i16))\n    }\n\n    // Parse to int32\n    i32, err := strconv.ParseInt(\"2147483647\", 10, 32)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"int32: %d\\n\", int32(i32))\n    }\n\n    // Parse to int64\n    i64, err := strconv.ParseInt(\"9223372036854775807\", 10, 64)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"int64: %d\\n\", i64)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#3-parsing-unsigned-integers","title":"3. Parsing Unsigned Integers","text":"<pre><code>func main() {\n    // ParseUint\n    u, err := strconv.ParseUint(\"4294967295\", 10, 64)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Parsed uint64: %d, type: %T\\n\", u, u)\n\n    // Parse to uint8\n    u8, err := strconv.ParseUint(\"255\", 10, 8)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"uint8: %d\\n\", uint8(u8))\n    }\n\n    // Parse to uint16\n    u16, err := strconv.ParseUint(\"65535\", 10, 16)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"uint16: %d\\n\", uint16(u16))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#floating-point-parsing","title":"Floating-Point Parsing","text":""},{"location":"2.%20Intermediate/19.%20Number-Parsing/#1-parsing-floats","title":"1. Parsing Floats","text":"<pre><code>func main() {\n    // ParseFloat to float64\n    f64, err := strconv.ParseFloat(\"3.14159\", 64)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Parsed float64: %f, type: %T\\n\", f64, f64)\n\n    // ParseFloat to float32\n    f32, err := strconv.ParseFloat(\"3.14159\", 32)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"Parsed float32: %f, type: %T\\n\", float32(f32), f32)\n    }\n\n    // Scientific notation\n    sci, err := strconv.ParseFloat(\"1.23e-4\", 64)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"Scientific notation: %g\\n\", sci)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#2-special-floating-point-values","title":"2. Special Floating-Point Values","text":"<pre><code>func main() {\n    // Parse special values\n    specialValues := []string{\"inf\", \"+Inf\", \"-Inf\", \"NaN\"}\n\n    for _, val := range specialValues {\n        f, err := strconv.ParseFloat(val, 64)\n        if err != nil {\n            fmt.Printf(\"Error parsing %s: %v\\n\", val, err)\n            continue\n        }\n        fmt.Printf(\"%s -&gt; %f\\n\", val, f)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#convenience-functions","title":"Convenience Functions","text":""},{"location":"2.%20Intermediate/19.%20Number-Parsing/#1-atoi-and-itoa","title":"1. Atoi and Itoa","text":"<p>For simple base-10 integer conversion:</p> <pre><code>func main() {\n    // Atoi (ASCII to integer)\n    i, err := strconv.Atoi(\"123\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Atoi result: %d, type: %T\\n\", i, i)\n\n    // Itoa (integer to ASCII)\n    s := strconv.Itoa(456)\n    fmt.Printf(\"Itoa result: %s, type: %T\\n\", s, s)\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#2-parsebool","title":"2. ParseBool","text":"<pre><code>func main() {\n    // Parse boolean values\n    boolStrings := []string{\"true\", \"false\", \"1\", \"0\", \"t\", \"f\", \"TRUE\", \"FALSE\"}\n\n    for _, s := range boolStrings {\n        b, err := strconv.ParseBool(s)\n        if err != nil {\n            fmt.Printf(\"Error parsing %q: %v\\n\", s, err)\n            continue\n        }\n        fmt.Printf(\"%q -&gt; %t\\n\", s, b)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#advanced-parsing-techniques","title":"Advanced Parsing Techniques","text":""},{"location":"2.%20Intermediate/19.%20Number-Parsing/#1-parsing-with-custom-formats","title":"1. Parsing with Custom Formats","text":"<pre><code>func main() {\n    // Parse number with commas\n    numWithCommas := \"1,234,567\"\n\n    // Remove commas before parsing\n    cleaned := strings.ReplaceAll(numWithCommas, \",\", \"\")\n    num, err := strconv.ParseInt(cleaned, 10, 64)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Number with commas: %d\\n\", num)\n\n    // Parse currency\n    currency := \"$1,234.56\"\n    cleaned = strings.ReplaceAll(currency, \"$\", \"\")\n    cleaned = strings.ReplaceAll(cleaned, \",\", \"\")\n    f, err := strconv.ParseFloat(cleaned, 64)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Currency: %.2f\\n\", f)\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#2-parsing-number-ranges","title":"2. Parsing Number Ranges","text":"<pre><code>func parseRange(s string) (min, max int, err error) {\n    parts := strings.Split(s, \"-\")\n    if len(parts) != 2 {\n        return 0, 0, fmt.Errorf(\"invalid range format\")\n    }\n\n    min, err = strconv.Atoi(strings.TrimSpace(parts[0]))\n    if err != nil {\n        return 0, 0, fmt.Errorf(\"invalid min value: %w\", err)\n    }\n\n    max, err = strconv.Atoi(strings.TrimSpace(parts[1]))\n    if err != nil {\n        return 0, 0, fmt.Errorf(\"invalid max value: %w\", err)\n    }\n\n    if min &gt; max {\n        return 0, 0, fmt.Errorf(\"min cannot be greater than max\")\n    }\n\n    return min, max, nil\n}\n\nfunc main() {\n    ranges := []string{\"1-10\", \"100-200\", \"50-25\"}\n\n    for _, r := range ranges {\n        min, max, err := parseRange(r)\n        if err != nil {\n            fmt.Printf(\"Error parsing %q: %v\\n\", r, err)\n            continue\n        }\n        fmt.Printf(\"Range %q: %d to %d\\n\", r, min, max)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#3-parsing-multiple-numbers-from-a-string","title":"3. Parsing Multiple Numbers from a String","text":"<pre><code>func parseNumbers(s string) ([]int, error) {\n    fields := strings.Fields(s)\n    numbers := make([]int, 0, len(fields))\n\n    for _, field := range fields {\n        num, err := strconv.Atoi(field)\n        if err != nil {\n            return nil, fmt.Errorf(\"invalid number %q: %w\", field, err)\n        }\n        numbers = append(numbers, num)\n    }\n\n    return numbers, nil\n}\n\nfunc main() {\n    data := \"10 20 30 40 50\"\n    numbers, err := parseNumbers(data)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Printf(\"Parsed numbers: %v\\n\", numbers)\n    fmt.Printf(\"Sum: %d\\n\", sum(numbers))\n}\n\nfunc sum(numbers []int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#error-handling","title":"Error Handling","text":""},{"location":"2.%20Intermediate/19.%20Number-Parsing/#1-common-parsing-errors","title":"1. Common Parsing Errors","text":"<pre><code>func main() {\n    // Invalid number format\n    _, err := strconv.ParseInt(\"abc\", 10, 64)\n    fmt.Printf(\"ParseInt error: %v\\n\", err) // strconv.ParseInt: parsing \"abc\": invalid syntax\n\n    // Out of range\n    _, err = strconv.ParseInt(\"999999999999999999999999999999\", 10, 64)\n    fmt.Printf(\"ParseInt error: %v\\n\", err) // strconv.ParseInt: parsing \"999999999999999999999999999999\": value out of range\n\n    // Invalid base\n    _, err = strconv.ParseInt(\"123\", 37, 64) // Base must be between 2 and 36\n    fmt.Printf(\"ParseInt error: %v\\n\", err)\n\n    // Empty string\n    _, err = strconv.ParseInt(\"\", 10, 64)\n    fmt.Printf(\"ParseInt error: %v\\n\", err)\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#2-safe-parsing-with-defaults","title":"2. Safe Parsing with Defaults","text":"<pre><code>func safeParseInt(s string, defaultValue int64) int64 {\n    if s == \"\" {\n        return defaultValue\n    }\n\n    i, err := strconv.ParseInt(s, 10, 64)\n    if err != nil {\n        return defaultValue\n    }\n\n    return i\n}\n\nfunc main() {\n    values := []string{\"123\", \"abc\", \"\", \"999999999999999999999999999999\"}\n    defaultValue := int64(0)\n\n    for _, val := range values {\n        result := safeParseInt(val, defaultValue)\n        fmt.Printf(\"safeParseInt(%q, %d) = %d\\n\", val, defaultValue, result)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#3-parsing-with-validation","title":"3. Parsing with Validation","text":"<pre><code>func parsePositiveInt(s string) (int, error) {\n    i, err := strconv.Atoi(s)\n    if err != nil {\n        return 0, fmt.Errorf(\"invalid integer: %w\", err)\n    }\n\n    if i &lt;= 0 {\n        return 0, fmt.Errorf(\"value must be positive\")\n    }\n\n    return i, nil\n}\n\nfunc parsePercentage(s string) (float64, error) {\n    f, err := strconv.ParseFloat(s, 64)\n    if err != nil {\n        return 0, fmt.Errorf(\"invalid percentage: %w\", err)\n    }\n\n    if f &lt; 0 || f &gt; 100 {\n        return 0, fmt.Errorf(\"percentage must be between 0 and 100\")\n    }\n\n    return f, nil\n}\n\nfunc main() {\n    // Test positive integer parsing\n    intTests := []string{\"10\", \"-5\", \"0\", \"abc\"}\n    for _, test := range intTests {\n        result, err := parsePositiveInt(test)\n        if err != nil {\n            fmt.Printf(\"parsePositiveInt(%q): %v\\n\", test, err)\n        } else {\n            fmt.Printf(\"parsePositiveInt(%q): %d\\n\", test, result)\n        }\n    }\n\n    // Test percentage parsing\n    percentTests := []string{\"50\", \"150\", \"-10\", \"abc\"}\n    for _, test := range percentTests {\n        result, err := parsePercentage(test)\n        if err != nil {\n            fmt.Printf(\"parsePercentage(%q): %v\\n\", test, err)\n        } else {\n            fmt.Printf(\"parsePercentage(%q): %.1f%%\\n\", test, result)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#real-world-example-configuration-parser","title":"Real-World Example: Configuration Parser","text":"<p>Let's build a comprehensive configuration parser that handles various number formats:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n)\n\n// Config represents application configuration\ntype Config struct {\n    ServerPort     int\n    MaxConnections int\n    Timeout        time.Duration\n    CacheSize      int64\n    DebugMode      bool\n    Threshold      float64\n    RetryCount     int\n}\n\n// ConfigParser handles parsing configuration values\ntype ConfigParser struct {\n    values map[string]string\n}\n\nfunc NewConfigParser(values map[string]string) *ConfigParser {\n    return &amp;ConfigParser{\n        values: values,\n    }\n}\n\nfunc (cp *ConfigParser) Parse() (*Config, error) {\n    config := &amp;Config{}\n\n    // Parse server port\n    port, err := cp.parseInt(\"server_port\", 8080, 1, 65535)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid server_port: %w\", err)\n    }\n    config.ServerPort = port\n\n    // Parse max connections\n    maxConn, err := cp.parseInt(\"max_connections\", 100, 1, 10000)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid max_connections: %w\", err)\n    }\n    config.MaxConnections = maxConn\n\n    // Parse timeout (supports duration strings)\n    timeout, err := cp.parseDuration(\"timeout\", 30*time.Second)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid timeout: %w\", err)\n    }\n    config.Timeout = timeout\n\n    // Parse cache size (supports K, M, G suffixes)\n    cacheSize, err := cp.parseSize(\"cache_size\", 1024*1024) // Default 1MB\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid cache_size: %w\", err)\n    }\n    config.CacheSize = cacheSize\n\n    // Parse debug mode\n    debug, err := cp.parseBool(\"debug_mode\", false)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid debug_mode: %w\", err)\n    }\n    config.DebugMode = debug\n\n    // Parse threshold\n    threshold, err := cp.parseFloat(\"threshold\", 0.5, 0.0, 1.0)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid threshold: %w\", err)\n    }\n    config.Threshold = threshold\n\n    // Parse retry count\n    retryCount, err := cp.parseInt(\"retry_count\", 3, 0, 10)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid retry_count: %w\", err)\n    }\n    config.RetryCount = retryCount\n\n    return config, nil\n}\n\nfunc (cp *ConfigParser) parseInt(key string, defaultValue, min, max int) (int, error) {\n    value, exists := cp.values[key]\n    if !exists || value == \"\" {\n        return defaultValue, nil\n    }\n\n    i, err := strconv.Atoi(value)\n    if err != nil {\n        return 0, fmt.Errorf(\"invalid integer: %w\", err)\n    }\n\n    if i &lt; min || i &gt; max {\n        return 0, fmt.Errorf(\"value %d is out of range [%d, %d]\", i, min, max)\n    }\n\n    return i, nil\n}\n\nfunc (cp *ConfigParser) parseFloat(key string, defaultValue, min, max float64) (float64, error) {\n    value, exists := cp.values[key]\n    if !exists || value == \"\" {\n        return defaultValue, nil\n    }\n\n    f, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        return 0, fmt.Errorf(\"invalid float: %w\", err)\n    }\n\n    if f &lt; min || f &gt; max {\n        return 0, fmt.Errorf(\"value %f is out of range [%f, %f]\", f, min, max)\n    }\n\n    return f, nil\n}\n\nfunc (cp *ConfigParser) parseBool(key string, defaultValue bool) (bool, error) {\n    value, exists := cp.values[key]\n    if !exists || value == \"\" {\n        return defaultValue, nil\n    }\n\n    b, err := strconv.ParseBool(value)\n    if err != nil {\n        return false, fmt.Errorf(\"invalid boolean: %w\", err)\n    }\n\n    return b, nil\n}\n\nfunc (cp *ConfigParser) parseDuration(key string, defaultValue time.Duration) (time.Duration, error) {\n    value, exists := cp.values[key]\n    if !exists || value == \"\" {\n        return defaultValue, nil\n    }\n\n    // Try to parse as duration string first\n    duration, err := time.ParseDuration(value)\n    if err == nil {\n        return duration, nil\n    }\n\n    // If that fails, try to parse as seconds\n    seconds, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        return 0, fmt.Errorf(\"invalid duration: %w\", err)\n    }\n\n    return time.Duration(seconds * float64(time.Second)), nil\n}\n\nfunc (cp *ConfigParser) parseSize(key string, defaultValue int64) (int64, error) {\n    value, exists := cp.values[key]\n    if !exists || value == \"\" {\n        return defaultValue, nil\n    }\n\n    // Check for size suffixes\n    suffixes := map[string]int64{\n        \"K\": 1024,\n        \"M\": 1024 * 1024,\n        \"G\": 1024 * 1024 * 1024,\n        \"T\": 1024 * 1024 * 1024 * 1024,\n    }\n\n    for suffix, multiplier := range suffixes {\n        if strings.HasSuffix(value, suffix) {\n            numStr := strings.TrimSuffix(value, suffix)\n            num, err := strconv.ParseInt(numStr, 10, 64)\n            if err != nil {\n                return 0, fmt.Errorf(\"invalid size: %w\", err)\n            }\n            return num * multiplier, nil\n        }\n    }\n\n    // No suffix, parse as bytes\n    return strconv.ParseInt(value, 10, 64)\n}\n\nfunc main() {\n    // Sample configuration values\n    configValues := map[string]string{\n        \"server_port\":     \"8080\",\n        \"max_connections\": \"100\",\n        \"timeout\":        \"30s\",\n        \"cache_size\":     \"2M\",\n        \"debug_mode\":     \"true\",\n        \"threshold\":      \"0.75\",\n        \"retry_count\":    \"3\",\n    }\n\n    // Parse configuration\n    parser := NewConfigParser(configValues)\n    config, err := parser.Parse()\n    if err != nil {\n        fmt.Printf(\"Error parsing configuration: %v\\n\", err)\n        return\n    }\n\n    // Print parsed configuration\n    fmt.Println(\"=== Parsed Configuration ===\")\n    fmt.Printf(\"Server Port: %d\\n\", config.ServerPort)\n    fmt.Printf(\"Max Connections: %d\\n\", config.MaxConnections)\n    fmt.Printf(\"Timeout: %v\\n\", config.Timeout)\n    fmt.Printf(\"Cache Size: %d bytes\\n\", config.CacheSize)\n    fmt.Printf(\"Debug Mode: %t\\n\", config.DebugMode)\n    fmt.Printf(\"Threshold: %.2f\\n\", config.Threshold)\n    fmt.Printf(\"Retry Count: %d\\n\", config.RetryCount)\n\n    // Test error cases\n    fmt.Println(\"\\n=== Testing Error Cases ===\")\n    errorConfigs := []map[string]string{\n        {\"server_port\": \"99999\"}, // Out of range\n        {\"timeout\": \"invalid\"},    // Invalid duration\n        {\"cache_size\": \"2X\"},     // Invalid suffix\n        {\"debug_mode\": \"maybe\"},   // Invalid boolean\n    }\n\n    for i, values := range errorConfigs {\n        fmt.Printf(\"\\nTest case %d:\\n\", i+1)\n        parser := NewConfigParser(values)\n        _, err := parser.Parse()\n        if err != nil {\n            fmt.Printf(\"Expected error: %v\\n\", err)\n        } else {\n            fmt.Println(\"Unexpected success\")\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Configuration Structure:</li> <li>Defines a <code>Config</code> struct with various numeric and boolean fields</li> <li> <p>Supports different data types (int, float64, bool, duration, size)</p> </li> <li> <p>Parser Implementation:</p> </li> <li><code>ConfigParser</code> handles parsing of configuration values</li> <li>Provides type-specific parsing methods with validation</li> <li> <p>Supports default values and range checking</p> </li> <li> <p>Advanced Parsing Features:</p> </li> <li>Duration parsing (supports \"30s\", \"1h\", etc.)</li> <li>Size parsing with suffixes (K, M, G, T)</li> <li>Boolean parsing with multiple formats</li> <li> <p>Range validation for all numeric values</p> </li> <li> <p>Error Handling:</p> </li> <li>Comprehensive error messages</li> <li>Graceful handling of missing values</li> <li>Type-specific validation</li> </ol>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Application Configuration:</li> <li>Environment variable parsing</li> <li>Configuration file parsing</li> <li> <p>Command-line argument processing</p> </li> <li> <p>Data Validation:</p> </li> <li>User input validation</li> <li>API parameter parsing</li> <li> <p>Form data processing</p> </li> <li> <p>Protocol Handling:</p> </li> <li>Network protocol parsing</li> <li>File format parsing</li> <li>Database result processing</li> </ol>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/19.%20Number-Parsing/#1-always-check-errors","title":"1. Always Check Errors","text":"<pre><code>// Good: Check errors\ni, err := strconv.Atoi(\"123\")\nif err != nil {\n    // Handle error\n}\n\n// Bad: Ignore errors\ni, _ := strconv.Atoi(\"123\") // Might panic on invalid input\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#2-validate-input-ranges","title":"2. Validate Input Ranges","text":"<pre><code>// Good: Validate range\nfunc parsePort(s string) (int, error) {\n    port, err := strconv.Atoi(s)\n    if err != nil {\n        return 0, err\n    }\n    if port &lt; 1 || port &gt; 65535 {\n        return 0, fmt.Errorf(\"port must be between 1 and 65535\")\n    }\n    return port, nil\n}\n\n// Bad: No validation\nfunc parsePortBad(s string) (int, error) {\n    return strconv.Atoi(s)\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#3-provide-default-values","title":"3. Provide Default Values","text":"<pre><code>// Good: Provide defaults\nfunc parseIntWithDefault(s string, defaultValue int) int {\n    if s == \"\" {\n        return defaultValue\n    }\n    i, err := strconv.Atoi(s)\n    if err != nil {\n        return defaultValue\n    }\n    return i\n}\n\n// Bad: No default handling\nfunc parseIntBad(s string) int {\n    i, _ := strconv.Atoi(s)\n    return i\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#4-use-appropriate-types","title":"4. Use Appropriate Types","text":"<pre><code>// Good: Use appropriate bit size\nfunc parseUserID(s string) (int32, error) {\n    i, err := strconv.ParseInt(s, 10, 32)\n    if err != nil {\n        return 0, err\n    }\n    return int32(i), nil\n}\n\n// Bad: Always use int64\nfunc parseUserIDBad(s string) (int64, error) {\n    return strconv.ParseInt(s, 10, 64)\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/19.%20Number-Parsing/#1-reuse-parsers","title":"1. Reuse Parsers","text":"<pre><code>// Good: Reuse scanner\nscanner := bufio.NewScanner(strings.NewReader(\"1 2 3 4 5\"))\nfor scanner.Scan() {\n    num, err := strconv.Atoi(scanner.Text())\n    // ...\n}\n\n// Bad: Create new scanner for each number\ndata := \"1 2 3 4 5\"\nfields := strings.Fields(data)\nfor _, field := range fields {\n    num, err := strconv.Atoi(field)\n    // ...\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#2-batch-processing","title":"2. Batch Processing","text":"<pre><code>// Good: Process in batches\nfunc parseNumbersBatch(data []string) ([]int, error) {\n    numbers := make([]int, len(data))\n    for i, s := range data {\n        num, err := strconv.Atoi(s)\n        if err != nil {\n            return nil, err\n        }\n        numbers[i] = num\n    }\n    return numbers, nil\n}\n\n// Bad: Process one by one with append\nfunc parseNumbersBad(data []string) ([]int, error) {\n    var numbers []int\n    for _, s := range data {\n        num, err := strconv.Atoi(s)\n        if err != nil {\n            return nil, err\n        }\n        numbers = append(numbers, num)\n    }\n    return numbers, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#conclusion","title":"Conclusion","text":"<p>Number parsing is a fundamental operation in Go programming. The <code>strconv</code> package provides comprehensive functions for converting strings to numeric types with proper error handling. By mastering these functions and following best practices, you can:</p> <ol> <li>Parse Various Number Formats:</li> <li>Integers with different bases</li> <li>Floating-point numbers</li> <li>Special values (inf, NaN)</li> <li> <p>Boolean values</p> </li> <li> <p>Handle Edge Cases:</p> </li> <li>Invalid input formats</li> <li>Out-of-range values</li> <li>Missing or empty values</li> <li> <p>Custom formats (currency, sizes, durations)</p> </li> <li> <p>Build Robust Applications:</p> </li> <li>Configuration parsing</li> <li>Input validation</li> <li>Data processing</li> <li>Protocol implementation</li> </ol> <p>The configuration parser example demonstrates how to build a comprehensive parsing system that handles various numeric types, validates ranges, and provides meaningful error messages. By following the patterns shown in this guide, you can create reliable and maintainable code for parsing numbers in your Go applications.</p> <p>Key takeaways: 1. Always check errors when parsing numbers 2. Validate input ranges to prevent invalid values 3. Provide default values for missing or invalid input 4. Use appropriate types (int8, int16, etc.) for your data 5. Handle custom formats (currency, sizes, durations) with preprocessing</p> <p>Number parsing might seem straightforward, but it's full of edge cases that can lead to bugs or security vulnerabilities if not handled properly. With Go's robust standard library and the patterns shown in this guide, you can build reliable and secure number parsing functionality.</p>"},{"location":"2.%20Intermediate/2.%20Recursion/","title":"Go Recursion: Functions That Call Themselves","text":"<p>Overview</p> <p>Master recursion in Go - a powerful programming technique where functions call themselves to solve complex problems by breaking them into smaller, similar subproblems. Learn when to use recursion, common patterns, and Go-specific considerations.</p> <p>Key Points</p> <ul> <li>Recursion requires base cases to prevent infinite loops</li> <li>Go doesn't optimize tail calls, making deep recursion expensive</li> <li>Best suited for naturally recursive problems like tree traversal</li> <li>Consider iterative alternatives for performance-critical code</li> <li>Stack usage grows with recursion depth</li> </ul>"},{"location":"2.%20Intermediate/2.%20Recursion/#understanding-recursion","title":"Understanding Recursion","text":"<p>Recursion is a programming technique where a function calls itself to solve a problem by breaking it down into smaller, similar subproblems.</p> <p>Recursion Components</p> <pre><code>graph TD\n    A[Recursive Function] --&gt; B[Base Case]\n    A --&gt; C[Recursive Case]\n    B --&gt; B1[Stops Recursion]\n    B --&gt; B2[Returns Simple Value]\n    C --&gt; C1[Calls Itself]\n    C --&gt; C2[Modified Parameters]\n    C --&gt; C3[Progress Toward Base]\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#essential-components","title":"Essential Components","text":"<p>Every recursive function must have:</p> <ol> <li>Base Case: Condition that stops the recursion</li> <li>Recursive Case: Function calls itself with modified arguments</li> <li>Progress: Each call moves closer to the base case</li> </ol> <p>Basic Recursion Pattern</p> Factorial FunctionFibonacci SequenceSum of Array factorial.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc factorial(n int) int {\n    if n &lt;= 1 { // Base case\n        return 1\n    }\n    return n * factorial(n-1) // Recursive case\n}\n\nfunc main() {\n    fmt.Println(factorial(5)) // 120 (5*4*3*2*1)\n    fmt.Println(factorial(0)) // 1\n    fmt.Println(factorial(1)) // 1\n}\n</code></pre> fibonacci.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n    if n &lt;= 1 { // Base cases\n        return n\n    }\n    return fibonacci(n-1) + fibonacci(n-2) // Recursive case\n}\n\nfunc main() {\n    for i := 0; i &lt; 10; i++ {\n        fmt.Printf(\"fib(%d) = %d\\n\", i, fibonacci(i))\n    }\n}\n</code></pre> array_sum.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc sumArray(arr []int) int {\n    if len(arr) == 0 { // Base case\n        return 0\n    }\n    return arr[0] + sumArray(arr[1:]) // Recursive case\n}\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n    fmt.Println(sumArray(numbers)) // 15\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#go-specific-considerations","title":"Go-Specific Considerations","text":""},{"location":"2.%20Intermediate/2.%20Recursion/#stack-management","title":"Stack Management","text":"<p>Go uses growable stacks, but recursion still has important limitations.</p> <p>Stack Limitations</p> <p>Go doesn't perform tail call optimization, making deep recursion memory-intensive.</p> <p>Stack Behavior</p> Stack GrowthStack Overflow Risk stack_growth.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc deepRecursion(n int) int {\n    if n == 0 {\n        var m runtime.MemStats\n        runtime.ReadMemStats(&amp;m)\n        fmt.Printf(\"Stack size at depth 0: %d KB\\n\", m.StackInuse/1024)\n        return 0\n    }\n    return 1 + deepRecursion(n-1)\n}\n\nfunc main() {\n    result := deepRecursion(1000)\n    fmt.Printf(\"Result: %d\\n\", result)\n}\n</code></pre> stack_overflow.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc riskyRecursion(n int) int {\n    if n == 0 {\n        return 0\n    }\n    // This could cause stack overflow with large n\n    return 1 + riskyRecursion(n-1)\n}\n\nfunc main() {\n    // Be careful with large values\n    fmt.Println(riskyRecursion(10000)) // May cause issues\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#when-to-use-recursion","title":"When to Use Recursion","text":"<p>Recursion is most appropriate for naturally recursive problems.</p> <p>Good Use Cases</p> Tree Traversal tree_traversal.go<pre><code>package main\n\nimport \"fmt\"\n\ntype TreeNode struct {\n    Value int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc (t *TreeNode) InorderTraversal() {\n    if t == nil { // Base case\n        return\n    }\n    t.Left.InorderTraversal()  // Recursive case\n    fmt.Printf(\"%d \", t.Value)\n    t.Right.InorderTraversal() // Recursive case\n}\n\nfunc main() {\n    root := &amp;TreeNode{\n        Value: 4,\n        Left:  &amp;TreeNode{Value: 2, Left: &amp;TreeNode{Value: 1}, Right: &amp;TreeNode{Value: 3}},\n        Right: &amp;TreeNode{Value: 6, Left: &amp;TreeNode{Value: 5}, Right: &amp;TreeNode{Value: 7}},\n    }\n    root.InorderTraversal() // 1 2 3 4 5 6 7\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#common-recursive-patterns","title":"Common Recursive Patterns","text":""},{"location":"2.%20Intermediate/2.%20Recursion/#linear-recursion","title":"Linear Recursion","text":"<p>Processing elements sequentially, one at a time.</p> <p>Linear Patterns</p> Array SumString Reversal array_sum.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc sum(arr []int) int {\n    if len(arr) == 0 { // Base case\n        return 0\n    }\n    return arr[0] + sum(arr[1:]) // Recursive case\n}\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n    fmt.Println(sum(numbers)) // 15\n}\n</code></pre> string_reverse.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc reverseString(s string) string {\n    if len(s) &lt;= 1 { // Base case\n        return s\n    }\n    return reverseString(s[1:]) + string(s[0]) // Recursive case\n}\n\nfunc main() {\n    fmt.Println(reverseString(\"hello\")) // \"olleh\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#binary-recursion","title":"Binary Recursion","text":"<p>Making two recursive calls, often for divide-and-conquer algorithms.</p> <p>Binary Patterns</p> Binary Search binary_search.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc binarySearch(arr []int, target, low, high int) int {\n    if low &gt; high { // Base case\n        return -1\n    }\n\n    mid := (low + high) / 2\n    if arr[mid] == target {\n        return mid\n    } else if arr[mid] &gt; target {\n        return binarySearch(arr, target, low, mid-1) // Left half\n    } else {\n        return binarySearch(arr, target, mid+1, high) // Right half\n    }\n}\n\nfunc main() {\n    arr := []int{1, 3, 5, 7, 9, 11, 13, 15}\n    result := binarySearch(arr, 7, 0, len(arr)-1)\n    fmt.Printf(\"Element found at index: %d\\n\", result)\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#backtracking","title":"Backtracking","text":"<p>Exploring all possible solutions and backtracking when needed.</p> <p>Backtracking Pattern</p> Generate Permutations permutations.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc generatePermutations(arr []string) [][]string {\n    var result [][]string\n\n    var backtrack func(start int)\n    backtrack = func(start int) {\n        if start == len(arr) { // Base case\n            temp := make([]string, len(arr))\n            copy(temp, arr)\n            result = append(result, temp)\n            return\n        }\n\n        for i := start; i &lt; len(arr); i++ {\n            arr[start], arr[i] = arr[i], arr[start] // Swap\n            backtrack(start + 1)                    // Recurse\n            arr[start], arr[i] = arr[i], arr[start] // Backtrack\n        }\n    }\n\n    backtrack(0)\n    return result\n}\n\nfunc main() {\n    perms := generatePermutations([]string{\"A\", \"B\", \"C\"})\n    for _, perm := range perms {\n        fmt.Println(perm)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/2.%20Recursion/#recursion-vs-iteration","title":"Recursion vs Iteration","text":"<p>Understanding when to choose recursion over iteration is crucial in Go.</p> <p>Comparison Table</p> Aspect Recursion Iteration Performance Slower (function call overhead) Faster (direct execution) Memory Usage Higher (stack frames) Lower (constant space) Readability Better for recursive problems Better for linear processes Stack Limit Risk of stack overflow No stack limit Tail Optimization Not available in Go N/A"},{"location":"2.%20Intermediate/2.%20Recursion/#optimization-techniques","title":"Optimization Techniques","text":"<p>Performance Optimization</p> MemoizationIterative AlternativeTail Recursion (Not Optimized) memoized_fibonacci.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc fibonacci(n int, memo map[int]int) int {\n    if n &lt;= 1 { // Base case\n        return n\n    }\n    if val, ok := memo[n]; ok { // Check cache\n        return val\n    }\n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]\n}\n\nfunc main() {\n    memo := make(map[int]int)\n    fmt.Println(fibonacci(50, memo)) // 12586269025\n}\n</code></pre> iterative_fibonacci.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc fibonacciIterative(n int) int {\n    if n &lt;= 1 {\n        return n\n    }\n\n    a, b := 0, 1\n    for i := 2; i &lt;= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}\n\nfunc main() {\n    fmt.Println(fibonacciIterative(50)) // 12586269025\n}\n</code></pre> tail_recursion.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc fibonacciTail(n, a, b int) int {\n    if n == 0 { // Base case\n        return a\n    }\n    return fibonacciTail(n-1, b, a+b) // Tail call (not optimized in Go)\n}\n\nfunc fibonacci(n int) int {\n    return fibonacciTail(n, 0, 1)\n}\n\nfunc main() {\n    fmt.Println(fibonacci(50)) // Still uses stack frames\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/2.%20Recursion/#essential-guidelines","title":"Essential Guidelines","text":"<p>Follow these practices for effective recursion in Go.</p> <p>Critical Rules</p> <ul> <li>Always define a base case to prevent infinite recursion</li> <li>Ensure each recursive call progresses toward the base case</li> <li>Consider depth limitations for unknown/unbounded problems</li> </ul> <p>Best Practice Patterns</p> Proper Base CaseInput ValidationDepth Limiting proper_base_case.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc countdown(n int) {\n    if n &lt;= 0 { // Clear base case\n        fmt.Println(\"Done!\")\n        return\n    }\n    fmt.Println(n)\n    countdown(n - 1) // Progress toward base case\n}\n\nfunc main() {\n    countdown(5)\n}\n</code></pre> input_validation.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc factorial(n int) int {\n    if n &lt; 0 { // Handle invalid input\n        return -1 // or panic/error\n    }\n    if n &lt;= 1 { // Base case\n        return 1\n    }\n    return n * factorial(n-1)\n}\n\nfunc main() {\n    fmt.Println(factorial(5))  // 120\n    fmt.Println(factorial(-1)) // -1 (error case)\n}\n</code></pre> depth_limiting.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc limitedRecursion(n, maxDepth int) int {\n    if maxDepth &lt;= 0 { // Depth limit reached\n        fmt.Println(\"Max depth reached\")\n        return 0\n    }\n    if n &lt;= 1 { // Base case\n        return 1\n    }\n    return n + limitedRecursion(n-1, maxDepth-1)\n}\n\nfunc main() {\n    result := limitedRecursion(10, 5)\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#real-world-application","title":"Real-World Application","text":""},{"location":"2.%20Intermediate/2.%20Recursion/#file-system-analysis","title":"File System Analysis","text":"<p>A practical example demonstrating recursion for directory traversal and analysis.</p> <p>Directory Analyzer</p> Core Implementation directory_analyzer.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n)\n\ntype FileStats struct {\n    TotalFiles int64\n    TotalSize  int64\n    FileTypes  map[string]int\n}\n\nfunc analyzeDirectory(dir string, stats *FileStats) error {\n    entries, err := os.ReadDir(dir)\n    if err != nil {\n        return err\n    }\n\n    for _, entry := range entries {\n        fullPath := filepath.Join(dir, entry.Name())\n\n        if entry.IsDir() {\n            // Recursive call for subdirectories\n            if err := analyzeDirectory(fullPath, stats); err != nil {\n                return err\n            }\n        } else {\n            // Process file\n            info, err := entry.Info()\n            if err != nil {\n                continue\n            }\n\n            stats.TotalFiles++\n            stats.TotalSize += info.Size()\n\n            ext := filepath.Ext(entry.Name())\n            if ext == \"\" {\n                ext = \"no_extension\"\n            }\n            stats.FileTypes[ext]++\n        }\n    }\n    return nil\n}\n\nfunc main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Println(\"Usage: go run analyzer.go &lt;directory&gt;\")\n        return\n    }\n\n    stats := &amp;FileStats{\n        FileTypes: make(map[string]int),\n    }\n\n    if err := analyzeDirectory(os.Args[1], stats); err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n        return\n    }\n\n    fmt.Printf(\"Total files: %d\\n\", stats.TotalFiles)\n    fmt.Printf(\"Total size: %.2f MB\\n\", float64(stats.TotalSize)/1024/1024)\n    fmt.Println(\"File types:\")\n    for ext, count := range stats.FileTypes {\n        fmt.Printf(\"  %s: %d files\\n\", ext, count)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#applications-and-benefits","title":"Applications and Benefits","text":"<p>Recursion is particularly valuable for specific types of problems.</p> <p>Common Applications</p> <ul> <li>File System Operations: Directory traversal, file search</li> <li>Data Structure Manipulation: Tree/graph operations</li> <li>Algorithm Implementation: Divide-and-conquer, backtracking</li> <li>Mathematical Computations: Factorial, Fibonacci, combinatorics</li> </ul> <p>Benefits of Recursive Approach</p> <ul> <li>Natural Fit: Directory structures are inherently recursive</li> <li>Code Clarity: More intuitive than manual stack management</li> <li>Maintainability: Easier to understand and modify</li> <li>Flexibility: Simple to add features like filtering or depth limits</li> </ul>"},{"location":"2.%20Intermediate/2.%20Recursion/#performance-considerations_1","title":"Performance Considerations","text":"<p>Limitations in Go</p> <ul> <li>No Tail Call Optimization: All recursive calls use stack frames</li> <li>Stack Depth: Very deep recursion can cause stack overflow</li> <li>Memory Usage: Each call consumes stack memory</li> </ul> <p>Optimization Strategies</p> <ul> <li>Use memoization for overlapping subproblems</li> <li>Consider iterative alternatives for deep recursion</li> <li>Implement depth limits for unknown input sizes</li> <li>Use channels and goroutines for concurrent processing</li> </ul>"},{"location":"2.%20Intermediate/2.%20Recursion/#quick-reference","title":"Quick Reference","text":"<p>Key Takeaways</p> <ul> <li>Base Cases: Always define conditions to stop recursion</li> <li>Progress: Each call must move closer to the base case</li> <li>Validation: Handle invalid inputs appropriately</li> <li>Depth Awareness: Consider maximum recursion depth</li> <li>Performance: Weigh recursion benefits against overhead</li> <li>Alternatives: Know when iteration might be better</li> </ul> <p>Remember</p> <p>\"Recursion is powerful for naturally recursive problems like tree traversal and divide-and-conquer algorithms. Use it when it significantly improves code clarity, but be mindful of Go's lack of tail call optimization.\"</p>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/","title":"URL Parsing in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/20.%20URL-Parsing/#introduction-to-url-parsing","title":"Introduction to URL Parsing","text":"<p>URLs (Uniform Resource Locators) are the foundation of web addressing. In Go, the <code>net/url</code> package provides robust functionality for parsing, constructing, and manipulating URLs. Understanding URL parsing is essential for web development, API interactions, and network programming.</p>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#basic-url-parsing","title":"Basic URL Parsing","text":""},{"location":"2.%20Intermediate/20.%20URL-Parsing/#1-parsing-a-url-string","title":"1. Parsing a URL String","text":"<p>The <code>url.Parse</code> function converts a URL string into a <code>url.URL</code> struct:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/url\"\n)\n\nfunc main() {\n    // Parse a complete URL\n    rawURL := \"https://user:pass@example.com:8080/path/to/resource?query=value#fragment\"\n    parsedURL, err := url.Parse(rawURL)\n    if err != nil {\n        fmt.Println(\"Error parsing URL:\", err)\n        return\n    }\n\n    fmt.Printf(\"Parsed URL: %+v\\n\", parsedURL)\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#2-accessing-url-components","title":"2. Accessing URL Components","text":"<p>The <code>url.URL</code> struct contains all components of a URL:</p> <pre><code>func main() {\n    rawURL := \"https://user:pass@example.com:8080/path/to/resource?query=value#fragment\"\n    parsedURL, err := url.Parse(rawURL)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Println(\"Scheme:\", parsedURL.Scheme)         // https\n    fmt.Println(\"Opaque:\", parsedURL.Opaque)         // (for non-hierarchical URLs)\n    fmt.Println(\"User:\", parsedURL.User)            // user:pass\n    fmt.Println(\"Host:\", parsedURL.Host)            // example.com:8080\n    fmt.Println(\"Hostname:\", parsedURL.Hostname())   // example.com\n    fmt.Println(\"Port:\", parsedURL.Port())           // 8080\n    fmt.Println(\"Path:\", parsedURL.Path)            // /path/to/resource\n    fmt.Println(\"RawPath:\", parsedURL.RawPath)      // /path/to/resource\n    fmt.Println(\"ForceQuery:\", parsedURL.ForceQuery) // false\n    fmt.Println(\"RawQuery:\", parsedURL.RawQuery)    // query=value\n    fmt.Println(\"Fragment:\", parsedURL.Fragment)    // fragment\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#working-with-url-components","title":"Working with URL Components","text":""},{"location":"2.%20Intermediate/20.%20URL-Parsing/#1-user-information","title":"1. User Information","text":"<pre><code>func main() {\n    rawURL := \"https://user:password@example.com\"\n    parsedURL, err := url.Parse(rawURL)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    // Access user information\n    user := parsedURL.User\n    fmt.Println(\"Username:\", user.Username())        // user\n    password, ok := user.Password()\n    fmt.Println(\"Password:\", password, ok)         // password true\n\n    // Create user info\n    newUser := url.UserPassword(\"newuser\", \"newpass\")\n    parsedURL.User = newUser\n    fmt.Println(\"Updated URL:\", parsedURL.String()) // https://newuser:newpass@example.com\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#2-host-and-port","title":"2. Host and Port","text":"<pre><code>func main() {\n    rawURL := \"https://example.com:8080\"\n    parsedURL, err := url.Parse(rawURL)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Println(\"Host:\", parsedURL.Host)          // example.com:8080\n    fmt.Println(\"Hostname:\", parsedURL.Hostname()) // example.com\n    fmt.Println(\"Port:\", parsedURL.Port())         // 8080\n\n    // Set port\n    parsedURL.Host = \"example.com:9090\"\n    fmt.Println(\"Updated URL:\", parsedURL.String()) // https://example.com:9090\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#3-path-manipulation","title":"3. Path Manipulation","text":"<pre><code>func main() {\n    rawURL := \"https://example.com/path/to/resource\"\n    parsedURL, err := url.Parse(rawURL)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Println(\"Path:\", parsedURL.Path) // /path/to/resource\n\n    // Join paths\n    parsedURL.Path = path.Join(parsedURL.Path, \"subresource\")\n    fmt.Println(\"Joined path:\", parsedURL.Path) // /path/to/resource/subresource\n\n    // Clean path\n    parsedURL.Path = \"/path/./to/../resource\"\n    fmt.Println(\"Before clean:\", parsedURL.Path) // /path/./to/../resource\n    parsedURL.Path = path.Clean(parsedURL.Path)\n    fmt.Println(\"After clean:\", parsedURL.Path)  // /path/resource\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#query-parameters","title":"Query Parameters","text":""},{"location":"2.%20Intermediate/20.%20URL-Parsing/#1-parsing-query-parameters","title":"1. Parsing Query Parameters","text":"<pre><code>func main() {\n    rawURL := \"https://example.com/search?q=golang&amp;sort=desc&amp;page=1\"\n    parsedURL, err := url.Parse(rawURL)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    // Get query values\n    query := parsedURL.Query()\n    fmt.Println(\"Query:\", query) // map[q:[golang] sort:[desc] page:[1]]\n\n    // Access individual parameters\n    fmt.Println(\"q:\", query.Get(\"q\"))     // golang\n    fmt.Println(\"sort:\", query.Get(\"sort\")) // desc\n    fmt.Println(\"page:\", query.Get(\"page\")) // 1\n    fmt.Println(\"limit:\", query.Get(\"limit\")) // \"\" (empty for missing keys)\n\n    // Get all values for a key (for multi-value parameters)\n    query.Add(\"category\", \"web\")\n    query.Add(\"category\", \"programming\")\n    fmt.Println(\"Categories:\", query[\"category\"]) // [web programming]\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#2-modifying-query-parameters","title":"2. Modifying Query Parameters","text":"<pre><code>func main() {\n    rawURL := \"https://example.com/search?q=golang\"\n    parsedURL, err := url.Parse(rawURL)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    query := parsedURL.Query()\n\n    // Add parameters\n    query.Add(\"sort\", \"desc\")\n    query.Add(\"page\", \"1\")\n\n    // Set parameter (replaces existing)\n    query.Set(\"q\", \"go programming\")\n\n    // Remove parameter\n    query.Del(\"sort\")\n\n    // Update the URL's query\n    parsedURL.RawQuery = query.Encode()\n    fmt.Println(\"Updated URL:\", parsedURL.String())\n    // Output: https://example.com/search?q=go+programming&amp;page=1\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#3-building-query-strings","title":"3. Building Query Strings","text":"<pre><code>func main() {\n    // Create query parameters from scratch\n    query := url.Values{}\n    query.Set(\"q\", \"golang\")\n    query.Set(\"sort\", \"desc\")\n    query.Set(\"page\", \"1\")\n\n    // Encode to string\n    queryString := query.Encode()\n    fmt.Println(\"Query string:\", queryString) // page=1&amp;q=golang&amp;sort=desc\n\n    // Build complete URL\n    baseURL := \"https://example.com/search\"\n    fullURL := baseURL + \"?\" + queryString\n    fmt.Println(\"Full URL:\", fullURL)\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#url-construction-and-resolution","title":"URL Construction and Resolution","text":""},{"location":"2.%20Intermediate/20.%20URL-Parsing/#1-building-urls-from-components","title":"1. Building URLs from Components","text":"<pre><code>func main() {\n    // Create URL from components\n    u := &amp;url.URL{\n        Scheme:   \"https\",\n        User:     url.UserPassword(\"user\", \"pass\"),\n        Host:     \"example.com:8080\",\n        Path:     \"/api/v1/resource\",\n        RawQuery: \"param1=value1&amp;param2=value2\",\n        Fragment: \"section1\",\n    }\n\n    fmt.Println(\"Constructed URL:\", u.String())\n    // Output: https://user:pass@example.com:8080/api/v1/resource?param1=value1&amp;param2=value2#section1\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#2-relative-url-resolution","title":"2. Relative URL Resolution","text":"<pre><code>func main() {\n    baseURL, _ := url.Parse(\"https://example.com/base/path/\")\n\n    // Resolve relative URLs\n    relativeURLs := []string{\n        \"subpath\",\n        \"/absolute/path\",\n        \"../parent\",\n        \"?query=param\",\n        \"#fragment\",\n    }\n\n    for _, rel := range relativeURLs {\n        resolved := baseURL.ResolveReference(&amp;url.URL{Path: rel})\n        fmt.Printf(\"%-15s -&gt; %s\\n\", rel, resolved.String())\n    }\n\n    // Output:\n    // subpath         -&gt; https://example.com/base/path/subpath\n    // /absolute/path  -&gt; https://example.com/absolute/path\n    // ../parent       -&gt; https://example.com/base/parent\n    // ?query=param    -&gt; https://example.com/base/path/?query=param\n    // #fragment       -&gt; https://example.com/base/path/#fragment\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#url-encoding-and-decoding","title":"URL Encoding and Decoding","text":""},{"location":"2.%20Intermediate/20.%20URL-Parsing/#1-path-and-query-encoding","title":"1. Path and Query Encoding","text":"<pre><code>func main() {\n    // URL encoding (percent-encoding)\n    original := \"hello world! @#$%\"\n    encoded := url.QueryEscape(original)\n    fmt.Println(\"Encoded:\", encoded) // hello+world%21+%40%23%24%25\n\n    // URL decoding\n    decoded, err := url.QueryEscape(encoded)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Decoded:\", decoded) // hello world! @#$%\n\n    // Path encoding (slightly different from query encoding)\n    pathEncoded := url.PathEscape(\"/path with spaces/\")\n    fmt.Println(\"Path encoded:\", pathEncoded) // /path%20with%20spaces/\n\n    pathDecoded, err := url.PathUnescape(pathEncoded)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Path decoded:\", pathDecoded) // /path with spaces/\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#2-component-encoding","title":"2. Component Encoding","text":"<pre><code>func main() {\n    // Encode individual URL components\n    scheme := \"https\"\n    host := \"example.com\"\n    path := \"/path with spaces\"\n    query := \"param=value with spaces\"\n\n    // Build URL with proper encoding\n    u := &amp;url.URL{\n        Scheme:   scheme,\n        Host:     host,\n        Path:     path,\n        RawQuery: url.QueryEscape(query),\n    }\n\n    fmt.Println(\"Encoded URL:\", u.String())\n    // Output: https://example.com/path%20with%20spaces?param%3Dvalue%20with%20spaces\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#real-world-example-url-normalizer","title":"Real-World Example: URL Normalizer","text":"<p>Let's build a comprehensive URL normalizer that handles various URL transformations:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/url\"\n    \"path\"\n    \"strings\"\n)\n\n// URLNormalizer handles URL normalization operations\ntype URLNormalizer struct {\n    defaultScheme string\n    defaultPort  string\n}\n\nfunc NewURLNormalizer() *URLNormalizer {\n    return &amp;URLNormalizer{\n        defaultScheme: \"https\",\n        defaultPort:  \"443\",\n    }\n}\n\n// NormalizeURL performs various normalization operations on a URL\nfunc (un *URLNormalizer) NormalizeURL(rawURL string) (string, error) {\n    // Parse the URL\n    parsedURL, err := url.Parse(rawURL)\n    if err != nil {\n        return \"\", fmt.Errorf(\"failed to parse URL: %w\", err)\n    }\n\n    // Apply normalizations\n    un.normalizeScheme(parsedURL)\n    un.normalizeHost(parsedURL)\n    un.normalizePath(parsedURL)\n    un.normalizePort(parsedURL)\n    un.normalizeQuery(parsedURL)\n    un.normalizeFragment(parsedURL)\n\n    return parsedURL.String(), nil\n}\n\nfunc (un *URLNormalizer) normalizeScheme(u *url.URL) {\n    // Default to https if scheme is empty\n    if u.Scheme == \"\" {\n        u.Scheme = un.defaultScheme\n    } else {\n        // Convert scheme to lowercase\n        u.Scheme = strings.ToLower(u.Scheme)\n    }\n}\n\nfunc (un *URLNormalizer) normalizeHost(u *url.URL) {\n    if u.Host == \"\" {\n        return\n    }\n\n    // Convert host to lowercase\n    host := strings.ToLower(u.Host)\n\n    // Remove default port\n    if u.Scheme == \"https\" &amp;&amp; strings.HasSuffix(host, \":443\") {\n        host = strings.TrimSuffix(host, \":443\")\n    } else if u.Scheme == \"http\" &amp;&amp; strings.HasSuffix(host, \":80\") {\n        host = strings.TrimSuffix(host, \":80\")\n    }\n\n    u.Host = host\n}\n\nfunc (un *URLNormalizer) normalizePath(u *url.URL) {\n    if u.Path == \"\" {\n        u.Path = \"/\"\n        return\n    }\n\n    // Remove trailing slash for non-root paths\n    if len(u.Path) &gt; 1 &amp;&amp; strings.HasSuffix(u.Path, \"/\") {\n        u.Path = strings.TrimSuffix(u.Path, \"/\")\n    }\n\n    // Remove dot segments\n    u.Path = path.Clean(u.Path)\n\n    // Remove duplicate slashes\n    u.Path = strings.ReplaceAll(u.Path, \"//\", \"/\")\n}\n\nfunc (un *URLNormalizer) normalizePort(u *url.URL) {\n    if u.Port() == \"\" {\n        return\n    }\n\n    // Remove default ports\n    if u.Scheme == \"https\" &amp;&amp; u.Port() == \"443\" {\n        u.Host = u.Hostname()\n    } else if u.Scheme == \"http\" &amp;&amp; u.Port() == \"80\" {\n        u.Host = u.Hostname()\n    }\n}\n\nfunc (un *URLNormalizer) normalizeQuery(u *url.URL) {\n    if u.RawQuery == \"\" {\n        return\n    }\n\n    query := u.Query()\n\n    // Sort query parameters for consistent ordering\n    // (Go's url.Values doesn't guarantee order, so we'll sort keys)\n    var keys []string\n    for k := range query {\n        keys = append(keys, k)\n    }\n\n    // Rebuild query with sorted keys\n    sortedQuery := url.Values{}\n    for _, k := range keys {\n        values := query[k]\n        // Sort values for multi-valued parameters\n        for i, v1 := range values {\n            for j := i + 1; j &lt; len(values); j++ {\n                if values[i] &gt; values[j] {\n                    values[i], values[j] = values[j], values[i]\n                }\n            }\n        }\n        sortedQuery[k] = values\n    }\n\n    u.RawQuery = sortedQuery.Encode()\n}\n\nfunc (un *URLNormalizer) normalizeFragment(u *url.URL) {\n    // Remove fragment (optional, depending on use case)\n    u.Fragment = \"\"\n}\n\n// CanonicalURL returns a canonical representation of the URL\nfunc (un *URLNormalizer) CanonicalURL(rawURL string) (string, error) {\n    normalized, err := un.NormalizeURL(rawURL)\n    if err != nil {\n        return \"\", err\n    }\n\n    // Additional canonicalization steps\n    parsed, err := url.Parse(normalized)\n    if err != nil {\n        return \"\", err\n    }\n\n    // Remove default port if present\n    if parsed.Port() != \"\" {\n        if (parsed.Scheme == \"http\" &amp;&amp; parsed.Port() == 80) ||\n            (parsed.Scheme == \"https\" &amp;&amp; parsed.Port() == 443) {\n            parsed.Host = parsed.Hostname()\n        }\n    }\n\n    // Ensure path ends with slash for directories\n    if parsed.Path != \"/\" &amp;&amp; !strings.Contains(path.Base(parsed.Path), \".\") {\n        parsed.Path += \"/\"\n    }\n\n    return parsed.String(), nil\n}\n\n// CompareURLs checks if two URLs are equivalent after normalization\nfunc (un *URLNormalizer) CompareURLs(url1, url2 string) (bool, error) {\n    normalized1, err := un.CanonicalURL(url1)\n    if err != nil {\n        return false, err\n    }\n\n    normalized2, err := un.CanonicalURL(url2)\n    if err != nil {\n        return false, err\n    }\n\n    return normalized1 == normalized2, nil\n}\n\nfunc main() {\n    normalizer := NewURLNormalizer()\n\n    // Test URLs\n    testURLs := []string{\n        \"HTTP://Example.com:80/Path/../To/./Resource?b=2&amp;a=1#fragment\",\n        \"https://example.com/Path/To/Resource/?a=1&amp;b=2\",\n        \"http://example.com:443/path/to/resource\",\n        \"https://example.com/path/to/resource/\",\n        \"example.com/path/to/resource\",\n        \"//example.com/path/to/resource\",\n    }\n\n    fmt.Println(\"=== URL Normalization ===\")\n    for _, testURL := range testURLs {\n        normalized, err := normalizer.NormalizeURL(testURL)\n        if err != nil {\n            fmt.Printf(\"Error normalizing %q: %v\\n\", testURL, err)\n            continue\n        }\n        fmt.Printf(\"%-50s -&gt; %s\\n\", testURL, normalized)\n    }\n\n    fmt.Println(\"\\n=== Canonical URLs ===\")\n    for _, testURL := range testURLs {\n        canonical, err := normalizer.CanonicalURL(testURL)\n        if err != nil {\n            fmt.Printf(\"Error canonicalizing %q: %v\\n\", testURL, err)\n            continue\n        }\n        fmt.Printf(\"%-50s -&gt; %s\\n\", testURL, canonical)\n    }\n\n    fmt.Println(\"\\n=== URL Comparison ===\")\n    comparisonTests := [][]string{\n        {\"http://example.com/path\", \"https://example.com/path\"},\n        {\"https://example.com/path/\", \"https://example.com/path\"},\n        {\"https://example.com:443/path\", \"https://example.com/path\"},\n        {\"https://EXAMPLE.com/path\", \"https://example.com/path\"},\n        {\"https://example.com/path?a=1&amp;b=2\", \"https://example.com/path?b=2&amp;a=1\"},\n    }\n\n    for _, pair := range comparisonTests {\n        equal, err := normalizer.CompareURLs(pair[0], pair[1])\n        if err != nil {\n            fmt.Printf(\"Error comparing %q and %q: %v\\n\", pair[0], pair[1], err)\n            continue\n        }\n        fmt.Printf(\"%-30s == %-30s -&gt; %t\\n\", pair[0], pair[1], equal)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>URL Normalization:</li> <li>Converts scheme to lowercase</li> <li>Normalizes host (lowercase, removes default ports)</li> <li>Cleans path (removes dot segments, duplicate slashes)</li> <li>Sorts query parameters</li> <li> <p>Removes fragments</p> </li> <li> <p>Canonical URL Generation:</p> </li> <li>Applies all normalizations</li> <li>Ensures consistent trailing slashes</li> <li>Removes default ports</li> <li> <p>Creates a standard representation</p> </li> <li> <p>URL Comparison:</p> </li> <li>Normalizes both URLs</li> <li>Compares canonical forms</li> <li>Handles various equivalent URL formats</li> </ol>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Web Crawlers:</li> <li>Avoid duplicate content by normalizing URLs</li> <li>Identify equivalent resources</li> <li> <p>Build consistent URL indexes</p> </li> <li> <p>API Clients:</p> </li> <li>Normalize request URLs</li> <li>Handle redirects properly</li> <li> <p>Cache responses efficiently</p> </li> <li> <p>Security Applications:</p> </li> <li>Detect phishing attempts</li> <li>Validate URL patterns</li> <li> <p>Filter malicious URLs</p> </li> <li> <p>Analytics Systems:</p> </li> <li>Aggregate data by normalized URLs</li> <li>Track user journeys consistently</li> <li>Generate accurate reports</li> </ol>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/20.%20URL-Parsing/#1-always-check-parse-errors","title":"1. Always Check Parse Errors","text":"<pre><code>// Good: Check errors\nparsedURL, err := url.Parse(userInput)\nif err != nil {\n    // Handle invalid URL\n}\n\n// Bad: Ignore errors\nparsedURL, _ := url.Parse(userInput) // Might panic\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#2-use-proper-encoding","title":"2. Use Proper Encoding","text":"<pre><code>// Good: Encode query parameters\nquery := url.Values{}\nquery.Set(\"search\", \"golang tutorials\")\nu.RawQuery = query.Encode()\n\n// Bad: Manual concatenation\nu.RawQuery = \"search=\" + \"golang tutorials\" // Not properly encoded\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#3-handle-relative-urls-carefully","title":"3. Handle Relative URLs Carefully","text":"<pre><code>// Good: Use ResolveReference for relative URLs\nbaseURL, _ := url.Parse(\"https://example.com/base/\")\nrelativeURL, _ := url.Parse(\"subpath\")\nabsoluteURL := baseURL.ResolveReference(relativeURL)\n\n// Bad: Manual concatenation\nabsoluteURL := baseURL.String() + relativeURL.String() // Might be incorrect\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#4-validate-url-components","title":"4. Validate URL Components","text":"<pre><code>func validateURL(u *url.URL) error {\n    if u.Scheme != \"http\" &amp;&amp; u.Scheme != \"https\" {\n        return fmt.Errorf(\"unsupported scheme: %s\", u.Scheme)\n    }\n\n    if u.Host == \"\" {\n        return fmt.Errorf(\"missing host\")\n    }\n\n    // Additional validations...\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"2.%20Intermediate/20.%20URL-Parsing/#1-case-sensitivity","title":"1. Case Sensitivity","text":"<pre><code>// URLs are case-insensitive in scheme and host\n// But case-sensitive in path and query parameters\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#2-trailing-slashes","title":"2. Trailing Slashes","text":"<pre><code>// /path and /path/ might be different resources\n// Normalize based on your application's needs\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#3-default-ports","title":"3. Default Ports","text":"<pre><code>// http://example.com:80/ and http://example.com/ are the same\n// Remove default ports during normalization\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#4-encoding-issues","title":"4. Encoding Issues","text":"<pre><code>// Different parts of URL have different encoding rules\n// Use PathEscape for paths, QueryEscape for queries\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#conclusion","title":"Conclusion","text":"<p>URL parsing is a critical skill for web development and network programming in Go. The <code>net/url</code> package provides comprehensive tools for:</p> <ol> <li>Parsing URLs:</li> <li>Break down URLs into components</li> <li>Handle various URL formats</li> <li> <p>Extract specific parts (scheme, host, path, etc.)</p> </li> <li> <p>Manipulating URLs:</p> </li> <li>Modify individual components</li> <li>Add/remove query parameters</li> <li> <p>Build URLs from scratch</p> </li> <li> <p>Normalizing URLs:</p> </li> <li>Create consistent representations</li> <li>Handle equivalent URLs</li> <li> <p>Prepare URLs for comparison</p> </li> <li> <p>Encoding and Decoding:</p> </li> <li>Properly encode special characters</li> <li>Handle different encoding rules for different parts</li> <li>Avoid security issues from improper encoding</li> </ol> <p>The URL normalizer example demonstrates how to build a robust system for handling URLs in real-world applications. By following best practices and understanding the nuances of URL parsing, you can create reliable and secure applications that work with web resources.</p> <p>Key takeaways: 1. Always validate and sanitize user-provided URLs 2. Use proper encoding for different URL components 3. Normalize URLs before comparison or storage 4. Handle relative URLs with <code>ResolveReference</code> 5. Be aware of security implications when working with URLs</p> <p>URL parsing might seem straightforward, but it has many edge cases that can lead to bugs or security vulnerabilities if not handled properly. With Go's excellent <code>net/url</code> package and the patterns shown in this guide, you can build robust and secure URL handling in your applications.</p>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/","title":"The <code>bufio</code> Package in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/21.%20Bufio-Package/#introduction-to-buffered-io","title":"Introduction to Buffered I/O","text":"<p>The <code>bufio</code> package in Go implements buffered I/O, wrapping <code>io.Reader</code> and <code>io.Writer</code> objects to create buffered readers and writers. Buffering reduces the number of system calls and improves performance, especially when dealing with small, frequent I/O operations.</p>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#why-use-buffered-io","title":"Why Use Buffered I/O?","text":"<ul> <li>Performance: Reduces system call overhead by reading/writing in chunks</li> <li>Convenience: Provides helpful methods for common operations like reading lines</li> <li>Efficiency: Minimizes disk/network I/O operations</li> <li>Flexibility: Works with any <code>io.Reader</code> or <code>io.Writer</code></li> </ul>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#buffered-readers-bufioreader","title":"Buffered Readers (<code>bufio.Reader</code>)","text":""},{"location":"2.%20Intermediate/21.%20Bufio-Package/#1-creating-a-buffered-reader","title":"1. Creating a Buffered Reader","text":"<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // Create a buffered reader from a string\n    reader := bufio.NewReader(strings.NewReader(\"Hello, World!\\nThis is a test.\\n\"))\n\n    // Read the entire content\n    content, err := io.ReadAll(reader)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Content:\", string(content))\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#2-reading-by-lines","title":"2. Reading by Lines","text":"<pre><code>func main() {\n    data := \"First line\\nSecond line\\nThird line\\n\"\n    reader := bufio.NewReader(strings.NewReader(data))\n\n    for {\n        line, err := reader.ReadString('\\n')\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            fmt.Println(\"Error:\", err)\n            return\n        }\n        fmt.Printf(\"Line: %q\\n\", strings.TrimSpace(line))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#3-reading-bytes","title":"3. Reading Bytes","text":"<pre><code>func main() {\n    data := \"Hello, World!\"\n    reader := bufio.NewReader(strings.NewReader(data))\n\n    // Read first 5 bytes\n    buf := make([]byte, 5)\n    n, err := reader.Read(buf)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Read %d bytes: %q\\n\", n, buf)\n\n    // Peek at next bytes without advancing\n    peeked, err := reader.Peek(3)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Peeked: %q\\n\", peeked)\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#4-using-readline-deprecated-but-still-used","title":"4. Using <code>ReadLine</code> (Deprecated but Still Used)","text":"<pre><code>func main() {\n    data := \"Line 1\\nLine 2\\nLine 3\\n\"\n    reader := bufio.NewReader(strings.NewReader(data))\n\n    for {\n        line, isPrefix, err := reader.ReadLine()\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            fmt.Println(\"Error:\", err)\n            return\n        }\n\n        fmt.Printf(\"Line: %q (isPrefix: %v)\\n\", line, isPrefix)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#the-bufioscanner-type","title":"The <code>bufio.Scanner</code> Type","text":""},{"location":"2.%20Intermediate/21.%20Bufio-Package/#1-basic-scanning","title":"1. Basic Scanning","text":"<pre><code>func main() {\n    data := \"word1 word2 word3\\nline2 word4\"\n    scanner := bufio.NewScanner(strings.NewReader(data))\n\n    // Scan line by line (default)\n    for scanner.Scan() {\n        fmt.Println(\"Line:\", scanner.Text())\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#2-custom-split-functions","title":"2. Custom Split Functions","text":"<pre><code>func main() {\n    data := \"apple,banana,cherry,date\"\n    scanner := bufio.NewScanner(strings.NewReader(data))\n\n    // Split by commas\n    scanner.Split(bufio.ScanWords) // Default is ScanLines\n\n    // Custom split function\n    splitFunc := func(data []byte, atEOF bool) (advance int, token []byte, err error) {\n        // Skip leading spaces\n        start := 0\n        for ; start &lt; len(data); start++ {\n            if data[start] != ',' {\n                break\n            }\n        }\n\n        // Scan until comma or EOF\n        for i := start; i &lt; len(data); i++ {\n            if data[i] == ',' {\n                return i + 1, data[start:i], nil\n            }\n        }\n\n        // If we're at EOF, we have a final, non-terminated line\n        if atEOF &amp;&amp; len(data) &gt; start {\n            return len(data), data[start:], nil\n        }\n\n        // Request more data\n        return start, nil, nil\n    }\n\n    scanner.Split(splitFunc)\n\n    for scanner.Scan() {\n        fmt.Println(\"Token:\", scanner.Text())\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#3-built-in-split-functions","title":"3. Built-in Split Functions","text":"<pre><code>func main() {\n    data := \"word1 word2\\nword3 word4\"\n\n    // ScanLines (default)\n    fmt.Println(\"ScanLines:\")\n    scanner := bufio.NewScanner(strings.NewReader(data))\n    scanner.Split(bufio.ScanLines)\n    for scanner.Scan() {\n        fmt.Println(scanner.Text())\n    }\n\n    // ScanWords\n    fmt.Println(\"\\nScanWords:\")\n    scanner = bufio.NewScanner(strings.NewReader(data))\n    scanner.Split(bufio.ScanWords)\n    for scanner.Scan() {\n        fmt.Println(scanner.Text())\n    }\n\n    // ScanBytes\n    fmt.Println(\"\\nScanBytes:\")\n    scanner = bufio.NewScanner(strings.NewReader(data))\n    scanner.Split(bufio.ScanBytes)\n    for scanner.Scan() {\n        fmt.Printf(\"%q \", scanner.Text())\n    }\n    fmt.Println()\n\n    // ScanRunes\n    fmt.Println(\"\\nScanRunes:\")\n    scanner = bufio.NewScanner(strings.NewReader(data))\n    scanner.Split(bufio.ScanRunes)\n    for scanner.Scan() {\n        fmt.Printf(\"%q \", scanner.Text())\n    }\n    fmt.Println()\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#buffered-writers-bufiowriter","title":"Buffered Writers (<code>bufio.Writer</code>)","text":""},{"location":"2.%20Intermediate/21.%20Bufio-Package/#1-creating-a-buffered-writer","title":"1. Creating a Buffered Writer","text":"<pre><code>func main() {\n    // Create a buffered writer that writes to os.Stdout\n    writer := bufio.NewWriter(os.Stdout)\n\n    // Write data\n    _, err := writer.WriteString(\"Hello, Buffered World!\\n\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    // Remember to flush!\n    err = writer.Flush()\n    if err != nil {\n        fmt.Println(\"Error flushing:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#2-writing-with-buffering","title":"2. Writing with Buffering","text":"<pre><code>func main() {\n    var buf bytes.Buffer\n    writer := bufio.NewWriter(&amp;buf)\n\n    // Write multiple times\n    for i := 0; i &lt; 5; i++ {\n        _, err := writer.WriteString(fmt.Sprintf(\"Line %d\\n\", i+1))\n        if err != nil {\n            fmt.Println(\"Error:\", err)\n            return\n        }\n        // Data is buffered, not yet written to buf\n    }\n\n    // Flush to write all buffered data\n    err := writer.Flush()\n    if err != nil {\n        fmt.Println(\"Error flushing:\", err)\n        return\n    }\n\n    fmt.Println(\"Buffer content:\")\n    fmt.Print(buf.String())\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#3-available-and-size","title":"3. Available and Size","text":"<pre><code>func main() {\n    writer := bufio.NewWriterSize(os.Stdout, 32) // 32-byte buffer\n\n    // Check available buffer space\n    fmt.Printf(\"Available: %d bytes\\n\", writer.Available())\n\n    // Write some data\n    writer.WriteString(\"Hello\")\n    fmt.Printf(\"Available after write: %d bytes\\n\", writer.Available())\n\n    // Check buffer size\n    fmt.Printf(\"Buffer size: %d bytes\\n\", writer.Size())\n\n    // Flush\n    writer.Flush()\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#real-world-example-log-file-processor","title":"Real-World Example: Log File Processor","text":"<p>Let's build a comprehensive log file processor that demonstrates various <code>bufio</code> features:</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"regexp\"\n    \"strings\"\n    \"time\"\n)\n\n// LogEntry represents a parsed log entry\ntype LogEntry struct {\n    Timestamp time.Time\n    Level     string\n    Message   string\n    Source    string\n}\n\n// LogProcessor handles log file processing\ntype LogProcessor struct {\n    inputFile  string\n    outputFile string\n    filter     *regexp.Regexp\n    stats      struct {\n        TotalLines   int\n        ErrorLines   int\n        WarningLines int\n        InfoLines    int\n    }\n}\n\nfunc NewLogProcessor(input, output string, filterPattern string) (*LogProcessor, error) {\n    lp := &amp;LogProcessor{\n        inputFile:  input,\n        outputFile: output,\n    }\n\n    if filterPattern != \"\" {\n        var err error\n        lp.filter, err = regexp.Compile(filterPattern)\n        if err != nil {\n            return nil, fmt.Errorf(\"invalid filter pattern: %w\", err)\n        }\n    }\n\n    return lp, nil\n}\n\n// ProcessFile reads the input log file, processes it, and writes to output\nfunc (lp *LogProcessor) ProcessFile() error {\n    // Open input file\n    inputFile, err := os.Open(lp.inputFile)\n    if err != nil {\n        return fmt.Errorf(\"failed to open input file: %w\", err)\n    }\n    defer inputFile.Close()\n\n    // Create output file\n    outputFile, err := os.Create(lp.outputFile)\n    if err != nil {\n        return fmt.Errorf(\"failed to create output file: %w\", err)\n    }\n    defer outputFile.Close()\n\n    // Create buffered reader and writer\n    reader := bufio.NewReader(inputFile)\n    writer := bufio.NewWriter(outputFile)\n    defer writer.Flush()\n\n    // Process line by line\n    lineNumber := 0\n    for {\n        lineNumber++\n        line, err := reader.ReadString('\\n')\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return fmt.Errorf(\"error reading line %d: %w\", lineNumber, err)\n        }\n\n        // Parse log entry\n        entry, err := lp.parseLogEntry(line, lineNumber)\n        if err != nil {\n            fmt.Fprintf(os.Stderr, \"Error parsing line %d: %v\\n\", lineNumber, err)\n            continue\n        }\n\n        // Apply filter if specified\n        if lp.filter != nil &amp;&amp; !lp.filter.MatchString(entry.Message) {\n            continue\n        }\n\n        // Update statistics\n        lp.updateStats(entry)\n\n        // Write processed entry\n        if err := lp.writeLogEntry(writer, entry); err != nil {\n            return fmt.Errorf(\"error writing line %d: %w\", lineNumber, err)\n        }\n    }\n\n    // Write summary statistics\n    if err := lp.writeSummary(writer); err != nil {\n        return fmt.Errorf(\"error writing summary: %w\", err)\n    }\n\n    fmt.Printf(\"Processing complete. Processed %d lines.\\n\", lp.stats.TotalLines)\n    return nil\n}\n\n// parseLogEntry parses a single log line\nfunc (lp *LogProcessor) parseLogEntry(line string, lineNumber int) (*LogEntry, error) {\n    line = strings.TrimSpace(line)\n    if line == \"\" {\n        return nil, fmt.Errorf(\"empty line\")\n    }\n\n    // Simple log format: [timestamp] [level] [source] message\n    // Example: [2023-11-15T14:30:45Z] [ERROR] [server] Database connection failed\n\n    parts := strings.SplitN(line, \"]\", 3)\n    if len(parts) &lt; 3 {\n        return nil, fmt.Errorf(\"invalid log format\")\n    }\n\n    // Parse timestamp\n    timestampStr := strings.Trim(parts[0], \"[ \")\n    timestamp, err := time.Parse(time.RFC3339, timestampStr)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid timestamp: %w\", err)\n    }\n\n    // Parse level\n    levelStr := strings.Trim(parts[1], \"[ \")\n    level := strings.ToUpper(levelStr)\n\n    // Parse source and message\n    rest := strings.TrimSpace(parts[2])\n    sourceEnd := strings.Index(rest, \"]\")\n    if sourceEnd == -1 {\n        return nil, fmt.Errorf(\"invalid source format\")\n    }\n\n    source := strings.Trim(rest[:sourceEnd], \"[ \")\n    message := strings.TrimSpace(rest[sourceEnd+1:])\n\n    return &amp;LogEntry{\n        Timestamp: timestamp,\n        Level:     level,\n        Message:   message,\n        Source:    source,\n    }, nil\n}\n\n// writeLogEntry writes a formatted log entry\nfunc (lp *LogProcessor) writeLogEntry(writer *bufio.Writer, entry *LogEntry) error {\n    // Format: [timestamp] LEVEL source: message\n    formatted := fmt.Sprintf(\"[%s] %s %s: %s\\n\",\n        entry.Timestamp.Format(time.RFC3339),\n        entry.Level,\n        entry.Source,\n        entry.Message)\n\n    _, err := writer.WriteString(formatted)\n    return err\n}\n\n// updateStats updates processing statistics\nfunc (lp *LogProcessor) updateStats(entry *LogEntry) {\n    lp.stats.TotalLines++\n\n    switch entry.Level {\n    case \"ERROR\":\n        lp.stats.ErrorLines++\n    case \"WARNING\", \"WARN\":\n        lp.stats.WarningLines++\n    case \"INFO\":\n        lp.stats.InfoLines++\n    }\n}\n\n// writeSummary writes processing summary\nfunc (lp *LogProcessor) writeSummary(writer *bufio.Writer) error {\n    summary := fmt.Sprintf(`\n=== Processing Summary ===\nTotal lines processed: %d\nError lines: %d\nWarning lines: %d\nInfo lines: %d\n========================\n`, lp.stats.TotalLines, lp.stats.ErrorLines, lp.stats.WarningLines, lp.stats.InfoLines)\n\n    _, err := writer.WriteString(summary)\n    return err\n}\n\n// generateSampleLog creates a sample log file for testing\nfunc generateSampleLog(filename string) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    writer := bufio.NewWriter(file)\n    defer writer.Flush()\n\n    logEntries := []string{\n        \"[2023-11-15T14:30:45Z] [INFO] [server] Server started\",\n        \"[2023-11-15T14:31:00Z] [INFO] [database] Connected to database\",\n        \"[2023-11-15T14:31:15Z] [WARNING] [auth] Failed login attempt\",\n        \"[2023-11-15T14:31:30Z] [ERROR] [database] Connection timeout\",\n        \"[2023-11-15T14:31:45Z] [INFO] [server] Request processed\",\n        \"[2023-11-15T14:32:00Z] [ERROR] [server] Internal server error\",\n    }\n\n    for _, entry := range logEntries {\n        if _, err := writer.WriteString(entry + \"\\n\"); err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n\nfunc main() {\n    // Generate sample log file\n    inputFile := \"sample.log\"\n    outputFile := \"processed.log\"\n\n    if err := generateSampleLog(inputFile); err != nil {\n        fmt.Printf(\"Error generating sample log: %v\\n\", err)\n        return\n    }\n    fmt.Println(\"Generated sample log file:\", inputFile)\n\n    // Create log processor\n    processor, err := NewLogProcessor(inputFile, outputFile, \"server|database\")\n    if err != nil {\n        fmt.Printf(\"Error creating log processor: %v\\n\", err)\n        return\n    }\n\n    // Process the log file\n    if err := processor.ProcessFile(); err != nil {\n        fmt.Printf(\"Error processing log file: %v\\n\", err)\n        return\n    }\n\n    fmt.Println(\"Log processing complete. Output written to:\", outputFile)\n\n    // Display the processed file\n    fmt.Println(\"\\n=== Processed Log Content ===\")\n    content, err := os.ReadFile(outputFile)\n    if err != nil {\n        fmt.Printf(\"Error reading output file: %v\\n\", err)\n        return\n    }\n    fmt.Print(string(content))\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Log Processing Pipeline:</li> <li>Reads log file line by line using <code>bufio.Reader</code></li> <li>Parses each log entry into structured data</li> <li>Applies filtering based on regex patterns</li> <li> <p>Writes processed entries using <code>bufio.Writer</code></p> </li> <li> <p>Buffered I/O Operations:</p> </li> <li>Uses <code>bufio.NewReader</code> for efficient line reading</li> <li>Uses <code>bufio.NewWriter</code> for efficient writing</li> <li> <p>Demonstrates proper resource management with <code>defer</code></p> </li> <li> <p>Error Handling:</p> </li> <li>Handles I/O errors gracefully</li> <li>Provides detailed error messages with line numbers</li> <li> <p>Continues processing after non-critical errors</p> </li> <li> <p>Statistics Tracking:</p> </li> <li>Counts different log levels</li> <li>Generates summary reports</li> <li>Writes statistics to output file</li> </ol>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Log Analysis:</li> <li>Process application logs</li> <li>Filter and categorize log entries</li> <li> <p>Generate summary reports</p> </li> <li> <p>Data Transformation:</p> </li> <li>Convert between data formats</li> <li>Clean and normalize data</li> <li> <p>Apply business rules</p> </li> <li> <p>File Processing:</p> </li> <li>Process large files efficiently</li> <li>Handle different line endings</li> <li>Memory-efficient processing</li> </ol>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/21.%20Bufio-Package/#1-always-flush-buffered-writers","title":"1. Always Flush Buffered Writers","text":"<pre><code>// Good: Explicit flush\nwriter := bufio.NewWriter(file)\n_, err := writer.WriteString(\"data\")\nif err != nil {\n    return err\n}\nerr = writer.Flush() // Important!\nif err != nil {\n    return err\n}\n\n// Bad: Forgetting to flush\nwriter := bufio.NewWriter(file)\nwriter.WriteString(\"data\") // Data might not be written!\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#2-handle-scanner-errors","title":"2. Handle Scanner Errors","text":"<pre><code>// Good: Check scanner errors\nscanner := bufio.NewScanner(file)\nfor scanner.Scan() {\n    // Process line\n}\nif err := scanner.Err(); err != nil {\n    log.Printf(\"Scanner error: %v\", err)\n}\n\n// Bad: Ignoring scanner errors\nscanner := bufio.NewScanner(file)\nfor scanner.Scan() {\n    // Process line\n}\n// Might miss important errors!\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#3-choose-appropriate-buffer-sizes","title":"3. Choose Appropriate Buffer Sizes","text":"<pre><code>// For small files or frequent operations\nreader := bufio.NewReader(os.Stdin) // Default buffer size (4096 bytes)\n\n// For large files or performance-critical code\nreader = bufio.NewReaderSize(os.Stdin, 64*1024) // 64KB buffer\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#4-close-resources-properly","title":"4. Close Resources Properly","text":"<pre><code>// Good: Use defer for cleanup\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n    return err\n}\ndefer file.Close()\n\nreader := bufio.NewReader(file)\n// Process file...\n\n// Bad: Manual cleanup (error-prone)\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n    return err\n}\nreader := bufio.NewReader(file)\n// Process file...\nfile.Close() // Might not execute if there's an error!\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/21.%20Bufio-Package/#1-buffer-size-impact","title":"1. Buffer Size Impact","text":"<pre><code>// Benchmark different buffer sizes\nfunc benchmarkBufferSize(filename string, bufferSize int) time.Duration {\n    file, _ := os.Open(filename)\n    defer file.Close()\n\n    start := time.Now()\n    reader := bufio.NewReaderSize(file, bufferSize)\n\n    // Read entire file\n    _, _ = io.Copy(io.Discard, reader)\n\n    return time.Since(start)\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#2-scanner-vs-manual-reading","title":"2. Scanner vs Manual Reading","text":"<pre><code>// Scanner is convenient but slightly slower\nfunc countLinesScanner(filename string) (int, error) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return 0, err\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    count := 0\n    for scanner.Scan() {\n        count++\n    }\n    return count, scanner.Err()\n}\n\n// Manual reading is faster but more code\nfunc countLinesManual(filename string) (int, error) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return 0, err\n    }\n    defer file.Close()\n\n    reader := bufio.NewReader(file)\n    count := 0\n    for {\n        _, err := reader.ReadString('\\n')\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return 0, err\n        }\n        count++\n    }\n    return count, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#common-patterns","title":"Common Patterns","text":""},{"location":"2.%20Intermediate/21.%20Bufio-Package/#1-line-by-line-processing","title":"1. Line-by-Line Processing","text":"<pre><code>func processFile(filename string, processFunc func(string) error) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    for scanner.Scan() {\n        if err := processFunc(scanner.Text()); err != nil {\n            return err\n        }\n    }\n    return scanner.Err()\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#2-buffered-writing-with-auto-flush","title":"2. Buffered Writing with Auto-Flush","text":"<pre><code>type AutoFlushWriter struct {\n    *bufio.Writer\n    flushInterval time.Duration\n    lastFlush    time.Time\n}\n\nfunc NewAutoFlushWriter(w io.Writer, size int, interval time.Duration) *AutoFlushWriter {\n    return &amp;AutoFlushWriter{\n        Writer:        bufio.NewWriterSize(w, size),\n        flushInterval: interval,\n        lastFlush:    time.Now(),\n    }\n}\n\nfunc (w *AutoFlushWriter) Write(p []byte) (int, error) {\n    n, err := w.Writer.Write(p)\n    if err != nil {\n        return n, err\n    }\n\n    // Auto-fllush if interval has passed\n    if time.Since(w.lastFlush) &gt; w.flushInterval {\n        w.Flush()\n        w.lastFlush = time.Now()\n    }\n\n    return n, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#3-custom-split-functions","title":"3. Custom Split Functions","text":"<pre><code>// Split by multiple delimiters\nfunc scanAnyDelimiter(data []byte, atEOF bool) (advance int, token []byte, err error) {\n    // Skip leading delimiters\n    start := 0\n    for ; start &lt; len(data); start++ {\n        if data[start] != ' ' &amp;&amp; data[start] != '\\t' &amp;&amp; data[start] != ',' {\n            break\n        }\n    }\n\n    // Scan until delimiter or EOF\n    for i := start; i &lt; len(data); i++ {\n        if data[i] == ' ' || data[i] == '\\t' || data[i] == ',' {\n            return i + 1, data[start:i], nil\n        }\n    }\n\n    // If we're at EOF, we have a final token\n    if atEOF &amp;&amp; len(data) &gt; start {\n        return len(data), data[start:], nil\n    }\n\n    // Request more data\n    return start, nil, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#conclusion","title":"Conclusion","text":"<p>The <code>bufio</code> package is essential for efficient I/O operations in Go. It provides:</p> <ol> <li>Buffered Reading:</li> <li><code>bufio.Reader</code> for efficient reading</li> <li><code>bufio.Scanner</code> for convenient tokenization</li> <li> <p>Various split functions for different parsing needs</p> </li> <li> <p>Buffered Writing:</p> </li> <li><code>bufio.Writer</code> for efficient writing</li> <li>Automatic flushing capabilities</li> <li> <p>Buffer size control</p> </li> <li> <p>Performance Benefits:</p> </li> <li>Reduced system call overhead</li> <li>Memory-efficient processing of large files</li> <li> <p>Flexible buffer sizing</p> </li> <li> <p>Convenience Features:</p> </li> <li>Line-by-line reading</li> <li>Custom tokenization</li> <li>Easy integration with <code>io.Reader</code> and <code>io.Writer</code></li> </ol> <p>The log file processor example demonstrates how to build a complete application using <code>bufio</code> for efficient file processing. By following best practices and understanding the performance characteristics, you can build fast and reliable I/O operations in your Go applications.</p> <p>Key takeaways: 1. Always flush buffered writers to ensure data is written 2. Check scanner errors to catch I/O problems 3. Choose appropriate buffer sizes based on your use case 4. Use defer for proper resource cleanup 5. Consider performance when choosing between Scanner and manual reading</p> <p>Buffered I/O is a fundamental concept in Go programming, and mastering <code>bufio</code> will help you build efficient and reliable applications that handle I/O operations effectively.</p>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/","title":"Base64 Encoding and Decoding in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/22.%20Base64-Coding/#introduction-to-base64","title":"Introduction to Base64","text":"<p>Base64 is a binary-to-text encoding scheme that represents binary data in an ASCII string format. It's commonly used when there's a need to encode binary data that needs to be stored or transferred over media designed to handle text. Go's <code>encoding/base64</code> package provides robust support for Base64 encoding and decoding operations.</p>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#basic-base64-operations","title":"Basic Base64 Operations","text":""},{"location":"2.%20Intermediate/22.%20Base64-Coding/#1-encoding-data-to-base64","title":"1. Encoding Data to Base64","text":"<pre><code>package main\n\nimport (\n    \"encoding/base64\"\n    \"fmt\"\n)\n\nfunc main() {\n    // Encode a string to Base64\n    data := \"Hello, World!\"\n    encoded := base64.StdEncoding.EncodeToString([]byte(data))\n    fmt.Println(\"Original:\", data)\n    fmt.Println(\"Encoded:\", encoded) // SGVsbG8sIFdvcmxkIQ==\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#2-decoding-base64-data","title":"2. Decoding Base64 Data","text":"<pre><code>func main() {\n    encoded := \"SGVsbG8sIFdvcmxkIQ==\"\n\n    decoded, err := base64.StdEncoding.DecodeString(encoded)\n    if err != nil {\n        fmt.Println(\"Decode error:\", err)\n        return\n    }\n\n    fmt.Println(\"Encoded:\", encoded)\n    fmt.Println(\"Decoded:\", string(decoded)) // Hello, World!\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#3-encoding-binary-data","title":"3. Encoding Binary Data","text":"<pre><code>func main() {\n    // Encode binary data\n    binaryData := []byte{0x48, 0x65, 0x6C, 0x6C, 0x6F} // \"Hello\" in bytes\n    encoded := base64.StdEncoding.EncodeToString(binaryData)\n    fmt.Printf(\"Binary: %x\\n\", binaryData)\n    fmt.Println(\"Encoded:\", encoded) // SGVsbG8=\n\n    // Decode back\n    decoded, err := base64.StdEncoding.DecodeString(encoded)\n    if err != nil {\n        fmt.Println(\"Decode error:\", err)\n        return\n    }\n    fmt.Printf(\"Decoded: %x\\n\", decoded)\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#url-safe-base64","title":"URL-Safe Base64","text":""},{"location":"2.%20Intermediate/22.%20Base64-Coding/#1-url-safe-encoding","title":"1. URL-Safe Encoding","text":"<p>Standard Base64 uses <code>+</code> and <code>/</code> which can cause issues in URLs. The URL-safe variant uses <code>-</code> and <code>_</code> instead:</p> <pre><code>func main() {\n    data := \"Hello, World! This is a test with special characters: +/=\"\n\n    // Standard encoding\n    standardEncoded := base64.StdEncoding.EncodeToString([]byte(data))\n    fmt.Println(\"Standard:\", standardEncoded)\n\n    // URL-safe encoding\n    urlEncoded := base64.URLEncoding.EncodeToString([]byte(data))\n    fmt.Println(\"URL-safe:\", urlEncoded)\n\n    // Note the difference: Standard uses + and /, URL-safe uses - and _\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#2-url-safe-decoding","title":"2. URL-Safe Decoding","text":"<pre><code>func main() {\n    urlEncoded := \"SGVsbG8sIFdvcmxkISBUaGlzIGlzIGEgdGVzdCB3aXRoIHNwZWNpYWwgY2hhcmFjdGVyczogKy8=\"\n\n    decoded, err := base64.URLEncoding.DecodeString(urlEncoded)\n    if err != nil {\n        fmt.Println(\"Decode error:\", err)\n        return\n    }\n\n    fmt.Println(\"URL-safe encoded:\", urlEncoded)\n    fmt.Println(\"Decoded:\", string(decoded))\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#raw-base64-without-padding","title":"Raw Base64 (Without Padding)","text":""},{"location":"2.%20Intermediate/22.%20Base64-Coding/#1-raw-encoding","title":"1. Raw Encoding","text":"<p>Raw Base64 omits the padding characters (<code>=</code>) at the end:</p> <pre><code>func main() {\n    data := \"Hello\"\n\n    // Standard encoding (with padding)\n    standardEncoded := base64.StdEncoding.EncodeToString([]byte(data))\n    fmt.Println(\"Standard (with padding):\", standardEncoded) // SGVsbG8=\n\n    // Raw encoding (without padding)\n    rawEncoded := base64.RawStdEncoding.EncodeToString([]byte(data))\n    fmt.Println(\"Raw (no padding):\", rawEncoded) // SGVsbG8\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#2-raw-decoding","title":"2. Raw Decoding","text":"<pre><code>func main() {\n    rawEncoded := \"SGVsbG8\" // No padding\n\n    // Raw decoding\n    decoded, err := base64.RawStdEncoding.DecodeString(rawEncoded)\n    if err != nil {\n        fmt.Println(\"Decode error:\", err)\n        return\n    }\n\n    fmt.Println(\"Raw encoded:\", rawEncoded)\n    fmt.Println(\"Decoded:\", string(decoded)) // Hello\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#streaming-operations","title":"Streaming Operations","text":""},{"location":"2.%20Intermediate/22.%20Base64-Coding/#1-streaming-encoding","title":"1. Streaming Encoding","text":"<p>For large data, use streaming to avoid loading everything into memory:</p> <pre><code>func main() {\n    // Create a pipe for streaming\n    pr, pw := io.Pipe()\n\n    // Start encoding in a goroutine\n    go func() {\n        defer pw.Close()\n        encoder := base64.NewEncoder(base64.StdEncoding, pw)\n        _, err := encoder.Write([]byte(\"Hello, streaming world!\"))\n        if err != nil {\n            fmt.Println(\"Encode error:\", err)\n            return\n        }\n        encoder.Close()\n    }()\n\n    // Read the encoded data\n    encoded, err := io.ReadAll(pr)\n    if err != nil {\n        fmt.Println(\"Read error:\", err)\n        return\n    }\n\n    fmt.Println(\"Streamed encoded:\", string(encoded))\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#2-streaming-decoding","title":"2. Streaming Decoding","text":"<pre><code>func main() {\n    encoded := \"SGVsbG8sIHN0cmVhbWluZyB3b3JsZCE=\"\n\n    // Create a pipe\n    pr, pw := io.Pipe()\n\n    // Start decoding in a goroutine\n    go func() {\n        defer pw.Close()\n        decoder := base64.NewDecoder(base64.StdEncoding, pr)\n        decoded, err := io.ReadAll(decoder)\n        if err != nil {\n            fmt.Println(\"Decode error:\", err)\n            return\n        }\n        fmt.Println(\"Streamed decoded:\", string(decoded))\n    }()\n\n    // Write encoded data to the pipe\n    _, err := pw.Write([]byte(encoded))\n    if err != nil {\n        fmt.Println(\"Write error:\", err)\n        return\n    }\n    pw.Close()\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#common-use-cases","title":"Common Use Cases","text":""},{"location":"2.%20Intermediate/22.%20Base64-Coding/#1-basic-authentication-header","title":"1. Basic Authentication Header","text":"<pre><code>func createBasicAuthHeader(username, password string) string {\n    credentials := username + \":\" + password\n    encoded := base64.StdEncoding.EncodeToString([]byte(credentials))\n    return \"Basic \" + encoded\n}\n\nfunc main() {\n    header := createBasicAuthHeader(\"alice\", \"secret123\")\n    fmt.Println(\"Authorization header:\", header)\n    // Output: Authorization: Basic YWxpY2U6c2VjcmV0MTIz\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#2-encoding-images-for-data-urls","title":"2. Encoding Images for Data URLs","text":"<pre><code>func imageToDataURL(imagePath string) (string, error) {\n    // Read image file\n    imageData, err := os.ReadFile(imagePath)\n    if err != nil {\n        return \"\", err\n    }\n\n    // Get MIME type (simplified - in real app, detect actual type)\n    mimeType := \"image/jpeg\"\n\n    // Encode to Base64\n    encoded := base64.StdEncoding.EncodeToString(imageData)\n\n    // Create data URL\n    return fmt.Sprintf(\"data:%s;base64,%s\", mimeType, encoded), nil\n}\n\nfunc main() {\n    // Note: This example assumes you have an image file\n    dataURL, err := imageToDataURL(\"example.jpg\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Data URL (first 100 chars):\", dataURL[:100]+\"...\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#3-jwt-json-web-token-components","title":"3. JWT (JSON Web Token) Components","text":"<pre><code>func encodeJWTPayload(payload map[string]interface{}) (string, error) {\n    // Convert payload to JSON\n    jsonData, err := json.Marshal(payload)\n    if err != nil {\n        return \"\", err\n    }\n\n    // Encode to Base64 URL-safe without padding\n    encoded := base64.RawURLEncoding.EncodeToString(jsonData)\n    return encoded, nil\n}\n\nfunc main() {\n    payload := map[string]interface{}{\n        \"sub\": \"1234567890\",\n        \"name\": \"John Doe\",\n        \"iat\": 1516239022,\n    }\n\n    encoded, err := encodeJWTPayload(payload)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Println(\"JWT Payload (Base64):\", encoded)\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#real-world-example-file-encryption-with-base64","title":"Real-World Example: File Encryption with Base64","text":"<p>Let's build a simple file encryption/decryption tool that uses Base64 encoding:</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"crypto/aes\"\n    \"crypto/cipher\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n)\n\n// EncryptedFile represents an encrypted file structure\ntype EncryptedFile struct {\n    IV        string `json:\"iv\"`        // Initialization vector\n    Ciphertext string `json:\"ciphertext\"` // Encrypted content\n}\n\n// FileEncryptor handles file encryption/decryption\ntype FileEncryptor struct {\n    key []byte\n}\n\nfunc NewFileEncryptor(key string) *FileEncryptor {\n    // Ensure key is 32 bytes for AES-256\n    keyBytes := []byte(key)\n    if len(keyBytes) &lt; 32 {\n        // Pad with zeros if key is too short\n        padded := make([]byte, 32)\n        copy(padded, keyBytes)\n        keyBytes = padded\n    } else if len(keyBytes) &gt; 32 {\n        keyBytes = keyBytes[:32] // Truncate if too long\n    }\n\n    return &amp;FileEncryptor{key: keyBytes}\n}\n\n// EncryptFile encrypts a file and saves the encrypted version\nfunc (fe *FileEncryptor) EncryptFile(inputPath, outputPath string) error {\n    // Read input file\n    plaintext, err := os.ReadFile(inputPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to read input file: %w\", err)\n    }\n\n    // Create cipher block\n    block, err := aes.NewCipher(fe.key)\n    if err != nil {\n        return fmt.Errorf(\"failed to create cipher: %w\", err)\n    }\n\n    // Generate IV\n    iv := make([]byte, aes.BlockSize)\n    if _, err := io.ReadFull(rand.Reader, iv); err != nil {\n        return fmt.Errorf(\"failed to generate IV: %w\", err)\n    }\n\n    // Encrypt the data\n    stream := cipher.NewCTR(block, iv)\n    ciphertext := make([]byte, len(plaintext))\n    stream.XORKeyStream(ciphertext, plaintext)\n\n    // Create encrypted file structure\n    encFile := EncryptedFile{\n        IV:        base64.StdEncoding.EncodeToString(iv),\n        Ciphertext: base64.StdEncoding.EncodeToString(ciphertext),\n    }\n\n    // Marshal to JSON\n    encData, err := json.Marshal(encFile)\n    if err != nil {\n        return fmt.Errorf(\"failed to marshal encrypted data: %w\", err)\n    }\n\n    // Write to output file\n    err = os.WriteFile(outputPath, encData, 0644)\n    if err != nil {\n        return fmt.Errorf(\"failed to write encrypted file: %w\", err)\n    }\n\n    fmt.Printf(\"File encrypted successfully: %s -&gt; %s\\n\", inputPath, outputPath)\n    return nil\n}\n\n// DecryptFile decrypts an encrypted file\nfunc (fe *FileEncryptor) DecryptFile(inputPath, outputPath string) error {\n    // Read encrypted file\n    encData, err := os.ReadFile(inputPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to read encrypted file: %w\", err)\n    }\n\n    // Unmarshal JSON\n    var encFile EncryptedFile\n    err = json.Unmarshal(encData, &amp;encFile)\n    if err != nil {\n        return fmt.Errorf(\"failed to unmarshal encrypted data: %w\", err)\n    }\n\n    // Decode Base64 components\n    iv, err := base64.StdEncoding.DecodeString(encFile.IV)\n    if err != nil {\n        return fmt.Errorf(\"failed to decode IV: %w\", err)\n    }\n\n    ciphertext, err := base64.StdEncoding.DecodeString(encFile.Ciphertext)\n    if err != nil {\n        return fmt.Errorf(\"failed to decode ciphertext: %w\", err)\n    }\n\n    // Create cipher block\n    block, err := aes.NewCipher(fe.key)\n    if err != nil {\n        return fmt.Errorf(\"failed to create cipher: %w\", err)\n    }\n\n    // Decrypt the data\n    stream := cipher.NewCTR(block, iv)\n    plaintext := make([]byte, len(ciphertext))\n    stream.XORKeyStream(plaintext, ciphertext)\n\n    // Write to output file\n    err = os.WriteFile(outputPath, plaintext, 0644)\n    if err != nil {\n        return fmt.Errorf(\"failed to write decrypted file: %w\", err)\n    }\n\n    fmt.Printf(\"File decrypted successfully: %s -&gt; %s\\n\", inputPath, outputPath)\n    return nil\n}\n\n// EncryptStream encrypts data from a reader to a writer\nfunc (fe *FileEncryptor) EncryptStream(src io.Reader, dst io.Writer) error {\n    // Create cipher block\n    block, err := aes.NewCipher(fe.key)\n    if err != nil {\n        return fmt.Errorf(\"failed to create cipher: %w\", err)\n    }\n\n    // Generate IV\n    iv := make([]byte, aes.BlockSize)\n    if _, err := io.ReadFull(rand.Reader, iv); err != nil {\n        return fmt.Errorf(\"failed to generate IV: %w\", err)\n    }\n\n    // Write IV to destination (Base64 encoded)\n    ivEncoded := base64.StdEncoding.EncodeToString(iv)\n    if _, err := dst.Write([]byte(ivEncoded + \"\\n\")); err != nil {\n        return fmt.Errorf(\"failed to write IV: %w\", err)\n    }\n\n    // Create encoder for streaming\n    encoder := base64.NewEncoder(base64.StdEncoding, dst)\n\n    // Create encrypting stream\n    stream := cipher.NewCTR(block, iv)\n\n    // Buffer for reading/writing\n    buf := make([]byte, 4096)\n\n    for {\n        n, err := src.Read(buf)\n        if err != nil &amp;&amp; err != io.EOF {\n            return fmt.Errorf(\"read error: %w\", err)\n        }\n        if n == 0 {\n            break\n        }\n\n        // Encrypt the buffer\n        encrypted := make([]byte, n)\n        stream.XORKeyStream(encrypted, buf[:n])\n\n        // Write encrypted data (Base64 encoded)\n        if _, err := encoder.Write(encrypted); err != nil {\n            return fmt.Errorf(\"write error: %w\", err)\n        }\n    }\n\n    // Close the encoder to flush any remaining data\n    if err := encoder.Close(); err != nil {\n        return fmt.Errorf(\"encoder close error: %w\", err)\n    }\n\n    return nil\n}\n\n// DecryptStream decrypts data from a reader to a writer\nfunc (fe *FileEncryptor) DecryptStream(src io.Reader, dst io.Writer) error {\n    // Read IV (first line)\n    scanner := bufio.NewScanner(src)\n    if !scanner.Scan() {\n        return fmt.Errorf(\"failed to read IV\")\n    }\n\n    ivEncoded := scanner.Text()\n    iv, err := base64.StdEncoding.DecodeString(ivEncoded)\n    if err != nil {\n        return fmt.Errorf(\"failed to decode IV: %w\", err)\n    }\n\n    // Create cipher block\n    block, err := aes.NewCipher(fe.key)\n    if err != nil {\n        return fmt.Errorf(\"failed to create cipher: %w\", err)\n    }\n\n    // Create decoder for streaming\n    decoder := base64.NewDecoder(base64.StdEncoding, src)\n\n    // Create decrypting stream\n    stream := cipher.NewCTR(block, iv)\n\n    // Buffer for reading/writing\n    buf := make([]byte, 4096)\n\n    for {\n        n, err := decoder.Read(buf)\n        if err != nil &amp;&amp; err != io.EOF {\n            return fmt.Errorf(\"read error: %w\", err)\n        }\n        if n == 0 {\n            break\n        }\n\n        // Decrypt the buffer\n        decrypted := make([]byte, n)\n        stream.XORKeyStream(decrypted, buf[:n])\n\n        // Write decrypted data\n        if _, err := dst.Write(decrypted); err != nil {\n            return fmt.Errorf(\"write error: %w\", err)\n        }\n    }\n\n    return nil\n}\n\nfunc main() {\n    // Create a sample file\n    sampleFile := \"sample.txt\"\n    encryptedFile := \"sample.enc\"\n    decryptedFile := \"sample_decrypted.txt\"\n\n    // Write sample content\n    err := os.WriteFile(sampleFile, []byte(\"This is a secret message that needs to be encrypted!\"), 0644)\n    if err != nil {\n        fmt.Println(\"Error creating sample file:\", err)\n        return\n    }\n\n    // Create encryptor with a key\n    encryptor := NewFileEncryptor(\"my-secret-key-123456789012345678901234\") // 32+ chars\n\n    // Encrypt the file\n    err = encryptor.EncryptFile(sampleFile, encryptedFile)\n    if err != nil {\n        fmt.Println(\"Encryption error:\", err)\n        return\n    }\n\n    // Decrypt the file\n    err = encryptor.DecryptFile(encryptedFile, decryptedFile)\n    if err != nil {\n        fmt.Println(\"Decryption error:\", err)\n        return\n    }\n\n    // Verify decryption\n    original, _ := os.ReadFile(sampleFile)\n    decrypted, _ := os.ReadFile(decryptedFile)\n\n    fmt.Printf(\"\\nOriginal content: %s\\n\", string(original))\n    fmt.Printf(\"Decrypted content: %s\\n\", string(decrypted))\n\n    if string(original) == string(decrypted) {\n        fmt.Println(\"\u2713 Encryption/decryption successful!\")\n    } else {\n        fmt.Println(\"\u2717 Encryption/decryption failed!\")\n    }\n\n    // Clean up\n    os.Remove(sampleFile)\n    os.Remove(encryptedFile)\n    os.Remove(decryptedFile)\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>File Encryption:</li> <li>Uses AES-256 encryption in CTR mode</li> <li>Generates a random IV (Initialization Vector)</li> <li>Encodes both IV and ciphertext in Base64</li> <li> <p>Stores everything in a JSON structure</p> </li> <li> <p>Streaming Operations:</p> </li> <li>Supports both file-based and stream-based encryption/decryption</li> <li>Uses Base64 encoding for the encrypted data</li> <li> <p>Handles large files efficiently with buffering</p> </li> <li> <p>Base64 Integration:</p> </li> <li>Encodes IV and ciphertext for safe storage/transmission</li> <li>Uses standard Base64 encoding for compatibility</li> <li>Demonstrates both string and streaming Base64 operations</li> </ol>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Secure Data Storage:</li> <li>Encrypt sensitive files before storage</li> <li>Encode encrypted data for database storage</li> <li> <p>Transmit encrypted data over text-based protocols</p> </li> <li> <p>API Communication:</p> </li> <li>Encode binary data in JSON/XML payloads</li> <li>Handle file uploads/downloads securely</li> <li> <p>Implement secure data exchange</p> </li> <li> <p>Configuration Management:</p> </li> <li>Encrypt configuration files</li> <li>Store encrypted secrets</li> <li>Encode encrypted data in environment variables</li> </ol>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/22.%20Base64-Coding/#1-choose-the-right-encoding-variant","title":"1. Choose the Right Encoding Variant","text":"<pre><code>// For URLs and filenames\nencoded := base64.URLEncoding.EncodeToString(data)\n\n// For JWT and similar tokens\nencoded := base64.RawURLEncoding.EncodeToString(data)\n\n// For general purpose\nencoded := base64.StdEncoding.EncodeToString(data)\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#2-handle-errors-gracefully","title":"2. Handle Errors Gracefully","text":"<pre><code>func safeDecode(encoded string) ([]byte, error) {\n    decoded, err := base64.StdEncoding.DecodeString(encoded)\n    if err != nil {\n        return nil, fmt.Errorf(\"base64 decode failed: %w\", err)\n    }\n    return decoded, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#3-validate-input-before-decoding","title":"3. Validate Input Before Decoding","text":"<pre><code>func isValidBase64(s string) bool {\n    _, err := base64.StdEncoding.DecodeString(s)\n    return err == nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#4-use-streaming-for-large-data","title":"4. Use Streaming for Large Data","text":"<pre><code>// For large files, use streaming instead of loading everything into memory\nfunc encodeLargeFile(src *os.File, dst *os.File) error {\n    encoder := base64.NewEncoder(base64.StdEncoding, dst)\n    _, err := io.Copy(encoder, src)\n    if err != nil {\n        return err\n    }\n    return encoder.Close()\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/22.%20Base64-Coding/#1-memory-usage","title":"1. Memory Usage","text":"<pre><code>// Bad: Loads entire file into memory\ndata, _ := os.ReadFile(\"largefile.bin\")\nencoded := base64.StdEncoding.EncodeToString(data)\n\n// Good: Uses streaming\nfile, _ := os.Open(\"largefile.bin\")\ndefer file.Close()\nencoder := base64.NewEncoder(base64.StdEncoding, os.Stdout)\nio.Copy(encoder, file)\nencoder.Close()\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#2-buffer-size","title":"2. Buffer Size","text":"<pre><code>// Adjust buffer size for optimal performance\nbuf := make([]byte, 64*1024) // 64KB buffer\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"2.%20Intermediate/22.%20Base64-Coding/#1-incorrect-encoding-variant","title":"1. Incorrect Encoding Variant","text":"<pre><code>// Encoding with StdEncoding but decoding with URLEncoding\nencoded := base64.StdEncoding.EncodeToString(data)\ndecoded, err := base64.URLEncoding.DecodeString(encoded) // Might fail!\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#2-forgetting-to-close-encodersdecoders","title":"2. Forgetting to Close Encoders/Decoders","text":"<pre><code>encoder := base64.NewEncoder(base64.StdEncoding, file)\nencoder.Write(data)\n// Missing: encoder.Close() - might leave data unflushed!\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#3-assuming-base64-is-encryption","title":"3. Assuming Base64 is Encryption","text":"<pre><code>// Base64 is encoding, not encryption!\n// It does not provide confidentiality\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#conclusion","title":"Conclusion","text":"<p>Base64 encoding is a fundamental tool for handling binary data in text-based environments. Go's <code>encoding/base64</code> package provides comprehensive support for:</p> <ol> <li>Standard Encoding/Decoding:</li> <li><code>StdEncoding</code> for general use</li> <li><code>URLEncoding</code> for URL-safe applications</li> <li> <p><code>RawStdEncoding</code> and <code>RawURLEncoding</code> for unpadded variants</p> </li> <li> <p>Streaming Operations:</p> </li> <li>Efficient handling of large data</li> <li>Memory-friendly processing</li> <li> <p>Integration with <code>io.Reader</code> and <code>io.Writer</code></p> </li> <li> <p>Common Use Cases:</p> </li> <li>Basic authentication headers</li> <li>Data URLs for images and files</li> <li>JWT and other token formats</li> <li>Email attachments</li> <li>Storing binary data in text formats</li> </ol> <p>The file encryption example demonstrates how Base64 integrates with cryptographic operations to provide secure data handling. By understanding the different encoding variants and following best practices, you can effectively use Base64 in your Go applications for various data transformation needs.</p> <p>Key takeaways: 1. Choose the right variant for your use case (Standard, URL-safe, Raw) 2. Use streaming for large data to avoid memory issues 3. Remember Base64 is encoding, not encryption 4. Handle errors properly when decoding 5. Close encoders/decoders to ensure all data is flushed</p> <p>Base64 is a simple yet powerful tool that bridges the gap between binary and text data, making it essential for many modern applications.</p>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/","title":"Cryptographic Hashing in Go: SHA-256/512 and the Crypto Package","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#introduction-to-cryptographic-hashing","title":"Introduction to Cryptographic Hashing","text":"<p>Cryptographic hash functions are fundamental building blocks of modern cryptography. They transform arbitrary input data into fixed-size output values (hashes) with specific security properties. Go's <code>crypto</code> package provides robust implementations of various cryptographic algorithms, including SHA-256 and SHA-512.</p>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#understanding-hash-functions","title":"Understanding Hash Functions","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#key-properties-of-cryptographic-hash-functions","title":"Key Properties of Cryptographic Hash Functions","text":"<ul> <li>Deterministic: Same input always produces same output</li> <li>Pre-image resistant: Given a hash, it's computationally infeasible to find the input</li> <li>Second pre-image resistant: Given an input, it's hard to find another input with same hash</li> <li>Collision resistant: Hard to find two different inputs with same hash</li> <li>Avalanche effect: Small change in input produces significant change in output</li> </ul>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#common-hash-algorithms","title":"Common Hash Algorithms","text":"<ul> <li>MD5: 128-bit hash (broken, not recommended for security)</li> <li>SHA-1: 160-bit hash (deprecated for security)</li> <li>SHA-256: 256-bit hash (part of SHA-2 family)</li> <li>SHA-512: 512-bit hash (part of SHA-2 family)</li> <li>SHA-3: Latest standard (Keccak algorithm)</li> </ul>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#sha-256-implementation-in-go","title":"SHA-256 Implementation in Go","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#1-basic-sha-256-hashing","title":"1. Basic SHA-256 Hashing","text":"<pre><code>package main\n\nimport (\n    \"crypto/sha256\"\n    \"encoding/hex\"\n    \"fmt\"\n)\n\nfunc main() {\n    // Simple string hashing\n    data := \"Hello, World!\"\n    hash := sha256.Sum256([]byte(data))\n\n    // Convert to hexadecimal string\n    hashString := hex.EncodeToString(hash[:])\n    fmt.Printf(\"SHA-256 hash of %q: %s\\n\", data, hashString)\n    // Output: SHA-256 hash of \"Hello, World!\": dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#2-hashing-files","title":"2. Hashing Files","text":"<pre><code>func hashFile(filename string) (string, error) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return \"\", err\n    }\n    defer file.Close()\n\n    hasher := sha256.New()\n    if _, err := io.Copy(hasher, file); err != nil {\n        return \"\", err\n    }\n\n    return hex.EncodeToString(hasher.Sum(nil)), nil\n}\n\nfunc main() {\n    // Create a sample file\n    content := []byte(\"This is a test file for SHA-256 hashing.\")\n    err := os.WriteFile(\"test.txt\", content, 0644)\n    if err != nil {\n        fmt.Println(\"Error creating file:\", err)\n        return\n    }\n\n    // Hash the file\n    hash, err := hashFile(\"test.txt\")\n    if err != nil {\n        fmt.Println(\"Error hashing file:\", err)\n        return\n    }\n\n    fmt.Printf(\"SHA-256 hash of file: %s\\n\", hash)\n\n    // Clean up\n    os.Remove(\"test.txt\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#3-incremental-hashing","title":"3. Incremental Hashing","text":"<pre><code>func incrementalHash() {\n    hasher := sha256.New()\n\n    // Write data in chunks\n    hasher.Write([]byte(\"First part \"))\n    hasher.Write([]byte(\"second part \"))\n    hasher.Write([]byte(\"third part\"))\n\n    hash := hasher.Sum(nil)\n    fmt.Printf(\"Incremental hash: %x\\n\", hash)\n}\n\nfunc main() {\n    incrementalHash()\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#sha-512-implementation-in-go","title":"SHA-512 Implementation in Go","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#1-basic-sha-512-hashing","title":"1. Basic SHA-512 Hashing","text":"<pre><code>func main() {\n    data := \"Hello, World!\"\n    hash := sha512.Sum512([]byte(data))\n\n    fmt.Printf(\"SHA-512 hash of %q:\\n%x\\n\", data, hash)\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#2-sha-512224-and-sha-512256-variants","title":"2. SHA-512/224 and SHA-512/256 Variants","text":"<pre><code>func main() {\n    data := \"Hello, World!\"\n\n    // SHA-512/224 (truncated to 224 bits)\n    hash224 := sha512.Sum512_224([]byte(data))\n    fmt.Printf(\"SHA-512/224: %x\\n\", hash224)\n\n    // SHA-512/256 (truncated to 256 bits)\n    hash256 := sha512.Sum512_256([]byte(data))\n    fmt.Printf(\"SHA-512/256: %x\\n\", hash256)\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#the-crypto-package","title":"The Crypto Package","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#1-overview-of-gos-crypto-package","title":"1. Overview of Go's Crypto Package","text":"<p>Go's <code>crypto</code> package provides a collection of cryptographic algorithms: - Hash functions (SHA-256, SHA-512, etc.) - Message Authentication Codes (HMAC) - Digital signatures - Encryption and decryption - Random number generation</p>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#2-available-hash-functions","title":"2. Available Hash Functions","text":"<pre><code>func availableHashes() {\n    data := \"Hello, World!\"\n\n    // MD5 (not secure, for legacy compatibility)\n    md5Hash := md5.Sum([]byte(data))\n    fmt.Printf(\"MD5: %x\\n\", md5Hash)\n\n    // SHA-1 (deprecated)\n    sha1Hash := sha1.Sum([]byte(data))\n    fmt.Printf(\"SHA-1: %x\\n\", sha1Hash)\n\n    // SHA-224\n    sha224Hash := sha256.Sum224([]byte(data))\n    fmt.Printf(\"SHA-224: %x\\n\", sha224Hash)\n\n    // SHA-256\n    sha256Hash := sha256.Sum256([]byte(data))\n    fmt.Printf(\"SHA-256: %x\\n\", sha256Hash)\n\n    // SHA-384\n    sha384Hash := sha512.Sum384([]byte(data))\n    fmt.Printf(\"SHA-384: %x\\n\", sha384Hash)\n\n    // SHA-512\n    sha512Hash := sha512.Sum512([]byte(data))\n    fmt.Printf(\"SHA-512: %x\\n\", sha512Hash)\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#hmac-hash-based-message-authentication-code","title":"HMAC (Hash-based Message Authentication Code)","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#1-hmac-with-sha-256","title":"1. HMAC with SHA-256","text":"<pre><code>func computeHMAC(message, key []byte) []byte {\n    mac := hmac.New(sha256.New, key)\n    mac.Write(message)\n    return mac.Sum(nil)\n}\n\nfunc main() {\n    message := []byte(\"Important message\")\n    key := []byte(\"secret-key\")\n\n    // Compute HMAC\n    hmac := computeHMAC(message, key)\n    fmt.Printf(\"HMAC-SHA256: %x\\n\", hmac)\n\n    // Verify HMAC (in real scenario, receiver would do this)\n    receivedHMAC := computeHMAC(message, key)\n    if hmac.Equal(receivedHMAC, hmac) {\n        fmt.Println(\"HMAC verification: SUCCESS\")\n    } else {\n        fmt.Println(\"HMAC verification: FAILED\")\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#password-hashing","title":"Password Hashing","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#1-why-not-use-plain-hash-functions-for-passwords","title":"1. Why Not Use Plain Hash Functions for Passwords?","text":"<p>Plain hash functions are fast, which makes them vulnerable to brute-force attacks. Passwords should be hashed with: - Slow hashing functions (to slow down brute-force) - Salting (to prevent rainbow table attacks) - Key stretching (multiple iterations)</p>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#2-using-bcrypt-for-password-hashing","title":"2. Using bcrypt for Password Hashing","text":"<pre><code>func hashPassword(password string) (string, error) {\n    // Generate a salt (bcrypt handles this automatically)\n    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n    if err != nil {\n        return \"\", err\n    }\n    return string(hashedPassword), nil\n}\n\nfunc checkPassword(hashedPassword, password string) bool {\n    err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))\n    return err == nil\n}\n\nfunc main() {\n    password := \"mySecretPassword123\"\n\n    // Hash the password\n    hashed, err := hashPassword(password)\n    if err != nil {\n        fmt.Println(\"Error hashing password:\", err)\n        return\n    }\n    fmt.Printf(\"Hashed password: %s\\n\", hashed)\n\n    // Check password\n    match := checkPassword(hashed, password)\n    fmt.Printf(\"Password check: %v\\n\", match)\n\n    // Check wrong password\n    match = checkPassword(hashed, \"wrongPassword\")\n    fmt.Printf(\"Wrong password check: %v\\n\", match)\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#3-using-scrypt-for-password-hashing","title":"3. Using scrypt for Password Hashing","text":"<pre><code>func hashPasswordScrypt(password string) (string, error) {\n    // Generate a random salt\n    salt := make([]byte, 16)\n    if _, err := rand.Read(salt); err != nil {\n        return \"\", err\n    }\n\n    // Hash the password with scrypt\n    hash, err := scrypt.Key([]byte(password), salt, 32768, 8, 1, 32)\n    if err != nil {\n        return \"\", err\n    }\n\n    // Prepend salt to hash for storage\n    storedHash := append(salt, hash...)\n    return base64.StdEncoding.EncodeToString(storedHash), nil\n}\n\nfunc checkPasswordScrypt(hashedPassword, password string) (bool, error) {\n    // Decode the stored hash\n    storedHash, err := base64.StdEncoding.DecodeString(hashedPassword)\n    if err != nil {\n        return false, err\n    }\n\n    // Extract salt and hash\n    salt := storedHash[:16]\n    expectedHash := storedHash[16:]\n\n    // Hash the provided password with the same salt\n    hash, err := scrypt.Key([]byte(password), salt, 32768, 8, 1, 32)\n    if err != nil {\n        return false, err\n    }\n\n    // Compare hashes\n    return subtle.ConstantTimeCompare(expectedHash, hash), nil\n}\n\nfunc main() {\n    password := \"mySecretPassword123\"\n\n    // Hash the password\n    hashed, err := hashPasswordScrypt(password)\n    if err != nil {\n        fmt.Println(\"Error hashing password:\", err)\n        return\n    }\n    fmt.Printf(\"Hashed password: %s\\n\", hashed)\n\n    // Check password\n    match, err := checkPasswordScrypt(hashed, password)\n    if err != nil {\n        fmt.Println(\"Error checking password:\", err)\n        return\n    }\n    fmt.Printf(\"Password check: %v\\n\", match)\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#real-world-example-file-integrity-checker","title":"Real-World Example: File Integrity Checker","text":"<p>Let's build a comprehensive file integrity checker that uses SHA-256 to detect file changes:</p> <pre><code>package main\n\nimport (\n    \"crypto/sha256\"\n    \"encoding/hex\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n    \"time\"\n)\n\n// FileHash represents a file and its hash\ntype FileHash struct {\n    Path     string    `json:\"path\"`\n    Hash     string    `json:\"hash\"`\n    Modified time.Time `json:\"modified\"`\n    Size     int64     `json:\"size\"`\n}\n\n// IntegrityDatabase stores file hashes for integrity checking\ntype IntegrityDatabase struct {\n    Files map[string]FileHash `json:\"files\"`\n}\n\n// NewIntegrityDatabase creates a new integrity database\nfunc NewIntegrityDatabase() *IntegrityDatabase {\n    return &amp;IntegrityDatabase{\n        Files: make(map[string]FileHash),\n    }\n}\n\n// AddFile adds a file to the database\nfunc (db *IntegrityDatabase) AddFile(path string) error {\n    // Get file info\n    info, err := os.Stat(path)\n    if err != nil {\n        return fmt.Errorf(\"failed to stat file: %w\", err)\n    }\n\n    // Calculate hash\n    hash, err := calculateFileHash(path)\n    if err != nil {\n        return fmt.Errorf(\"failed to calculate hash: %w\", err)\n    }\n\n    // Add to database\n    db.Files[path] = FileHash{\n        Path:     path,\n        Hash:     hash,\n        Modified: info.ModTime(),\n        Size:     info.Size(),\n    }\n\n    return nil\n}\n\n// AddDirectory adds all files in a directory to the database\nfunc (db *IntegrityDatabase) AddDirectory(dirPath string) error {\n    return filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        // Skip directories\n        if info.IsDir() {\n            return nil\n        }\n\n        // Add file to database\n        if err := db.AddFile(path); err != nil {\n            fmt.Printf(\"Error adding file %s: %v\\n\", path, err)\n        }\n\n        return nil\n    })\n}\n\n// CheckIntegrity checks if files have been modified\nfunc (db *IntegrityDatabase) CheckIntegrity() ([]string, error) {\n    var modifiedFiles []string\n\n    for path, storedHash := range db.Files {\n        // Check if file still exists\n        if _, err := os.Stat(path); os.IsNotExist(err) {\n            modifiedFiles = append(modifiedFiles, fmt.Sprintf(\"DELETED: %s\", path))\n            continue\n        }\n\n        // Get current file info\n        info, err := os.Stat(path)\n        if err != nil {\n            modifiedFiles = append(modifiedFiles, fmt.Sprintf(\"ERROR: %s - %v\", path, err))\n            continue\n        }\n\n        // Check modification time\n        if info.ModTime() != storedHash.Modified {\n            modifiedFiles = append(modifiedFiles, fmt.Sprintf(\"MODIFIED: %s (timestamp changed)\", path))\n            continue\n        }\n\n        // Check size\n        if info.Size() != storedHash.Size {\n            modifiedFiles = append(modifiedFiles, fmt.Sprintf(\"MODIFIED: %s (size changed)\", path))\n            continue\n        }\n\n        // Check hash\n        currentHash, err := calculateFileHash(path)\n        if err != nil {\n            modifiedFiles = append(modifiedFiles, fmt.Sprintf(\"ERROR: %s - %v\", path, err))\n            continue\n        }\n\n        if currentHash != storedHash.Hash {\n            modifiedFiles = append(modifiedFiles, fmt.Sprintf(\"MODIFIED: %s (content changed)\", path))\n        }\n    }\n\n    return modifiedFiles, nil\n}\n\n// Save saves the database to a file\nfunc (db *IntegrityDatabase) Save(filename string) error {\n    data, err := json.MarshalIndent(db, \"\", \"  \")\n    if err != nil {\n        return fmt.Errorf(\"failed to marshal database: %w\", err)\n    }\n\n    return os.WriteFile(filename, data, 0644)\n}\n\n// Load loads the database from a file\nfunc (db *IntegrityDatabase) Load(filename string) error {\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return fmt.Errorf(\"failed to read database file: %w\", err)\n    }\n\n    return json.Unmarshal(data, db)\n}\n\n// calculateFileHash calculates the SHA-256 hash of a file\nfunc calculateFileHash(filename string) (string, error) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return \"\", err\n    }\n    defer file.Close()\n\n    hasher := sha256.New()\n    if _, err := io.Copy(hasher, file); err != nil {\n        return \"\", err\n    }\n\n    return hex.EncodeToString(hasher.Sum(nil)), nil\n}\n\nfunc main() {\n    // Create a sample directory structure\n    baseDir := \"test_files\"\n    subDir := filepath.Join(baseDir, \"subdir\")\n\n    // Create directories\n    os.MkdirAll(subDir, 0755)\n    defer os.RemoveAll(baseDir) // Clean up\n\n    // Create sample files\n    files := map[string]string{\n        filepath.Join(baseDir, \"file1.txt\"):          \"This is file 1\",\n        filepath.Join(baseDir, \"file2.txt\"):          \"This is file 2\",\n        filepath.Join(subDir, \"subfile1.txt\"):       \"This is subfile 1\",\n        filepath.Join(subDir, \"subfile2.txt\"):       \"This is subfile 2\",\n    }\n\n    for path, content := range files {\n        err := os.WriteFile(path, []byte(content), 0644)\n        if err != nil {\n            fmt.Printf(\"Error creating file %s: %v\\n\", path, err)\n            continue\n        }\n    }\n\n    // Create integrity database\n    db := NewIntegrityDatabase()\n\n    // Add all files to database\n    fmt.Println(\"Adding files to integrity database...\")\n    err := db.AddDirectory(baseDir)\n    if err != nil {\n        fmt.Printf(\"Error adding directory: %v\\n\", err)\n        return\n    }\n\n    // Save database\n    dbFile := \"integrity_db.json\"\n    err = db.Save(dbFile)\n    if err != nil {\n        fmt.Printf(\"Error saving database: %v\\n\", err)\n        return\n    }\n    fmt.Printf(\"Database saved to %s\\n\", dbFile)\n\n    // Check integrity (should be clean)\n    fmt.Println(\"\\nChecking integrity (should be clean)...\")\n    modified, err := db.CheckIntegrity()\n    if err != nil {\n        fmt.Printf(\"Error checking integrity: %v\\n\", err)\n        return\n    }\n\n    if len(modified) == 0 {\n        fmt.Println(\"All files are intact!\")\n    } else {\n        fmt.Println(\"Modified files:\")\n        for _, msg := range modified {\n            fmt.Println(\"  -\", msg)\n        }\n    }\n\n    // Modify a file\n    fmt.Println(\"\\nModifying a file...\")\n    modifiedFile := filepath.Join(baseDir, \"file1.txt\")\n    err = os.WriteFile(modifiedFile, []byte(\"This file has been modified!\"), 0644)\n    if err != nil {\n        fmt.Printf(\"Error modifying file: %v\\n\", err)\n        return\n    }\n\n    // Check integrity again\n    fmt.Println(\"\\nChecking integrity (should detect modification)...\")\n    modified, err = db.CheckIntegrity()\n    if err != nil {\n        fmt.Printf(\"Error checking integrity: %v\\n\", err)\n        return\n    }\n\n    fmt.Println(\"Modified files:\")\n    for _, msg := range modified {\n        fmt.Println(\"  -\", msg)\n    }\n\n    // Delete a file\n    fmt.Println(\"\\nDeleting a file...\")\n    deletedFile := filepath.Join(subDir, \"subfile1.txt\")\n    err = os.Remove(deletedFile)\n    if err != nil {\n        fmt.Printf(\"Error deleting file: %v\\n\", err)\n        return\n    }\n\n    // Check integrity again\n    fmt.Println(\"\\nChecking integrity (should detect deletion)...\")\n    modified, err = db.CheckIntegrity()\n    if err != nil {\n        fmt.Printf(\"Error checking integrity: %v\\n\", err)\n        return\n    }\n\n    fmt.Println(\"Modified files:\")\n    for _, msg := range modified {\n        fmt.Println(\"  -\", msg)\n    }\n\n    // Clean up\n    os.Remove(dbFile)\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>File Integrity Database:</li> <li>Stores SHA-256 hashes of files along with metadata</li> <li>Tracks file paths, modification times, and sizes</li> <li> <p>Saves and loads database from JSON</p> </li> <li> <p>Directory Scanning:</p> </li> <li>Recursively scans directories to add all files</li> <li>Calculates SHA-256 hashes for each file</li> <li> <p>Stores file metadata for comparison</p> </li> <li> <p>Integrity Checking:</p> </li> <li>Compares current file state with stored hashes</li> <li>Detects modifications, deletions, and other changes</li> <li> <p>Provides detailed reports of all changes</p> </li> <li> <p>Security Features:</p> </li> <li>Uses SHA-256 for cryptographic integrity</li> <li>Checks multiple attributes (hash, size, timestamp)</li> <li>Provides comprehensive change detection</li> </ol>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Security Auditing:</li> <li>Detect unauthorized file changes</li> <li>Monitor system files for tampering</li> <li> <p>Verify software integrity</p> </li> <li> <p>Backup Verification:</p> </li> <li>Ensure backup files haven't been corrupted</li> <li>Verify restore operations</li> <li> <p>Detect bit rot in storage systems</p> </li> <li> <p>Compliance Monitoring:</p> </li> <li>Track changes to regulated files</li> <li>Maintain audit trails</li> <li>Demonstrate data integrity</li> </ol>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#1-choose-the-right-hash-algorithm","title":"1. Choose the Right Hash Algorithm","text":"<pre><code>// For general purpose integrity checking\nhash := sha256.Sum256(data)\n\n// For higher security requirements\nhash := sha512.Sum512(data)\n\n// For legacy systems (not recommended for new applications)\nhash := sha1.Sum(data) // Deprecated\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#2-use-constant-time-comparison-for-security","title":"2. Use Constant-Time Comparison for Security","text":"<pre><code>// Good: Use constant-time comparison\nif subtle.ConstantTimeCompare(expectedHash, actualHash) == 1 {\n    // Hashes match\n}\n\n// Bad: Regular comparison vulnerable to timing attacks\nif expectedHash == actualHash {\n    // Hashes match\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#3-handle-passwords-properly","title":"3. Handle Passwords Properly","text":"<pre><code>// Good: Use bcrypt or scrypt for passwords\nhashedPassword, err := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n\n// Bad: Use plain hash functions for passwords\nhash := sha256.Sum256(password) // Vulnerable to brute-force\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#4-use-salt-for-password-hashing","title":"4. Use Salt for Password Hashing","text":"<pre><code>// Good: bcrypt handles salting automatically\nhashedPassword, _ := bcrypt.GenerateFromPassword(password, 12)\n\n// Bad: Hash without salt\nhash := sha256.Sum256([]byte(\"password\" + \"static_salt\")) // Vulnerable\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#security-considerations","title":"Security Considerations","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#1-hash-function-security","title":"1. Hash Function Security","text":"<ul> <li>MD5 and SHA-1: Broken, not suitable for security</li> <li>SHA-256: Currently secure for most applications</li> <li>SHA-512: More secure, uses more resources</li> <li>SHA-3: Latest standard, alternative to SHA-2</li> </ul>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#2-password-hashing-security","title":"2. Password Hashing Security","text":"<ul> <li>Never use plain hash functions for passwords</li> <li>Use specialized algorithms like bcrypt, scrypt, or Argon2</li> <li>Use appropriate work factors to slow down brute-force attacks</li> <li>Always use unique salts for each password</li> </ul>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#3-integrity-verification-security","title":"3. Integrity Verification Security","text":"<ul> <li>Store hashes securely (separate from data)</li> <li>Use HMAC when hash needs to be verified by untrusted parties</li> <li>Consider digital signatures for non-repudiation</li> </ul>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#1-hash-function-performance","title":"1. Hash Function Performance","text":"<pre><code>// SHA-256 is generally faster than SHA-512\n// Benchmark for your specific use case\nfunc benchmarkHashes(data []byte) {\n    start := time.Now()\n    sha256.Sum256(data)\n    sha256Duration := time.Since(start)\n\n    start = time.Now()\n    sha512.Sum512(data)\n    sha512Duration := time.Since(start)\n\n    fmt.Printf(\"SHA-256: %v\\n\", sha256Duration)\n    fmt.Printf(\"SHA-512: %v\\n\", sha512Duration)\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#2-memory-usage-for-large-files","title":"2. Memory Usage for Large Files","text":"<pre><code>// Good: Stream hashing for large files\nfunc hashLargeFile(filename string) (string, error) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return \"\", err\n    }\n    defer file.Close()\n\n    hasher := sha256.New()\n    if _, err := io.Copy(hasher, file); err != nil {\n        return \"\", err\n    }\n\n    return hex.EncodeToString(hasher.Sum(nil)), nil\n}\n\n// Bad: Load entire file into memory\nfunc hashLargeFileBad(filename string) (string, error) {\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return \"\", err\n    }\n    hash := sha256.Sum256(data)\n    return hex.EncodeToString(hash[:]), nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#conclusion","title":"Conclusion","text":"<p>Cryptographic hashing is a fundamental security primitive in Go. The <code>crypto</code> package provides robust implementations of:</p> <ol> <li>Hash Functions:</li> <li>SHA-256 and SHA-512 for integrity checking</li> <li>Various output sizes (224, 256, 384, 512 bits)</li> <li> <p>Streaming support for large data</p> </li> <li> <p>Message Authentication:</p> </li> <li>HMAC for verifying message integrity and authenticity</li> <li> <p>Support for different hash algorithms</p> </li> <li> <p>Password Hashing:</p> </li> <li>bcrypt for secure password storage</li> <li>scrypt for memory-hard password hashing</li> <li> <p>Protection against brute-force attacks</p> </li> <li> <p>Security Applications:</p> </li> <li>File integrity verification</li> <li>Digital signatures</li> <li>Data deduplication</li> <li>Blockchain and cryptocurrency</li> </ol> <p>The file integrity checker example demonstrates how to build a practical security application using SHA-256 hashing. By following best practices and understanding security considerations, you can effectively use cryptographic hashing in your Go applications to protect data integrity and enhance security.</p> <p>Key takeaways: 1. Use SHA-256 or SHA-512 for integrity checking (avoid MD5/SHA-1) 2. Use specialized algorithms (bcrypt, scrypt) for password hashing 3. Implement constant-time comparison for security-sensitive operations 4. Use streaming for large files to avoid memory issues 5. Store hashes securely separate from the data they protect</p> <p>Cryptographic hashing is a powerful tool for ensuring data integrity and security, but it must be used correctly to be effective. Go's crypto package provides all the tools you need to implement secure hashing in your applications.</p>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/","title":"File I/O in Go: Reading and Writing Files","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#introduction-to-file-operations-in-go","title":"Introduction to File Operations in Go","text":"<p>File input/output (I/O) is a fundamental aspect of many applications. Go provides a rich set of packages for file operations, primarily through the <code>os</code>, <code>io</code>, and <code>bufio</code> packages. This guide covers reading from and writing to files, handling different file modes, error handling, and best practices.</p>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#basic-file-operations","title":"Basic File Operations","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-creating-and-writing-files","title":"1. Creating and Writing Files","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Create a new file\n    file, err := os.Create(\"example.txt\")\n    if err != nil {\n        fmt.Println(\"Error creating file:\", err)\n        return\n    }\n    defer file.Close() // Ensure file is closed when done\n\n    // Write a string to the file\n    _, err = file.WriteString(\"Hello, World!\\n\")\n    if err != nil {\n        fmt.Println(\"Error writing to file:\", err)\n        return\n    }\n\n    // Write bytes to the file\n    _, err = file.Write([]byte(\"This is a byte slice.\\n\"))\n    if err != nil {\n        fmt.Println(\"Error writing bytes:\", err)\n        return\n    }\n\n    fmt.Println(\"File created and written successfully\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-reading-files","title":"2. Reading Files","text":"<pre><code>func main() {\n    // Open the file for reading\n    file, err := os.Open(\"example.txt\")\n    if err != nil {\n        fmt.Println(\"Error opening file:\", err)\n        return\n    }\n    defer file.Close()\n\n    // Read the entire file content\n    content, err := os.ReadFile(\"example.txt\")\n    if err != nil {\n        fmt.Println(\"Error reading file:\", err)\n        return\n    }\n\n    fmt.Println(\"File content:\")\n    fmt.Println(string(content))\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#file-opening-modes","title":"File Opening Modes","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-different-open-flags","title":"1. Different Open Flags","text":"<p>Go provides various flags for opening files with different modes:</p> <pre><code>func main() {\n    // Open file with different modes\n    flags := []struct {\n        name string\n        flag int\n        mode string\n    }{\n        {\"Read Only\", os.O_RDONLY, \"r\"},\n        {\"Write Only\", os.O_WRONLY, \"w\"},\n        {\"Read Write\", os.O_RDWR, \"rw\"},\n        {\"Append\", os.O_APPEND, \"a\"},\n        {\"Create\", os.O_CREATE, \"create\"},\n        {\"Truncate\", os.O_TRUNC, \"truncate\"},\n        {\"Exclusive\", os.O_EXCL, \"exclusive\"},\n    }\n\n    for _, f := range flags {\n        fmt.Printf(\"%-12s: %d (%s)\\n\", f.name, f.flag, f.mode)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-using-openfile-with-flags","title":"2. Using OpenFile with Flags","text":"<pre><code>func main() {\n    // Open file in append mode\n    file, err := os.OpenFile(\"example.txt\", os.O_APPEND|os.O_WRONLY, 0644)\n    if err != nil {\n        fmt.Println(\"Error opening file:\", err)\n        return\n    }\n    defer file.Close()\n\n    // Append content\n    _, err = file.WriteString(\"Appended content.\\n\")\n    if err != nil {\n        fmt.Println(\"Error appending to file:\", err)\n        return\n    }\n\n    fmt.Println(\"Content appended successfully\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#buffered-io-with-bufio","title":"Buffered I/O with bufio","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-buffered-writing","title":"1. Buffered Writing","text":"<pre><code>func main() {\n    // Create file\n    file, err := os.Create(\"buffered_example.txt\")\n    if err != nil {\n        fmt.Println(\"Error creating file:\", err)\n        return\n    }\n    defer file.Close()\n\n    // Create buffered writer\n    writer := bufio.NewWriter(file)\n    defer writer.Flush() // Ensure all buffered data is written\n\n    // Write multiple lines\n    lines := []string{\n        \"First line\",\n        \"Second line\",\n        \"Third line\",\n    }\n\n    for _, line := range lines {\n        _, err := writer.WriteString(line + \"\\n\")\n        if err != nil {\n            fmt.Println(\"Error writing:\", err)\n            return\n        }\n    }\n\n    fmt.Println(\"Buffered writing completed\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-buffered-reading","title":"2. Buffered Reading","text":"<pre><code>func main() {\n    // Open file\n    file, err := os.Open(\"buffered_example.txt\")\n    if err != nil {\n        fmt.Println(\"Error opening file:\", err)\n        return\n    }\n    defer file.Close()\n\n    // Create buffered reader\n    reader := bufio.NewReader(file)\n\n    // Read line by line\n    fmt.Println(\"Reading file line by line:\")\n    for {\n        line, err := reader.ReadString('\\n')\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            fmt.Println(\"Error reading:\", err)\n            return\n        }\n        fmt.Print(line)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#3-using-scanner-for-line-by-line-reading","title":"3. Using Scanner for Line-by-Line Reading","text":"<pre><code>func main() {\n    // Open file\n    file, err := os.Open(\"buffered_example.txt\")\n    if err != nil {\n        fmt.Println(\"Error opening file:\", err)\n        return\n    }\n    defer file.Close()\n\n    // Create scanner\n    scanner := bufio.NewScanner(file)\n\n    // Read line by line\n    fmt.Println(\"Using scanner:\")\n    for scanner.Scan() {\n        fmt.Println(scanner.Text())\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Println(\"Scanner error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#working-with-different-file-formats","title":"Working with Different File Formats","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-json-files","title":"1. JSON Files","text":"<pre><code>type Person struct {\n    Name string `json:\"name\"`\n    Age  int    `json:\"age\"`\n}\n\nfunc main() {\n    // Write JSON file\n    people := []Person{\n        {\"Alice\", 30},\n        {\"Bob\", 25},\n        {\"Charlie\", 35},\n    }\n\n    // Marshal to JSON\n    jsonData, err := json.MarshalIndent(people, \"\", \"  \")\n    if err != nil {\n        fmt.Println(\"Error marshaling JSON:\", err)\n        return\n    }\n\n    // Write to file\n    err = os.WriteFile(\"people.json\", jsonData, 0644)\n    if err != nil {\n        fmt.Println(\"Error writing JSON file:\", err)\n        return\n    }\n\n    // Read JSON file\n    var readPeople []Person\n    data, err := os.ReadFile(\"people.json\")\n    if err != nil {\n        fmt.Println(\"Error reading JSON file:\", err)\n        return\n    }\n\n    err = json.Unmarshal(data, &amp;readPeople)\n    if err != nil {\n        fmt.Println(\"Error unmarshaling JSON:\", err)\n        return\n    }\n\n    fmt.Println(\"Read from JSON file:\")\n    for _, person := range readPeople {\n        fmt.Printf(\"%s is %d years old\\n\", person.Name, person.Age)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-csv-files","title":"2. CSV Files","text":"<pre><code>func main() {\n    // Write CSV file\n    file, err := os.Create(\"data.csv\")\n    if err != nil {\n        fmt.Println(\"Error creating CSV file:\", err)\n        return\n    }\n    defer file.Close()\n\n    writer := csv.NewWriter(file)\n    defer writer.Flush()\n\n    // Write header\n    err = writer.Write([]string{\"Name\", \"Age\", \"City\"})\n    if err != nil {\n        fmt.Println(\"Error writing header:\", err)\n        return\n    }\n\n    // Write records\n    records := [][]string{\n        {\"Alice\", \"30\", \"New York\"},\n        {\"Bob\", \"25\", \"Los Angeles\"},\n        {\"Charlie\", \"35\", \"Chicago\"},\n    }\n\n    for _, record := range records {\n        err = writer.Write(record)\n        if err != nil {\n            fmt.Println(\"Error writing record:\", err)\n            return\n        }\n    }\n\n    // Read CSV file\n    file, err = os.Open(\"data.csv\")\n    if err != nil {\n        fmt.Println(\"Error opening CSV file:\", err)\n        return\n    }\n    defer file.Close()\n\n    reader := csv.NewReader(file)\n    records, err = reader.ReadAll()\n    if err != nil {\n        fmt.Println(\"Error reading CSV:\", err)\n        return\n    }\n\n    fmt.Println(\"\\nRead from CSV file:\")\n    for i, record := range records {\n        if i == 0 {\n            fmt.Printf(\"Header: %v\\n\", record)\n        } else {\n            fmt.Printf(\"Record: %v\\n\", record)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#directory-operations","title":"Directory Operations","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-creating-directories","title":"1. Creating Directories","text":"<pre><code>func main() {\n    // Create single directory\n    err := os.Mkdir(\"testdir\", 0755)\n    if err != nil {\n        fmt.Println(\"Error creating directory:\", err)\n    }\n\n    // Create nested directories (MkdirAll)\n    err = os.MkdirAll(\"testdir/nested1/nested2\", 0755)\n    if err != nil {\n        fmt.Println(\"Error creating nested directories:\", err)\n    }\n\n    fmt.Println(\"Directories created\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-reading-directory-contents","title":"2. Reading Directory Contents","text":"<pre><code>func main() {\n    // Open directory\n    dir, err := os.Open(\".\")\n    if err != nil {\n        fmt.Println(\"Error opening directory:\", err)\n        return\n    }\n    defer dir.Close()\n\n    // Read directory contents\n    names, err := dir.Readdirnames(-1)\n    if err != nil {\n        fmt.Println(\"Error reading directory:\", err)\n        return\n    }\n\n    fmt.Println(\"Directory contents:\")\n    for _, name := range names {\n        fmt.Println(name)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#3-walking-directory-tree","title":"3. Walking Directory Tree","text":"<pre><code>func main() {\n    // Walk directory tree\n    err := filepath.Walk(\".\", func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n        fmt.Println(path)\n        return nil\n    })\n    if err != nil {\n        fmt.Println(\"Error walking directory:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#temporary-files","title":"Temporary Files","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-creating-temporary-files","title":"1. Creating Temporary Files","text":"<pre><code>func main() {\n    // Create temporary file\n    tempFile, err := os.CreateTemp(\"\", \"example-*.txt\")\n    if err != nil {\n        fmt.Println(\"Error creating temp file:\", err)\n        return\n    }\n    defer os.Remove(tempFile.Name()) // Clean up\n\n    fmt.Println(\"Temporary file created:\", tempFile.Name())\n\n    // Write to temp file\n    _, err = tempFile.WriteString(\"This is temporary content\")\n    if err != nil {\n        fmt.Println(\"Error writing to temp file:\", err)\n        return\n    }\n\n    // Read from temp file\n    content, err := os.ReadFile(tempFile.Name())\n    if err != nil {\n        fmt.Println(\"Error reading temp file:\", err)\n        return\n    }\n\n    fmt.Println(\"Temp file content:\", string(content))\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-temporary-directories","title":"2. Temporary Directories","text":"<pre><code>func main() {\n    // Create temporary directory\n    tempDir, err := os.MkdirTemp(\"\", \"example-\")\n    if err != nil {\n        fmt.Println(\"Error creating temp directory:\", err)\n        return\n    }\n    defer os.RemoveAll(tempDir) // Clean up\n\n    fmt.Println(\"Temporary directory created:\", tempDir)\n\n    // Create a file in temp directory\n    tempFile := filepath.Join(tempDir, \"test.txt\")\n    err = os.WriteFile(tempFile, []byte(\"Hello from temp dir\"), 0644)\n    if err != nil {\n        fmt.Println(\"Error creating file in temp dir:\", err)\n        return\n    }\n\n    // Read the file\n    content, err := os.ReadFile(tempFile)\n    if err != nil {\n        fmt.Println(\"Error reading file in temp dir:\", err)\n        return\n    }\n\n    fmt.Println(\"File in temp dir content:\", string(content))\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#error-handling-in-file-operations","title":"Error Handling in File Operations","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-common-file-errors","title":"1. Common File Errors","text":"<pre><code>func safeFileOperation(filename string) error {\n    // Try to open file\n    file, err := os.Open(filename)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return fmt.Errorf(\"file does not exist: %w\", err)\n        }\n        if os.IsPermission(err) {\n            return fmt.Errorf(\"permission denied: %w\", err)\n        }\n        return fmt.Errorf(\"error opening file: %w\", err)\n    }\n    defer file.Close()\n\n    // Read file content\n    _, err = io.ReadAll(file)\n    if err != nil {\n        return fmt.Errorf(\"error reading file: %w\", err)\n    }\n\n    return nil\n}\n\nfunc main() {\n    err := safeFileOperation(\"nonexistent.txt\")\n    if err != nil {\n        fmt.Println(\"File operation error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-retry-mechanism-for-file-operations","title":"2. Retry Mechanism for File Operations","text":"<pre><code>func retryFileOperation(operation func() error, maxRetries int) error {\n    var err error\n    for i := 0; i &lt; maxRetries; i++ {\n        err = operation()\n        if err == nil {\n            return nil\n        }\n\n        // Check if it's a retryable error\n        if os.IsPermission(err) || os.IsExist(err) {\n            time.Sleep(time.Second * time.Duration(i+1))\n            continue\n        }\n\n        // Non-retryable error\n        return err\n    }\n\n    return fmt.Errorf(\"operation failed after %d retries: %w\", maxRetries, err)\n}\n\nfunc main() {\n    // Example: Try to create a file that might be locked\n    err := retryFileOperation(func() error {\n        file, err := os.Create(\"locked_file.txt\")\n        if err != nil {\n            return err\n        }\n        file.Close()\n        return nil\n    }, 3)\n\n    if err != nil {\n        fmt.Println(\"Error after retries:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#real-world-example-log-rotator","title":"Real-World Example: Log Rotator","text":"<p>Let's build a simple log rotator that demonstrates various file operations:</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n    \"time\"\n)\n\n// LogRotator handles log file rotation\ntype LogRotator struct {\n    basePath    string\n    maxSize     int64\n    maxBackups  int\n    currentFile *os.File\n    currentSize int64\n}\n\n// NewLogRotator creates a new log rotator\nfunc NewLogRotator(basePath string, maxSize int64, maxBackups int) *LogRotator {\n    return &amp;LogRotator{\n        basePath:   basePath,\n        maxSize:    maxSize,\n        maxBackups: maxBackups,\n    }\n}\n\n// Open opens the current log file or creates a new one\nfunc (lr *LogRotator) Open() error {\n    // Try to open existing file\n    file, err := os.OpenFile(lr.basePath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)\n    if err != nil {\n        return fmt.Errorf(\"failed to open log file: %w\", err)\n    }\n\n    // Get current file size\n    info, err := file.Stat()\n    if err != nil {\n        file.Close()\n        return fmt.Errorf(\"failed to get file info: %w\", err)\n    }\n\n    lr.currentFile = file\n    lr.currentSize = info.Size()\n\n    // Check if rotation is needed\n    if lr.currentSize &gt;= lr.maxSize {\n        if err := lr.rotate(); err != nil {\n            file.Close()\n            return err\n        }\n    }\n\n    return nil\n}\n\n// Write writes data to the log file\nfunc (lr *LogRotator) Write(p []byte) (int, error) {\n    if lr.currentFile == nil {\n        if err := lr.Open(); err != nil {\n            return 0, err\n        }\n    }\n\n    // Check if rotation is needed\n    if lr.currentSize+int64(len(p)) &gt;= lr.maxSize {\n        if err := lr.rotate(); err != nil {\n            return 0, err\n        }\n    }\n\n    n, err := lr.currentFile.Write(p)\n    if err != nil {\n        return n, err\n    }\n\n    lr.currentSize += int64(n)\n    return n, nil\n}\n\n// Close closes the current log file\nfunc (lr *LogRotator) Close() error {\n    if lr.currentFile != nil {\n        return lr.currentFile.Close()\n    }\n    return nil\n}\n\n// rotate performs log rotation\nfunc (lr *LogRotator) rotate() error {\n    // Close current file\n    if lr.currentFile != nil {\n        lr.currentFile.Close()\n    }\n\n    // Rotate existing backup files\n    for i := lr.maxBackups - 1; i &gt;= 0; i-- {\n        oldPath := lr.backupPath(i)\n        newPath := lr.backupPath(i + 1)\n\n        if _, err := os.Stat(oldPath); err == nil {\n            if i == lr.maxBackups-1 {\n                // Remove the oldest backup\n                os.Remove(oldPath)\n            } else {\n                // Rename the backup\n                os.Rename(oldPath, newPath)\n            }\n        }\n    }\n\n    // Rename current file to backup\n    if _, err := os.Stat(lr.basePath); err == nil {\n        os.Rename(lr.basePath, lr.backupPath(0))\n    }\n\n    // Create new file\n    file, err := os.OpenFile(lr.basePath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)\n    if err != nil {\n        return fmt.Errorf(\"failed to create new log file: %w\", err)\n    }\n\n    lr.currentFile = file\n    lr.currentSize = 0\n\n    return nil\n}\n\n// backupPath returns the path for a backup file\nfunc (lr *LogRotator) backupPath(index int) string {\n    if index == 0 {\n        return lr.basePath + \".1\"\n    }\n    return fmt.Sprintf(\"%s.%d\", lr.basePath, index+1)\n}\n\n// WriteString writes a string to the log file\nfunc (lr *LogRotator) WriteString(s string) (int, error) {\n    return lr.Write([]byte(s))\n}\n\n// WriteLine writes a line to the log file\nfunc (lr *LogRotator) WriteLine(line string) error {\n    _, err := lr.WriteString(line + \"\\n\")\n    return err\n}\n\nfunc main() {\n    // Create log rotator\n    rotator := NewLogRotator(\"app.log\", 1024, 3) // 1KB max size, 3 backups\n\n    // Open log file\n    if err := rotator.Open(); err != nil {\n        fmt.Println(\"Error opening log rotator:\", err)\n        return\n    }\n    defer rotator.Close()\n\n    // Write log entries\n    logEntries := []string{\n        \"INFO: Application started\",\n        \"INFO: Processing request\",\n        \"DEBUG: Processing data\",\n        \"INFO: Request processed successfully\",\n        \"WARNING: High memory usage detected\",\n        \"ERROR: Database connection failed\",\n        \"INFO: Retrying database connection\",\n        \"INFO: Database connection restored\",\n        \"INFO: Application shutting down\",\n    }\n\n    for _, entry := range logEntries {\n        timestamp := time.Now().Format(\"2006-01-02 15:04:05\")\n        logLine := fmt.Sprintf(\"[%s] %s\", timestamp, entry)\n\n        if err := rotator.WriteLine(logLine); err != nil {\n            fmt.Println(\"Error writing log entry:\", err)\n            continue\n        }\n\n        fmt.Printf(\"Logged: %s\\n\", entry)\n\n        // Small delay to simulate real logging\n        time.Sleep(100 * time.Millisecond)\n    }\n\n    // List all log files\n    fmt.Println(\"\\nLog files created:\")\n    matches, err := filepath.Glob(\"app.log*\")\n    if err != nil {\n        fmt.Println(\"Error listing log files:\", err)\n        return\n    }\n\n    for _, match := range matches {\n        info, err := os.Stat(match)\n        if err != nil {\n            fmt.Println(\"Error getting file info:\", err)\n            continue\n        }\n\n        fmt.Printf(\"%s (%d bytes)\\n\", match, info.Size())\n\n        // Show first few lines of each file\n        file, err := os.Open(match)\n        if err != nil {\n            fmt.Println(\"Error opening file:\", err)\n            continue\n        }\n\n        scanner := bufio.NewScanner(file)\n        lineCount := 0\n        for scanner.Scan() &amp;&amp; lineCount &lt; 3 {\n            fmt.Printf(\"  %s\\n\", scanner.Text())\n            lineCount++\n        }\n        file.Close()\n\n        if lineCount &gt;= 3 {\n            fmt.Println(\"  ...\")\n        }\n    }\n\n    // Clean up\n    os.RemoveAll(\"app.log\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Log Rotation Logic:</li> <li>Monitors log file size and rotates when it exceeds the limit</li> <li>Maintains a specified number of backup files</li> <li> <p>Renames existing backups to make room for new ones</p> </li> <li> <p>File Operations:</p> </li> <li>Creates, opens, writes to, and closes files</li> <li>Renames files for rotation</li> <li> <p>Handles file size tracking</p> </li> <li> <p>Error Handling:</p> </li> <li>Gracefully handles file operation errors</li> <li>Ensures files are properly closed</li> <li> <p>Provides meaningful error messages</p> </li> <li> <p>Directory Management:</p> </li> <li>Works with file paths and backups</li> <li>Lists and manages multiple log files</li> <li>Demonstrates file system operations</li> </ol>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Logging Systems:</li> <li>Application logging with rotation</li> <li>Log file management</li> <li> <p>Archive and cleanup</p> </li> <li> <p>Data Processing:</p> </li> <li>Batch file processing</li> <li>Data transformation</li> <li> <p>File format conversion</p> </li> <li> <p>Backup Systems:</p> </li> <li>File backup and rotation</li> <li>Version management</li> <li>Storage optimization</li> </ol>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-always-close-files","title":"1. Always Close Files","text":"<pre><code>// Good: Use defer to ensure files are closed\nfunc processFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close() // Ensure file is closed\n\n    // Process file...\n    return nil\n}\n\n// Bad: Forgetting to close files\nfunc processFileBad(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    // No defer - file might not be closed if error occurs\n    // Process file...\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-use-buffered-io-for-performance","title":"2. Use Buffered I/O for Performance","text":"<pre><code>// Good: Use buffered I/O for frequent operations\nfunc writeManyLines(filename string, lines []string) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    writer := bufio.NewWriter(file)\n    defer writer.Flush()\n\n    for _, line := range lines {\n        _, err := writer.WriteString(line + \"\\n\")\n        if err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n\n// Bad: Unbuffered writes for many operations\nfunc writeManyLinesBad(filename string, lines []string) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    for _, line := range lines {\n        _, err := file.WriteString(line + \"\\n\") // System call for each line\n        if err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#3-handle-errors-properly","title":"3. Handle Errors Properly","text":"<pre><code>// Good: Handle specific errors\nfunc readFile(filename string) ([]byte, error) {\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil, fmt.Errorf(\"file not found: %s\", filename)\n        }\n        if os.IsPermission(err) {\n            return nil, fmt.Errorf(\"permission denied: %s\", filename)\n        }\n        return nil, fmt.Errorf(\"failed to read file: %w\", err)\n    }\n    return data, nil\n}\n\n// Bad: Generic error handling\nfunc readFileBad(filename string) ([]byte, error) {\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return nil, err // No context about what went wrong\n    }\n    return data, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#4-use-appropriate-file-permissions","title":"4. Use Appropriate File Permissions","text":"<pre><code>// Good: Use appropriate permissions\nfunc createConfigFile() error {\n    // 0600: Read/write for owner only\n    return os.WriteFile(\"config.json\", configData, 0600)\n}\n\nfunc createLogFile() error {\n    // 0644: Read/write for owner, read for others\n    return os.WriteFile(\"app.log\", logData, 0644)\n}\n\nfunc createExecutable() error {\n    // 0755: Read/write/execute for owner, read/execute for others\n    return os.WriteFile(\"myapp\", binaryData, 0755)\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-buffer-size-optimization","title":"1. Buffer Size Optimization","text":"<pre><code>// Adjust buffer size based on use case\nfunc copyFileWithBufferSize(src, dst string, bufferSize int) error {\n    srcFile, err := os.Open(src)\n    if err != nil {\n        return err\n    }\n    defer srcFile.Close()\n\n    dstFile, err := os.Create(dst)\n    if err != nil {\n        return err\n    }\n    defer dstFile.Close()\n\n    // Use custom buffer size\n    buf := make([]byte, bufferSize)\n    _, err = io.CopyBuffer(dstFile, srcFile, buf)\n    return err\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-concurrent-file-operations","title":"2. Concurrent File Operations","text":"<pre><code>// Process multiple files concurrently\nfunc processFilesConcurrently(filenames []string) error {\n    var wg sync.WaitGroup\n    errChan := make(chan error, len(filenames))\n\n    for _, filename := range filenames {\n        wg.Add(1)\n        go func(fname string) {\n            defer wg.Done()\n\n            // Process file\n            if err := processSingleFile(fname); err != nil {\n                errChan &lt;- err\n            }\n        }(filename)\n    }\n\n    // Wait for all goroutines to complete\n    wg.Wait()\n    close(errChan)\n\n    // Check for errors\n    for err := range errChan {\n        if err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#conclusion","title":"Conclusion","text":"<p>File I/O is a critical aspect of many Go applications. The <code>os</code>, <code>io</code>, and <code>bufio</code> packages provide comprehensive tools for:</p> <ol> <li>Basic File Operations:</li> <li>Creating, reading, writing, and closing files</li> <li>Different file modes (read, write, append)</li> <li> <p>Error handling and resource management</p> </li> <li> <p>Buffered I/O:</p> </li> <li>Improved performance with buffered readers and writers</li> <li>Line-by-line processing with Scanner</li> <li> <p>Efficient handling of large files</p> </li> <li> <p>Advanced Operations:</p> </li> <li>Working with different file formats (JSON, CSV)</li> <li>Directory operations and file system traversal</li> <li> <p>Temporary files and directories</p> </li> <li> <p>Real-World Applications:</p> </li> <li>Logging systems with rotation</li> <li>Data processing pipelines</li> <li>Configuration management</li> <li>Backup and archival systems</li> </ol> <p>The log rotator example demonstrates how to combine various file operations to build a practical application that handles file rotation, backup management, and error scenarios. By following best practices and understanding performance considerations, you can build robust and efficient file I/O operations in your Go applications.</p> <p>Key takeaways: 1. Always close files using <code>defer</code> to prevent resource leaks 2. Use buffered I/O for better performance with frequent operations 3. Handle errors appropriately with specific error types and messages 4. Use appropriate file permissions based on the sensitivity of data 5. Consider concurrency for processing multiple files efficiently 6. Implement proper cleanup for temporary files and resources</p> <p>File I/O might seem straightforward, but it's full of edge cases and performance considerations. With Go's excellent standard library and the patterns shown in this guide, you can build reliable and efficient file operations in your applications.</p>"},{"location":"2.%20Intermediate/25.%20Line-Filters/","title":"Line Filters in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/25.%20Line-Filters/#introduction-to-line-filters","title":"Introduction to Line Filters","text":"<p>A line filter is a program that reads input line by line, processes each line according to some rules, and then outputs the result. This pattern is fundamental in Unix/Linux command-line tools like <code>grep</code>, <code>sed</code>, <code>awk</code>, and <code>sort</code>. In Go, we can build efficient line filters using the <code>bufio</code> package for line-oriented input and output.</p>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#basic-line-filter-structure","title":"Basic Line Filter Structure","text":""},{"location":"2.%20Intermediate/25.%20Line-Filters/#1-simple-line-filter","title":"1. Simple Line Filter","text":"<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Create a new scanner that reads from standard input\n    scanner := bufio.NewScanner(os.Stdin)\n\n    // Read line by line\n    for scanner.Scan() {\n        line := scanner.Text()\n        // Process the line (in this case, just print it)\n        fmt.Println(line)\n    }\n\n    // Check for any errors during scanning\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error reading input: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#2-line-filter-with-transformation","title":"2. Line Filter with Transformation","text":"<pre><code>func main() {\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        // Transform the line to uppercase\n        transformed := strings.ToUpper(line)\n        fmt.Println(transformed)\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#building-practical-line-filters","title":"Building Practical Line Filters","text":""},{"location":"2.%20Intermediate/25.%20Line-Filters/#1-grep-like-filter","title":"1. Grep-like Filter","text":"<pre><code>func main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintf(os.Stderr, \"Usage: %s &lt;pattern&gt;\\n\", os.Args[0])\n        os.Exit(1)\n    }\n\n    pattern := os.Args[1]\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        // Check if line contains the pattern\n        if strings.Contains(line, pattern) {\n            fmt.Println(line)\n        }\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#2-numbering-lines-like-cat-n","title":"2. Numbering Lines (like <code>cat -n</code>)","text":"<pre><code>func main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    lineNumber := 1\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        // Print line number followed by the line\n        fmt.Printf(\"%6d  %s\\n\", lineNumber, line)\n        lineNumber++\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#3-unique-lines-like-uniq","title":"3. Unique Lines (like <code>uniq</code>)","text":"<pre><code>func main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var previousLine string\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        // Only print if different from previous line\n        if line != previousLine {\n            fmt.Println(line)\n            previousLine = line\n        }\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#advanced-line-filters","title":"Advanced Line Filters","text":""},{"location":"2.%20Intermediate/25.%20Line-Filters/#1-multiple-pattern-matching","title":"1. Multiple Pattern Matching","text":"<pre><code>func main() {\n    if len(os.Args) &lt; 3 {\n        fmt.Fprintf(os.Stderr, \"Usage: %s &lt;mode&gt; &lt;pattern1&gt; [pattern2 ...]\\n\", os.Args[0])\n        fmt.Fprintf(os.Stderr, \"Modes: any, all, none\\n\")\n        os.Exit(1)\n    }\n\n    mode := os.Args[1]\n    patterns := os.Args[2:]\n\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        var matches int\n\n        for _, pattern := range patterns {\n            if strings.Contains(line, pattern) {\n                matches++\n            }\n        }\n\n        // Check based on mode\n        printLine := false\n        switch mode {\n        case \"any\":\n            printLine = matches &gt; 0\n        case \"all\":\n            printLine = matches == len(patterns)\n        case \"none\":\n            printLine = matches == 0\n        }\n\n        if printLine {\n            fmt.Println(line)\n        }\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#2-field-processing-like-awk","title":"2. Field Processing (like <code>awk</code>)","text":"<pre><code>func main() {\n    if len(os.Args) &lt; 3 {\n        fmt.Fprintf(os.Stderr, \"Usage: %s &lt;field&gt; &lt;delimiter&gt;\\n\", os.Args[0])\n        os.Exit(1)\n    }\n\n    fieldNum, err := strconv.Atoi(os.Args[1])\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Invalid field number: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    delimiter := os.Args[2]\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        fields := strings.Split(line, delimiter)\n\n        if fieldNum &lt;= len(fields) {\n            fmt.Println(fields[fieldNum-1])\n        }\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#3-case-insensitive-filtering","title":"3. Case-Insensitive Filtering","text":"<pre><code>func main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintf(os.Stderr, \"Usage: %s &lt;pattern&gt;\\n\", os.Args[0])\n        os.Exit(1)\n    }\n\n    pattern := strings.ToLower(os.Args[1])\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        // Case-insensitive comparison\n        if strings.Contains(strings.ToLower(line), pattern) {\n            fmt.Println(line)\n        }\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#line-filters-with-files","title":"Line Filters with Files","text":""},{"location":"2.%20Intermediate/25.%20Line-Filters/#1-reading-from-files","title":"1. Reading from Files","text":"<pre><code>func main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintf(os.Stderr, \"Usage: %s &lt;filename&gt; [pattern]\\n\", os.Args[0])\n        os.Exit(1)\n    }\n\n    filename := os.Args[1]\n    var pattern string\n    if len(os.Args) &gt; 2 {\n        pattern = os.Args[2]\n    }\n\n    // Open the file\n    file, err := os.Open(filename)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Error opening file: %v\\n\", err)\n        os.Exit(1)\n    }\n    defer file.Close()\n\n    // Create scanner from file\n    scanner := bufio.NewScanner(file)\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        if pattern == \"\" || strings.Contains(line, pattern) {\n            fmt.Println(line)\n        }\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error reading file: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#2-multiple-files-processing","title":"2. Multiple Files Processing","text":"<pre><code>func processFile(filename string, pattern string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        if pattern == \"\" || strings.Contains(line, pattern) {\n            // Print filename prefix for multiple files\n            if len(os.Args) &gt; 3 {\n                fmt.Printf(\"%s:%s\\n\", filename, line)\n            } else {\n                fmt.Println(line)\n            }\n        }\n    }\n\n    return scanner.Err()\n}\n\nfunc main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintf(os.Stderr, \"Usage: %s &lt;file1&gt; [file2 ...] [pattern]\\n\", os.Args[0])\n        os.Exit(1)\n    }\n\n    // Determine which arguments are files and which is the pattern\n    var files []string\n    var pattern string\n\n    // If last argument doesn't exist as a file, it's the pattern\n    lastArg := os.Args[len(os.Args)-1]\n    if _, err := os.Stat(lastArg); os.IsNotExist(err) &amp;&amp; len(os.Args) &gt; 2 {\n        pattern = lastArg\n        files = os.Args[1 : len(os.Args)-1]\n    } else {\n        files = os.Args[1:]\n    }\n\n    // Process each file\n    for _, filename := range files {\n        err := processFile(filename, pattern)\n        if err != nil {\n            fmt.Fprintf(os.Stderr, \"Error processing %s: %v\\n\", filename, err)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#real-world-example-log-analyzer","title":"Real-World Example: Log Analyzer","text":"<p>Let's build a comprehensive log analyzer that demonstrates various line filter techniques:</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"regexp\"\n    \"sort\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n)\n\n// LogEntry represents a parsed log entry\ntype LogEntry struct {\n    Timestamp time.Time\n    Level     string\n    Message   string\n    Source    string\n}\n\n// LogAnalyzer provides log analysis functionality\ntype LogAnalyzer struct {\n    patterns    map[string]*regexp.Regexp\n    levelFilter string\n    sourceFilter string\n    timeStart   time.Time\n    timeEnd     time.Time\n    unique     bool\n    count      bool\n    statistics  map[string]int\n}\n\n// NewLogAnalyzer creates a new log analyzer\nfunc NewLogAnalyzer() *LogAnalyzer {\n    return &amp;LogAnalyzer{\n        patterns:   make(map[string]*regexp.Regexp),\n        statistics: make(map[string]int),\n    }\n}\n\n// AddPattern adds a regex pattern to match\nfunc (la *LogAnalyzer) AddPattern(name, pattern string) error {\n    re, err := regexp.Compile(pattern)\n    if err != nil {\n        return fmt.Errorf(\"invalid pattern %q: %w\", name, err)\n    }\n    la.patterns[name] = re\n    return nil\n}\n\n// SetLevelFilter sets the log level filter\nfunc (la *LogAnalyzer) SetLevelFilter(level string) {\n    la.levelFilter = strings.ToUpper(level)\n}\n\n// SetSourceFilter sets the source filter\nfunc (la *LogAnalyzer) SetSourceFilter(source string) {\n    la.sourceFilter = source\n}\n\n// SetTimeRange sets the time range filter\nfunc (la *LogAnalyzer) SetTimeRange(start, end string) error {\n    var err error\n    if start != \"\" {\n        la.timeStart, err = time.Parse(\"2006-01-02\", start)\n        if err != nil {\n            return fmt.Errorf(\"invalid start time: %w\", err)\n        }\n    }\n    if end != \"\" {\n        la.timeEnd, err = time.Parse(\"2006-01-02\", end)\n        if err != nil {\n            return fmt.Errorf(\"invalid end time: %w\", err)\n        }\n    }\n    return nil\n}\n\n// SetUnique enables unique line filtering\nfunc (la *LogAnalyzer) SetUnique(unique bool) {\n    la.unique = unique\n}\n\n// SetCount enables counting mode\nfunc (la *LogAnalyzer) SetCount(count bool) {\n    la.count = count\n}\n\n// ParseLogLine parses a log line into a LogEntry\nfunc (la *LogAnalyzer) ParseLogLine(line string) (*LogEntry, error) {\n    // Simple log format: [timestamp] [level] [source] message\n    // Example: [2023-11-15T14:30:45Z] [ERROR] [server] Database connection failed\n\n    parts := strings.SplitN(line, \"]\", 3)\n    if len(parts) &lt; 3 {\n        return nil, fmt.Errorf(\"invalid log format\")\n    }\n\n    // Parse timestamp\n    timestampStr := strings.Trim(parts[0], \"[ \")\n    timestamp, err := time.Parse(time.RFC3339, timestampStr)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid timestamp: %w\", err)\n    }\n\n    // Parse level\n    levelStr := strings.Trim(parts[1], \"[ \")\n    level := strings.ToUpper(levelStr)\n\n    // Parse source and message\n    rest := strings.TrimSpace(parts[2])\n    sourceEnd := strings.Index(rest, \"]\")\n    if sourceEnd == -1 {\n        return nil, fmt.Errorf(\"invalid source format\")\n    }\n\n    source := strings.Trim(rest[:sourceEnd], \"[ \")\n    message := strings.TrimSpace(rest[sourceEnd+1:])\n\n    return &amp;LogEntry{\n        Timestamp: timestamp,\n        Level:     level,\n        Message:   message,\n        Source:    source,\n    }, nil\n}\n\n// ShouldInclude determines if a log entry should be included\nfunc (la *LogAnalyzer) ShouldInclude(entry *LogEntry) bool {\n    // Level filter\n    if la.levelFilter != \"\" &amp;&amp; entry.Level != la.levelFilter {\n        return false\n    }\n\n    // Source filter\n    if la.sourceFilter != \"\" &amp;&amp; entry.Source != la.sourceFilter {\n        return false\n    }\n\n    // Time range filter\n    if !la.timeStart.IsZero() &amp;&amp; entry.Timestamp.Before(la.timeStart) {\n        return false\n    }\n    if !la.timeEnd.IsZero() &amp;&amp; entry.Timestamp.After(la.timeEnd) {\n        return false\n    }\n\n    // Pattern matching\n    for _, re := range la.patterns {\n        if !re.MatchString(entry.Message) {\n            return false\n        }\n    }\n\n    return true\n}\n\n// ProcessFile processes a log file\nfunc (la *LogAnalyzer) ProcessFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return fmt.Errorf(\"failed to open file: %w\", err)\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    var previousLine string\n\n    for scanner.Scan() {\n        line := scanner.Text()\n\n        // Parse log entry\n        entry, err := la.ParseLogLine(line)\n        if err != nil {\n            // If parsing fails, treat as plain text\n            entry = &amp;LogEntry{\n                Message: line,\n            }\n        }\n\n        // Check filters\n        if !la.ShouldInclude(entry) {\n            continue\n        }\n\n        // Update statistics\n        la.statistics[entry.Level]++\n\n        // Unique filter\n        if la.unique &amp;&amp; line == previousLine {\n            continue\n        }\n\n        // Output the line\n        if la.count {\n            // Count mode - we'll output statistics at the end\n        } else {\n            fmt.Println(line)\n        }\n\n        previousLine = line\n    }\n\n    return scanner.Err()\n}\n\n// PrintStatistics prints the collected statistics\nfunc (la *LogAnalyzer) PrintStatistics() {\n    if !la.count {\n        return\n    }\n\n    fmt.Println(\"\\n=== Log Statistics ===\")\n\n    // Sort levels by count\n    type levelCount struct {\n        level string\n        count int\n    }\n\n    var counts []levelCount\n    for level, count := range la.statistics {\n        counts = append(counts, levelCount{level, count})\n    }\n\n    sort.Slice(counts, func(i, j int) bool {\n        return counts[i].count &gt; counts[j].count\n    })\n\n    total := 0\n    for _, lc := range counts {\n        total += lc.count\n    }\n\n    for _, lc := range counts {\n        percentage := float64(lc.count) / float64(total) * 100\n        fmt.Printf(\"%-8s: %6d (%5.1f%%)\\n\", lc.level, lc.count, percentage)\n    }\n\n    fmt.Printf(\"Total: %d entries\\n\", total)\n}\n\nfunc main() {\n    analyzer := NewLogAnalyzer()\n\n    // Parse command line arguments\n    args := os.Args[1:]\n    i := 0\n\n    for i &lt; len(args) {\n        switch args[i] {\n        case \"-p\", \"--pattern\":\n            if i+1 &gt;= len(args) {\n                fmt.Fprintln(os.Stderr, \"Error: pattern name required\")\n                os.Exit(1)\n            }\n            name := args[i+1]\n            if i+2 &gt;= len(args) {\n                fmt.Fprintln(os.Stderr, \"Error: pattern required\")\n                os.Exit(1)\n            }\n            pattern := args[i+2]\n            if err := analyzer.AddPattern(name, pattern); err != nil {\n                fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n                os.Exit(1)\n            }\n            i += 3\n\n        case \"-l\", \"--level\":\n            if i+1 &gt;= len(args) {\n                fmt.Fprintln(os.Stderr, \"Error: level required\")\n                os.Exit(1)\n            }\n            analyzer.SetLevelFilter(args[i+1])\n            i += 2\n\n        case \"-s\", \"--source\":\n            if i+1 &gt;= len(args) {\n                fmt.Fprintln(os.Stderr, \"Error: source required\")\n                os.Exit(1)\n            }\n            analyzer.SetSourceFilter(args[i+1])\n            i += 2\n\n        case \"-t\", \"--time\":\n            if i+2 &gt;= len(args) {\n                fmt.Fprintln(os.Stderr, \"Error: start and end time required\")\n                os.Exit(1)\n            }\n            if err := analyzer.SetTimeRange(args[i+1], args[i+2]); err != nil {\n                fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n                os.Exit(1)\n            }\n            i += 3\n\n        case \"-u\", \"--unique\":\n            analyzer.SetUnique(true)\n            i++\n\n        case \"-c\", \"--count\":\n            analyzer.SetCount(true)\n            i++\n\n        default:\n            // Assume it's a filename\n            filename := args[i]\n            if err := analyzer.ProcessFile(filename); err != nil {\n                fmt.Fprintf(os.Stderr, \"Error processing %s: %v\\n\", filename, err)\n                os.Exit(1)\n            }\n            i++\n        }\n    }\n\n    // Print statistics if in count mode\n    analyzer.PrintStatistics()\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Log Parsing:</li> <li>Parses structured log entries with timestamp, level, source, and message</li> <li>Handles both structured and unstructured log lines</li> <li> <p>Supports multiple log formats through extensibility</p> </li> <li> <p>Filtering Capabilities:</p> </li> <li>Level-based filtering (ERROR, WARNING, INFO, etc.)</li> <li>Source-based filtering (specific modules or services)</li> <li>Time range filtering</li> <li>Pattern matching with regular expressions</li> <li> <p>Duplicate line removal</p> </li> <li> <p>Analysis Features:</p> </li> <li>Statistics collection and reporting</li> <li>Count mode for aggregate analysis</li> <li> <p>Percentage calculations for log levels</p> </li> <li> <p>Command-Line Interface:</p> </li> <li>Flexible argument parsing</li> <li>Multiple filter options</li> <li>Support for multiple input files</li> </ol>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Log Analysis:</li> <li>Filter application logs by error level</li> <li>Find specific error patterns</li> <li>Analyze log frequency over time</li> <li> <p>Identify problematic modules</p> </li> <li> <p>System Administration:</p> </li> <li>Monitor system logs for specific events</li> <li>Filter authentication logs</li> <li>Track resource usage patterns</li> <li> <p>Generate usage reports</p> </li> <li> <p>Security Monitoring:</p> </li> <li>Detect suspicious activity patterns</li> <li>Filter access logs for specific IPs</li> <li>Monitor authentication failures</li> <li>Generate security reports</li> </ol>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/25.%20Line-Filters/#1-handle-large-files-efficiently","title":"1. Handle Large Files Efficiently","text":"<pre><code>// Good: Process line by line without loading entire file\nfunc processLargeFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    // Adjust buffer size for large files\n    buf := make([]byte, 64*1024) // 64KB buffer\n    scanner.Buffer(buf, 1024*1024) // Max token size 1MB\n\n    for scanner.Scan() {\n        // Process line\n    }\n    return scanner.Err()\n}\n\n// Bad: Read entire file into memory\nfunc processLargeFileBad(filename string) error {\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return err\n    }\n    lines := strings.Split(string(data), \"\\n\")\n    for _, line := range lines {\n        // Process line\n    }\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#2-use-appropriate-scanner-settings","title":"2. Use Appropriate Scanner Settings","text":"<pre><code>// Good: Configure scanner for your use case\nfunc createScanner(file *os.File) *bufio.Scanner {\n    scanner := bufio.NewScanner(file)\n\n    // Adjust buffer size based on expected line length\n    scanner.Buffer(make([]byte, 4096), 1024*1024)\n\n    // Custom split function if needed\n    scanner.Split(bufio.ScanLines)\n\n    return scanner\n}\n\n// Bad: Use default scanner for all cases\nfunc createScannerBad(file *os.File) *bufio.Scanner {\n    return bufio.NewScanner(file) // May not be optimal\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#3-graceful-error-handling","title":"3. Graceful Error Handling","text":"<pre><code>// Good: Handle errors gracefully and continue processing\nfunc processFilesWithErrors(filenames []string) {\n    for _, filename := range filenames {\n        file, err := os.Open(filename)\n        if err != nil {\n            fmt.Fprintf(os.Stderr, \"Warning: Cannot open %s: %v\\n\", filename, err)\n            continue\n        }\n\n        scanner := bufio.NewScanner(file)\n        for scanner.Scan() {\n            // Process line\n        }\n\n        if err := scanner.Err(); err != nil {\n            fmt.Fprintf(os.Stderr, \"Warning: Error reading %s: %v\\n\", filename, err)\n        }\n\n        file.Close()\n    }\n}\n\n// Bad: Exit on first error\nfunc processFilesWithErrorsBad(filenames []string) {\n    for _, filename := range filenames {\n        file, err := os.Open(filename)\n        if err != nil {\n            fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n            os.Exit(1)\n        }\n        // Process file...\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#4-support-multiple-input-sources","title":"4. Support Multiple Input Sources","text":"<pre><code>// Good: Handle both files and stdin\nfunc processInput(input string) error {\n    var scanner *bufio.Scanner\n\n    if input == \"-\" || input == \"\" {\n        // Read from stdin\n        scanner = bufio.NewScanner(os.Stdin)\n    } else {\n        // Read from file\n        file, err := os.Open(input)\n        if err != nil {\n            return err\n        }\n        defer file.Close()\n        scanner = bufio.NewScanner(file)\n    }\n\n    for scanner.Scan() {\n        // Process line\n    }\n\n    return scanner.Err()\n}\n\n// Bad: Only handle files\nfunc processInputBad(input string) error {\n    file, err := os.Open(input)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    for scanner.Scan() {\n        // Process line\n    }\n    return scanner.Err()\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/25.%20Line-Filters/#1-buffer-size-optimization","title":"1. Buffer Size Optimization","text":"<pre><code>// Benchmark different buffer sizes\nfunc benchmarkBufferSize(filename string, bufferSize int) time.Duration {\n    file, err := os.Open(filename)\n    if err != nil {\n        return 0\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    buf := make([]byte, bufferSize)\n    scanner.Buffer(buf, bufferSize)\n\n    start := time.Now()\n    for scanner.Scan() {\n        // Process line\n    }\n    return time.Since(start)\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#2-parallel-processing-for-multiple-files","title":"2. Parallel Processing for Multiple Files","text":"<pre><code>func processFilesParallel(filenames []string) {\n    var wg sync.WaitGroup\n    results := make(chan string, len(filenames))\n\n    for _, filename := range filenames {\n        wg.Add(1)\n        go func(fname string) {\n            defer wg.Done()\n\n            file, err := os.Open(fname)\n            if err != nil {\n                results &lt;- fmt.Sprintf(\"Error opening %s: %v\", fname, err)\n                return\n            }\n            defer file.Close()\n\n            scanner := bufio.NewScanner(file)\n            lineCount := 0\n            for scanner.Scan() {\n                lineCount++\n            }\n\n            results &lt;- fmt.Sprintf(\"%s: %d lines\", fname, lineCount)\n        }(filename)\n    }\n\n    // Wait for all goroutines to complete\n    go func() {\n        wg.Wait()\n        close(results)\n    }()\n\n    // Collect results\n    for result := range results {\n        fmt.Println(result)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#conclusion","title":"Conclusion","text":"<p>Line filters are a powerful and flexible pattern in Go for processing text input line by line. The <code>bufio</code> package provides excellent tools for building efficient line filters that can:</p> <ol> <li>Process Text Efficiently:</li> <li>Handle large files without loading everything into memory</li> <li>Process input line by line with minimal memory overhead</li> <li> <p>Support both files and standard input</p> </li> <li> <p>Filter and Transform:</p> </li> <li>Filter lines based on patterns, levels, or other criteria</li> <li>Transform lines with string operations</li> <li> <p>Combine multiple filters for complex processing</p> </li> <li> <p>Analyze and Aggregate:</p> </li> <li>Collect statistics and metrics</li> <li>Count occurrences and frequencies</li> <li> <p>Generate reports and summaries</p> </li> <li> <p>Integrate with Unix Tools:</p> </li> <li>Work seamlessly in Unix pipelines</li> <li>Support standard input/output streams</li> <li>Follow Unix philosophy of doing one thing well</li> </ol> <p>The log analyzer example demonstrates how to build a sophisticated line filter that combines multiple filtering techniques, pattern matching, and statistical analysis. By following best practices and understanding performance considerations, you can create efficient and reliable line filters for various text processing tasks in Go.</p> <p>Key takeaways: 1. Use <code>bufio.Scanner</code> for line-oriented input processing 2. Handle large files by processing line by line 3. Support multiple input sources (files and stdin) 4. Provide flexible filtering options through command-line arguments 5. Handle errors gracefully without terminating the entire process 6. Consider performance when dealing with very large files</p> <p>Line filters are a fundamental tool in text processing and system administration. With Go's excellent I/O libraries and the patterns shown in this guide, you can build powerful and efficient line filters for your specific needs.</p>"},{"location":"2.%20Intermediate/26.%20File-Paths/","title":"File Paths in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/26.%20File-Paths/#introduction-to-file-paths-in-go","title":"Introduction to File Paths in Go","text":"<p>File paths are fundamental to working with file systems. Go provides two packages for handling paths: - <code>path</code>: For slash-separated paths (URLs, Unix-like paths) - <code>path/filepath</code>: For operating system-specific file paths (handles both Windows and Unix-style paths)</p> <p>Understanding how to manipulate file paths correctly is crucial for building cross-platform applications that work seamlessly across different operating systems.</p>"},{"location":"2.%20Intermediate/26.%20File-Paths/#basic-path-operations","title":"Basic Path Operations","text":""},{"location":"2.%20Intermediate/26.%20File-Paths/#1-joining-paths","title":"1. Joining Paths","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"path\"\n    \"path/filepath\"\n)\n\nfunc main() {\n    // Using path package (slash-separated)\n    p := path.Join(\"dir\", \"subdir\", \"file.txt\")\n    fmt.Println(\"path.Join:\", p) // dir/subdir/file.txt\n\n    // Using filepath package (OS-specific)\n    fp := filepath.Join(\"dir\", \"subdir\", \"file.txt\")\n    fmt.Println(\"filepath.Join:\", fp) // On Unix: dir/subdir/file.txt, On Windows: dir\\subdir\\file.txt\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#2-splitting-paths","title":"2. Splitting Paths","text":"<pre><code>func main() {\n    // Split into directory and file\n    dir, file := path.Split(\"dir/subdir/file.txt\")\n    fmt.Printf(\"dir: %q, file: %q\\n\", dir, file) // dir: \"dir/subdir/\", file: \"file.txt\"\n\n    // Split into components (path package)\n    components := strings.Split(\"dir/subdir/file.txt\", \"/\")\n    fmt.Println(\"Split components:\", components) // [dir subdir file.txt]\n\n    // Split into components (filepath package)\n    components = strings.Split(filepath.Join(\"dir\", \"subdir\", \"file.txt\"), string(filepath.Separator))\n    fmt.Println(\"filepath split components:\", components)\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#3-cleaning-paths","title":"3. Cleaning Paths","text":"<pre><code>func main() {\n    // Clean removes redundant separators and resolves . and ..\n    messyPath := \"dir//subdir/./file.txt/../other.txt\"\n    cleaned := path.Clean(messyPath)\n    fmt.Println(\"Original:\", messyPath) // dir//subdir/./file.txt/../other.txt\n    fmt.Println(\"Cleaned:\", cleaned) // dir/subdir/other.txt\n\n    // filepath.Clean also handles OS-specific separators\n    messyPath = filepath.Join(\"dir\", \"\", \"subdir\", \".\", \"file.txt\", \"..\", \"other.txt\")\n    cleaned = filepath.Clean(messyPath)\n    fmt.Println(\"filepath cleaned:\", cleaned)\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#path-components","title":"Path Components","text":""},{"location":"2.%20Intermediate/26.%20File-Paths/#1-extracting-path-components","title":"1. Extracting Path Components","text":"<pre><code>func main() {\n    fullPath := \"/home/user/documents/report.txt\"\n\n    // Get directory path\n    dir := filepath.Dir(fullPath)\n    fmt.Println(\"Dir:\", dir) // /home/user/documents\n\n    // Get file name with extension\n    file := filepath.Base(fullPath)\n    fmt.Println(\"Base:\", file) // report.txt\n\n    // Get file name without extension\n    name := filepath.Base(fullPath[:len(fullPath)-len(filepath.Ext(fullPath))])\n    fmt.Println(\"Name without ext:\", name) // report\n\n    // Get extension\n    ext := filepath.Ext(fullPath)\n    fmt.Println(\"Extension:\", ext) // .txt\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#2-working-with-extensions","title":"2. Working with Extensions","text":"<pre><code>func main() {\n    // Check if path has extension\n    path1 := \"document.pdf\"\n    path2 := \"document\"\n    fmt.Println(\"Has extension:\", filepath.Ext(path1) != \"\") // true\n    fmt.Println(\"Has extension:\", filepath.Ext(path2) != \"\") // false\n\n    // Change extension\n    newPath := strings.TrimSuffix(path1, filepath.Ext(path1)) + \".docx\"\n    fmt.Println(\"Changed extension:\", newPath) // document.docx\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#absolute-and-relative-paths","title":"Absolute and Relative Paths","text":""},{"location":"2.%20Intermediate/26.%20File-Paths/#1-converting-between-path-types","title":"1. Converting Between Path Types","text":"<pre><code>func main() {\n    // Get current working directory\n    cwd, err := os.Getwd()\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Current working directory:\", cwd)\n\n    // Create relative path\n    relPath := \"documents/report.txt\"\n    fmt.Println(\"Relative path:\", relPath)\n\n    // Convert to absolute path\n    absPath, err := filepath.Abs(relPath)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Absolute path:\", absPath)\n\n    // Check if path is absolute\n    fmt.Println(\"Is absolute:\", filepath.IsAbs(absPath))   // true\n    fmt.Println(\"Is absolute:\", filepath.IsAbs(relPath)) // false\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#2-relative-path-calculations","title":"2. Relative Path Calculations","text":"<pre><code>func main() {\n    // Get relative path between two absolute paths\n    path1 := \"/home/user/documents\"\n    path2 := \"/home/user/downloads/report.txt\"\n\n    relPath, err := filepath.Rel(path1, path2)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Relative path from %s to %s: %s\\n\", path1, path2, relPath)\n    // Output: ../downloads/report.txt\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#directory-operations","title":"Directory Operations","text":""},{"location":"2.%20Intermediate/26.%20File-Paths/#1-creating-directories","title":"1. Creating Directories","text":"<pre><code>func main() {\n    // Create single directory\n    err := os.Mkdir(\"testdir\", 0755)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n\n    // Create nested directories (MkdirAll)\n    err = os.MkdirAll(\"testdir/nested1/nested2\", 0755)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n\n    // Clean up\n    os.RemoveAll(\"testdir\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#2-listing-directory-contents","title":"2. Listing Directory Contents","text":"<pre><code>func main() {\n    // List directory contents\n    dir := \".\"\n    entries, err := os.ReadDir(dir)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Println(\"Contents of\", dir, \":\")\n    for _, entry := range entries {\n        info, err := entry.Info()\n        if err != nil {\n            fmt.Println(\"Error getting info:\", err)\n            continue\n        }\n\n        if info.IsDir() {\n            fmt.Printf(\"DIR  %s\\n\", entry.Name())\n        } else {\n            fmt.Printf(\"FILE %s (%d bytes)\\n\", entry.Name(), info.Size())\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#3-walking-directory-trees","title":"3. Walking Directory Trees","text":"<pre><code>func main() {\n    // Walk directory tree\n    root := \".\"\n    fmt.Println(\"Walking directory tree starting from\", root, \":\")\n\n    err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        // Skip hidden files (Unix-like)\n        if strings.HasPrefix(filepath.Base(path), \".\") {\n            return nil\n        }\n\n        relPath, err := filepath.Rel(root, path)\n        if err != nil {\n            return err\n        }\n\n        depth := strings.Count(relPath, string(filepath.Separator))\n        indent := strings.Repeat(\"  \", depth)\n\n        if info.IsDir() {\n            fmt.Printf(\"%sDIR  %s\\n\", indent, info.Name())\n        } else {\n            fmt.Printf(\"%sFILE %s (%d bytes)\\n\", indent, info.Name(), info.Size())\n        }\n\n        return nil\n    })\n\n    if err != nil {\n        fmt.Println(\"Error walking directory:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#cross-platform-considerations","title":"Cross-Platform Considerations","text":""},{"location":"2.%20Intermediate/26.%20File-Paths/#1-path-separator","title":"1. Path Separator","text":"<pre><code>func main() {\n    // filepath.Separator is OS-specific\n    fmt.Println(\"Path separator:\", string(filepath.Separator))\n    // On Unix: /\n    // On Windows: \\\n\n    // filepath.ListSeparator is for PATH environment variable\n    fmt.Println(\"List separator:\", string(filepath.ListSeparator))\n    // On Unix: :\n    // On Windows: ;\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#2-volume-names-windows","title":"2. Volume Names (Windows)","text":"<pre><code>func main() {\n    // Volume names are Windows-specific\n    volume := filepath.VolumeName(\"C:\\\\Windows\\\\System32\")\n    fmt.Println(\"Volume name:\", volume) // C:\n\n    // On Unix, VolumeName returns empty string\n    volume = filepath.VolumeName(\"/usr/bin\")\n    fmt.Println(\"Volume name:\", volume) // (empty)\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#3-handling-different-path-styles","title":"3. Handling Different Path Styles","text":"<pre><code>func main() {\n    // Match function works with both styles\n    unixPath := \"/home/user/file.txt\"\n    windowsPath := \"C:\\\\Users\\\\user\\\\file.txt\"\n\n    // Match returns true if the pattern matches\n    matched, err := filepath.Match(\"*.txt\", unixPath)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Match %s: %v\\n\", unixPath, matched)\n\n    matched, err = filepath.Match(\"*.txt\", windowsPath)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Match %s: %v\\n\", windowsPath, matched)\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#real-world-example-file-organizer","title":"Real-World Example: File Organizer","text":"<p>Let's build a file organizer that sorts files into directories based on their extensions:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\n// FileOrganizer organizes files into directories based on extensions\ntype FileOrganizer struct {\n    sourceDir      string\n    targetDir      string\n    extensionMap   map[string]string\n    dryRun         bool\n    verbose        bool\n    movedFiles     int\n    skippedFiles   int\n    errorFiles     int\n}\n\n// NewFileOrganizer creates a new file organizer\nfunc NewFileOrganizer(source, target string) *FileOrganizer {\n    return &amp;FileOrganizer{\n        sourceDir:    source,\n        targetDir:    target,\n        extensionMap: map[string]string{\n            \".txt\":  \"Documents\",\n            \".doc\":  \"Documents\",\n            \".docx\": \"Documents\",\n            \".pdf\":  \"Documents\",\n            \".jpg\":  \"Images\",\n            \".jpeg\": \"Images\",\n            \".png\":  \"Images\",\n            \".gif\":  \"Images\",\n            \".mp3\":  \"Music\",\n            \".wav\":  \"Music\",\n            \".mp4\":  \"Videos\",\n            \".avi\":  \"Videos\",\n            \".mkv\":  \"Videos\",\n            \".zip\":  \"Archives\",\n            \".tar\":  \"Archives\",\n            \".gz\":   \"Archives\",\n            \".exe\":  \"Programs\",\n            \".dll\":  \"Programs\",\n            \".go\":   \"Source\",\n            \".py\":   \"Source\",\n            \".js\":   \"Source\",\n            \".html\": \"Web\",\n            \".css\":  \"Web\",\n        },\n        dryRun: false,\n        verbose: false,\n    }\n}\n\n// SetDryRun enables dry run mode (no actual file operations)\nfunc (fo *FileOrganizer) SetDryRun(dryRun bool) {\n    fo.dryRun = dryRun\n}\n\n// SetVerbose enables verbose output\nfunc (fo *FileOrganizer) SetVerbose(verbose bool) {\n    fo.verbose = verbose\n}\n\n// AddCustomExtension adds a custom extension mapping\nfunc (fo *FileOrganizer) AddCustomExtension(ext, dir string) {\n    if !strings.HasPrefix(ext, \".\") {\n        ext = \".\" + ext\n    }\n    fo.extensionMap[ext] = dir\n}\n\n// Organize starts the file organization process\nfunc (fo *FileOrganizer) Organize() error {\n    // Create target directory if it doesn't exist\n    if err := os.MkdirAll(fo.targetDir, 0755); err != nil {\n        return fmt.Errorf(\"failed to create target directory: %w\", err)\n    }\n\n    // Walk through source directory\n    err := filepath.Walk(fo.sourceDir, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        // Skip directories\n        if info.IsDir() {\n            return nil\n        }\n\n        // Skip hidden files\n        if strings.HasPrefix(filepath.Base(path), \".\") {\n            return nil\n        }\n\n        // Process file\n        return fo.processFile(path, info)\n    })\n\n    if err != nil {\n        return fmt.Errorf(\"error walking directory: %w\", err)\n    }\n\n    // Print summary\n    fo.printSummary()\n    return nil\n}\n\n// processFile handles individual file processing\nfunc (fo *FileOrganizer) processFile(path string, info os.FileInfo) error {\n    // Get file extension\n    ext := strings.ToLower(filepath.Ext(path))\n\n    // Determine target directory\n    targetDir := fo.extensionMap[ext]\n    if targetDir == \"\" {\n        targetDir = \"Other\"\n    }\n\n    // Create full target path\n    relPath, err := filepath.Rel(fo.sourceDir, path)\n    if err != nil {\n        fo.errorFiles++\n        if fo.verbose {\n            fmt.Printf(\"Error getting relative path for %s: %v\\n\", path, err)\n        }\n        return nil\n    }\n\n    targetPath := filepath.Join(fo.targetDir, targetDir, filepath.Base(relPath))\n\n    // Create target directory if it doesn't exist\n    targetDirPath := filepath.Join(fo.targetDir, targetDir)\n    if err := os.MkdirAll(targetDirPath, 0755); err != nil {\n        fo.errorFiles++\n        if fo.verbose {\n            fmt.Printf(\"Error creating directory %s: %v\\n\", targetDirPath, err)\n        }\n        return nil\n    }\n\n    // Move the file\n    if fo.dryRun {\n        if fo.verbose {\n            fmt.Printf(\"[DRY RUN] Would move: %s -&gt; %s\\n\", path, targetPath)\n        }\n        fo.movedFiles++\n    } else {\n        if err := os.Rename(path, targetPath); err != nil {\n            // If rename fails (cross-device?), try copy and delete\n            if err := fo.copyAndDelete(path, targetPath, info); err != nil {\n                fo.errorFiles++\n                if fo.verbose {\n                    fmt.Printf(\"Error moving %s: %v\\n\", path, err)\n                }\n                return nil\n            }\n        }\n        if fo.verbose {\n            fmt.Printf(\"Moved: %s -&gt; %s\\n\", path, targetPath)\n        }\n        fo.movedFiles++\n    }\n\n    return nil\n}\n\n// copyAndDelete copies a file and then deletes the original\nfunc (fo *FileOrganizer) copyAndDelete(src, dst string, info os.FileInfo) error {\n    // Copy file\n    if err := fo.copyFile(src, dst, info); err != nil {\n        return err\n    }\n\n    // Delete original\n    if err := os.Remove(src); err != nil {\n        return fmt.Errorf(\"failed to delete original file: %w\", err)\n    }\n\n    return nil\n}\n\n// copyFile copies a file preserving permissions\nfunc (fo *FileOrganizer) copyFile(src, dst string, info os.FileInfo) error {\n    // Open source file\n    source, err := os.Open(src)\n    if err != nil {\n        return err\n    }\n    defer source.Close()\n\n    // Create destination file\n    destination, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, info.Mode())\n    if err != nil {\n        return err\n    }\n    defer destination.Close()\n\n    // Copy content\n    _, err = io.Copy(destination, source)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n\n// printSummary prints the organization summary\nfunc (fo *FileOrganizer) printSummary() {\n    fmt.Println(\"\\n=== File Organization Summary ===\")\n    fmt.Printf(\"Files moved: %d\\n\", fo.movedFiles)\n    fmt.Printf(\"Files skipped: %d\\n\", fo.skippedFiles)\n    fmt.Printf(\"Errors encountered: %d\\n\", fo.errorFiles)\n}\n\nfunc main() {\n    // Create sample directory structure for testing\n    sourceDir := \"test_source\"\n    targetDir := \"test_target\"\n\n    // Create source directory with sample files\n    if err := createTestFiles(sourceDir); err != nil {\n        fmt.Println(\"Error creating test files:\", err)\n        return\n    }\n    defer os.RemoveAll(sourceDir)\n    defer os.RemoveAll(targetDir)\n\n    // Create file organizer\n    organizer := NewFileOrganizer(sourceDir, targetDir)\n    organizer.SetVerbose(true)\n    organizer.SetDryRun(false) // Set to true to test without moving files\n\n    // Add custom extension\n    organizer.AddCustomExtension(\".log\", \"Logs\")\n\n    // Organize files\n    fmt.Println(\"Organizing files...\")\n    if err := organizer.Organize(); err != nil {\n        fmt.Println(\"Error organizing files:\", err)\n        return\n    }\n}\n\n// createTestFiles creates a directory structure with sample files\nfunc createTestFiles(baseDir string) error {\n    // Create base directory\n    if err := os.MkdirAll(baseDir, 0755); err != nil {\n        return err\n    }\n\n    // Create subdirectories\n    subdirs := []string{\"docs\", \"images\", \"music\"}\n    for _, subdir := range subdirs {\n        dirPath := filepath.Join(baseDir, subdir)\n        if err := os.Mkdir(dirPath, 0755); err != nil {\n            return err\n        }\n    }\n\n    // Create sample files\n    files := map[string]string{\n        filepath.Join(baseDir, \"document.txt\"):         \"This is a text document\",\n        filepath.Join(baseDir, \"image.jpg\"):           \"JPEG image data\",\n        filepath.Join(baseDir, \"music.mp3\"):           \"MP3 audio data\",\n        filepath.Join(baseDir, \"archive.zip\"):          \"ZIP archive data\",\n        filepath.Join(baseDir, \"program.go\"):          \"Go source code\",\n        filepath.Join(baseDir, \"app.log\"):             \"Application log\",\n        filepath.Join(baseDir, \"docs\", \"report.pdf\"):  \"PDF report\",\n        filepath.Join(baseDir, \"images\", \"photo.png\"): \"PNG image data\",\n        filepath.Join(baseDir, \"music\", \"song.wav\"):    \"WAV audio data\",\n    }\n\n    for path, content := range files {\n        if err := os.WriteFile(path, []byte(content), 0644); err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>File Organization Logic:</li> <li>Maps file extensions to target directories</li> <li>Walks through the source directory tree</li> <li>Moves files to appropriate subdirectories based on extensions</li> <li> <p>Handles cross-device moves with copy-and-delete fallback</p> </li> <li> <p>Path Manipulation:</p> </li> <li>Uses <code>filepath.Join</code> for OS-specific path construction</li> <li>Extracts file extensions with <code>filepath.Ext</code></li> <li>Creates relative paths with <code>filepath.Rel</code></li> <li> <p>Handles directory creation with <code>os.MkdirAll</code></p> </li> <li> <p>Cross-Platform Support:</p> </li> <li>Works on both Windows and Unix-like systems</li> <li>Uses <code>filepath</code> functions for OS-specific path handling</li> <li> <p>Preserves file permissions during copy operations</p> </li> <li> <p>Safety Features:</p> </li> <li>Dry run mode for testing without actual file operations</li> <li>Verbose output for debugging</li> <li>Error handling and reporting</li> <li>Summary statistics</li> </ol>"},{"location":"2.%20Intermediate/26.%20File-Paths/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>File Management:</li> <li>Organize downloads folder</li> <li>Clean up project directories</li> <li>Sort media files by type</li> <li> <p>Archive old files</p> </li> <li> <p>Backup Systems:</p> </li> <li>Organize backup files by date or type</li> <li>Create structured backup hierarchies</li> <li> <p>Handle incremental backups</p> </li> <li> <p>Content Management:</p> </li> <li>Organize document repositories</li> <li>Sort assets by type or category</li> <li>Maintain consistent directory structures</li> </ol>"},{"location":"2.%20Intermediate/26.%20File-Paths/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/26.%20File-Paths/#1-always-use-filepath-for-file-system-paths","title":"1. Always Use <code>filepath</code> for File System Paths","text":"<pre><code>// Good: Use filepath for file system operations\npath := filepath.Join(\"dir\", \"subdir\", \"file.txt\")\nabsPath, err := filepath.Abs(path)\n\n// Bad: Use path package for file system\npath = path.Join(\"dir\", \"subdir\", \"file.txt\") // May not work on Windows\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#2-clean-paths-before-using","title":"2. Clean Paths Before Using","text":"<pre><code>// Good: Clean paths to remove redundant separators\nmessyPath := \"dir//subdir/./file.txt/../other.txt\"\ncleanPath := filepath.Clean(messyPath)\n\n// Bad: Use paths without cleaning\n// May cause issues with redundant separators or relative references\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#3-handle-path-separators-correctly","title":"3. Handle Path Separators Correctly","text":"<pre><code>// Good: Use filepath.Separator for OS-specific separator\nseparator := string(filepath.Separator)\n\n// Bad: Hardcode separators\nseparator := \"/\" // Won't work on Windows\nseparator := \"\\\\\" // Won't work on Unix\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#4-check-path-types-before-operations","title":"4. Check Path Types Before Operations","text":"<pre><code>// Good: Check if path is absolute or relative\nif filepath.IsAbs(path) {\n    // Handle absolute path\n} else {\n    // Handle relative path\n}\n\n// Bad: Assume path type without checking\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#5-use-rel-for-relative-path-display","title":"5. Use <code>Rel</code> for Relative Path Display","text":"<pre><code>// Good: Show relative paths for user display\nrelPath, err := filepath.Rel(basePath, fullPath)\nif err == nil {\n    fmt.Println(\"Relative path:\", relPath)\n}\n\n// Bad: Show absolute paths when relative would be clearer\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#security-considerations","title":"Security Considerations","text":""},{"location":"2.%20Intermediate/26.%20File-Paths/#1-path-traversal-prevention","title":"1. Path Traversal Prevention","text":"<pre><code>// Good: Validate paths to prevent directory traversal\nfunc safeJoin(base, path string) (string, error) {\n    // Clean the path\n    cleanPath := filepath.Clean(filepath.Join(base, path))\n\n    // Check if the result is still within base directory\n    relPath, err := filepath.Rel(base, cleanPath)\n    if err != nil {\n        return \"\", err\n    }\n\n    // Check if path tries to escape base directory\n    if strings.HasPrefix(relPath, \"..\"+string(filepath.Separator)) {\n        return \"\", fmt.Errorf(\"invalid path: attempts to escape base directory\")\n    }\n\n    return cleanPath, nil\n}\n\n// Bad: Join paths without validation\nfunc unsafeJoin(base, path string) string {\n    return filepath.Join(base, path) // May allow directory traversal\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#2-sanitize-user-input","title":"2. Sanitize User Input","text":"<pre><code>// Good: Sanitize user-provided paths\nfunc sanitizeUserInput(userPath string) string {\n    // Remove any suspicious characters\n    // Clean the path\n    return filepath.Clean(userPath)\n}\n\n// Bad: Use user input directly\nfunc processUserPath(userPath string) {\n    path := filepath.Join(\"/base\", userPath) // Dangerous!\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#performance-considerations","title":"Performance Considerations","text":""},{"location":"2.%20Intermediate/26.%20File-Paths/#1-efficient-directory-walking","title":"1. Efficient Directory Walking","text":"<pre><code>// Good: Skip unnecessary files during walk\nfunc walkDirectory(root string, filter func(string) bool) error {\n    return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        // Skip directories\n        if info.IsDir() {\n            return nil\n        }\n\n        // Apply filter\n        if !filter(path) {\n            return nil\n        }\n\n        // Process file\n        return processFile(path)\n    })\n}\n\n// Bad: Process all files without filtering\nfunc walkDirectoryBad(root string) error {\n    return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n        if info.IsDir() {\n            return nil\n        }\n        // Process every file, even if not needed\n        return processFile(path)\n    })\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#2-cache-path-operations","title":"2. Cache Path Operations","text":"<pre><code>// Good: Cache frequently used path operations\ntype PathCache struct {\n    baseDir string\n    cache   map[string]string\n    mu      sync.RWMutex\n}\n\nfunc (pc *PathCache) GetRelativePath(absPath string) (string, error) {\n    pc.mu.RLock()\n    if relPath, ok := pc.cache[absPath]; ok {\n        pc.mu.RUnlock()\n        return relPath, nil\n    }\n    pc.mu.RUnlock()\n\n    relPath, err := filepath.Rel(pc.baseDir, absPath)\n    if err != nil {\n        return \"\", err\n    }\n\n    pc.mu.Lock()\n    pc.cache[absPath] = relPath\n    pc.mu.Unlock()\n\n    return relPath, nil\n}\n\n// Bad: Recalculate paths every time\nfunc getRelativePathBad(base, absPath string) (string, error) {\n    return filepath.Rel(base, absPath) // No caching\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#conclusion","title":"Conclusion","text":"<p>File path manipulation is a critical aspect of many Go applications. The <code>path</code> and <code>filepath</code> packages provide comprehensive tools for:</p> <ol> <li>Path Construction:</li> <li>Join paths with OS-appropriate separators</li> <li>Clean paths to remove redundancies</li> <li> <p>Handle absolute and relative paths correctly</p> </li> <li> <p>Path Analysis:</p> </li> <li>Extract components (directory, filename, extension)</li> <li>Check path properties (absolute, relative)</li> <li> <p>Match patterns against paths</p> </li> <li> <p>Directory Operations:</p> </li> <li>Create and manage directory structures</li> <li>Walk directory trees efficiently</li> <li> <p>Handle cross-platform path differences</p> </li> <li> <p>Cross-Platform Support:</p> </li> <li>Work seamlessly on Windows, macOS, and Linux</li> <li>Handle different path separators and conventions</li> <li>Build truly portable applications</li> </ol> <p>The file organizer example demonstrates how to build a practical application that uses various path operations to organize files systematically. By following best practices and understanding cross-platform considerations, you can create robust file system utilities in Go.</p> <p>Key takeaways: 1. Use <code>filepath</code> for file system operations (not <code>path</code>) 2. Clean paths before using them to remove redundancies 3. Validate paths to prevent security issues like directory traversal 4. Handle both absolute and relative paths appropriately 5. Consider cross-platform differences in path separators and conventions 6. Use efficient directory walking with proper filtering</p> <p>File paths might seem simple, but they're full of edge cases and platform-specific nuances. With Go's excellent path manipulation libraries and the patterns shown in this guide, you can build reliable and portable file system operations in your applications.</p>"},{"location":"2.%20Intermediate/27.%20Directories/","title":"Directories and Linux Permission Codes in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/27.%20Directories/#introduction-to-directories-and-permissions","title":"Introduction to Directories and Permissions","text":"<p>In Go, working with directories and file permissions is essential for building robust system utilities and applications. While Go provides cross-platform support, understanding Linux permission codes is crucial for applications targeting Unix-like systems. This guide covers directory operations, permission management, and the intricacies of Linux permission codes.</p>"},{"location":"2.%20Intermediate/27.%20Directories/#directory-operations","title":"Directory Operations","text":""},{"location":"2.%20Intermediate/27.%20Directories/#1-creating-directories","title":"1. Creating Directories","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Create a single directory\n    err := os.Mkdir(\"mydir\", 0755) // 0755 = rwxr-xr-x\n    if err != nil {\n        fmt.Println(\"Error creating directory:\", err)\n        return\n    }\n    fmt.Println(\"Directory created successfully\")\n\n    // Create nested directories (MkdirAll)\n    err = os.MkdirAll(\"mydir/nested1/nested2\", 0755)\n    if err != nil {\n        fmt.Println(\"Error creating nested directories:\", err)\n        return\n    }\n    fmt.Println(\"Nested directories created successfully\")\n\n    // Clean up\n    os.RemoveAll(\"mydir\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#2-removing-directories","title":"2. Removing Directories","text":"<pre><code>func main() {\n    // Create test directory structure\n    os.MkdirAll(\"testdir/subdir\", 0755)\n\n    // Remove empty directory\n    err := os.Remove(\"testdir/subdir\")\n    if err != nil {\n        fmt.Println(\"Error removing directory:\", err)\n    }\n\n    // Remove directory and all contents (RemoveAll)\n    err = os.RemoveAll(\"testdir\")\n    if err != nil {\n        fmt.Println(\"Error removing directory tree:\", err)\n    }\n\n    fmt.Println(\"Directories removed successfully\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#3-listing-directory-contents","title":"3. Listing Directory Contents","text":"<pre><code>func main() {\n    // Create test directory with files\n    os.MkdirAll(\"testdir\", 0755)\n    os.WriteFile(\"testdir/file1.txt\", []byte(\"content1\"), 0644)\n    os.WriteFile(\"testdir/file2.txt\", []byte(\"content2\"), 0644)\n    os.Mkdir(\"testdir/subdir\", 0755)\n\n    // Read directory contents\n    entries, err := os.ReadDir(\"testdir\")\n    if err != nil {\n        fmt.Println(\"Error reading directory:\", err)\n        return\n    }\n\n    fmt.Println(\"Contents of testdir:\")\n    for _, entry := range entries {\n        info, err := entry.Info()\n        if err != nil {\n            fmt.Println(\"Error getting info:\", err)\n            continue\n        }\n\n        if info.IsDir() {\n            fmt.Printf(\"DIR  %s/\\n\", entry.Name())\n        } else {\n            fmt.Printf(\"FILE %s (%d bytes)\\n\", entry.Name(), info.Size())\n        }\n    }\n\n    // Clean up\n    os.RemoveAll(\"testdir\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#4-changing-current-directory","title":"4. Changing Current Directory","text":"<pre><code>func main() {\n    // Get current working directory\n    originalDir, err := os.Getwd()\n    if err != nil {\n        fmt.Println(\"Error getting current directory:\", err)\n        return\n    }\n    fmt.Println(\"Original directory:\", originalDir)\n\n    // Create and change to test directory\n    os.Mkdir(\"testdir\", 0755)\n    err = os.Chdir(\"testdir\")\n    if err != nil {\n        fmt.Println(\"Error changing directory:\", err)\n        return\n    }\n\n    // Get new current directory\n    currentDir, err := os.Getwd()\n    if err != nil {\n        fmt.Println(\"Error getting current directory:\", err)\n        return\n    }\n    fmt.Println(\"Current directory:\", currentDir)\n\n    // Change back to original directory\n    err = os.Chdir(originalDir)\n    if err != nil {\n        fmt.Println(\"Error changing directory:\", err)\n        return\n    }\n\n    // Clean up\n    os.RemoveAll(\"testdir\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#understanding-linux-permission-codes","title":"Understanding Linux Permission Codes","text":""},{"location":"2.%20Intermediate/27.%20Directories/#1-permission-basics","title":"1. Permission Basics","text":"<p>Linux permissions are represented by a 9-bit mask divided into three sets of 3 bits each: - Owner (user): rwx - Group: rwx - Others: rwx</p> <p>Each permission has a numeric value: - r (read) = 4 - w (write) = 2 - x (execute) = 1</p>"},{"location":"2.%20Intermediate/27.%20Directories/#2-octal-permission-notation","title":"2. Octal Permission Notation","text":"<pre><code>func main() {\n    // Common permission codes and their meanings\n    permissions := map[int]string{\n        000: \"--- --- ---\", // No permissions\n        400: \"r-- --- ---\", // Read only for owner\n        600: \"rw- --- ---\", // Read/write for owner\n        644: \"rw- r-- r--\", // Read/write for owner, read for group and others\n        700: \"rwx --- ---\", // Full permissions for owner\n        755: \"rwxr-xr-x\", // Full for owner, read/execute for group and others\n        777: \"rwxrwxrwx\", // Full permissions for everyone\n    }\n\n    fmt.Println(\"Common Linux Permission Codes:\")\n    for code, desc := range permissions {\n        fmt.Printf(\"%03d: %s\\n\", code, desc)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#3-symbolic-notation","title":"3. Symbolic Notation","text":"<pre><code>func main() {\n    // Symbolic notation examples\n    symbolic := map[string]string{\n        \"u=rwx\":   \"Owner: read, write, execute\",\n        \"g=rx\":   \"Group: read, execute\",\n        \"o=r\":     \"Others: read\",\n        \"u=rwx,g=rx,o=r\": \"Owner: rwx, Group: rx, Others: r\",\n        \"a=rwx\":   \"All: read, write, execute\",\n    }\n\n    fmt.Println(\"Symbolic Permission Notation:\")\n    for sym, desc := range symbolic {\n        fmt.Printf(\"%-15s: %s\\n\", sym, desc)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#working-with-permissions-in-go","title":"Working with Permissions in Go","text":""},{"location":"2.%20Intermediate/27.%20Directories/#1-setting-file-permissions","title":"1. Setting File Permissions","text":"<pre><code>func main() {\n    // Create a file with specific permissions\n    content := []byte(\"Hello, World!\")\n\n    // Create file with 644 permissions (rw-r--r--)\n    err := os.WriteFile(\"test.txt\", content, 0644)\n    if err != nil {\n        fmt.Println(\"Error creating file:\", err)\n        return\n    }\n\n    // Get file info to check permissions\n    info, err := os.Stat(\"test.txt\")\n    if err != nil {\n        fmt.Println(\"Error getting file info:\", err)\n        return\n    }\n\n    fmt.Printf(\"File mode: %04o\\n\", info.Mode().Perm())\n\n    // Change permissions to 755 (rwxr-xr-x)\n    err = os.Chmod(\"test.txt\", 0755)\n    if err != nil {\n        fmt.Println(\"Error changing permissions:\", err)\n        return\n    }\n\n    // Verify the change\n    info, err = os.Stat(\"test.txt\")\n    if err != nil {\n        fmt.Println(\"Error getting file info:\", err)\n        return\n    }\n\n    fmt.Printf(\"New file mode: %04o\\n\", info.Mode().Perm())\n\n    // Clean up\n    os.Remove(\"test.txt\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#2-checking-file-permissions","title":"2. Checking File Permissions","text":"<pre><code>func main() {\n    // Create test files with different permissions\n    files := map[string]os.FileMode{\n        \"readonly.txt\":  0444, // r--r--r--\n        \"readwrite.txt\": 0666, // rw-rw-rw-\n        \"executable.txt\": 0755, // rwxr-xr-x\n        \"private.txt\":   0600, // rw-------\n    }\n\n    for filename, mode := range files {\n        os.WriteFile(filename, []byte(\"test\"), mode)\n    }\n\n    // Check permissions for each file\n    for filename := range files {\n        info, err := os.Stat(filename)\n        if err != nil {\n            fmt.Printf(\"Error getting info for %s: %v\\n\", filename, err)\n            continue\n        }\n\n        mode := info.Mode().Perm()\n        fmt.Printf(\"%-15s: %04o (%s)\\n\", filename, mode, permissionString(mode))\n    }\n\n    // Clean up\n    for filename := range files {\n        os.Remove(filename)\n    }\n}\n\n// permissionString converts numeric permissions to symbolic notation\nfunc permissionString(mode os.FileMode) string {\n    var result [9]byte\n\n    // Owner permissions\n    result[0] = 'r'\n    if mode&amp;0400 == 0 {\n        result[0] = '-'\n    }\n    result[1] = 'w'\n    if mode&amp;0200 == 0 {\n        result[1] = '-'\n    }\n    result[2] = 'x'\n    if mode&amp;0100 == 0 {\n        result[2] = '-'\n    }\n\n    // Group permissions\n    result[3] = 'r'\n    if mode&amp;0040 == 0 {\n        result[3] = '-'\n    }\n    result[4] = 'w'\n    if mode&amp;0020 == 0 {\n        result[4] = '-'\n    }\n    result[5] = 'x'\n    if mode&amp;0010 == 0 {\n        result[5] = '-'\n    }\n\n    // Others permissions\n    result[6] = 'r'\n    if mode&amp;0004 == 0 {\n        result[6] = '-'\n    }\n    result[7] = 'w'\n    if mode&amp;0002 == 0 {\n        result[7] = '-'\n    }\n    result[8] = 'x'\n    if mode&amp;0001 == 0 {\n        result[8] = '-'\n    }\n\n    return string(result[:3]) + \" \" + string(result[3:6]) + \" \" + string(result[6:])\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#3-checking-file-accessibility","title":"3. Checking File Accessibility","text":"<pre><code>func main() {\n    // Create test file\n    os.WriteFile(\"test.txt\", []byte(\"test\"), 0644)\n\n    // Check if file exists\n    if _, err := os.Stat(\"test.txt\"); err == nil {\n        fmt.Println(\"File exists\")\n    }\n\n    // Check if file is readable\n    file, err := os.Open(\"test.txt\")\n    if err == nil {\n        fmt.Println(\"File is readable\")\n        file.Close()\n    }\n\n    // Check if file is writable\n    file, err = os.OpenFile(\"test.txt\", os.O_WRONLY, 0)\n    if err == nil {\n        fmt.Println(\"File is writable\")\n        file.Close()\n    }\n\n    // Check if file is executable\n    info, _ := os.Stat(\"test.txt\")\n    if info.Mode().Perm()&amp;0111 != 0 {\n        fmt.Println(\"File is executable\")\n    }\n\n    // Clean up\n    os.Remove(\"test.txt\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#advanced-permission-operations","title":"Advanced Permission Operations","text":""},{"location":"2.%20Intermediate/27.%20Directories/#1-changing-ownership-unixlinux-only","title":"1. Changing Ownership (Unix/Linux only)","text":"<pre><code>func main() {\n    // Note: This example only works on Unix-like systems\n    // You need appropriate permissions to change ownership\n\n    // Create test file\n    os.WriteFile(\"test.txt\", []byte(\"test\"), 0644)\n\n    // Change owner (requires root privileges)\n    // err := os.Chown(\"test.txt\", 1000, 1000) // UID=1000, GID=1000\n    // if err != nil {\n    //     fmt.Println(\"Error changing ownership:\", err)\n    // }\n\n    // Get file info\n    info, err := os.Stat(\"test.txt\")\n    if err != nil {\n        fmt.Println(\"Error getting file info:\", err)\n        return\n    }\n\n    // Get owner and group (Unix specific)\n    if stat, ok := info.Sys().(*syscall.Stat_t); ok {\n        fmt.Printf(\"UID: %d, GID: %d\\n\", stat.Uid, stat.Gid)\n    }\n\n    // Clean up\n    os.Remove(\"test.txt\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#2-setting-sticky-bit-setuid-setgid","title":"2. Setting Sticky Bit, SetUID, SetGID","text":"<pre><code>func main() {\n    // Create test file\n    os.WriteFile(\"test.txt\", []byte(\"test\"), 0644)\n\n    // Set sticky bit (used for shared directories)\n    err := os.Chmod(\"test.txt, 01644) // 1000 (sticky bit) + 644\n    if err != nil {\n        fmt.Println(\"Error setting sticky bit:\", err)\n    }\n\n    // Set SetUID bit\n    err = os.Chmod(\"test.txt\", 04644) // 4000 (SetUID) + 644\n    if err != nil {\n        fmt.Println(\"Error setting SetUID bit:\", err)\n    }\n\n    // Set SetGID bit\n    err = os.Chmod(\"test.txt\", 02644) // 2000 (SetGID) + 644\n    if err != nil {\n        fmt.Println(\"Error setting SetGID bit:\", err)\n    }\n\n    // Check final permissions\n    info, err := os.Stat(\"test.txt\")\n    if err != nil {\n        fmt.Println(\"Error getting file info:\", err)\n        return\n    }\n\n    fmt.Printf(\"Final mode: %04o\\n\", info.Mode().Perm())\n\n    // Clean up\n    os.Remove(\"test.txt\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#real-world-example-secure-file-manager","title":"Real-World Example: Secure File Manager","text":"<p>Let's build a secure file manager that demonstrates directory operations and permission management:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/user\"\n    \"path/filepath\"\n    \"strconv\"\n    \"strings\"\n    \"syscall\"\n)\n\n// SecureFileManager handles file operations with permission management\ntype SecureFileManager struct {\n    baseDir string\n    verbose bool\n}\n\n// NewSecureFileManager creates a new secure file manager\nfunc NewSecureFileManager(baseDir string, verbose bool) *SecureFileManager {\n    return &amp;SecureFileManager{\n        baseDir: baseDir,\n        verbose: verbose,\n    }\n}\n\n// CreateSecureDirectory creates a directory with secure permissions\nfunc (sfm *SecureFileManager) CreateSecureDirectory(path string, perm os.FileMode) error {\n    fullPath := filepath.Join(sfm.baseDir, path)\n\n    if sfm.verbose {\n        fmt.Printf(\"Creating directory: %s with permissions %04o\\n\", fullPath, perm)\n    }\n\n    err := os.Mkdir(fullPath, perm)\n    if err != nil {\n        return fmt.Errorf(\"failed to create directory: %w\", err)\n    }\n\n    return nil\n}\n\n// CreateSecureFile creates a file with secure permissions\nfunc (sfm *SecureFileManager) CreateSecureFile(path string, content []byte, perm os.FileMode) error {\n    fullPath := filepath.Join(sfm.baseDir, path)\n\n    if sfm.verbose {\n        fmt.Printf(\"Creating file: %s with permissions %04o\\n\", fullPath, perm)\n    }\n\n    err := os.WriteFile(fullPath, content, perm)\n    if err != nil {\n        return fmt.Errorf(\"failed to create file: %w\", err)\n    }\n\n    return nil\n}\n\n// SetPermissions sets file or directory permissions\nfunc (sfm *SecureFileManager) SetPermissions(path string, perm os.FileMode) error {\n    fullPath := filepath.Join(sfm.baseDir, path)\n\n    if sfm.verbose {\n        fmt.Printf(\"Setting permissions for %s to %04o\\n\", fullPath, perm)\n    }\n\n    err := os.Chmod(fullPath, perm)\n    if err != nil {\n        return fmt.Errorf(\"failed to set permissions: %w\", err)\n    }\n\n    return nil\n}\n\n// SetOwnership sets file ownership (Unix/Linux only)\nfunc (sfm *SecureFileManager) SetOwnership(path string, uid, gid int) error {\n    fullPath := filepath.Join(sfm.baseDir, path)\n\n    if sfm.verbose {\n        fmt.Printf(\"Setting ownership for %s to UID:%d GID:%d\\n\", fullPath, uid, gid)\n    }\n\n    err := os.Chown(fullPath, uid, gid)\n    if err != nil {\n        return fmt.Errorf(\"failed to set ownership: %w\", err)\n    }\n\n    return nil\n}\n\n// CheckPermissions checks and reports file permissions\nfunc (sfm *SecureFileManager) CheckPermissions(path string) error {\n    fullPath := filepath.Join(sfm.baseDir, path)\n\n    info, err := os.Stat(fullPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to stat file: %w\", err)\n    }\n\n    mode := info.Mode().Perm()\n    fmt.Printf(\"Permissions for %s:\\n\", fullPath)\n    fmt.Printf(\"  Octal: %04o\\n\", mode)\n    fmt.Printf(\"  Symbolic: %s\\n\", permissionString(mode))\n\n    // Check accessibility\n    sfm.checkAccessibility(fullPath, mode)\n\n    return nil\n}\n\n// checkAccessibility checks if file is readable/writable/executable\nfunc (sfm *SecureFileManager) checkAccessibility(path string, mode os.FileMode) {\n    // Check readability\n    file, err := os.Open(path)\n    if err == nil {\n        fmt.Println(\"  Readable: Yes\")\n        file.Close()\n    } else {\n        fmt.Println(\"  Readable: No\")\n    }\n\n    // Check writability\n    file, err = os.OpenFile(path, os.O_WRONLY, 0)\n    if err == nil {\n        fmt.Println(\"  Writable: Yes\")\n        file.Close()\n    } else {\n        fmt.Println(\"  Writable: No\")\n    }\n\n    // Check executability\n    if mode&amp;0111 != 0 {\n        fmt.Println(\"  Executable: Yes\")\n    } else {\n        fmt.Println(\"  Executable: No\")\n    }\n}\n\n// CreateSecureStructure creates a secure directory structure\nfunc (sfm *SecureFileManager) CreateSecureStructure() error {\n    // Create base directory\n    if err := sfm.CreateSecureDirectory(\"\", 0755); err != nil {\n        return err\n    }\n\n    // Create subdirectories with appropriate permissions\n    dirs := map[string]os.FileMode{\n        \"docs\":       0755, // rwxr-xr-x\n        \"bin\":        0755, // rwxr-xr-x\n        \"etc\":        0755, // rwxr-xr-x\n        \"var\":        0755, // rwxr-xr-x\n        \"tmp\":        01777, // rwxrwxrwt (sticky bit)\n        \"logs\":       0750, // rwxr-x---\n        \"config\":     0750, // rwxr-x---\n    }\n\n    for dir, perm := range dirs {\n        if err := sfm.CreateSecureDirectory(dir, perm); err != nil {\n            return err\n        }\n    }\n\n    // Create configuration files with secure permissions\n    configFiles := map[string]string{\n        \"config/app.conf\":    \"app configuration\",\n        \"config/database.conf\": \"database configuration\",\n        \"logs/app.log\":       \"application log\",\n    }\n\n    for path, content := range configFiles {\n        perm := os.FileMode(0640) // rw-r-----\n        if strings.Contains(path, \"logs\") {\n            perm = 0640 // rw-r-----\n        }\n        if err := sfm.CreateSecureFile(path, []byte(content), perm); err != nil {\n            return err\n        }\n    }\n\n    // Create executable scripts\n    scripts := map[string]string{\n        \"bin/start.sh\": \"#!/bin/bash\\necho \\\"Starting application\\\"\",\n        \"bin/stop.sh\":  \"#!/bin/bash\\necho \\\"Stopping application\\\"\",\n    }\n\n    for path, content := range scripts {\n        if err := sfm.CreateSecureFile(path, []byte(content), 0755); err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n\n// SecureCopy copies a file with preserved permissions\nfunc (sfm *SecureFileManager) SecureCopy(src, dst string) error {\n    srcPath := filepath.Join(sfm.baseDir, src)\n    dstPath := filepath.Join(sfm.baseDir, dst)\n\n    if sfm.verbose {\n        fmt.Printf(\"Secure copying %s to %s\\n\", srcPath, dstPath)\n    }\n\n    // Get source file info\n    info, err := os.Stat(srcPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to stat source file: %w\", err)\n    }\n\n    // Copy file content\n    content, err := os.ReadFile(srcPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to read source file: %w\", err)\n    }\n\n    // Create destination file with same permissions\n    err = os.WriteFile(dstPath, content, info.Mode())\n    if err != nil {\n        return fmt.Errorf(\"failed to write destination file: %w\", err)\n    }\n\n    // Copy ownership if possible\n    if stat, ok := info.Sys().(*syscall.Stat_t); ok {\n        err = os.Chown(dstPath, stat.Uid, stat.Gid)\n        if err != nil {\n            fmt.Printf(\"Warning: Failed to copy ownership: %v\\n\", err)\n        }\n    }\n\n    return nil\n}\n\n// AuditPermissions audits all files and directories\nfunc (sfm *SecureFileManager) AuditPermissions() error {\n    return filepath.Walk(sfm.baseDir, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        relPath, err := filepath.Rel(sfm.baseDir, path)\n        if err != nil {\n            return err\n        }\n\n        if info.IsDir() {\n            fmt.Printf(\"Directory: %s\\n\", relPath)\n        } else {\n            fmt.Printf(\"File: %s\\n\", relPath)\n        }\n\n        mode := info.Mode().Perm()\n        fmt.Printf(\"  Permissions: %04o (%s)\\n\", mode, permissionString(mode))\n\n        // Check for potential security issues\n        if info.IsDir() &amp;&amp; mode&amp;0022 != 0 {\n            fmt.Printf(\"  WARNING: Directory is writable by group/others\\n\")\n        }\n\n        if !info.IsDir() &amp;&amp; mode&amp;0111 != 0 {\n            fmt.Printf(\"  INFO: File is not executable\\n\")\n        }\n\n        if mode&amp;0002 != 0 &amp;&amp; !info.IsDir() {\n            fmt.Printf(\"  WARNING: File is writable by others\\n\")\n        }\n\n        return nil\n    })\n}\n\n// permissionString converts numeric permissions to symbolic notation\nfunc permissionString(mode os.FileMode) string {\n    var result [9]byte\n\n    // Owner permissions\n    result[0] = 'r'\n    if mode&amp;0400 == 0 {\n        result[0] = '-'\n    }\n    result[1] = 'w'\n    if mode&amp;0200 == 0 {\n        result[1] = '-'\n    }\n    result[2] = 'x'\n    if mode&amp;0100 == 0 {\n        result[2] = '-'\n    }\n\n    // Group permissions\n    result[3] = 'r'\n    if mode&amp;0040 == 0 {\n        result[3] = '-'\n    }\n    result[4] = 'w'\n    if mode&amp;0020 == 0 {\n        result[4] = '-'\n    }\n    result[5] = 'x'\n    if mode&amp;0010 == 0 {\n        result[5] = '-'\n    }\n\n    // Others permissions\n    result[6] = 'r'\n    if mode&amp;0004 == 0 {\n        result[6] = '-'\n    }\n    result[7] = 'w'\n    if mode&amp;0002 == 0 {\n        result[7] = '-'\n    }\n    result[8] = 'x'\n    if mode&amp;0001 == 0 {\n        result[8] = '-'\n    }\n\n    return string(result[:3]) + \" \" + string(result[3:6]) + \" \" + string(result[6:])\n}\n\nfunc main() {\n    // Create secure file manager\n    manager := NewSecureFileManager(\"secure_app\", true)\n\n    // Create secure directory structure\n    fmt.Println(\"Creating secure directory structure...\")\n    if err := manager.CreateSecureStructure(); err != nil {\n        fmt.Printf(\"Error creating structure: %v\\n\", err)\n        return\n    }\n\n    // Check permissions of a specific file\n    fmt.Println(\"\\nChecking permissions of config/app.conf:\")\n    if err := manager.CheckPermissions(\"config/app.conf\"); err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n    }\n\n    // Secure copy example\n    fmt.Println(\"\\nPerforming secure copy...\")\n    if err := manager.SecureCopy(\"config/app.conf\", \"config/app.conf.bak\"); err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n    }\n\n    // Audit all permissions\n    fmt.Println(\"\\nAuditing permissions...\")\n    if err := manager.AuditPermissions(); err != nil {\n        fmt.Printf(\"Error during audit: %v\\n\", err)\n    }\n\n    // Clean up\n    fmt.Println(\"\\nCleaning up...\")\n    os.RemoveAll(\"secure_app\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#how-this-example-works","title":"How This Example Works:","text":"<ol> <li>Secure Directory Creation:</li> <li>Creates directories with appropriate permissions</li> <li>Uses standard Unix permission conventions</li> <li> <p>Implements special permissions (like sticky bit for /tmp)</p> </li> <li> <p>File Permission Management:</p> </li> <li>Creates files with secure default permissions</li> <li>Provides methods to change permissions</li> <li> <p>Supports ownership changes (on Unix systems)</p> </li> <li> <p>Permission Auditing:</p> </li> <li>Analyzes all files and directories</li> <li>Identifies potential security issues</li> <li> <p>Reports permissions in both octal and symbolic notation</p> </li> <li> <p>Secure Operations:</p> </li> <li>Copies files while preserving permissions</li> <li>Maintains ownership when possible</li> <li>Verifies accessibility (read/write/execute)</li> </ol>"},{"location":"2.%20Intermediate/27.%20Directories/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>System Administration:</li> <li>Secure setup of application directories</li> <li>Permission management for multi-user systems</li> <li> <p>Security auditing and compliance</p> </li> <li> <p>Application Deployment:</p> </li> <li>Creating secure directory structures</li> <li>Setting appropriate file permissions</li> <li> <p>Ensuring least privilege principle</p> </li> <li> <p>Security Tools:</p> </li> <li>Permission auditors</li> <li>File system security scanners</li> <li>Intrusion detection systems</li> </ol>"},{"location":"2.%20Intermediate/27.%20Directories/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/27.%20Directories/#1-use-principle-of-least-privilege","title":"1. Use Principle of Least Privilege","text":"<pre><code>// Good: Use minimal necessary permissions\nfunc createConfigFile() error {\n    return os.WriteFile(\"config.json\", configData, 0600) // rw-------\n}\n\n// Bad: Use overly permissive permissions\nfunc createConfigFileBad() error {\n    return os.WriteFile(\"config.json\", configData, 0666) // rw-rw-rw-\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#2-secure-directory-permissions","title":"2. Secure Directory Permissions","text":"<pre><code>// Good: Use appropriate directory permissions\nfunc createAppDirectory() error {\n    return os.Mkdir(\"app\", 0755) // rwxr-xr-x\n}\n\n// Bad: Use world-writable directories\nfunc createAppDirectoryBad() error {\n    return os.Mkdir(\"app\", 0777) // rwxrwxrwx\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#3-handle-cross-platform-differences","title":"3. Handle Cross-Platform Differences","text":"<pre><code>// Good: Check platform before Unix-specific operations\nfunc setOwnership(path string, uid, gid int) error {\n    if runtime.GOOS != \"windows\" {\n        return os.Chown(path, uid, gid)\n    }\n    return nil // Ownership not applicable on Windows\n}\n\n// Bad: Assume Unix-like system\nfunc setOwnershipBad(path string, uid, gid int) error {\n    return os.Chown(path, uid, gid) // Will fail on Windows\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#4-validate-paths-before-operations","title":"4. Validate Paths Before Operations","text":"<pre><code>// Good: Validate paths to prevent directory traversal\nfunc safeJoin(base, path string) (string, error) {\n    cleanPath := filepath.Clean(filepath.Join(base, path))\n    if !strings.HasPrefix(cleanPath, base) {\n        return \"\", fmt.Errorf(\"invalid path: attempts to escape base directory\")\n    }\n    return cleanPath, nil\n}\n\n// Bad: Join paths without validation\nfunc unsafeJoin(base, path string) string {\n    return filepath.Join(base, path) // Potentially unsafe\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#security-considerations","title":"Security Considerations","text":""},{"location":"2.%20Intermediate/27.%20Directories/#1-directory-traversal-prevention","title":"1. Directory Traversal Prevention","text":"<pre><code>// Good: Validate and sanitize paths\nfunc safeFilePath(baseDir, userPath string) (string, error) {\n    // Remove any .. components\n    cleanPath := filepath.Clean(filepath.Join(baseDir, userPath))\n\n    // Ensure the result is still within baseDir\n    relPath, err := filepath.Rel(baseDir, cleanPath)\n    if err != nil || strings.HasPrefix(relPath, \"..\") {\n        return \"\", fmt.Errorf(\"invalid path: %s\", userPath)\n    }\n\n    return cleanPath, nil\n}\n\n// Bad: Directly use user input\nfunc unsafeFilePath(baseDir, userPath string) string {\n    return filepath.Join(baseDir, userPath) // Vulnerable to traversal\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#2-permission-validation","title":"2. Permission Validation","text":"<pre><code>// Good: Validate permissions before operations\nfunc validatePermissions(path string, required os.FileMode) error {\n    info, err := os.Stat(path)\n    if err != nil {\n        return err\n    }\n\n    currentMode := info.Mode().Perm()\n    if currentMode&amp;required != required {\n        return fmt.Errorf(\"insufficient permissions: have %o, need %o\", currentMode, required)\n    }\n\n    return nil\n}\n\n// Bad: Assume permissions are correct\nfunc unsafeWrite(path string, data []byte) error {\n    return os.WriteFile(path, data, 0644) // May fail due to permissions\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#3-sensitive-file-handling","title":"3. Sensitive File Handling","text":"<pre><code>// Good: Handle sensitive files with secure permissions\nfunc createSecureConfig(config []byte) error {\n    // Create with restrictive permissions\n    err := os.WriteFile(\"config.json\", config, 0600) // rw-------\n    if err != nil {\n        return err\n    }\n\n    // Set ownership to application user if possible\n    if runtime.GOOS != \"windows\" {\n        uid, gid := getAppUserIDs()\n        return os.Chown(\"config.json\", uid, gid)\n    }\n\n    return nil\n}\n\n// Bad: Create sensitive files with default permissions\nfunc createSecureConfigBad(config []byte) error {\n    return os.WriteFile(\"config.json\", config, 0644) // Readable by group/others\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#conclusion","title":"Conclusion","text":"<p>Directory operations and permission management are crucial for building secure and robust system utilities in Go. The <code>os</code> package provides comprehensive tools for:</p> <ol> <li>Directory Management:</li> <li>Create, remove, and list directories</li> <li>Handle nested directory structures</li> <li> <p>Change current working directory</p> </li> <li> <p>Permission Control:</p> </li> <li>Set and modify file permissions</li> <li>Understand octal and symbolic notation</li> <li> <p>Handle special permission bits (sticky, SetUID, SetGID)</p> </li> <li> <p>Security Features:</p> </li> <li>Implement least privilege principle</li> <li>Validate paths to prevent traversal</li> <li> <p>Audit permissions for security issues</p> </li> <li> <p>Cross-Platform Support:</p> </li> <li>Work with both Windows and Unix-like systems</li> <li>Handle platform-specific differences gracefully</li> <li>Provide fallbacks for unsupported features</li> </ol> <p>The secure file manager example demonstrates how to build a comprehensive system that handles directory operations and permission management with security in mind. By following best practices and understanding Linux permission codes, you can create secure and reliable file system utilities in Go.</p> <p>Key takeaways: 1. Use appropriate permissions for files and directories 2. Implement least privilege principle 3. Validate paths to prevent security issues 4. Handle cross-platform differences gracefully 5. Audit permissions regularly for security compliance</p> <p>Directory and permission management might seem complex, but they're essential for building secure system utilities. With Go's excellent standard library and the patterns shown in this guide, you can create robust and secure file system operations in your applications.</p>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/","title":"Temporary Files and Directories and the Embed Directive in Go","text":""},{"location":"2.%20Intermediate/28.%20Directories-Addon/#temporary-files-and-directories-in-go","title":"Temporary Files and Directories in Go","text":""},{"location":"2.%20Intermediate/28.%20Directories-Addon/#introduction","title":"Introduction","text":"<p>Working with temporary files and directories is a common requirement in many applications, such as: - Storing intermediate data during processing - Creating scratch files for complex operations - Handling file uploads in web applications - Testing file operations without affecting the main file system</p> <p>Go provides the <code>os</code> package for creating and managing temporary files and directories.</p>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#creating-temporary-files","title":"Creating Temporary Files","text":"<p>The <code>os.CreateTemp</code> function creates a temporary file: - Takes two arguments: a directory and a pattern - If directory is empty, uses the default temporary directory (from <code>os.TempDir</code>) - The pattern can include a \"*\" which will be replaced with a random string</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    // Create a temporary file\n    tmpFile, err := os.CreateTemp(\"\", \"example-*.txt\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer os.Remove(tmpFile.Name()) // Clean up the file afterwards\n    defer tmpFile.Close()\n\n    fmt.Printf(\"Created temporary file: %s\\n\", tmpFile.Name())\n\n    // Write some data to the temporary file\n    _, err = io.WriteString(tmpFile, \"This is temporary data\\n\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Read the data back\n    _, err = tmpFile.Seek(0, 0)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    content, err := io.ReadAll(tmpFile)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"File content: %s\", string(content))\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#creating-temporary-directories","title":"Creating Temporary Directories","text":"<p>The <code>os.MkdirTemp</code> function creates a temporary directory: - Similar to <code>os.CreateTemp</code>, it takes a directory and a pattern - Returns the path to the created directory</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc main() {\n    // Create a temporary directory\n    tmpDir, err := os.MkdirTemp(\"\", \"example-dir-*\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer os.RemoveAll(tmpDir) // Clean up the directory afterwards\n\n    fmt.Printf(\"Created temporary directory: %s\\n\", tmpDir)\n\n    // Create a file inside the temporary directory\n    filePath := filepath.Join(tmpDir, \"testfile.txt\")\n    file, err := os.Create(filePath)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n\n    // Write to the file\n    _, err = file.WriteString(\"Hello, temporary directory!\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Created file: %s\\n\", filePath)\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#best-practices-for-temporary-files","title":"Best Practices for Temporary Files","text":"<ol> <li>Always clean up: Use <code>defer</code> to ensure temporary files and directories are removed</li> <li>Use meaningful patterns: Helps with debugging and identification</li> <li>Handle permissions: Be aware of security implications when using temporary files</li> <li>Consider atomic operations: For critical applications, use <code>os.Rename</code> for atomic file operations</li> </ol> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc main() {\n    // Create a temporary file with a specific pattern\n    tmpFile, err := os.CreateTemp(\"\", \"report-*.csv\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer os.Remove(tmpFile.Name())\n    defer tmpFile.Close()\n\n    // Write CSV data\n    csvData := \"Name,Age,City\\nJohn,30,New York\\nJane,25,Chicago\\n\"\n    _, err = tmpFile.WriteString(csvData)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // For final storage, we can rename the file atomically\n    finalPath := filepath.Join(os.TempDir(), \"final_report.csv\")\n    err = os.Rename(tmpFile.Name(), finalPath)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Report saved to: %s\\n\", finalPath)\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#the-embed-directive-in-go","title":"The Embed Directive in Go","text":""},{"location":"2.%20Intermediate/28.%20Directories-Addon/#introduction_1","title":"Introduction","text":"<p>The <code>embed</code> package, introduced in Go 1.16, allows programs to embed files and directories into the binary at compile time. This is useful for: - Including static assets (like HTML, CSS, images) in web applications - Bundling configuration files - Distributing a single binary without external dependencies</p>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#basic-usage","title":"Basic Usage","text":"<p>To use the embed directive: 1. Import the <code>embed</code> package 2. Declare a variable of type <code>embed.FS</code> (for a file system) or <code>string</code>, <code>[]byte</code> (for a single file) 3. Use the <code>//go:embed</code> directive to specify which files to embed</p>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#embedding-a-single-file","title":"Embedding a Single File","text":"<pre><code>package main\n\nimport (\n    _ \"embed\"\n    \"fmt\"\n)\n\n//go:embed hello.txt\nvar s string\n\nfunc main() {\n    fmt.Println(s)\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#embedding-multiple-files","title":"Embedding Multiple Files","text":"<pre><code>package main\n\nimport (\n    \"embed\"\n    \"fmt\"\n)\n\n//go:embed static/*\nvar staticFS embed.FS\n\nfunc main() {\n    // Read a file from the embedded file system\n    content, err := staticFS.ReadFile(\"static/style.css\")\n    if err != nil {\n        panic(err)\n    }\n    fmt.Printf(\"CSS content:\\n%s\\n\", string(content))\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#accessing-embedded-files","title":"Accessing Embedded Files","text":"<p>For a file system (<code>embed.FS</code>), you can use methods like: - <code>ReadFile</code>: Read the contents of a file - <code>ReadDir</code>: List directory contents - <code>Open</code>: Open a file for reading</p> <pre><code>package main\n\nimport (\n    \"embed\"\n    \"fmt\"\n    \"io/fs\"\n    \"log\"\n)\n\n//go:embed templates/*\nvar templatesFS embed.FS\n\nfunc main() {\n    // List all files in the embedded directory\n    entries, err := fs.ReadDir(templatesFS, \"templates\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(\"Embedded templates:\")\n    for _, entry := range entries {\n        fmt.Printf(\"- %s\\n\", entry.Name())\n    }\n\n    // Read a specific template\n    content, err := templatesFS.ReadFile(\"templates/home.html\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"\\nHome template content:\\n%s\\n\", string(content))\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#real-world-example-web-server-with-embedded-assets","title":"Real-World Example: Web Server with Embedded Assets","text":"<p>Let's create a web server that serves HTML, CSS, and JavaScript from embedded files:</p> <pre><code>package main\n\nimport (\n    \"embed\"\n    \"io/fs\"\n    \"log\"\n    \"net/http\"\n)\n\n//go:embed static/*\nvar staticFS embed.FS\n\nfunc main() {\n    // Create a sub FS that points to the static directory\n    static, err := fs.Sub(staticFS, \"static\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Serve static files\n    http.Handle(\"/\", http.FileServer(http.FS(static)))\n\n    log.Println(\"Server started at http://localhost:8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#advanced-embedding-patterns","title":"Advanced Embedding Patterns","text":""},{"location":"2.%20Intermediate/28.%20Directories-Addon/#embedding-multiple-specific-files","title":"Embedding Multiple Specific Files","text":"<pre><code>//go:embed config.json\n//go:embed default.yaml\n//go:embed .env.example\nvar configFiles embed.FS\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#recursive-embedding","title":"Recursive Embedding","text":"<pre><code>//go:embed assets/**/*\nvar allAssets embed.FS\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#embedding-with-variables","title":"Embedding with Variables","text":"<pre><code>//go:embed version.txt\nvar version string\n\n//go:embed banner.txt\nvar banner []byte\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#benefits-of-using-embed","title":"Benefits of Using Embed","text":"<ol> <li>Simplified deployment: Single binary without external files</li> <li>Improved portability: No need to manage file paths</li> <li>Better security: No risk of missing files or tampering</li> <li>Consistent environments: Same files across development, testing, and production</li> </ol>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#limitations-and-considerations","title":"Limitations and Considerations","text":"<ol> <li>Binary size: Increases binary size with embedded content</li> <li>Read-only: Embedded files are read-only at runtime</li> <li>No runtime modification: Cannot be modified after compilation</li> <li>Build-time only: Files are embedded at compile time, not runtime</li> </ol>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#real-world-example-application-with-temporary-files-and-embedded-resources","title":"Real-World Example: Application with Temporary Files and Embedded Resources","text":"<p>Let's create a practical example that combines both temporary files and embedded resources:</p> <pre><code>package main\n\nimport (\n    \"embed\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n    \"text/template\"\n)\n\n//go:embed templates/*\nvar templateFS embed.FS\n\n//go:embed static/*\nvar staticFS embed.FS\n\nfunc main() {\n    // Parse embedded templates\n    tmpl, err := template.ParseFS(templateFS, \"templates/*.html\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create a temporary directory for generated reports\n    tmpDir, err := os.MkdirTemp(\"\", \"report-generator-*\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer os.RemoveAll(tmpDir)\n\n    // Setup HTTP handlers\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        tmpl.ExecuteTemplate(w, \"home.html\", map[string]string{\n            \"Title\": \"Report Generator\",\n        })\n    })\n\n    http.HandleFunc(\"/generate\", func(w http.ResponseWriter, r *http.Request) {\n        // Generate a temporary report file\n        reportPath := filepath.Join(tmpDir, \"report.txt\")\n        reportFile, err := os.Create(reportPath)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        defer reportFile.Close()\n\n        // Write report content\n        _, err = io.WriteString(reportFile, \"Generated Report\\n\")\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n\n        // Read the report back\n        content, err := os.ReadFile(reportPath)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n\n        // Display the report\n        tmpl.ExecuteTemplate(w, \"report.html\", map[string]string{\n            \"Title\":   \"Generated Report\",\n            \"Content\": string(content),\n        })\n    })\n\n    // Serve static files\n    static, err := fs.Sub(staticFS, \"static\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    http.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.FS(static))))\n\n    fmt.Println(\"Server started at http://localhost:8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#how-this-example-demonstrates-both-concepts","title":"How This Example Demonstrates Both Concepts:","text":"<ol> <li>Temporary Files and Directories:</li> <li>Creates a temporary directory for report generation</li> <li>Generates temporary report files</li> <li>Ensures cleanup with <code>defer os.RemoveAll(tmpDir)</code></li> <li> <p>Uses atomic file operations for report generation</p> </li> <li> <p>Embed Directive:</p> </li> <li>Embeds HTML templates in the binary</li> <li>Embeds static assets (CSS, JS, images)</li> <li>Uses <code>template.ParseFS</code> to parse embedded templates</li> <li>Serves embedded static files via HTTP</li> </ol>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#real-world-applications","title":"Real-World Applications:","text":"<ol> <li>Web Applications:</li> <li>Single-binary deployment with all assets embedded</li> <li>Temporary file handling for uploads and processing</li> <li> <p>Template rendering with embedded HTML</p> </li> <li> <p>CLI Tools:</p> </li> <li>Embed default configuration files</li> <li>Create temporary files for processing</li> <li> <p>Generate reports in temporary locations</p> </li> <li> <p>Data Processing Pipelines:</p> </li> <li>Use temporary files for intermediate data</li> <li>Embed processing templates and configurations</li> <li>Ensure cleanup of temporary resources</li> </ol>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#best-practices","title":"Best Practices:","text":"<ol> <li>For Temporary Files:</li> <li>Always clean up with <code>defer</code></li> <li>Use meaningful patterns for identification</li> <li>Consider security implications (permissions, sensitive data)</li> <li> <p>Use atomic operations for critical file operations</p> </li> <li> <p>For Embed Directive:</p> </li> <li>Organize embedded files in logical directories</li> <li>Use patterns to include multiple files</li> <li>Consider binary size implications</li> <li>Remember embedded files are read-only</li> </ol>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#conclusion","title":"Conclusion","text":""},{"location":"2.%20Intermediate/28.%20Directories-Addon/#temporary-files-and-directories","title":"Temporary Files and Directories:","text":"<ul> <li>Essential for many applications requiring intermediate storage</li> <li>Go provides simple functions (<code>os.CreateTemp</code>, <code>os.MkdirTemp</code>) for creation</li> <li>Always clean up temporary resources to avoid disk space issues</li> <li>Consider security and atomic operations for critical applications</li> </ul>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#embed-directive","title":"Embed Directive:","text":"<ul> <li>Powerful feature for bundling assets into the binary</li> <li>Simplifies deployment and distribution</li> <li>Supports single files, multiple files, and entire directories</li> <li>Ideal for web applications, CLI tools, and configuration management</li> </ul> <p>By combining these two features, you can create robust Go applications that: - Handle temporary data securely and efficiently - Distribute as single binaries with all necessary resources - Provide consistent behavior across different environments - Simplify deployment and maintenance</p> <p>Mastering temporary file handling and the embed directive will significantly enhance your ability to create professional, self-contained Go applications.</p>"},{"location":"2.%20Intermediate/29.%20Command-Line/","title":"Command Line Arguments/Flags and Sub-Commands in Go","text":""},{"location":"2.%20Intermediate/29.%20Command-Line/#introduction-to-command-line-arguments-in-go","title":"Introduction to Command Line Arguments in Go","text":"<p>Command-line interfaces (CLIs) are essential for many applications, allowing users to interact with programs through text-based commands. Go provides robust support for handling command-line arguments and flags, enabling developers to create powerful CLI tools.</p>"},{"location":"2.%20Intermediate/29.%20Command-Line/#basic-command-line-arguments","title":"Basic Command Line Arguments","text":"<p>The simplest way to access command-line arguments in Go is through the <code>os.Args</code> slice, which contains all arguments passed to the program:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // os.Args[0] is the program name\n    // os.Args[1:] are the actual arguments\n    if len(os.Args) &lt; 2 {\n        fmt.Println(\"Please provide at least one argument\")\n        os.Exit(1)\n    }\n\n    fmt.Println(\"Program name:\", os.Args[0])\n    fmt.Println(\"Arguments:\")\n    for i, arg := range os.Args[1:] {\n        fmt.Printf(\"  %d: %s\\n\", i+1, arg)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/29.%20Command-Line/#the-flag-package","title":"The flag Package","text":"<p>Go's standard <code>flag</code> package provides a more structured way to parse command-line options (flags). It supports various data types and automatically generates help messages.</p>"},{"location":"2.%20Intermediate/29.%20Command-Line/#basic-flag-usage","title":"Basic Flag Usage","text":"<pre><code>package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n)\n\nfunc main() {\n    // Define flags\n    name := flag.String(\"name\", \"World\", \"Name to greet\")\n    age := flag.Int(\"age\", 0, \"Your age\")\n    verbose := flag.Bool(\"verbose\", false, \"Enable verbose output\")\n\n    // Parse the command-line flags\n    flag.Parse()\n\n    // Use the flag values\n    if *verbose {\n        fmt.Println(\"Running in verbose mode\")\n    }\n\n    fmt.Printf(\"Hello, %s!\\n\", *name)\n    if *age &gt; 0 {\n        fmt.Printf(\"You are %d years old.\\n\", *age)\n    }\n\n    // Access non-flag arguments\n    args := flag.Args()\n    if len(args) &gt; 0 {\n        fmt.Println(\"Additional arguments:\")\n        for i, arg := range args {\n            fmt.Printf(\"  %d: %s\\n\", i, arg)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/29.%20Command-Line/#flag-types-and-functions","title":"Flag Types and Functions","text":"<p>The <code>flag</code> package provides functions for different data types:</p> Function Description Example <code>flag.String()</code> String flag <code>name := flag.String(\"name\", \"default\", \"help\")</code> <code>flag.Int()</code> Integer flag <code>port := flag.Int(\"port\", 8080, \"Port number\")</code> <code>flag.Bool()</code> Boolean flag <code>debug := flag.Bool(\"debug\", false, \"Debug mode\")</code> <code>flag.Float64()</code> Float flag <code>threshold := flag.Float64(\"threshold\", 0.5, \"Threshold value\")</code> <code>flag.Duration()</code> Duration flag <code>timeout := flag.Duration(\"timeout\", 30*time.Second, \"Timeout duration\")</code>"},{"location":"2.%20Intermediate/29.%20Command-Line/#custom-flag-types","title":"Custom Flag Types","text":"<p>You can also define custom flag types by implementing the <code>flag.Value</code> interface:</p> <pre><code>package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"strings\"\n)\n\n// Custom type for a list of strings\ntype stringList []string\n\nfunc (s *stringList) String() string {\n    return fmt.Sprintf(\"%v\", *s)\n}\n\nfunc (s *stringList) Set(value string) error {\n    *s = strings.Split(value, \",\")\n    return nil\n}\n\nfunc main() {\n    var languages stringList\n    flag.Var(&amp;languages, \"lang\", \"Comma-separated list of languages\")\n    flag.Parse()\n\n    fmt.Println(\"Languages:\", languages)\n}\n</code></pre>"},{"location":"2.%20Intermediate/29.%20Command-Line/#command-line-sub-commands","title":"Command Line Sub-Commands","text":"<p>Sub-commands allow you to create CLI tools with multiple actions, similar to <code>git</code> (with commands like <code>commit</code>, <code>push</code>, etc.) or <code>docker</code> (with commands like <code>run</code>, <code>build</code>, etc.).</p>"},{"location":"2.%20Intermediate/29.%20Command-Line/#implementing-sub-commands-with-the-flag-package","title":"Implementing Sub-Commands with the flag Package","text":"<p>While the standard <code>flag</code> package doesn't have built-in support for sub-commands, you can implement them manually:</p> <pre><code>package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Check if we have at least one sub-command\n    if len(os.Args) &lt; 2 {\n        fmt.Println(\"Usage: myapp &lt;command&gt; [options]\")\n        os.Exit(1)\n    }\n\n    // Extract the sub-command\n    cmd := os.Args[1]\n\n    // Create a new flag set for each sub-command\n    switch cmd {\n    case \"greet\":\n        greetCmd := flag.NewFlagSet(\"greet\", flag.ExitOnError)\n        name := greetCmd.String(\"name\", \"World\", \"Name to greet\")\n        formal := greetCmd.Bool(\"formal\", false, \"Use formal greeting\")\n\n        // Parse the flags for this sub-command\n        greetCmd.Parse(os.Args[2:])\n\n        // Execute the sub-command\n        if *formal {\n            fmt.Printf(\"Good day, %s.\\n\", *name)\n        } else {\n            fmt.Printf(\"Hello, %s!\\n\", *name)\n        }\n\n    case \"calculate\":\n        calcCmd := flag.NewFlagSet(\"calculate\", flag.ExitOnError)\n        operation := calcCmd.String(\"op\", \"add\", \"Operation to perform (add, subtract, multiply, divide)\")\n        x := calcCmd.Float64(\"x\", 0, \"First operand\")\n        y := calcCmd.Float64(\"y\", 0, \"Second operand\")\n\n        // Parse the flags for this sub-command\n        calcCmd.Parse(os.Args[2:])\n\n        // Execute the sub-command\n        var result float64\n        switch *operation {\n        case \"add\":\n            result = *x + *y\n        case \"subtract\":\n            result = *x - *y\n        case \"multiply\":\n            result = *x * *y\n        case \"divide\":\n            if *y == 0 {\n                fmt.Println(\"Error: Division by zero\")\n                os.Exit(1)\n            }\n            result = *x / *y\n        default:\n            fmt.Printf(\"Unknown operation: %s\\n\", *operation)\n            os.Exit(1)\n        }\n\n        fmt.Printf(\"Result: %f\\n\", result)\n\n    default:\n        fmt.Printf(\"Unknown command: %s\\n\", cmd)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/29.%20Command-Line/#using-third-party-libraries-for-sub-commands","title":"Using Third-Party Libraries for Sub-Commands","text":"<p>While the manual approach works, it can become cumbersome for complex applications. Third-party libraries like <code>cobra</code> and <code>urfave/cli</code> provide more powerful features for building CLI applications.</p>"},{"location":"2.%20Intermediate/29.%20Command-Line/#introduction-to-cobra","title":"Introduction to Cobra","text":"<p>Cobra is a popular library for building powerful CLI applications in Go. It's used by many well-known projects including Kubernetes, Hugo, and Docker.</p> <p>First, install Cobra: <pre><code>go get -u github.com/spf13/cobra@latest\n</code></pre></p>"},{"location":"2.%20Intermediate/29.%20Command-Line/#basic-cobra-example","title":"Basic Cobra Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/spf13/cobra\"\n)\n\nfunc main() {\n    var rootCmd = &amp;cobra.Command{\n        Use:   \"myapp\",\n        Short: \"My application does amazing things\",\n        Long:  `My application is a powerful CLI tool that demonstrates Cobra's capabilities.`,\n    }\n\n    var greetCmd = &amp;cobra.Command{\n        Use:   \"greet\",\n        Short: \"Greets someone\",\n        Run: func(cmd *cobra.Command, args []string) {\n            name, _ := cmd.Flags().GetString(\"name\")\n            formal, _ := cmd.Flags().GetBool(\"formal\")\n\n            if formal {\n                fmt.Printf(\"Good day, %s.\\n\", name)\n            } else {\n                fmt.Printf(\"Hello, %s!\\n\", name)\n            }\n        },\n    }\n\n    greetCmd.Flags().StringP(\"name\", \"n\", \"World\", \"Name to greet\")\n    greetCmd.Flags().BoolP(\"formal\", \"f\", false, \"Use formal greeting\")\n\n    var calculateCmd = &amp;cobra.Command{\n        Use:   \"calculate\",\n        Short: \"Performs a calculation\",\n        Run: func(cmd *cobra.Command, args []string) {\n            operation, _ := cmd.Flags().GetString(\"operation\")\n            x, _ := cmd.Flags().GetFloat64(\"x\")\n            y, _ := cmd.Flags().GetFloat64(\"y\")\n\n            var result float64\n            switch operation {\n            case \"add\":\n                result = x + y\n            case \"subtract\":\n                result = x - y\n            case \"multiply\":\n                result = x * y\n            case \"divide\":\n                if y == 0 {\n                    fmt.Println(\"Error: Division by zero\")\n                    return\n                }\n                result = x / y\n            default:\n                fmt.Printf(\"Unknown operation: %s\\n\", operation)\n                return\n            }\n\n            fmt.Printf(\"Result: %f\\n\", result)\n        },\n    }\n\n    calculateCmd.Flags().StringP(\"operation\", \"o\", \"add\", \"Operation to perform\")\n    calculateCmd.Flags().Float64P(\"x\", \"x\", 0, \"First operand\")\n    calculateCmd.Flags().Float64P(\"y\", \"y\", 0, \"Second operand\")\n\n    rootCmd.AddCommand(greetCmd, calculateCmd)\n\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/29.%20Command-Line/#advanced-cobra-features","title":"Advanced Cobra Features","text":"<p>Cobra provides many advanced features:</p> <ol> <li> <p>Automatic Help Generation:    <pre><code>var helpCmd = &amp;cobra.Command{\n    Use:   \"help [command]\",\n    Short: \"Help about any command\",\n    Long: `Help provides help for any command in the application.\nSimply type ` + \"`myapp help [command]`\" + ` for full details.`,\n\n    Run: func(cmd *cobra.Command, args []string) {\n        // Cobra automatically handles help\n    },\n}\n</code></pre></p> </li> <li> <p>Validation of Arguments:    <pre><code>var cmd = &amp;cobra.Command{\n    Use:   \"create [name]\",\n    Short: \"Create a resource\",\n    Args:  cobra.ExactArgs(1),\n    Run: func(cmd *cobra.Command, args []string) {\n        name := args[0]\n        fmt.Printf(\"Creating resource: %s\\n\", name)\n    },\n}\n</code></pre></p> </li> <li> <p>Persistent Flags:    <pre><code>var verbose bool\n\nfunc init() {\n    rootCmd.PersistentFlags().BoolVarP(&amp;verbose, \"verbose\", \"v\", false, \"verbose output\")\n}\n</code></pre></p> </li> <li> <p>Pre-run and Post-run Hooks:    <pre><code>var cmd = &amp;cobra.Command{\n    Use:   \"example\",\n    Short: \"An example command\",\n    PreRun: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"Pre-run hook\")\n    },\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"Running command\")\n    },\n    PostRun: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"Post-run hook\")\n    },\n}\n</code></pre></p> </li> </ol>"},{"location":"2.%20Intermediate/29.%20Command-Line/#real-world-example-a-complete-cli-application","title":"Real-World Example: A Complete CLI Application","text":"<p>Let's create a more realistic example: a file management tool with multiple sub-commands.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n\n    \"github.com/spf13/cobra\"\n)\n\nvar rootCmd = &amp;cobra.Command{\n    Use:   \"filemanager\",\n    Short: \"A simple file management tool\",\n    Long:  `Filemanager is a CLI tool for basic file operations like copying, moving, and searching.`,\n}\n\nvar copyCmd = &amp;cobra.Command{\n    Use:   \"copy [source] [destination]\",\n    Short: \"Copy a file from source to destination\",\n    Args:  cobra.ExactArgs(2),\n    Run: func(cmd *cobra.Command, args []string) {\n        source := args[0]\n        destination := args[1]\n\n        // Open source file\n        srcFile, err := os.Open(source)\n        if err != nil {\n            fmt.Printf(\"Error opening source file: %v\\n\", err)\n            return\n        }\n        defer srcFile.Close()\n\n        // Create destination file\n        destFile, err := os.Create(destination)\n        if err != nil {\n            fmt.Printf(\"Error creating destination file: %v\\n\", err)\n            return\n        }\n        defer destFile.Close()\n\n        // Copy file contents\n        _, err = io.Copy(destFile, srcFile)\n        if err != nil {\n            fmt.Printf(\"Error copying file: %v\\n\", err)\n            return\n        }\n\n        fmt.Printf(\"File copied from %s to %s\\n\", source, destination)\n    },\n}\n\nvar moveCmd = &amp;cobra.Command{\n    Use:   \"move [source] [destination]\",\n    Short: \"Move a file from source to destination\",\n    Args:  cobra.ExactArgs(2),\n    Run: func(cmd *cobra.Command, args []string) {\n        source := args[0]\n        destination := args[1]\n\n        err := os.Rename(source, destination)\n        if err != nil {\n            fmt.Printf(\"Error moving file: %v\\n\", err)\n            return\n        }\n\n        fmt.Printf(\"File moved from %s to %s\\n\", source, destination)\n    },\n}\n\nvar searchCmd = &amp;cobra.Command{\n    Use:   \"search [pattern] [directory]\",\n    Short: \"Search for files matching a pattern in a directory\",\n    Args:  cobra.ExactArgs(2),\n    Run: func(cmd *cobra.Command, args []string) {\n        pattern := args[0]\n        directory := args[1]\n\n        recursive, _ := cmd.Flags().GetBool(\"recursive\")\n\n        err := filepath.Walk(directory, func(path string, info os.FileInfo, err error) error {\n            if err != nil {\n                return err\n            }\n\n            // Skip directories if not recursive\n            if info.IsDir() &amp;&amp; path != directory &amp;&amp; !recursive {\n                return filepath.SkipDir\n            }\n\n            // Check if the filename matches the pattern\n            matched, err := filepath.Match(pattern, info.Name())\n            if err != nil {\n                return err\n            }\n\n            if matched {\n                relPath, err := filepath.Rel(directory, path)\n                if err != nil {\n                    return err\n                }\n                fmt.Println(relPath)\n            }\n\n            return nil\n        })\n\n        if err != nil {\n            fmt.Printf(\"Error searching directory: %v\\n\", err)\n        }\n    },\n}\n\nvar listCmd = &amp;cobra.Command{\n    Use:   \"list [directory]\",\n    Short: \"List files in a directory\",\n    Args:  cobra.MaximumNArgs(1),\n    Run: func(cmd *cobra.Command, args []string) {\n        directory := \".\"\n        if len(args) &gt; 0 {\n            directory = args[0]\n        }\n\n        showHidden, _ := cmd.Flags().GetBool(\"all\")\n        longFormat, _ := cmd.Flags().GetBool(\"long\")\n\n        files, err := os.ReadDir(directory)\n        if err != nil {\n            fmt.Printf(\"Error reading directory: %v\\n\", err)\n            return\n        }\n\n        for _, file := range files {\n            // Skip hidden files unless -a is specified\n            if !showHidden &amp;&amp; strings.HasPrefix(file.Name(), \".\") {\n                continue\n            }\n\n            if longFormat {\n                info, err := file.Info()\n                if err != nil {\n                    fmt.Printf(\"Error getting file info: %v\\n\", err)\n                    continue\n                }\n\n                size := info.Size()\n                mode := info.Mode()\n                fmt.Printf(\"%-10s %8d %s\\n\", mode, size, file.Name())\n            } else {\n                fmt.Println(file.Name())\n            }\n        }\n    },\n}\n\nfunc init() {\n    searchCmd.Flags().BoolP(\"recursive\", \"r\", false, \"Search recursively\")\n    listCmd.Flags().BoolP(\"all\", \"a\", false, \"Show hidden files\")\n    listCmd.Flags().BoolP(\"long\", \"l\", false, \"Use long listing format\")\n\n    rootCmd.AddCommand(copyCmd, moveCmd, searchCmd, listCmd)\n}\n\nfunc main() {\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/29.%20Command-Line/#how-this-example-demonstrates-cli-concepts","title":"How This Example Demonstrates CLI Concepts:","text":"<ol> <li>Multiple Sub-Commands:</li> <li><code>copy</code>: Copies files from source to destination</li> <li><code>move</code>: Moves/renames files</li> <li><code>search</code>: Searches for files matching a pattern</li> <li> <p><code>list</code>: Lists files in a directory</p> </li> <li> <p>Flag Handling:</p> </li> <li>Boolean flags for options like <code>recursive</code>, <code>all</code>, and <code>long</code></li> <li> <p>Proper flag parsing for each sub-command</p> </li> <li> <p>Argument Validation:</p> </li> <li>Using <code>cobra.ExactArgs</code> to ensure the correct number of arguments</li> <li> <p>Using <code>cobra.MaximumNArgs</code> for optional arguments</p> </li> <li> <p>Error Handling:</p> </li> <li>Proper error messages for file operations</li> <li> <p>Graceful handling of missing files or directories</p> </li> <li> <p>File Operations:</p> </li> <li>Demonstrates real file operations like copying, moving, and listing</li> <li>Shows how to walk directory trees recursively</li> </ol>"},{"location":"2.%20Intermediate/29.%20Command-Line/#best-practices-for-cli-applications","title":"Best Practices for CLI Applications","text":"<ol> <li>Consistent Interface:</li> <li>Follow common conventions (like <code>--help</code> for help)</li> <li> <p>Use similar flag names across commands (e.g., <code>--verbose</code> or <code>-v</code>)</p> </li> <li> <p>Clear Help Messages:</p> </li> <li>Provide concise and helpful descriptions for commands and flags</li> <li> <p>Include examples in help text when appropriate</p> </li> <li> <p>Argument Validation:</p> </li> <li>Validate the number and type of arguments</li> <li> <p>Provide clear error messages for invalid input</p> </li> <li> <p>Error Handling:</p> </li> <li>Return appropriate exit codes (0 for success, non-zero for errors)</li> <li> <p>Provide meaningful error messages</p> </li> <li> <p>Testing:</p> </li> <li>Write tests for your CLI commands</li> <li>Test both successful execution and error conditions</li> </ol>"},{"location":"2.%20Intermediate/29.%20Command-Line/#conclusion","title":"Conclusion","text":""},{"location":"2.%20Intermediate/29.%20Command-Line/#command-line-arguments-and-flags","title":"Command Line Arguments and Flags:","text":"<ul> <li>Go's <code>flag</code> package provides a simple way to handle command-line flags</li> <li>Supports various data types and custom flag types</li> <li>Automatically generates help messages</li> </ul>"},{"location":"2.%20Intermediate/29.%20Command-Line/#sub-commands","title":"Sub-Commands:","text":"<ul> <li>Can be implemented manually with <code>flag.NewFlagSet</code></li> <li>Third-party libraries like Cobra provide more powerful features</li> <li>Enable complex CLI applications with multiple actions</li> </ul>"},{"location":"2.%20Intermediate/29.%20Command-Line/#choosing-the-right-approach","title":"Choosing the Right Approach:","text":"<ul> <li>For simple applications, the standard <code>flag</code> package may be sufficient</li> <li>For complex applications with multiple sub-commands, consider using Cobra</li> <li>Cobra provides features like automatic help generation, argument validation, and more</li> </ul> <p>By mastering command-line argument parsing and sub-commands in Go, you can create powerful, user-friendly CLI tools that integrate well into command-line workflows. Whether you're building simple utilities or complex applications, Go provides the tools you need to create professional CLI interfaces.</p>"},{"location":"2.%20Intermediate/3.%20Pointers/","title":"Go Pointers: Memory Addresses and References","text":"<p>Overview</p> <p>Master Go pointers - variables that store memory addresses rather than values. Learn how to use pointers for efficient memory management, data sharing, and building complex data structures while maintaining Go's safety guarantees.</p> <p>Key Points</p> <ul> <li>Pointers store memory addresses, not values</li> <li>Use <code>&amp;</code> to get an address, <code>*</code> to dereference</li> <li>Safer than C/C++ pointers with automatic memory management</li> <li>Essential for efficient data sharing and modification</li> <li>Zero value of a pointer is <code>nil</code></li> </ul>"},{"location":"2.%20Intermediate/3.%20Pointers/#understanding-pointers","title":"Understanding Pointers","text":"<p>A pointer is a variable that stores the memory address of another variable, providing indirect access to that variable's value.</p> <p>Pointer Concepts</p> <pre><code>graph LR\n    A[Variable] --&gt; B[Memory Address]\n    C[Pointer] --&gt; B\n    B --&gt; D[Stored Value]\n    A --&gt; D\n    C --&gt; E[Indirect Access]\n    E --&gt; D\n    style A fill:#999,stroke:#333,stroke-width:2px,color:#000\n    style C fill:#999,stroke:#333,stroke-width:2px,color:#000</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#memory-layout","title":"Memory Layout","text":"<p>Every variable in Go is stored at a specific memory location.</p> <p>Basic Pointer Operations</p> Address and DereferencePointer DeclarationNil Pointer Safety basic_pointers.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 42\n    p := &amp;x // p holds the address of x\n\n    fmt.Printf(\"Value of x: %d\\n\", x)        // 42\n    fmt.Printf(\"Address of x: %p\\n\", &amp;x)     // 0x...\n    fmt.Printf(\"Value of p: %p\\n\", p)       // 0x... (same as &amp;x)\n    fmt.Printf(\"Value at p: %d\\n\", *p)      // 42 (dereference)\n\n    *p = 21 // Modify x through pointer\n    fmt.Printf(\"New value of x: %d\\n\", x)   // 21\n}\n</code></pre> pointer_declaration.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var p *int      // Pointer to int (nil initially)\n    var q *string   // Pointer to string (nil initially)\n\n    fmt.Printf(\"p: %v\\n\", p) // &lt;nil&gt;\n    fmt.Printf(\"q: %v\\n\", q) // &lt;nil&gt;\n\n    x := 100\n    p = &amp;x // Assign address of x to p\n\n    fmt.Printf(\"p now points to: %d\\n\", *p) // 100\n}\n</code></pre> nil_safety.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var p *int\n\n    // Check for nil before dereferencing\n    if p != nil {\n        fmt.Println(*p)\n    } else {\n        fmt.Println(\"Pointer is nil\")\n    }\n\n    // Safe assignment\n    x := 42\n    p = &amp;x\n\n    if p != nil {\n        fmt.Printf(\"Value: %d\\n\", *p) // 42\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#pointer-operations","title":"Pointer Operations","text":""},{"location":"2.%20Intermediate/3.%20Pointers/#creating-and-using-pointers","title":"Creating and Using Pointers","text":"<p>Pointers provide multiple ways to work with memory addresses.</p> <p>Pointer Patterns</p> Direct AssignmentNew FunctionPointer Arithmetic (Not Allowed) direct_assignment.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Go Programming\"\n    ptr := &amp;name // Get address of name\n\n    fmt.Printf(\"Original: %s\\n\", name)     // Go Programming\n    fmt.Printf(\"Via pointer: %s\\n\", *ptr)  // Go Programming\n\n    *ptr = \"Go Language\" // Modify through pointer\n    fmt.Printf(\"Modified: %s\\n\", name)     // Go Language\n}\n</code></pre> new_function.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    p := new(int) // Allocates memory, returns pointer\n\n    fmt.Printf(\"Initial value: %d\\n\", *p) // 0 (zero value)\n\n    *p = 100\n    fmt.Printf(\"New value: %d\\n\", *p)     // 100\n}\n</code></pre> no_arithmetic.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    arr := [3]int{10, 20, 30}\n    p := &amp;arr[0]\n\n    fmt.Printf(\"First element: %d\\n\", *p) // 10\n\n    // This would cause a compile error in Go:\n    // p++ // Pointer arithmetic not allowed\n    // p = p + 1 // Not allowed\n\n    // Use slices or array indexing instead\n    fmt.Printf(\"Second element: %d\\n\", arr[1]) // 20\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#complete-example","title":"Complete Example","text":"<pre><code>func main() {\n    x := 100\n    p := &amp;x\n\n    fmt.Println(\"Value of x:\", x)       // 100\n    fmt.Println(\"Address of x:\", &amp;x)   // e.g., 0x1040a124\n    fmt.Println(\"Value of p:\", p)       // Same as &amp;x\n    fmt.Println(\"Value at p:\", *p)      // 100\n\n    *p = 200\n    fmt.Println(\"New value of x:\", x)  // 200\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#pointers-vs-values-when-to-use-each","title":"Pointers vs. Values: When to Use Each","text":""},{"location":"2.%20Intermediate/3.%20Pointers/#using-values","title":"Using Values","text":"<pre><code>type Person struct {\n    Name string\n    Age  int\n}\n\nfunc birthday(p Person) {\n    p.Age++ // Only modifies the copy\n}\n\nfunc main() {\n    alice := Person{\"Alice\", 30}\n    birthday(alice)\n    fmt.Println(alice.Age) // Still 30 (original unchanged)\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#using-pointers","title":"Using Pointers","text":"<pre><code>func birthday(p *Person) {\n    p.Age++ // Modifies the original\n}\n\nfunc main() {\n    alice := Person{\"Alice\", 30}\n    birthday(&amp;alice)\n    fmt.Println(alice.Age) // 31 (original modified)\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#key-differences","title":"Key Differences","text":"Aspect Values Pointers Copy Behavior Creates complete copy Copies only memory address Memory Usage Higher for large structs Constant (8 bytes on 64-bit systems) Mutability Original unchanged Can modify original data Nil Safety Always valid Can be nil (requires checks) Performance Slower for large data Faster for large data"},{"location":"2.%20Intermediate/3.%20Pointers/#pointer-safety-in-go","title":"Pointer Safety in Go","text":"<p>Go provides several safety features not found in languages like C:</p>"},{"location":"2.%20Intermediate/3.%20Pointers/#1-no-pointer-arithmetic","title":"1. No Pointer Arithmetic","text":"<p>Go doesn't allow pointer arithmetic, preventing dangerous memory operations: <pre><code>// INVALID in Go:\np := &amp;x\np++ // Compiler error: cannot increment pointer\n</code></pre></p>"},{"location":"2.%20Intermediate/3.%20Pointers/#2-garbage-collection","title":"2. Garbage Collection","text":"<p>Go's garbage collector automatically manages memory: - No need to manually free memory - Prevents memory leaks and dangling pointers - Safe pointer use without manual memory management</p>"},{"location":"2.%20Intermediate/3.%20Pointers/#3-type-safety","title":"3. Type Safety","text":"<p>Pointers are strongly typed: <pre><code>var p *int\nvar s *string\np = s // Compiler error: type mismatch\n</code></pre></p>"},{"location":"2.%20Intermediate/3.%20Pointers/#common-pointer-patterns-in-go","title":"Common Pointer Patterns in Go","text":""},{"location":"2.%20Intermediate/3.%20Pointers/#1-modifying-function-parameters","title":"1. Modifying Function Parameters","text":"<pre><code>func setToZero(p *int) {\n    *p = 0\n}\n\nfunc main() {\n    x := 42\n    setToZero(&amp;x)\n    fmt.Println(x) // 0\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#2-pointer-receivers-for-methods","title":"2. Pointer Receivers for Methods","text":"<pre><code>type Counter struct {\n    count int\n}\n\nfunc (c *Counter) Increment() {\n    c.count++\n}\n\nfunc main() {\n    c := Counter{count: 0}\n    c.Increment()\n    fmt.Println(c.count) // 1\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#3-returning-pointers-from-functions","title":"3. Returning Pointers from Functions","text":"<pre><code>func createInt(value int) *int {\n    return &amp;value // Safe: Go escapes value to heap\n}\n\nfunc main() {\n    p := createInt(42)\n    fmt.Println(*p) // 42\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#4-pointers-to-structs","title":"4. Pointers to Structs","text":"<pre><code>type User struct {\n    Name string\n    Email string\n}\n\nfunc newUser(name, email string) *User {\n    return &amp;User{Name: name, Email: email}\n}\n\nfunc main() {\n    u := newUser(\"Alice\", \"alice@example.com\")\n    fmt.Println((*u).Name) // Alice\n    fmt.Println(u.Name)    // Alice (automatic dereferencing)\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#working-with-nil-pointers","title":"Working with Nil Pointers","text":"<p>A pointer that doesn't point to anything has the value <code>nil</code>:</p> <pre><code>var p *int\nfmt.Println(p == nil) // true\n\n// Dereferencing a nil pointer causes a panic:\nfmt.Println(*p) // Panic: runtime error: invalid memory address\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#safe-dereferencing","title":"Safe Dereferencing","text":"<p>Always check for nil before dereferencing: <pre><code>func safePrint(p *int) {\n    if p != nil {\n        fmt.Println(*p)\n    } else {\n        fmt.Println(\"Pointer is nil\")\n    }\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/3.%20Pointers/#pointers-and-interfaces","title":"Pointers and Interfaces","text":"<p>Interfaces can hold pointers: <pre><code>type Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype MyWriter struct{}\n\nfunc (w *MyWriter) Write(data []byte) (int, error) {\n    fmt.Println(string(data))\n    return len(data), nil\n}\n\nfunc main() {\n    var w Writer = &amp;MyWriter{} // Interface holds pointer\n    w.Write([]byte(\"Hello\"))\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/3.%20Pointers/#common-pitfalls-and-best-practices","title":"Common Pitfalls and Best Practices","text":""},{"location":"2.%20Intermediate/3.%20Pointers/#1-unnecessary-pointers","title":"1. Unnecessary Pointers","text":"<p>Avoid pointers for small, immutable values: <pre><code>// Bad: Unnecessary pointer for small value\nfunc isAdult(age *int) bool {\n    return *age &gt;= 18\n}\n\n// Good: Use value directly\nfunc isAdult(age int) bool {\n    return age &gt;= 18\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/3.%20Pointers/#2-confusing-pointers-and-values","title":"2. Confusing Pointers and Values","text":"<p>Remember that methods with value receivers can't modify the original: <pre><code>type Value struct {\n    x int\n}\n\nfunc (v Value) Set(val int) {\n    v.x = val // Only modifies the copy\n}\n\nfunc main() {\n    v := Value{x: 10}\n    v.Set(20)\n    fmt.Println(v.x) // Still 10\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/3.%20Pointers/#3-returning-pointers-to-local-variables","title":"3. Returning Pointers to Local Variables","text":"<p>Go handles this safely by escaping to the heap, but be mindful: <pre><code>func getInt() *int {\n    x := 42\n    return &amp;x // Safe: Go allocates x on heap\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/3.%20Pointers/#4-pointer-maps-and-slices","title":"4. Pointer Maps and Slices","text":"<p>Maps and slices are reference types, but you might still need pointers: <pre><code>// Modifying slice elements\nfunc modifySlice(s []int) {\n    s[0] = 100 // Modifies original slice\n}\n\n// Modifying slice itself (e.g., resizing)\nfunc modifySlicePointer(s *[]int) {\n    *s = append(*s, 200) // Modifies original slice header\n}\n</code></pre></p>"},{"location":"2.%20Intermediate/3.%20Pointers/#real-world-example-linked-list-implementation","title":"Real-World Example: Linked List Implementation","text":"<p>A practical application of pointers is implementing a linked list, which is impossible without pointers in Go.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// Node represents a single element in the linked list\ntype Node struct {\n    Value int\n    Next  *Node\n}\n\n// LinkedList represents the linked list structure\ntype LinkedList struct {\n    Head *Node\n    Length int\n}\n\n// Append adds a new node to the end of the list\nfunc (ll *LinkedList) Append(value int) {\n    newNode := &amp;Node{Value: value}\n\n    if ll.Head == nil {\n        ll.Head = newNode\n    } else {\n        current := ll.Head\n        for current.Next != nil {\n            current = current.Next\n        }\n        current.Next = newNode\n    }\n    ll.Length++\n}\n\n// Prepend adds a new node to the beginning of the list\nfunc (ll *LinkedList) Prepend(value int) {\n    newNode := &amp;Node{Value: value, Next: ll.Head}\n    ll.Head = newNode\n    ll.Length++\n}\n\n// Delete removes a node with the given value\nfunc (ll *LinkedList) Delete(value int) {\n    if ll.Head == nil {\n        return\n    }\n\n    // Special case: deleting the head\n    if ll.Head.Value == value {\n        ll.Head = ll.Head.Next\n        ll.Length--\n        return\n    }\n\n    current := ll.Head\n    for current.Next != nil {\n        if current.Next.Value == value {\n            current.Next = current.Next.Next\n            ll.Length--\n            return\n        }\n        current = current.Next\n    }\n}\n\n// Find searches for a value and returns its node\nfunc (ll *LinkedList) Find(value int) *Node {\n    current := ll.Head\n    for current != nil {\n        if current.Value == value {\n            return current\n        }\n        current = current.Next\n    }\n    return nil\n}\n\n// Display prints all values in the list\nfunc (ll *LinkedList) Display() {\n    current := ll.Head\n    for current != nil {\n        fmt.Printf(\"%d -&gt; \", current.Value)\n        current = current.Next\n    }\n    fmt.Println(\"nil\")\n}\n\n// Reverse reverses the linked list in place\nfunc (ll *LinkedList) Reverse() {\n    var prev *Node\n    current := ll.Head\n    var next *Node\n\n    for current != nil {\n        next = current.Next   // Store next node\n        current.Next = prev   // Reverse current node's pointer\n        prev = current        // Move prev one step forward\n        current = next        // Move current one step forward\n    }\n    ll.Head = prev\n}\n\nfunc main() {\n    // Create a new linked list\n    ll := &amp;LinkedList{}\n\n    // Append elements\n    ll.Append(10)\n    ll.Append(20)\n    ll.Append(30)\n    fmt.Println(\"After appending:\")\n    ll.Display() // 10 -&gt; 20 -&gt; 30 -&gt; nil\n\n    // Prepend an element\n    ll.Prepend(5)\n    fmt.Println(\"\\nAfter prepending:\")\n    ll.Display() // 5 -&gt; 10 -&gt; 20 -&gt; 30 -&gt; nil\n\n    // Find an element\n    found := ll.Find(20)\n    if found != nil {\n        fmt.Println(\"\\nFound node with value:\", found.Value)\n    }\n\n    // Delete an element\n    ll.Delete(20)\n    fmt.Println(\"\\nAfter deleting 20:\")\n    ll.Display() // 5 -&gt; 10 -&gt; 30 -&gt; nil\n\n    // Reverse the list\n    ll.Reverse()\n    fmt.Println(\"\\nAfter reversing:\")\n    ll.Display() // 30 -&gt; 10 -&gt; 5 -&gt; nil\n\n    fmt.Println(\"\\nList length:\", ll.Length)\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#how-this-implementation-uses-pointers","title":"How This Implementation Uses Pointers:","text":"<ol> <li>Node Structure:</li> <li><code>Next *Node</code> is a pointer to the next node in the sequence</li> <li> <p>This creates the chain that defines the linked list</p> </li> <li> <p>LinkedList Structure:</p> </li> <li><code>Head *Node</code> points to the first node in the list</li> <li> <p>Without this pointer, we couldn't access the list</p> </li> <li> <p>Method Implementations:</p> </li> <li>All methods use pointer receivers (<code>*LinkedList</code>) to modify the original list</li> <li>Traversal relies on following pointers from one node to the next</li> <li> <p>Insertions and deletions manipulate pointers to restructure the list</p> </li> <li> <p>Key Pointer Operations:</p> </li> <li><code>current.Next</code> accesses the next node via pointer</li> <li><code>current.Next = newNode</code> changes which node comes next</li> <li><code>prev = current</code> moves pointer references during reversal</li> </ol>"},{"location":"2.%20Intermediate/3.%20Pointers/#real-world-applications-of-linked-lists","title":"Real-World Applications of Linked Lists:","text":"<ol> <li>Implementation of Other Data Structures:</li> <li>Stacks and queues can be built using linked lists</li> <li> <p>Graph adjacency lists often use linked structures</p> </li> <li> <p>Memory Management:</p> </li> <li>Used in memory allocators to track free blocks</li> <li> <p>Garbage collectors use similar pointer structures</p> </li> <li> <p>Dynamic Data Storage:</p> </li> <li>When you need frequent insertions/deletions at arbitrary positions</li> <li> <p>When the size is unknown or changes frequently</p> </li> <li> <p>File Systems:</p> </li> <li>Some file systems use linked lists for free space management</li> <li> <p>Directory structures can be represented as linked lists</p> </li> <li> <p>Web Browser History:</p> </li> <li>Forward/backward navigation can be implemented with a doubly linked list</li> </ol>"},{"location":"2.%20Intermediate/3.%20Pointers/#benefits-of-this-pointer-based-approach","title":"Benefits of This Pointer-Based Approach:","text":"<ol> <li>Dynamic Sizing:</li> <li>Can grow or shrink without reallocating entire structure</li> <li> <p>No wasted space from overallocation</p> </li> <li> <p>Efficient Insertions/Deletions:</p> </li> <li>O(1) time for operations at known positions</li> <li> <p>No need to shift elements like in arrays</p> </li> <li> <p>Memory Efficiency:</p> </li> <li>Only allocates memory for actual elements</li> <li> <p>No preallocation needed</p> </li> <li> <p>Flexibility:</p> </li> <li>Easy to implement complex operations like reversal</li> <li>Can be extended to doubly linked lists or circular lists</li> </ol>"},{"location":"2.%20Intermediate/3.%20Pointers/#conclusion","title":"Conclusion","text":"<p>Pointers are a powerful feature in Go that enable: - Efficient memory usage by avoiding copying large data structures - Shared state across different parts of your program - Implementation of complex data structures like linked lists, trees, and graphs - Fine-grained control over mutability</p> <p>Key takeaways: 1. Use pointers when you need to modify the original data 2. Prefer values for small, immutable data 3. Always check for nil before dereferencing 4. Remember that Go provides safety features not found in C/C++ 5. Understand that methods with pointer receivers can modify the original value</p> <p>The linked list example demonstrates how pointers enable the creation of dynamic data structures that are fundamental to computer science. Mastering pointers is essential for writing efficient, idiomatic Go code, especially when working with complex algorithms or performance-critical applications.</p> <p>By understanding pointers, you gain deeper insight into how Go manages memory and how to write more efficient programs. They are a cornerstone of systems programming and a key differentiator between high-level and low-level programming languages.</p>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/","title":"Environment Variables in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/30.%20Environment-Variables/#introduction-to-environment-variables","title":"Introduction to Environment Variables","text":"<p>Environment variables are a fundamental mechanism for configuring applications at runtime. They are key-value pairs that can affect the behavior of running processes on a computer system. In Go, environment variables are commonly used for:</p> <ul> <li>Application configuration (database URLs, API keys, etc.)</li> <li>Controlling application behavior (debug mode, log levels, etc.)</li> <li>Providing environment-specific settings (development, staging, production)</li> <li>Storing sensitive information that shouldn't be hardcoded</li> </ul> <p>Go provides the <code>os</code> package for working with environment variables, offering a simple and effective API.</p>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#reading-environment-variables","title":"Reading Environment Variables","text":""},{"location":"2.%20Intermediate/30.%20Environment-Variables/#getting-a-single-environment-variable","title":"Getting a Single Environment Variable","text":"<p>The <code>os.Getenv</code> function retrieves the value of an environment variable. It returns an empty string if the variable is not set:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Get the value of the HOME environment variable\n    home := os.Getenv(\"HOME\")\n    fmt.Println(\"Home directory:\", home)\n\n    // Try to get a variable that might not exist\n    path := os.Getenv(\"NON_EXISTENT_VAR\")\n    fmt.Println(\"Non-existent variable:\", path)\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#getting-a-variable-with-a-default-value","title":"Getting a Variable with a Default Value","text":"<p>Since <code>os.Getenv</code> returns an empty string for unset variables, you can provide a default value:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Get the PORT variable, default to 8080 if not set\n    port := os.Getenv(\"PORT\")\n    if port == \"\" {\n        port = \"8080\"\n    }\n    fmt.Println(\"Server will run on port:\", port)\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#checking-if-a-variable-exists","title":"Checking if a Variable Exists","text":"<p>To distinguish between an unset variable and a variable set to an empty string, use <code>os.LookupEnv</code>:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Check if DEBUG is set\n    debug, exists := os.LookupEnv(\"DEBUG\")\n    if exists {\n        fmt.Println(\"DEBUG is set to:\", debug)\n    } else {\n        fmt.Println(\"DEBUG is not set\")\n    }\n\n    // Set an empty variable for demonstration\n    os.Setenv(\"EMPTY_VAR\", \"\")\n\n    // Check if EMPTY_VAR exists\n    empty, exists := os.LookupEnv(\"EMPTY_VAR\")\n    if exists {\n        fmt.Println(\"EMPTY_VAR exists and is set to:\", empty)\n    } else {\n        fmt.Println(\"EMPTY_VAR does not exist\")\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#setting-environment-variables","title":"Setting Environment Variables","text":""},{"location":"2.%20Intermediate/30.%20Environment-Variables/#setting-a-variable","title":"Setting a Variable","text":"<p>Use <code>os.Setenv</code> to set an environment variable:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Set an environment variable\n    err := os.Setenv(\"APP_ENV\", \"development\")\n    if err != nil {\n        fmt.Println(\"Error setting environment variable:\", err)\n        return\n    }\n\n    // Verify it was set\n    env := os.Getenv(\"APP_ENV\")\n    fmt.Println(\"APP_ENV is now:\", env)\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#modifying-existing-variables","title":"Modifying Existing Variables","text":"<p><code>os.Setenv</code> will overwrite existing variables:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Set initial value\n    os.Setenv(\"LOG_LEVEL\", \"info\")\n    fmt.Println(\"Initial LOG_LEVEL:\", os.Getenv(\"LOG_LEVEL\"))\n\n    // Change the value\n    os.Setenv(\"LOG_LEVEL\", \"debug\")\n    fmt.Println(\"Updated LOG_LEVEL:\", os.Getenv(\"LOG_LEVEL\"))\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#unsetting-environment-variables","title":"Unsetting Environment Variables","text":"<p>Use <code>os.Unsetenv</code> to remove an environment variable:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Set a variable\n    os.Setenv(\"TEMP_VAR\", \"temporary\")\n    fmt.Println(\"TEMP_VAR set to:\", os.Getenv(\"TEMP_VAR\"))\n\n    // Unset the variable\n    err := os.Unsetenv(\"TEMP_VAR\")\n    if err != nil {\n        fmt.Println(\"Error unsetting environment variable:\", err)\n        return\n    }\n\n    // Verify it was unset\n    value, exists := os.LookupEnv(\"TEMP_VAR\")\n    if exists {\n        fmt.Println(\"TEMP_VAR still exists with value:\", value)\n    } else {\n        fmt.Println(\"TEMP_VAR has been unset\")\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#listing-all-environment-variables","title":"Listing All Environment Variables","text":"<p>To get all environment variables, use <code>os.Environ</code>, which returns a slice of strings in the format \"KEY=VALUE\":</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // Get all environment variables\n    envVars := os.Environ()\n\n    fmt.Println(\"Environment variables:\")\n    for _, env := range envVars {\n        // Split into key and value\n        pair := strings.SplitN(env, \"=\", 2)\n        if len(pair) == 2 {\n            fmt.Printf(\"%s = %s\\n\", pair[0], pair[1])\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#using-environment-variables-for-configuration","title":"Using Environment Variables for Configuration","text":"<p>Environment variables are an excellent way to configure applications without hardcoding values. Here's a common pattern for configuration management:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"time\"\n)\n\ntype Config struct {\n    Port         int\n    DatabaseURL  string\n    DebugMode    bool\n    LogLevel     string\n    MaxConnections int\n    Timeout      time.Duration\n}\n\nfunc LoadConfig() (*Config, error) {\n    config := &amp;Config{}\n\n    // Get port with default\n    portStr := os.Getenv(\"PORT\")\n    if portStr == \"\" {\n        portStr = \"8080\"\n    }\n    port, err := strconv.Atoi(portStr)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid PORT: %v\", err)\n    }\n    config.Port = port\n\n    // Get database URL (required)\n    config.DatabaseURL = os.Getenv(\"DATABASE_URL\")\n    if config.DatabaseURL == \"\" {\n        return nil, fmt.Errorf(\"DATABASE_URL is required\")\n    }\n\n    // Get debug mode\n    debugStr := os.Getenv(\"DEBUG\")\n    config.DebugMode = debugStr == \"true\" || debugStr == \"1\" || debugStr == \"yes\"\n\n    // Get log level with default\n    config.LogLevel = os.Getenv(\"LOG_LEVEL\")\n    if config.LogLevel == \"\" {\n        config.LogLevel = \"info\"\n    }\n\n    // Get max connections with default\n    maxConnStr := os.Getenv(\"MAX_CONNECTIONS\")\n    if maxConnStr == \"\" {\n        maxConnStr = \"10\"\n    }\n    maxConn, err := strconv.Atoi(maxConnStr)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid MAX_CONNECTIONS: %v\", err)\n    }\n    config.MaxConnections = maxConn\n\n    // Get timeout with default\n    timeoutStr := os.Getenv(\"TIMEOUT\")\n    if timeoutStr == \"\" {\n        timeoutStr = \"30s\"\n    }\n    timeout, err := time.ParseDuration(timeoutStr)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid TIMEOUT: %v\", err)\n    }\n    config.Timeout = timeout\n\n    return config, nil\n}\n\nfunc main() {\n    // Set some environment variables for demonstration\n    os.Setenv(\"DATABASE_URL\", \"postgres://user:pass@localhost/dbname\")\n    os.Setenv(\"DEBUG\", \"true\")\n    os.Setenv(\"TIMEOUT\", \"5s\")\n\n    // Load configuration\n    config, err := LoadConfig()\n    if err != nil {\n        fmt.Println(\"Error loading configuration:\", err)\n        os.Exit(1)\n    }\n\n    // Print configuration\n    fmt.Printf(\"Port: %d\\n\", config.Port)\n    fmt.Printf(\"Database URL: %s\\n\", config.DatabaseURL)\n    fmt.Printf(\"Debug Mode: %v\\n\", config.DebugMode)\n    fmt.Printf(\"Log Level: %s\\n\", config.LogLevel)\n    fmt.Printf(\"Max Connections: %d\\n\", config.MaxConnections)\n    fmt.Printf(\"Timeout: %v\\n\", config.Timeout)\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#best-practices-for-environment-variables","title":"Best Practices for Environment Variables","text":""},{"location":"2.%20Intermediate/30.%20Environment-Variables/#1-naming-conventions","title":"1. Naming Conventions","text":"<ul> <li>Use uppercase letters and underscores</li> <li>Be descriptive but concise</li> <li>Group related variables with a common prefix</li> </ul> <pre><code>// Good\nos.Setenv(\"DATABASE_URL\", \"postgres://...\")\nos.Setenv(\"DATABASE_MAX_CONNECTIONS\", \"10\")\n\n// Less clear\nos.Setenv(\"DB\", \"postgres://...\")\nos.Setenv(\"MAXCONN\", \"10\")\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#2-documentation","title":"2. Documentation","text":"<p>Document all environment variables your application uses:</p> <pre><code>// Configuration via environment variables:\n//\n// PORT: Port to listen on (default: 8080)\n// DATABASE_URL: Database connection string (required)\n// DEBUG: Enable debug mode (true/false, default: false)\n// LOG_LEVEL: Logging level (debug, info, warn, error, default: info)\n// MAX_CONNECTIONS: Maximum database connections (default: 10)\n// TIMEOUT: Request timeout (e.g., 30s, 1m, default: 30s)\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#3-validation","title":"3. Validation","text":"<p>Validate environment variables and provide clear error messages:</p> <pre><code>func LoadConfig() (*Config, error) {\n    config := &amp;Config{}\n\n    // Required variable\n    config.DatabaseURL = os.Getenv(\"DATABASE_URL\")\n    if config.DatabaseURL == \"\" {\n        return nil, fmt.Errorf(\"DATABASE_URL environment variable is required\")\n    }\n\n    // Validate port range\n    portStr := os.Getenv(\"PORT\")\n    if portStr == \"\" {\n        portStr = \"8080\"\n    }\n    port, err := strconv.Atoi(portStr)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid PORT: must be a number\")\n    }\n    if port &lt; 1 || port &gt; 65535 {\n        return nil, fmt.Errorf(\"invalid PORT: must be between 1 and 65535\")\n    }\n    config.Port = port\n\n    // ... rest of configuration\n\n    return config, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#4-security-considerations","title":"4. Security Considerations","text":"<ul> <li>Never log sensitive environment variables</li> <li>Use <code>.env</code> files for development (but don't commit them)</li> <li>Consider using secrets management for production</li> </ul> <pre><code>// Don't do this - exposes secrets in logs\nfmt.Printf(\"Connecting to database with URL: %s\\n\", os.Getenv(\"DATABASE_URL\"))\n\n// Instead, log a generic message\nfmt.Println(\"Connecting to database...\")\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#5-defaults-and-overrides","title":"5. Defaults and Overrides","text":"<ul> <li>Provide sensible defaults for optional settings</li> <li>Allow configuration files to override environment variables if needed</li> </ul>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#real-world-example-web-application-configuration","title":"Real-World Example: Web Application Configuration","text":"<p>Let's create a more comprehensive example of a web application that uses environment variables for configuration:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"strconv\"\n    \"time\"\n)\n\n// AppConfig holds the application configuration\ntype AppConfig struct {\n    Server      ServerConfig\n    Database    DatabaseConfig\n    Auth        AuthConfig\n    Logging     LoggingConfig\n    Features    FeatureFlags\n}\n\n// ServerConfig holds HTTP server configuration\ntype ServerConfig struct {\n    Port         int\n    ReadTimeout  time.Duration\n    WriteTimeout time.Duration\n    IdleTimeout  time.Duration\n}\n\n// DatabaseConfig holds database configuration\ntype DatabaseConfig struct {\n    URL             string\n    MaxOpenConns    int\n    MaxIdleConns    int\n    ConnMaxLifetime time.Duration\n}\n\n// AuthConfig holds authentication configuration\ntype AuthConfig struct {\n    JWTSecret      string\n    TokenExpiry    time.Duration\n    RefreshExpiry  time.Duration\n}\n\n// LoggingConfig holds logging configuration\ntype LoggingConfig struct {\n    Level  string\n    Format string\n}\n\n// FeatureFlags holds feature toggle configuration\ntype FeatureFlags struct {\n    EnableNewUI    bool\n    EnableCache    bool\n    EnableAnalytics bool\n}\n\n// LoadConfig loads configuration from environment variables\nfunc LoadConfig() (*AppConfig, error) {\n    config := &amp;AppConfig{}\n\n    // Server configuration\n    serverPort, err := getIntEnv(\"SERVER_PORT\", 8080)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid SERVER_PORT: %v\", err)\n    }\n\n    serverReadTimeout, err := getDurationEnv(\"SERVER_READ_TIMEOUT\", \"15s\")\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid SERVER_READ_TIMEOUT: %v\", err)\n    }\n\n    serverWriteTimeout, err := getDurationEnv(\"SERVER_WRITE_TIMEOUT\", \"15s\")\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid SERVER_WRITE_TIMEOUT: %v\", err)\n    }\n\n    serverIdleTimeout, err := getDurationEnv(\"SERVER_IDLE_TIMEOUT\", \"60s\")\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid SERVER_IDLE_TIMEOUT: %v\", err)\n    }\n\n    config.Server = ServerConfig{\n        Port:         serverPort,\n        ReadTimeout:  serverReadTimeout,\n        WriteTimeout: serverWriteTimeout,\n        IdleTimeout:  serverIdleTimeout,\n    }\n\n    // Database configuration\n    dbURL := os.Getenv(\"DATABASE_URL\")\n    if dbURL == \"\" {\n        return nil, fmt.Errorf(\"DATABASE_URL is required\")\n    }\n\n    dbMaxOpenConns, err := getIntEnv(\"DATABASE_MAX_OPEN_CONNS\", 25)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid DATABASE_MAX_OPEN_CONNS: %v\", err)\n    }\n\n    dbMaxIdleConns, err := getIntEnv(\"DATABASE_MAX_IDLE_CONNS\", 25)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid DATABASE_MAX_IDLE_CONNS: %v\", err)\n    }\n\n    dbConnMaxLifetime, err := getDurationEnv(\"DATABASE_CONN_MAX_LIFETIME\", \"5m\")\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid DATABASE_CONN_MAX_LIFETIME: %v\", err)\n    }\n\n    config.Database = DatabaseConfig{\n        URL:             dbURL,\n        MaxOpenConns:    dbMaxOpenConns,\n        MaxIdleConns:    dbMaxIdleConns,\n        ConnMaxLifetime: dbConnMaxLifetime,\n    }\n\n    // Auth configuration\n    jwtSecret := os.Getenv(\"AUTH_JWT_SECRET\")\n    if jwtSecret == \"\" {\n        return nil, fmt.Errorf(\"AUTH_JWT_SECRET is required\")\n    }\n\n    tokenExpiry, err := getDurationEnv(\"AUTH_TOKEN_EXPIRY\", \"15m\")\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid AUTH_TOKEN_EXPIRY: %v\", err)\n    }\n\n    refreshExpiry, err := getDurationEnv(\"AUTH_REFRESH_EXPIRY\", \"7d\")\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid AUTH_REFRESH_EXPIRY: %v\", err)\n    }\n\n    config.Auth = AuthConfig{\n        JWTSecret:     jwtSecret,\n        TokenExpiry:   tokenExpiry,\n        RefreshExpiry: refreshExpiry,\n    }\n\n    // Logging configuration\n    logLevel := os.Getenv(\"LOGGING_LEVEL\")\n    if logLevel == \"\" {\n        logLevel = \"info\"\n    }\n\n    logFormat := os.Getenv(\"LOGGING_FORMAT\")\n    if logFormat == \"\" {\n        logFormat = \"json\"\n    }\n\n    config.Logging = LoggingConfig{\n        Level:  logLevel,\n        Format: logFormat,\n    }\n\n    // Feature flags\n    config.Features = FeatureFlags{\n        EnableNewUI:    getBoolEnv(\"FEATURE_NEW_UI\", false),\n        EnableCache:    getBoolEnv(\"FEATURE_CACHE\", true),\n        EnableAnalytics: getBoolEnv(\"FEATURE_ANALYTICS\", false),\n    }\n\n    return config, nil\n}\n\n// Helper functions for environment variable parsing\nfunc getIntEnv(key string, defaultValue int) (int, error) {\n    valueStr := os.Getenv(key)\n    if valueStr == \"\" {\n        return defaultValue, nil\n    }\n\n    value, err := strconv.Atoi(valueStr)\n    if err != nil {\n        return 0, err\n    }\n\n    return value, nil\n}\n\nfunc getDurationEnv(key, defaultValue string) (time.Duration, error) {\n    valueStr := os.Getenv(key)\n    if valueStr == \"\" {\n        valueStr = defaultValue\n    }\n\n    value, err := time.ParseDuration(valueStr)\n    if err != nil {\n        return 0, err\n    }\n\n    return value, nil\n}\n\nfunc getBoolEnv(key string, defaultValue bool) bool {\n    valueStr := os.Getenv(key)\n    if valueStr == \"\" {\n        return defaultValue\n    }\n\n    return valueStr == \"true\" || valueStr == \"1\" || valueStr == \"yes\" || valueStr == \"on\"\n}\n\nfunc main() {\n    // Set some environment variables for demonstration\n    os.Setenv(\"DATABASE_URL\", \"postgres://user:pass@localhost/myapp\")\n    os.Setenv(\"AUTH_JWT_SECRET\", \"super-secret-jwt-key\")\n    os.Setenv(\"FEATURE_CACHE\", \"true\")\n\n    // Load configuration\n    config, err := LoadConfig()\n    if err != nil {\n        log.Fatalf(\"Error loading configuration: %v\", err)\n    }\n\n    // Print configuration (in a real app, you might not want to log secrets)\n    configJSON, _ := json.MarshalIndent(config, \"\", \"  \")\n    fmt.Printf(\"Application configuration:\\n%s\\n\", string(configJSON))\n\n    // Start the server\n    server := &amp;http.Server{\n        Addr:         fmt.Sprintf(\":%d\", config.Server.Port),\n        ReadTimeout:  config.Server.ReadTimeout,\n        WriteTimeout: config.Server.WriteTimeout,\n        IdleTimeout:  config.Server.IdleTimeout,\n    }\n\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(map[string]string{\n            \"message\": \"Hello, World!\",\n            \"status\":  \"ok\",\n        })\n    })\n\n    log.Printf(\"Starting server on port %d\", config.Server.Port)\n    if err := server.ListenAndServe(); err != nil {\n        log.Fatalf(\"Server error: %v\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#how-this-example-demonstrates-environment-variables","title":"How This Example Demonstrates Environment Variables:","text":"<ol> <li>Structured Configuration:</li> <li>Organizes configuration into logical groups (Server, Database, Auth, etc.)</li> <li> <p>Uses nested structs for better organization</p> </li> <li> <p>Type Conversion:</p> </li> <li>Helper functions for converting environment variables to specific types</li> <li> <p>Proper error handling for invalid values</p> </li> <li> <p>Required vs. Optional Variables:</p> </li> <li>Clearly distinguishes between required and optional settings</li> <li> <p>Provides sensible defaults for optional variables</p> </li> <li> <p>Validation:</p> </li> <li>Validates environment variables and returns clear error messages</li> <li> <p>Ensures critical settings are present</p> </li> <li> <p>Feature Flags:</p> </li> <li>Demonstrates using environment variables for feature toggling</li> <li>Allows enabling/disabling functionality without code changes</li> </ol>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"2.%20Intermediate/30.%20Environment-Variables/#using-env-files-for-development","title":"Using .env Files for Development","text":"<p>For development, it's common to use <code>.env</code> files to set environment variables. While Go doesn't have built-in support for <code>.env</code> files, you can use third-party packages like <code>godotenv</code>:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/joho/godotenv\"\n)\n\nfunc main() {\n    // Load .env file\n    err := godotenv.Load()\n    if err != nil {\n        log.Println(\"Warning: .env file not found\")\n    }\n\n    // Access environment variables\n    dbURL := os.Getenv(\"DATABASE_URL\")\n    fmt.Println(\"Database URL:\", dbURL)\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#environment-variables-in-tests","title":"Environment Variables in Tests","text":"<p>When writing tests, you might need to set environment variables temporarily:</p> <pre><code>package main\n\nimport (\n    \"os\"\n    \"testing\"\n)\n\nfunc TestLoadConfig(t *testing.T) {\n    // Save original environment variables\n    originalPort := os.Getenv(\"PORT\")\n    originalDBURL := os.Getenv(\"DATABASE_URL\")\n\n    // Restore original values after the test\n    defer func() {\n        os.Setenv(\"PORT\", originalPort)\n        os.Setenv(\"DATABASE_URL\", originalDBURL)\n    }()\n\n    // Set test values\n    os.Setenv(\"PORT\", \"9090\")\n    os.Setenv(\"DATABASE_URL\", \"postgres://test:test@localhost/testdb\")\n\n    // Test the configuration loading\n    config, err := LoadConfig()\n    if err != nil {\n        t.Fatalf(\"LoadConfig() error = %v\", err)\n    }\n\n    if config.Port != 9090 {\n        t.Errorf(\"Expected port 9090, got %d\", config.Port)\n    }\n\n    if config.DatabaseURL != \"postgres://test:test@localhost/testdb\" {\n        t.Errorf(\"Unexpected database URL: %s\", config.DatabaseURL)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#environment-variables-in-docker-and-kubernetes","title":"Environment Variables in Docker and Kubernetes","text":"<p>Environment variables are particularly important when containerizing applications:</p>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#docker-example","title":"Docker Example","text":"<pre><code>FROM golang:1.19-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /app\nCOPY --from=builder /app/main .\n# Set default environment variables\nENV PORT=8080\nENV LOG_LEVEL=info\nCMD [\"./main\"]\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#kubernetes-example","title":"Kubernetes Example","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: myapp\n  template:\n    metadata:\n      labels:\n        app: myapp\n    spec:\n      containers:\n      - name: myapp\n        image: myapp:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: PORT\n          value: \"8080\"\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: db-secret\n              key: url\n        - name: LOG_LEVEL\n          value: \"info\"\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#conclusion","title":"Conclusion","text":"<p>Environment variables are a powerful and flexible way to configure Go applications:</p>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#key-takeaways","title":"Key Takeaways:","text":"<ol> <li>Reading Variables:</li> <li>Use <code>os.Getenv</code> for simple access</li> <li>Use <code>os.LookupEnv</code> to distinguish unset variables from empty strings</li> <li> <p>Provide sensible defaults for optional settings</p> </li> <li> <p>Setting Variables:</p> </li> <li>Use <code>os.Setenv</code> to set environment variables</li> <li> <p>Remember that changes only affect the current process and its children</p> </li> <li> <p>Configuration Management:</p> </li> <li>Structure your configuration logically</li> <li>Validate environment variables and provide clear error messages</li> <li> <p>Use helper functions for type conversion</p> </li> <li> <p>Best Practices:</p> </li> <li>Follow naming conventions</li> <li>Document all environment variables</li> <li>Never log sensitive information</li> <li> <p>Use <code>.env</code> files for development (but don't commit them)</p> </li> <li> <p>Real-World Applications:</p> </li> <li>Environment variables are essential for containerized applications</li> <li>They enable configuration without code changes</li> <li>They're a standard way to manage secrets and settings across different environments</li> </ol> <p>By mastering environment variables in Go, you can create more flexible, secure, and maintainable applications that can be easily deployed across different environments without code changes.</p>"},{"location":"2.%20Intermediate/31.%20Logging/","title":"Logging in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/31.%20Logging/#introduction-to-logging","title":"Introduction to Logging","text":"<p>Logging is a critical aspect of software development that provides visibility into application behavior, helps with debugging, and enables monitoring and troubleshooting. In Go, logging can range from simple output using the standard library to sophisticated structured logging with third-party packages.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#the-standard-log-package","title":"The Standard Log Package","text":"<p>Go's standard <code>log</code> package provides basic logging functionality. It's simple and built-in, making it suitable for small applications or quick prototyping.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    // Basic logging\n    log.Println(\"This is a standard log message\")\n\n    // Logging with formatting\n    name := \"Alice\"\n    age := 30\n    log.Printf(\"User: %s, Age: %d\", name, age)\n\n    // Fatal logging (terminates the program)\n    log.Fatal(\"This message will be logged and the program will exit\")\n\n    // Panic logging (causes a panic)\n    log.Panic(\"This message will be logged and then panic\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#log-flags","title":"Log Flags","text":"<p>The <code>log</code> package allows you to customize the output format using flags:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    // Set log flags to include date, time, and file name\n    log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)\n\n    log.Println(\"This log includes date, time, and file name\")\n\n    // Set a custom prefix\n    log.SetPrefix(\"APP: \")\n    log.Println(\"This log has a custom prefix\")\n\n    // Set output to a file\n    file, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n    if err != nil {\n        log.Fatal(\"Failed to open log file:\", err)\n    }\n    defer file.Close()\n\n    log.SetOutput(file)\n    log.Println(\"This message will be written to app.log\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#available-log-flags","title":"Available Log Flags","text":"Flag Description <code>log.Ldate</code> Date in the local time zone: 2009/01/23 <code>log.Ltime</code> Time in the local time zone: 01:23:23 <code>log.Lmicroseconds</code> Microsecond resolution: 01:23:23.123123 <code>log.Llongfile</code> Full file name and line number: /a/b/c/d.go:23 <code>log.Lshortfile</code> Final file name element and line number: d.go:23 <code>log.LUTC</code> Use UTC rather than the local time zone <code>log.Lmsgprefix</code> Move the prefix to the beginning of the message <code>log.LstdFlags</code> Standard flags: Ldate"},{"location":"2.%20Intermediate/31.%20Logging/#third-party-logging-libraries","title":"Third-Party Logging Libraries","text":"<p>While the standard <code>log</code> package is sufficient for simple use cases, many applications benefit from more advanced features provided by third-party logging libraries.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#logrus","title":"Logrus","text":"<p>Logrus is a structured logger for Go, compatible with the standard library logger.</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    // Create a new logger\n    logger := logrus.New()\n\n    // Set log level\n    logger.SetLevel(logrus.DebugLevel)\n\n    // Set formatter\n    logger.SetFormatter(&amp;logrus.JSONFormatter{})\n\n    // Set output to stdout\n    logger.SetOutput(os.Stdout)\n\n    // Log with different levels\n    logger.Debug(\"Debug message\")\n    logger.Info(\"Info message\")\n    logger.Warn(\"Warning message\")\n    logger.Error(\"Error message\")\n\n    // Log with fields\n    logger.WithFields(logrus.Fields{\n        \"event\": \"test\",\n        \"topic\": \"logging\",\n    }).Info(\"Message with fields\")\n\n    // Fatal and panic\n    // logger.Fatal(\"Fatal message\")  // This would terminate the program\n    // logger.Panic(\"Panic message\")  // This would cause a panic\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#zap","title":"Zap","text":"<p>Zap is a high-performance, structured logging library from Uber.</p> <pre><code>package main\n\nimport (\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, err := zap.NewProduction()\n    if err != nil {\n        panic(err)\n    }\n    defer logger.Sync()\n\n    // Basic logging\n    logger.Info(\"Info message\",\n        zap.String(\"service\", \"example\"),\n        zap.Int(\"attempt\", 3),\n    )\n\n    // Debug logging (disabled in production by default)\n    logger.Debug(\"Debug message\")\n\n    // Error logging\n    logger.Error(\"Error message\",\n        zap.Error(fmt.Errorf(\"something went wrong\")),\n    )\n\n    // For development, you can use a different configuration\n    devLogger, err := zap.NewDevelopment()\n    if err != nil {\n        panic(err)\n    }\n    defer devLogger.Sync()\n\n    devLogger.Debug(\"This debug message will be visible in development mode\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#zerolog","title":"Zerolog","text":"<p>Zerolog is a zero-allocation JSON logger designed for performance.</p> <pre><code>package main\n\nimport (\n    \"github.com/rs/zerolog\"\n    \"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n    // Set global log level\n    zerolog.SetGlobalLevel(zerolog.InfoLevel)\n\n    // Basic logging\n    log.Info().Msg(\"Info message\")\n    log.Debug().Msg(\"Debug message\")  // This won't be printed\n\n    // Structured logging\n    log.Info().\n        Str(\"service\", \"example\").\n        Int(\"attempt\", 3).\n        Msg(\"Message with fields\")\n\n    // Error logging\n    log.Error().\n        Err(fmt.Errorf(\"something went wrong\")).\n        Msg(\"Error message\")\n\n    // Create a child logger with context\n    subLogger := log.With().Str(\"component\", \"auth\").Logger()\n    subLogger.Info().Msg(\"Message from auth component\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#structured-logging","title":"Structured Logging","text":"<p>Structured logging uses key-value pairs to make logs more machine-readable and searchable. This is particularly valuable in production environments where logs might be processed by automated systems.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#benefits-of-structured-logging","title":"Benefits of Structured Logging","text":"<ol> <li>Machine-Readable: Logs can be easily parsed by log management systems</li> <li>Consistent Format: All logs follow the same structure</li> <li>Rich Context: Additional metadata can be attached to log messages</li> <li>Better Filtering: Logs can be filtered based on specific fields</li> </ol>"},{"location":"2.%20Intermediate/31.%20Logging/#example-with-logrus","title":"Example with Logrus","text":"<pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n    logger.SetFormatter(&amp;logrus.JSONFormatter{})\n\n    // Log with context\n    logger.WithFields(logrus.Fields{\n        \"event\":     \"user_login\",\n        \"user_id\":   \"123\",\n        \"ip\":        \"192.168.1.1\",\n        \"user_agent\": \"Mozilla/5.0\",\n    }).Info(\"User logged in\")\n\n    // Nested fields\n    requestLogger := logger.WithFields(logrus.Fields{\n        \"request_id\": \"abc123\",\n        \"method\":     \"GET\",\n        \"path\":       \"/api/users\",\n    })\n\n    requestLogger.Info(\"Request received\")\n    requestLogger.WithFields(logrus.Fields{\n        \"status\": 200,\n        \"duration\": \"120ms\",\n    }).Info(\"Request completed\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#example-with-zap","title":"Example with Zap","text":"<pre><code>package main\n\nimport (\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    logger, _ := zap.NewProduction()\n    defer logger.Sync()\n\n    // Log with context\n    logger.Info(\"User logged in\",\n        zap.String(\"event\", \"user_login\"),\n        zap.String(\"user_id\", \"123\"),\n        zap.String(\"ip\", \"192.168.1.1\"),\n        zap.String(\"user_agent\", \"Mozilla/5.0\"),\n    )\n\n    // Create a child logger with context\n    requestLogger := logger.With(\n        zap.String(\"request_id\", \"abc123\"),\n        zap.String(\"method\", \"GET\"),\n        zap.String(\"path\", \"/api/users\"),\n    )\n\n    requestLogger.Info(\"Request received\")\n    requestLogger.Info(\"Request completed\",\n        zap.Int(\"status\", 200),\n        zap.String(\"duration\", \"120ms\"),\n    )\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#log-levels","title":"Log Levels","text":"<p>Log levels help categorize messages by severity, allowing developers to control verbosity and focus on relevant information.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#common-log-levels","title":"Common Log Levels","text":"Level Description Typical Use Trace Very detailed information, typically for debugging Detailed execution flow Debug Diagnostic information for developers Variable values, state information Info General information about application execution Application startup, configuration Warn Potentially harmful situations Deprecated API usage, unexpected but recoverable errors Error Error events that might still allow the application to continue Failed operations, exceptions Fatal Severe errors that will cause the application to terminate Critical system failures Panic Similar to Fatal, but with a stack trace Unrecoverable errors"},{"location":"2.%20Intermediate/31.%20Logging/#setting-log-levels","title":"Setting Log Levels","text":"<pre><code>package main\n\nimport (\n    \"github.com/sirupsen/logrus\"\n    \"go.uber.org/zap\"\n    \"github.com/rs/zerolog\"\n    \"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n    // Logrus\n    logrusLogger := logrus.New()\n    logrusLogger.SetLevel(logrus.WarnLevel)  // Only show Warn, Error, Fatal, Panic\n\n    logrusLogger.Debug(\"This won't be visible\")\n    logrusLogger.Info(\"This won't be visible\")\n    logrusLogger.Warn(\"This will be visible\")\n\n    // Zap\n    zapLogger, _ := zap.NewProduction()\n    defer zapLogger.Sync()\n\n    zapLogger.Debug(\"This won't be visible in production\")\n    zapLogger.Info(\"This will be visible\")\n\n    // Zerolog\n    zerolog.SetGlobalLevel(zerolog.InfoLevel)\n\n    log.Debug().Msg(\"This won't be visible\")\n    log.Info().Msg(\"This will be visible\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#log-formatting","title":"Log Formatting","text":"<p>Log formatting determines how log messages are presented. Different formats are suitable for different environments.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#text-format","title":"Text Format","text":"<p>Human-readable format suitable for development:</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // Text formatter\n    logger.SetFormatter(&amp;logrus.TextFormatter{\n        FullTimestamp: true,\n        ForceColors:   true,\n    })\n\n    logger.WithFields(logrus.Fields{\n        \"event\": \"test\",\n        \"topic\": \"logging\",\n    }).Info(\"Message with fields\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#json-format","title":"JSON Format","text":"<p>Machine-readable format suitable for production:</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // JSON formatter\n    logger.SetFormatter(&amp;logrus.JSONFormatter{})\n\n    logger.WithFields(logrus.Fields{\n        \"event\": \"test\",\n        \"topic\": \"logging\",\n    }).Info(\"Message with fields\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#custom-formatters","title":"Custom Formatters","text":"<p>You can create custom formatters for specific needs:</p> <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"os\"\n    \"time\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\ntype CustomFormatter struct{}\n\nfunc (f *CustomFormatter) Format(entry *logrus.Entry) ([]byte, error) {\n    timestamp := time.Now().Format(\"2006-01-02 15:04:05\")\n    var b *bytes.Buffer\n    if entry.Buffer != nil {\n        b = entry.Buffer\n    } else {\n        b = &amp;bytes.Buffer{}\n    }\n\n    fmt.Fprintf(b, \"[%s] %s: %s\", timestamp, entry.Level, entry.Message)\n    for k, v := range entry.Data {\n        fmt.Fprintf(b, \" %s=%v\", k, v)\n    }\n    b.WriteByte('\\n')\n    return b.Bytes(), nil\n}\n\nfunc main() {\n    logger := logrus.New()\n    logger.SetFormatter(&amp;CustomFormatter{})\n\n    logger.WithFields(logrus.Fields{\n        \"event\": \"test\",\n        \"topic\": \"logging\",\n    }).Info(\"Message with fields\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#log-destinations","title":"Log Destinations","text":"<p>Logs can be directed to different outputs depending on the environment and requirements.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#standard-output","title":"Standard Output","text":"<pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // Output to stdout\n    logger.SetOutput(os.Stdout)\n    logger.Info(\"This message goes to stdout\")\n\n    // Output to stderr\n    logger.SetOutput(os.Stderr)\n    logger.Info(\"This message goes to stderr\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#file-output","title":"File Output","text":"<pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // Open a file for logging\n    file, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n    if err != nil {\n        logger.Fatal(\"Failed to open log file:\", err)\n    }\n    defer file.Close()\n\n    logger.SetOutput(file)\n    logger.Info(\"This message goes to app.log\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#multiple-outputs","title":"Multiple Outputs","text":"<pre><code>package main\n\nimport (\n    \"io\"\n    \"os\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // Create a multi-writer to write to both stdout and a file\n    file, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n    if err != nil {\n        logger.Fatal(\"Failed to open log file:\", err)\n    }\n    defer file.Close()\n\n    multiWriter := io.MultiWriter(os.Stdout, file)\n    logger.SetOutput(multiWriter)\n\n    logger.Info(\"This message goes to both stdout and app.log\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#log-rotation","title":"Log Rotation","text":"<p>For long-running applications, log rotation is essential to prevent log files from consuming too much disk space:</p> <pre><code>package main\n\nimport (\n    \"github.com/sirupsen/logrus\"\n    \"gopkg.in/natefinch/lumberjack.v2\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // Set up log rotation\n    logger.SetOutput(&amp;lumberjack.Logger{\n        Filename:   \"app.log\",\n        MaxSize:    100, // megabytes\n        MaxBackups: 3,\n        MaxAge:     28, // days\n        Compress:   true,\n    })\n\n    logger.Info(\"This message goes to a rotating log file\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#contextual-logging","title":"Contextual Logging","text":"<p>Contextual logging adds relevant context to log messages, making them more informative and easier to debug.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#request-context-in-web-applications","title":"Request Context in Web Applications","text":"<pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // Create a logger with request context\n        requestLogger := logger.WithFields(logrus.Fields{\n            \"method\": r.Method,\n            \"path\":   r.URL.Path,\n            \"remote\": r.RemoteAddr,\n        })\n\n        requestLogger.Info(\"Request received\")\n\n        // Process request...\n\n        requestLogger.WithFields(logrus.Fields{\n            \"status\": 200,\n            \"size\":   1024,\n        }).Info(\"Request completed\")\n    })\n\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#correlation-ids","title":"Correlation IDs","text":"<p>Correlation IDs help track requests across multiple services:</p> <pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/google/uuid\"\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // Get or create correlation ID\n        correlationID := r.Header.Get(\"X-Correlation-ID\")\n        if correlationID == \"\" {\n            correlationID = uuid.New().String()\n        }\n\n        // Add correlation ID to response header\n        w.Header().Set(\"X-Correlation-ID\", correlationID)\n\n        // Create logger with correlation ID\n        requestLogger := logger.WithField(\"correlation_id\", correlationID)\n\n        requestLogger.Info(\"Request received\")\n\n        // Process request...\n\n        requestLogger.Info(\"Request completed\")\n    })\n\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#performance-considerations","title":"Performance Considerations","text":"<p>Logging can impact application performance, especially in high-throughput systems. Here are some considerations:</p>"},{"location":"2.%20Intermediate/31.%20Logging/#asynchronous-logging","title":"Asynchronous Logging","text":"<p>Asynchronous logging can reduce the impact on application performance:</p> <pre><code>package main\n\nimport (\n    \"github.com/sirupsen/logrus\"\n    \"gopkg.in/natefinch/lumberjack.v2\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // Set up log rotation\n    logger.SetOutput(&amp;lumberjack.Logger{\n        Filename:   \"app.log\",\n        MaxSize:    100,\n        MaxBackups: 3,\n        MaxAge:     28,\n        Compress:   true,\n    })\n\n    // For production, consider using a hook for asynchronous logging\n    // This is a simplified example - in production, use a proper async hook\n    logger.SetFormatter(&amp;logrus.JSONFormatter{})\n\n    // In a real application, you might use a library like logrus-async-hook\n    // or implement a buffered channel for log messages\n\n    logger.Info(\"This message is logged synchronously\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#conditional-logging","title":"Conditional Logging","text":"<p>Avoid expensive operations if the log level won't be used:</p> <pre><code>package main\n\nimport (\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n    logger.SetLevel(logrus.InfoLevel)\n\n    // Bad: The expensive operation is always performed\n    logger.Debug(\"Result of expensive operation: \", expensiveOperation())\n\n    // Good: The expensive operation is only performed if needed\n    if logger.IsLevelEnabled(logrus.DebugLevel) {\n        logger.Debug(\"Result of expensive operation: \", expensiveOperation())\n    }\n}\n\nfunc expensiveOperation() string {\n    // Simulate an expensive operation\n    return \"result\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#high-performance-logging-with-zap","title":"High-Performance Logging with Zap","text":"<p>Zap is designed for high performance with minimal allocations:</p> <pre><code>package main\n\nimport (\n    \"go.uber.org/zap\"\n    \"go.uber.org/zap/zapcore\"\n)\n\nfunc main() {\n    // Create a high-performance logger\n    config := zap.NewProductionConfig()\n    config.OutputPaths = []string{\"stdout\"}\n    config.ErrorOutputPaths = []string{\"stderr\"}\n\n    logger, err := config.Build()\n    if err != nil {\n        panic(err)\n    }\n    defer logger.Sync()\n\n    // Sugared logger is more flexible but slightly slower\n    sugar := logger.Sugar()\n\n    // For high-performance scenarios, use the non-sugared logger\n    logger.Info(\"High-performance logging\",\n        zap.String(\"service\", \"example\"),\n        zap.Int(\"attempt\", 3),\n    )\n\n    // For convenience, use the sugared logger\n    sugar.Infow(\"Convenient logging\",\n        \"service\", \"example\",\n        \"attempt\", 3,\n    )\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/31.%20Logging/#1-use-appropriate-log-levels","title":"1. Use Appropriate Log Levels","text":"<pre><code>package main\n\nimport (\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // Use appropriate log levels\n    logger.Debug(\"Detailed information for debugging\")  // Development only\n    logger.Info(\"General information about application state\")\n    logger.Warn(\"Something unexpected but not critical\")\n    logger.Error(\"An error occurred but the application can continue\")\n    // logger.Fatal(\"A critical error that terminates the application\")\n    // logger.Panic(\"A critical error that terminates with a stack trace\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#2-include-relevant-context","title":"2. Include Relevant Context","text":"<pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // Include relevant context\n        logger.WithFields(logrus.Fields{\n            \"method\": r.Method,\n            \"path\":   r.URL.Path,\n            \"remote\": r.RemoteAddr,\n        }).Info(\"Request received\")\n\n        // Process request...\n    })\n\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#3-log-errors-with-stack-traces","title":"3. Log Errors with Stack Traces","text":"<pre><code>package main\n\nimport (\n    \"errors\"\n    \"runtime/debug\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // Log errors with stack traces\n    err := errors.New(\"something went wrong\")\n    logger.WithFields(logrus.Fields{\n        \"error\": err,\n        \"stack\": string(debug.Stack()),\n    }).Error(\"An error occurred\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#4-avoid-logging-sensitive-information","title":"4. Avoid Logging Sensitive Information","text":"<pre><code>package main\n\nimport (\n    \"github.com/sirupsen/logrus\"\n)\n\ntype User struct {\n    ID       string\n    Username string\n    Password string // Sensitive\n}\n\nfunc main() {\n    logger := logrus.New()\n\n    user := User{\n        ID:       \"123\",\n        Username: \"alice\",\n        Password: \"secret\",\n    }\n\n    // Bad: Logs sensitive information\n    logger.Infof(\"User logged in: %+v\", user)\n\n    // Good: Excludes sensitive information\n    logger.WithFields(logrus.Fields{\n        \"user_id\":  user.ID,\n        \"username\": user.Username,\n    }).Info(\"User logged in\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#5-use-structured-logging-in-production","title":"5. Use Structured Logging in Production","text":"<pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n    logger := logrus.New()\n\n    // Use structured logging in production\n    if os.Getenv(\"ENVIRONMENT\") == \"production\" {\n        logger.SetFormatter(&amp;logrus.JSONFormatter{})\n        logger.SetOutput(os.Stdout)\n    } else {\n        // Use human-readable format in development\n        logger.SetFormatter(&amp;logrus.TextFormatter{\n            FullTimestamp: true,\n            ForceColors:   true,\n        })\n    }\n\n    logger.Info(\"Application started\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#real-world-example-web-application-logging","title":"Real-World Example: Web Application Logging","text":"<p>Let's create a comprehensive example of logging in a web application:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n\n    \"github.com/google/uuid\"\n    \"github.com/gorilla/mux\"\n    \"github.com/sirupsen/logrus\"\n    \"gopkg.in/natefinch/lumberjack.v2\"\n)\n\ntype User struct {\n    ID    string `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\nvar users = []User{\n    {ID: \"1\", Name: \"Alice\", Email: \"alice@example.com\"},\n    {ID: \"2\", Name: \"Bob\", Email: \"bob@example.com\"},\n}\n\nfunc main() {\n    // Set up logger\n    logger := logrus.New()\n\n    // Configure based on environment\n    if os.Getenv(\"ENVIRONMENT\") == \"production\" {\n        logger.SetFormatter(&amp;logrus.JSONFormatter{})\n        logger.SetOutput(&amp;lumberjack.Logger{\n            Filename:   \"app.log\",\n            MaxSize:    100,\n            MaxBackups: 5,\n            MaxAge:     30,\n            Compress:   true,\n        })\n        logger.SetLevel(logrus.InfoLevel)\n    } else {\n        logger.SetFormatter(&amp;logrus.TextFormatter{\n            FullTimestamp: true,\n            ForceColors:   true,\n        })\n        logger.SetLevel(logrus.DebugLevel)\n    }\n\n    // Create router\n    r := mux.NewRouter()\n\n    // Add logging middleware\n    r.Use(loggingMiddleware(logger))\n\n    // Define routes\n    r.HandleFunc(\"/users\", getUsers(logger)).Methods(\"GET\")\n    r.HandleFunc(\"/users/{id}\", getUser(logger)).Methods(\"GET\")\n\n    // Start server\n    server := &amp;http.Server{\n        Addr:         \":8080\",\n        Handler:      r,\n        ReadTimeout:  10 * time.Second,\n        WriteTimeout: 10 * time.Second,\n    }\n\n    logger.Info(\"Starting server on :8080\")\n    if err := server.ListenAndServe(); err != nil {\n        logger.Fatal(\"Server error: \", err)\n    }\n}\n\nfunc loggingMiddleware(logger *logrus.Logger) mux.MiddlewareFunc {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            start := time.Now()\n\n            // Get or create correlation ID\n            correlationID := r.Header.Get(\"X-Correlation-ID\")\n            if correlationID == \"\" {\n                correlationID = uuid.New().String()\n            }\n\n            // Add correlation ID to response header\n            w.Header().Set(\"X-Correlation-ID\", correlationID)\n\n            // Create logger with request context\n            requestLogger := logger.WithFields(logrus.Fields{\n                \"correlation_id\": correlationID,\n                \"method\":         r.Method,\n                \"path\":           r.URL.Path,\n                \"remote_addr\":    r.RemoteAddr,\n                \"user_agent\":     r.UserAgent(),\n            })\n\n            // Log request\n            requestLogger.Info(\"Request received\")\n\n            // Create response recorder to capture status code\n            recorder := &amp;responseRecorder{w, http.StatusOK}\n\n            // Call next handler\n            next.ServeHTTP(recorder, r)\n\n            // Calculate request duration\n            duration := time.Since(start)\n\n            // Log response\n            requestLogger.WithFields(logrus.Fields{\n                \"status\":   recorder.statusCode,\n                \"duration\": duration,\n            }).Info(\"Request completed\")\n        })\n    }\n}\n\ntype responseRecorder struct {\n    http.ResponseWriter\n    statusCode int\n}\n\nfunc (r *responseRecorder) WriteHeader(statusCode int) {\n    r.statusCode = statusCode\n    r.ResponseWriter.WriteHeader(statusCode)\n}\n\nfunc getUsers(logger *logrus.Logger) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        requestLogger := logger.WithField(\"endpoint\", \"getUsers\")\n\n        requestLogger.Debug(\"Retrieving all users\")\n\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(users)\n\n        requestLogger.Info(\"Retrieved all users\")\n    }\n}\n\nfunc getUser(logger *logrus.Logger) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        vars := mux.Vars(r)\n        id := vars[\"id\"]\n\n        requestLogger := logger.WithFields(logrus.Fields{\n            \"endpoint\": \"getUser\",\n            \"user_id\":  id,\n        })\n\n        requestLogger.Debug(\"Retrieving user\")\n\n        for _, user := range users {\n            if user.ID == id {\n                w.Header().Set(\"Content-Type\", \"application/json\")\n                json.NewEncoder(w).Encode(user)\n\n                requestLogger.Info(\"Retrieved user\")\n                return\n            }\n        }\n\n        requestLogger.WithField(\"status\", \"not_found\").Warn(\"User not found\")\n        http.NotFound(w, r)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#how-this-example-demonstrates-logging-concepts","title":"How This Example Demonstrates Logging Concepts:","text":"<ol> <li>Environment-Based Configuration:</li> <li>Different logging formats for development and production</li> <li>Log rotation in production</li> <li> <p>Different log levels for different environments</p> </li> <li> <p>Middleware for Request Logging:</p> </li> <li>Logs incoming requests with relevant context</li> <li>Includes correlation IDs for request tracking</li> <li> <p>Captures response status and duration</p> </li> <li> <p>Contextual Logging:</p> </li> <li>Adds context to log messages (endpoint, user ID, etc.)</li> <li> <p>Uses child loggers for specific operations</p> </li> <li> <p>Structured Logging:</p> </li> <li>Uses key-value pairs for machine-readable logs</li> <li> <p>Consistent format across all log messages</p> </li> <li> <p>Error Handling:</p> </li> <li>Appropriate log levels for different situations</li> <li>Includes relevant context for debugging</li> </ol>"},{"location":"2.%20Intermediate/31.%20Logging/#conclusion","title":"Conclusion","text":"<p>Logging is a critical aspect of application development in Go:</p>"},{"location":"2.%20Intermediate/31.%20Logging/#key-takeaways","title":"Key Takeaways:","text":"<ol> <li>Standard Library:</li> <li>The <code>log</code> package is simple and built-in</li> <li>Suitable for small applications or quick prototyping</li> <li> <p>Limited in features compared to third-party libraries</p> </li> <li> <p>Third-Party Libraries:</p> </li> <li>Logrus provides structured logging with a familiar API</li> <li>Zap offers high performance with minimal allocations</li> <li> <p>Zerolog is designed for zero-allocation logging</p> </li> <li> <p>Structured Logging:</p> </li> <li>Makes logs machine-readable and searchable</li> <li>Enables better filtering and analysis</li> <li> <p>Essential for production environments</p> </li> <li> <p>Best Practices:</p> </li> <li>Use appropriate log levels</li> <li>Include relevant context</li> <li>Avoid logging sensitive information</li> <li>Use structured logging in production</li> <li> <p>Implement log rotation for long-running applications</p> </li> <li> <p>Performance Considerations:</p> </li> <li>Be mindful of the performance impact of logging</li> <li>Use asynchronous logging for high-throughput applications</li> <li>Consider conditional logging to avoid expensive operations</li> </ol> <p>By implementing effective logging practices, you can create more maintainable, debuggable, and monitorable Go applications. Whether you're building a simple CLI tool or a complex web service, proper logging will help you understand and troubleshoot your application's behavior.</p>"},{"location":"2.%20Intermediate/32.%20JSON/","title":"JSON in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/32.%20JSON/#introduction-to-json","title":"Introduction to JSON","text":"<p>JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write and easy for machines to parse and generate. In Go, the <code>encoding/json</code> package provides robust support for working with JSON data.</p>"},{"location":"2.%20Intermediate/32.%20JSON/#basic-json-operations","title":"Basic JSON Operations","text":""},{"location":"2.%20Intermediate/32.%20JSON/#marshaling-go-to-json","title":"Marshaling (Go to JSON)","text":"<p>Marshaling converts Go data structures into JSON format:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n)\n\ntype Person struct {\n    Name  string `json:\"name\"`\n    Age   int    `json:\"age\"`\n    Email string `json:\"email,omitempty\"`\n}\n\nfunc main() {\n    person := Person{\n        Name: \"Alice\",\n        Age:  30,\n        // Email is left empty to demonstrate omitempty\n    }\n\n    // Marshal to JSON\n    jsonData, err := json.Marshal(person)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(jsonData))\n    // Output: {\"name\":\"Alice\",\"age\":30}\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#unmarshaling-json-to-go","title":"Unmarshaling (JSON to Go)","text":"<p>Unmarshaling converts JSON data into Go data structures:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n)\n\ntype Person struct {\n    Name  string `json:\"name\"`\n    Age   int    `json:\"age\"`\n    Email string `json:\"email,omitempty\"`\n}\n\nfunc main() {\n    jsonStr := `{\"name\":\"Bob\",\"age\":25,\"email\":\"bob@example.com\"}`\n\n    var person Person\n    err := json.Unmarshal([]byte(jsonStr), &amp;person)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"%+v\\n\", person)\n    // Output: {Name:Bob Age:25 Email:bob@example.com}\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#struct-tags","title":"Struct Tags","text":"<p>Struct tags provide metadata that control how fields are encoded and decoded:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n)\n\ntype Employee struct {\n    ID        int      `json:\"id\"`\n    FirstName string   `json:\"first_name\"`\n    LastName  string   `json:\"last_name\"`\n    Email     string   `json:\"email,omitempty\"`\n    IsActive  bool     `json:\"is_active\"`\n    Roles     []string `json:\"roles\"`\n    Salary    float64  `json:\"salary,omitempty\"`\n    // Field will be ignored\n    password string `json:\"-\"`\n}\n\nfunc main() {\n    employee := Employee{\n        ID:        1001,\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        IsActive:  true,\n        Roles:     []string{\"admin\", \"developer\"},\n        password:  \"secret\",\n    }\n\n    jsonData, err := json.Marshal(employee)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(jsonData))\n    // Output: {\"id\":1001,\"first_name\":\"John\",\"last_name\":\"Doe\",\"is_active\":true,\"roles\":[\"admin\",\"developer\"]}\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#common-struct-tags","title":"Common Struct Tags","text":"Tag Description <code>json:\"field_name\"</code> Specifies the JSON key name <code>json:\"-\"</code> Omits the field from JSON output <code>json:\"omitempty\"</code> Omits the field if it has a zero value <code>json:\",string\"</code> Encodes the field as a string (useful for numbers)"},{"location":"2.%20Intermediate/32.%20JSON/#working-with-dynamic-json","title":"Working with Dynamic JSON","text":"<p>Sometimes you need to work with JSON that doesn't have a fixed structure:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n)\n\nfunc main() {\n    // JSON with unknown structure\n    jsonStr := `{\n        \"name\": \"Alice\",\n        \"age\": 30,\n        \"address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"New York\"\n        },\n        \"hobbies\": [\"reading\", \"hiking\"]\n    }`\n\n    // Unmarshal into map[string]interface{}\n    var data map[string]interface{}\n    err := json.Unmarshal([]byte(jsonStr), &amp;data)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Access data dynamically\n    fmt.Println(\"Name:\", data[\"name\"])\n    fmt.Println(\"Age:\", data[\"age\"])\n\n    // Type assertion for nested objects\n    if address, ok := data[\"address\"].(map[string]interface{}); ok {\n        fmt.Println(\"City:\", address[\"city\"])\n    }\n\n    // Type assertion for arrays\n    if hobbies, ok := data[\"hobbies\"].([]interface{}); ok {\n        fmt.Println(\"First hobby:\", hobbies[0])\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#custom-marshaling-and-unmarshaling","title":"Custom Marshaling and Unmarshaling","text":"<p>You can implement custom JSON encoding and decoding by implementing the <code>json.Marshaler</code> and <code>json.Unmarshaler</code> interfaces:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"strings\"\n    \"time\"\n)\n\ntype Date struct {\n    time.Time\n}\n\n// Implement Marshaler interface\nfunc (d Date) MarshalJSON() ([]byte, error) {\n    return json.Marshal(d.Time.Format(\"2006-01-02\"))\n}\n\n// Implement Unmarshaler interface\nfunc (d *Date) UnmarshalJSON(data []byte) error {\n    var s string\n    if err := json.Unmarshal(data, &amp;s); err != nil {\n        return err\n    }\n\n    t, err := time.Parse(\"2006-01-02\", s)\n    if err != nil {\n        return err\n    }\n\n    d.Time = t\n    return nil\n}\n\ntype Event struct {\n    Name string `json:\"name\"`\n    Date Date   `json:\"date\"`\n}\n\nfunc main() {\n    // Custom marshaling\n    event := Event{\n        Name: \"Conference\",\n        Date: Date{time.Date(2023, 10, 15, 0, 0, 0, 0, time.UTC)},\n    }\n\n    jsonData, err := json.Marshal(event)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(string(jsonData))\n    // Output: {\"name\":\"Conference\",\"date\":\"2023-10-15\"}\n\n    // Custom unmarshaling\n    jsonStr := `{\"name\":\"Meeting\",\"date\":\"2023-11-20\"}`\n    var newEvent Event\n    err = json.Unmarshal([]byte(jsonStr), &amp;newEvent)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"%+v\\n\", newEvent)\n    // Output: {Name:Meeting Date:{Time:2023-11-20 00:00:00 +0000 UTC}}\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#streaming-json","title":"Streaming JSON","text":"<p>For large JSON documents, streaming can be more memory-efficient:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n)\n\ntype Product struct {\n    ID    int     `json:\"id\"`\n    Name  string  `json:\"name\"`\n    Price float64 `json:\"price\"`\n}\n\nfunc main() {\n    // Create a file for demonstration\n    file, err := os.Create(\"products.json\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n\n    // Create a JSON encoder\n    encoder := json.NewEncoder(file)\n\n    // Write multiple JSON objects\n    products := []Product{\n        {ID: 1, Name: \"Laptop\", Price: 999.99},\n        {ID: 2, Name: \"Phone\", Price: 699.99},\n        {ID: 3, Name: \"Tablet\", Price: 399.99},\n    }\n\n    // Write as a JSON array\n    err = encoder.Encode(products)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Reset file position for reading\n    _, err = file.Seek(0, 0)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create a JSON decoder\n    decoder := json.NewDecoder(file)\n\n    // Read the JSON array\n    var decodedProducts []Product\n    err = decoder.Decode(&amp;decodedProducts)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"%+v\\n\", decodedProducts)\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#working-with-json-in-web-applications","title":"Working with JSON in Web Applications","text":"<p>JSON is commonly used in web applications for APIs:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n)\n\ntype User struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\nvar users = []User{\n    {ID: 1, Name: \"Alice\", Email: \"alice@example.com\"},\n    {ID: 2, Name: \"Bob\", Email: \"bob@example.com\"},\n}\n\nfunc main() {\n    http.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(users)\n    })\n\n    http.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n        // Parse JSON from request body\n        var newUser User\n        err := json.NewDecoder(r.Body).Decode(&amp;newUser)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusBadRequest)\n            return\n        }\n\n        // Add new user\n        newUser.ID = len(users) + 1\n        users = append(users, newUser)\n\n        // Return the created user\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusCreated)\n        json.NewEncoder(w).Encode(newUser)\n    })\n\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#handling-json-errors","title":"Handling JSON Errors","text":"<p>Proper error handling is crucial when working with JSON:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n)\n\nfunc main() {\n    // Invalid JSON\n    invalidJSON := `{\"name\": \"Alice\", \"age\": 30,` // Missing closing brace\n\n    var person struct {\n        Name string `json:\"name\"`\n        Age  int    `json:\"age\"`\n    }\n\n    err := json.Unmarshal([]byte(invalidJSON), &amp;person)\n    if err != nil {\n        // Type assertion to get more details about the error\n        if syntaxErr, ok := err.(*json.SyntaxError); ok {\n            fmt.Printf(\"Syntax error at offset %d: %v\\n\", syntaxErr.Offset, syntaxErr)\n        } else if unmarshalErr, ok := err.(*json.UnmarshalTypeError); ok {\n            fmt.Printf(\"Unmarshal type error: field %s, value %v, expected %v\\n\", \n                unmarshalErr.Field, unmarshalErr.Value, unmarshalErr.Type)\n        } else {\n            fmt.Printf(\"Error unmarshaling JSON: %v\\n\", err)\n        }\n        return\n    }\n\n    fmt.Printf(\"%+v\\n\", person)\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#pretty-printing-json","title":"Pretty-Printing JSON","text":"<p>For debugging or display purposes, you might want to format JSON:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype Person struct {\n    Name  string   `json:\"name\"`\n    Age   int      `json:\"age\"`\n    Hobbies []string `json:\"hobbies\"`\n}\n\nfunc main() {\n    person := Person{\n        Name:    \"Alice\",\n        Age:     30,\n        Hobbies: []string{\"reading\", \"hiking\", \"coding\"},\n    }\n\n    // Marshal with indentation\n    jsonData, err := json.MarshalIndent(person, \"\", \"  \")\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(string(jsonData))\n    /*\n    Output:\n    {\n      \"name\": \"Alice\",\n      \"age\": 30,\n      \"hobbies\": [\n        \"reading\",\n        \"hiking\",\n        \"coding\"\n      ]\n    }\n    */\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#working-with-json-numbers","title":"Working with JSON Numbers","text":"<p>JSON doesn't distinguish between integer and floating-point numbers, but Go does:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"strings\"\n)\n\nfunc main() {\n    // JSON with numbers\n    jsonStr := `{\"count\": 42, \"price\": 19.99, \"big_number\": 1234567890123456789}`\n\n    // Use json.Number to preserve exact representation\n    var data map[string]json.Number\n    err := json.Unmarshal([]byte(jsonStr), &amp;data)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Access numbers\n    count, err := data[\"count\"].Int64()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    price, err := data[\"price\"].Float64()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    bigNumber := data[\"big_number\"].String()\n\n    fmt.Printf(\"Count: %d\\n\", count)\n    fmt.Printf(\"Price: %f\\n\", price)\n    fmt.Printf(\"Big Number: %s\\n\", bigNumber)\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#json-and-time","title":"JSON and Time","text":"<p>Time values require special handling in JSON:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"time\"\n)\n\ntype Event struct {\n    Name      string    `json:\"name\"`\n    Timestamp time.Time `json:\"timestamp\"`\n}\n\nfunc main() {\n    // Default time format\n    event := Event{\n        Name:      \"Conference\",\n        Timestamp: time.Date(2023, 10, 15, 9, 30, 0, 0, time.UTC),\n    }\n\n    jsonData, err := json.Marshal(event)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(\"Default time format:\", string(jsonData))\n    // Output: {\"name\":\"Conference\",\"timestamp\":\"2023-10-15T09:30:00Z\"}\n\n    // Custom time format\n    type CustomEvent struct {\n        Name      string `json:\"name\"`\n        Timestamp string `json:\"timestamp\"`\n    }\n\n    customEvent := CustomEvent{\n        Name:      \"Meeting\",\n        Timestamp: \"2023-11-20 14:00:00\",\n    }\n\n    customJsonData, err := json.Marshal(customEvent)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(\"Custom time format:\", string(customJsonData))\n    // Output: {\"name\":\"Meeting\",\"timestamp\":\"2023-11-20 14:00:00\"}\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#real-world-example-rest-api-client","title":"Real-World Example: REST API Client","text":"<p>Let's create a more comprehensive example that demonstrates various JSON handling techniques:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"time\"\n)\n\n// Post represents a blog post\ntype Post struct {\n    ID        int       `json:\"id\"`\n    Title     string    `json:\"title\"`\n    Body      string    `json:\"body\"`\n    UserID    int       `json:\"userId\"`\n    CreatedAt time.Time `json:\"createdAt\"`\n    UpdatedAt time.Time `json:\"updatedAt\"`\n}\n\n// Comment represents a comment on a post\ntype Comment struct {\n    ID        int    `json:\"id\"`\n    PostID    int    `json:\"postId\"`\n    Name      string `json:\"name\"`\n    Email     string `json:\"email\"`\n    Body      string `json:\"body\"`\n}\n\n// PostWithComments combines a post with its comments\ntype PostWithComments struct {\n    Post     Post      `json:\"post\"`\n    Comments []Comment `json:\"comments\"`\n}\n\n// Custom UnmarshalJSON for Post to handle date parsing\nfunc (p *Post) UnmarshalJSON(data []byte) error {\n    type Alias Post\n    aux := &amp;struct {\n        CreatedAt string `json:\"createdAt\"`\n        UpdatedAt string `json:\"updatedAt\"`\n        *Alias\n    }{\n        Alias: (*Alias)(p),\n    }\n\n    if err := json.Unmarshal(data, &amp;aux); err != nil {\n        return err\n    }\n\n    // Parse dates\n    var err error\n    p.CreatedAt, err = time.Parse(time.RFC3339, aux.CreatedAt)\n    if err != nil {\n        return err\n    }\n\n    p.UpdatedAt, err = time.Parse(time.RFC3339, aux.UpdatedAt)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n\nfunc main() {\n    // Fetch a post from JSONPlaceholder API\n    resp, err := http.Get(\"https://jsonplaceholder.typicode.com/posts/1\")\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        panic(err)\n    }\n\n    var post Post\n    err = json.Unmarshal(body, &amp;post)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Post: %+v\\n\", post)\n\n    // Fetch comments for the post\n    commentsURL := fmt.Sprintf(\"https://jsonplaceholder.typicode.com/posts/%d/comments\", post.ID)\n    resp, err = http.Get(commentsURL)\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n\n    body, err = io.ReadAll(resp.Body)\n    if err != nil {\n        panic(err)\n    }\n\n    var comments []Comment\n    err = json.Unmarshal(body, &amp;comments)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Found %d comments\\n\", len(comments))\n\n    // Combine post and comments\n    postWithComments := PostWithComments{\n        Post:     post,\n        Comments: comments,\n    }\n\n    // Marshal to JSON with indentation\n    jsonData, err := json.MarshalIndent(postWithComments, \"\", \"  \")\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(\"Post with comments:\")\n    fmt.Println(string(jsonData))\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#how-this-example-demonstrates-json-concepts","title":"How This Example Demonstrates JSON Concepts:","text":"<ol> <li>Custom Unmarshaling:</li> <li>Implements <code>UnmarshalJSON</code> to handle date parsing</li> <li> <p>Uses an alias type to avoid infinite recursion</p> </li> <li> <p>API Integration:</p> </li> <li>Fetches JSON data from a REST API</li> <li> <p>Handles HTTP responses and errors</p> </li> <li> <p>Data Transformation:</p> </li> <li>Combines multiple API responses into a single structure</li> <li> <p>Creates a new JSON representation of the combined data</p> </li> <li> <p>Pretty-Printing:</p> </li> <li>Uses <code>json.MarshalIndent</code> for readable output</li> <li>Demonstrates formatting JSON for display</li> </ol>"},{"location":"2.%20Intermediate/32.%20JSON/#best-practices-for-json-in-go","title":"Best Practices for JSON in Go","text":""},{"location":"2.%20Intermediate/32.%20JSON/#1-use-struct-tags-effectively","title":"1. Use Struct Tags Effectively","text":"<pre><code>type User struct {\n    ID       int    `json:\"id\"`\n    Username string `json:\"username\"`\n    Email    string `json:\"email,omitempty\"`\n    Password string `json:\"-\"` // Never expose passwords\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#2-handle-errors-gracefully","title":"2. Handle Errors Gracefully","text":"<pre><code>func handleJSON(w http.ResponseWriter, r *http.Request) {\n    var data Data\n    if err := json.NewDecoder(r.Body).Decode(&amp;data); err != nil {\n        http.Error(w, \"Invalid JSON\", http.StatusBadRequest)\n        return\n    }\n\n    // Process data...\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#3-use-pointers-for-optional-fields","title":"3. Use Pointers for Optional Fields","text":"<pre><code>type Config struct {\n    Timeout *int `json:\"timeout,omitempty\"`\n    // This allows distinguishing between \"not provided\" and \"provided as 0\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#4-consider-performance-for-large-data","title":"4. Consider Performance for Large Data","text":"<pre><code>// For large JSON payloads, use streaming\nfunc processLargeJSON(r io.Reader) error {\n    decoder := json.NewDecoder(r)\n\n    // Use a streaming approach\n    for {\n        var item Item\n        if err := decoder.Decode(&amp;item); err != nil {\n            if err == io.EOF {\n                break\n            }\n            return err\n        }\n\n        // Process item\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#5-validate-json-input","title":"5. Validate JSON Input","text":"<pre><code>func validateUserJSON(jsonData []byte) error {\n    var user User\n    if err := json.Unmarshal(jsonData, &amp;user); err != nil {\n        return err\n    }\n\n    if user.Name == \"\" {\n        return errors.New(\"name is required\")\n    }\n\n    if user.Age &lt; 0 || user.Age &gt; 120 {\n        return errors.New(\"invalid age\")\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":""},{"location":"2.%20Intermediate/32.%20JSON/#1-case-sensitivity","title":"1. Case Sensitivity","text":"<p>JSON field names are case-sensitive, but Go struct tags can handle this:</p> <pre><code>type Person struct {\n    FirstName string `json:\"firstName\"` // Maps to JSON \"firstName\"\n    LastName  string `json:\"lastName\"`  // Maps to JSON \"lastName\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#2-zero-values-vs-omitted-fields","title":"2. Zero Values vs. Omitted Fields","text":"<p>Use <code>omitempty</code> to omit fields with zero values:</p> <pre><code>type User struct {\n    Name  string `json:\"name\"`\n    Email string `json:\"email,omitempty\"` // Omitted if empty\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#3-unexported-fields","title":"3. Unexported Fields","text":"<p>Unexported fields (lowercase) are not marshaled:</p> <pre><code>type User struct {\n    Name     string `json:\"name\"`\n    password string `json:\"-\"` // Explicitly ignored\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#4-time-handling","title":"4. Time Handling","text":"<p>Time values require special handling:</p> <pre><code>type Event struct {\n    Time time.Time `json:\"time\"`\n}\n\n// Default format is RFC3339\n// For custom formats, implement custom marshaling\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#5-numeric-precision","title":"5. Numeric Precision","text":"<p>For large numbers, use <code>json.Number</code>:</p> <pre><code>type Data struct {\n    ID json.Number `json:\"id\"`\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#conclusion","title":"Conclusion","text":"<p>JSON handling in Go is powerful and flexible:</p>"},{"location":"2.%20Intermediate/32.%20JSON/#key-takeaways","title":"Key Takeaways:","text":"<ol> <li>Basic Operations:</li> <li>Use <code>json.Marshal</code> and <code>json.Unmarshal</code> for simple cases</li> <li> <p>Struct tags control JSON field names and behavior</p> </li> <li> <p>Advanced Techniques:</p> </li> <li>Implement custom marshaling/unmarshaling for special cases</li> <li>Use streaming for large JSON documents</li> <li> <p>Handle dynamic JSON with <code>interface{}</code> or <code>map[string]interface{}</code></p> </li> <li> <p>Web Applications:</p> </li> <li>JSON is the standard for REST APIs</li> <li> <p>Use <code>json.Encoder</code> and <code>json.Decoder</code> for HTTP request/response handling</p> </li> <li> <p>Best Practices:</p> </li> <li>Use struct tags effectively</li> <li>Handle errors gracefully</li> <li>Consider performance for large data</li> <li> <p>Validate JSON input</p> </li> <li> <p>Common Pitfalls:</p> </li> <li>Be aware of case sensitivity</li> <li>Understand zero values vs. omitted fields</li> <li>Remember that unexported fields are ignored</li> <li>Handle time values carefully</li> <li>Use <code>json.Number</code> for large integers</li> </ol> <p>By mastering JSON handling in Go, you can effectively work with APIs, configuration files, and data interchange in your applications. The <code>encoding/json</code> package provides all the tools you need for robust JSON processing.</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/","title":"Struct Tags in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/33.%20Struct-Tags/#introduction-to-struct-tags","title":"Introduction to Struct Tags","text":"<p>Struct tags in Go are metadata attached to struct fields that provide additional information to other code about how to handle those fields. They are string literals placed after the field type in a struct definition, enclosed in backticks.</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#basic-syntax","title":"Basic Syntax","text":"<pre><code>type User struct {\n    ID        int    `json:\"id\" db:\"user_id\"`\n    Username  string `json:\"username\" db:\"username\" validate:\"required\"`\n    Email     string `json:\"email,omitempty\" db:\"email\" validate:\"required,email\"`\n    Password  string `json:\"-\" db:\"password_hash\"` // \"-\" means ignore in JSON\n    CreatedAt time.Time `json:\"created_at\" db:\"created_at\"`\n}\n</code></pre> <p>Struct tags follow the format: <pre><code>`key:\"value\" key2:\"value2\"`\n</code></pre></p> <p>The key is typically the name of the package or tool that will use the tag, and the value is the configuration for that tool.</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#common-uses-of-struct-tags","title":"Common Uses of Struct Tags","text":""},{"location":"2.%20Intermediate/33.%20Struct-Tags/#1-json-encodingdecoding","title":"1. JSON Encoding/Decoding","text":"<p>The <code>encoding/json</code> package uses struct tags to control how structs are converted to and from JSON.</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n)\n\ntype Person struct {\n    FirstName string `json:\"first_name\"`\n    LastName  string `json:\"last_name\"`\n    Age       int    `json:\"age,omitempty\"`\n    Password  string `json:\"-\"` // This field will be ignored\n}\n\nfunc main() {\n    person := Person{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        Age:       0, // Will be omitted due to omitempty\n        Password:  \"secret\",\n    }\n\n    jsonData, err := json.Marshal(person)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(jsonData))\n    // Output: {\"first_name\":\"John\",\"last_name\":\"Doe\"}\n}\n</code></pre> <p>Common JSON struct tags: - <code>json:\"field_name\"</code> - Specifies the JSON key name - <code>json:\"-\"</code> - Omits the field from JSON output - <code>json:\"omitempty\"</code> - Omits the field if it has a zero value - <code>json:\",string\"</code> - Encodes the field as a string (useful for numbers)</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#2-xml-encodingdecoding","title":"2. XML Encoding/Decoding","text":"<p>Similar to JSON, the <code>encoding/xml</code> package uses struct tags for XML conversion.</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"log\"\n)\n\ntype Person struct {\n    XMLName   xml.Name `xml:\"person\"`\n    FirstName string   `xml:\"firstName\"`\n    LastName  string   `xml:\"lastName\"`\n    Age       int      `xml:\"age,omitempty\"`\n}\n\nfunc main() {\n    person := Person{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n    }\n\n    xmlData, err := xml.Marshal(person)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(xmlData))\n    // Output: &lt;person&gt;&lt;firstName&gt;John&lt;/firstName&gt;&lt;lastName&gt;Doe&lt;/lastName&gt;&lt;/person&gt;\n}\n</code></pre> <p>Common XML struct tags: - <code>xml:\"element_name\"</code> - Specifies the XML element name - <code>xml:\"-\"</code> - Omits the field - <code>xml:\",attr\"</code> - Encodes the field as an attribute - <code>xml:\",chardata\"</code> - Encodes the field as character data - <code>xml:\",omitempty\"</code> - Omits the field if it has a zero value - <code>xml:\",innerxml\"</code> - Uses the raw XML</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#3-database-mapping","title":"3. Database Mapping","text":"<p>Struct tags are commonly used with database libraries to map struct fields to database columns.</p> <pre><code>package main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n\n    _ \"github.com/lib/pq\"\n)\n\ntype User struct {\n    ID        int       `db:\"id\"`\n    Username  string    `db:\"username\"`\n    Email     string    `db:\"email\"`\n    CreatedAt time.Time `db:\"created_at\"`\n}\n\nfunc main() {\n    db, err := sql.Open(\"postgres\", \"user=postgres dbname=test sslmode=disable\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n\n    rows, err := db.Query(\"SELECT id, username, email, created_at FROM users WHERE id = $1\", 1)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer rows.Close()\n\n    for rows.Next() {\n        var user User\n        err := rows.Scan(&amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.CreatedAt)\n        if err != nil {\n            log.Fatal(err)\n        }\n        fmt.Printf(\"%+v\\n\", user)\n    }\n}\n</code></pre> <p>With ORM libraries like GORM, struct tags provide even more functionality:</p> <pre><code>package main\n\nimport (\n    \"time\"\n\n    \"gorm.io/driver/sqlite\"\n    \"gorm.io/gorm\"\n)\n\ntype User struct {\n    ID        uint      `gorm:\"primaryKey\"`\n    Username  string    `gorm:\"uniqueIndex;size:255\"`\n    Email     string    `gorm:\"uniqueIndex;size:255\"`\n    Password  string    `gorm:\"size:255\"`\n    CreatedAt time.Time `gorm:\"autoCreateTime\"`\n    UpdatedAt time.Time `gorm:\"autoUpdateTime\"`\n    DeletedAt gorm.DeletedAt `gorm:\"index\"`\n}\n\nfunc main() {\n    db, err := gorm.Open(sqlite.Open(\"test.db\"), &amp;gorm.Config{})\n    if err != nil {\n        panic(\"failed to connect database\")\n    }\n\n    // Auto migrate the schema\n    db.AutoMigrate(&amp;User{})\n}\n</code></pre> <p>Common GORM struct tags: - <code>gorm:\"primaryKey\"</code> - Marks the field as primary key - <code>gorm:\"uniqueIndex\"</code> - Creates a unique index - <code>gorm:\"index\"</code> - Creates an index - <code>gorm:\"size:n\"</code> - Specifies the column size - <code>gorm:\"not null\"</code> - Marks the column as NOT NULL - <code>gorm:\"autoCreateTime\"</code> - Automatically sets the creation time - <code>gorm:\"autoUpdateTime\"</code> - Automatically updates the modification time</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#4-validation","title":"4. Validation","text":"<p>Struct tags are used with validation libraries to define validation rules.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/go-playground/validator/v10\"\n)\n\ntype User struct {\n    Username string `validate:\"required,min=3,max=20\"`\n    Email    string `validate:\"required,email\"`\n    Age      int    `validate:\"gte=18\"`\n    Password string `validate:\"required,min=8\"`\n}\n\nfunc main() {\n    validate := validator.New()\n\n    user := User{\n        Username: \"ab\",        // Too short\n        Email:    \"invalid\",   // Invalid email\n        Age:      16,          // Too young\n        Password: \"short\",     // Too short\n    }\n\n    err := validate.Struct(user)\n    if err != nil {\n        // Validation failed\n        for _, e := range err.(validator.ValidationErrors) {\n            fmt.Printf(\"Field %s failed validation: %s\\n\", e.Field(), e.Tag())\n        }\n    }\n}\n</code></pre> <p>Common validation tags: - <code>validate:\"required\"</code> - Field is required - <code>validate:\"min=n\"</code> - Minimum length or value - <code>validate:\"max=n\"</code> - Maximum length or value - <code>validate:\"email\"</code> - Must be a valid email - <code>validate:\"gte=n\"</code> - Greater than or equal to n - <code>validate:\"lte=n\"</code> - Less than or equal to n - <code>validate:\"oneof=a b c\"</code> - Must be one of the specified values</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#5-configuration-management","title":"5. Configuration Management","text":"<p>Struct tags can be used with configuration libraries to map environment variables or config files to struct fields.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/spf13/viper\"\n)\n\ntype Config struct {\n    ServerPort int    `mapstructure:\"server_port\"`\n    DatabaseURL string `mapstructure:\"database_url\"`\n    DebugMode  bool   `mapstructure:\"debug_mode\"`\n}\n\nfunc main() {\n    viper.SetConfigName(\"config\")\n    viper.SetConfigType(\"yaml\")\n    viper.AddConfigPath(\".\")\n\n    if err := viper.ReadInConfig(); err != nil {\n        panic(fmt.Errorf(\"fatal error config file: %w\", err))\n    }\n\n    var config Config\n    if err := viper.Unmarshal(&amp;config); err != nil {\n        panic(fmt.Errorf(\"unable to decode config: %w\", err))\n    }\n\n    fmt.Printf(\"%+v\\n\", config)\n}\n</code></pre>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#custom-struct-tags-and-reflection","title":"Custom Struct Tags and Reflection","text":"<p>You can create your own struct tags and use reflection to read them.</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#reading-struct-tags-with-reflection","title":"Reading Struct Tags with Reflection","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"strings\"\n)\n\ntype Person struct {\n    Name string `mytag:\"name\" other:\"value\"`\n    Age  int    `mytag:\"age\"`\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 30}\n\n    // Get the type of the struct\n    t := reflect.TypeOf(p)\n\n    // Iterate over the fields\n    for i := 0; i &lt; t.NumField(); i++ {\n        field := t.Field(i)\n\n        // Get the tag value for \"mytag\"\n        tag := field.Tag.Get(\"mytag\")\n        if tag != \"\" {\n            fmt.Printf(\"Field %s has mytag: %s\\n\", field.Name, tag)\n        }\n\n        // Get all tags\n        tags := field.Tag\n        fmt.Printf(\"All tags for field %s: %s\\n\", field.Name, tags)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#parsing-custom-struct-tags","title":"Parsing Custom Struct Tags","text":"<p>You can create your own parser for custom struct tags:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"strings\"\n)\n\ntype Person struct {\n    Name string `custom:\"name;required\"`\n    Age  int    `custom:\"age;min=18\"`\n}\n\nfunc parseCustomTag(tag string) map[string]string {\n    result := make(map[string]string)\n\n    parts := strings.Split(tag, \";\")\n    for _, part := range parts {\n        kv := strings.SplitN(part, \"=\", 2)\n        if len(kv) == 1 {\n            result[kv[0]] = \"\"\n        } else {\n            result[kv[0]] = kv[1]\n        }\n    }\n\n    return result\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 30}\n\n    t := reflect.TypeOf(p)\n\n    for i := 0; i &lt; t.NumField(); i++ {\n        field := t.Field(i)\n        customTag := field.Tag.Get(\"custom\")\n\n        if customTag != \"\" {\n            parsed := parseCustomTag(customTag)\n            fmt.Printf(\"Field %s has custom tag: %v\\n\", field.Name, parsed)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#implementing-custom-validation-with-struct-tags","title":"Implementing Custom Validation with Struct Tags","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype User struct {\n    Username string `validate:\"required,min=3,max=20\"`\n    Email    string `validate:\"required,email\"`\n    Age      int    `validate:\"gte=18\"`\n}\n\ntype ValidationRule struct {\n    Name  string\n    Value string\n}\n\nfunc parseValidationTag(tag string) []ValidationRule {\n    var rules []ValidationRule\n\n    parts := strings.Split(tag, \",\")\n    for _, part := range parts {\n        kv := strings.SplitN(part, \"=\", 2)\n        if len(kv) == 1 {\n            rules = append(rules, ValidationRule{Name: kv[0]})\n        } else {\n            rules = append(rules, ValidationRule{Name: kv[0], Value: kv[1]})\n        }\n    }\n\n    return rules\n}\n\nfunc validateStruct(s interface{}) error {\n    v := reflect.ValueOf(s)\n    if v.Kind() == reflect.Ptr {\n        v = v.Elem()\n    }\n\n    if v.Kind() != reflect.Struct {\n        return fmt.Errorf(\"input is not a struct\")\n    }\n\n    t := v.Type()\n\n    for i := 0; i &lt; t.NumField(); i++ {\n        field := t.Field(i)\n        fieldValue := v.Field(i)\n\n        validateTag := field.Tag.Get(\"validate\")\n        if validateTag == \"\" {\n            continue\n        }\n\n        rules := parseValidationTag(validateTag)\n\n        for _, rule := range rules {\n            switch rule.Name {\n            case \"required\":\n                if isZero(fieldValue) {\n                    return fmt.Errorf(\"%s is required\", field.Name)\n                }\n            case \"min\":\n                min, err := strconv.Atoi(rule.Value)\n                if err != nil {\n                    return fmt.Errorf(\"invalid min value for %s\", field.Name)\n                }\n\n                switch fieldValue.Kind() {\n                case reflect.String:\n                    if len(fieldValue.String()) &lt; min {\n                        return fmt.Errorf(\"%s must be at least %d characters\", field.Name, min)\n                    }\n                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n                    if fieldValue.Int() &lt; int64(min) {\n                        return fmt.Errorf(\"%s must be at least %d\", field.Name, min)\n                    }\n                }\n            case \"max\":\n                max, err := strconv.Atoi(rule.Value)\n                if err != nil {\n                    return fmt.Errorf(\"invalid max value for %s\", field.Name)\n                }\n\n                switch fieldValue.Kind() {\n                case reflect.String:\n                    if len(fieldValue.String()) &gt; max {\n                        return fmt.Errorf(\"%s must be at most %d characters\", field.Name, max)\n                    }\n                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n                    if fieldValue.Int() &gt; int64(max) {\n                        return fmt.Errorf(\"%s must be at most %d\", field.Name, max)\n                    }\n                }\n            case \"email\":\n                // Simple email validation\n                email := fieldValue.String()\n                if !strings.Contains(email, \"@\") || !strings.Contains(email, \".\") {\n                    return fmt.Errorf(\"%s must be a valid email\", field.Name)\n                }\n            case \"gte\":\n                min, err := strconv.Atoi(rule.Value)\n                if err != nil {\n                    return fmt.Errorf(\"invalid gte value for %s\", field.Name)\n                }\n\n                if fieldValue.Kind() == reflect.Int || fieldValue.Kind() == reflect.Int64 {\n                    if fieldValue.Int() &lt; int64(min) {\n                        return fmt.Errorf(\"%s must be greater than or equal to %d\", field.Name, min)\n                    }\n                }\n            }\n        }\n    }\n\n    return nil\n}\n\nfunc isZero(v reflect.Value) bool {\n    switch v.Kind() {\n    case reflect.String:\n        return v.String() == \"\"\n    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n        return v.Int() == 0\n    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n        return v.Uint() == 0\n    case reflect.Float32, reflect.Float64:\n        return v.Float() == 0\n    case reflect.Ptr, reflect.Map, reflect.Slice, reflect.Interface:\n        return v.IsNil()\n    case reflect.Struct:\n        // For structs, check if all fields are zero\n        for i := 0; i &lt; v.NumField(); i++ {\n            if !isZero(v.Field(i)) {\n                return false\n            }\n        }\n        return true\n    }\n    return false\n}\n\nfunc main() {\n    user := User{\n        Username: \"ab\",        // Too short\n        Email:    \"invalid\",   // Invalid email\n        Age:      16,          // Too young\n    }\n\n    err := validateStruct(user)\n    if err != nil {\n        fmt.Println(\"Validation errors:\")\n        fmt.Println(err)\n    } else {\n        fmt.Println(\"Validation passed\")\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#best-practices-and-common-pitfalls","title":"Best Practices and Common Pitfalls","text":""},{"location":"2.%20Intermediate/33.%20Struct-Tags/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use Descriptive Tag Names <pre><code>// Good\ntype User struct {\n    Username string `json:\"username\" db:\"username\" validate:\"required,min=3,max=20\"`\n}\n\n// Bad\ntype User struct {\n    Username string `j:\"username\" d:\"username\" v:\"required,min=3,max=20\"`\n}\n</code></pre></p> </li> <li> <p>Keep Tags Organized <pre><code>// Good - consistent ordering\ntype User struct {\n    Username string `json:\"username\" db:\"username\" validate:\"required,min=3,max=20\"`\n    Email    string `json:\"email\" db:\"email\" validate:\"required,email\"`\n}\n\n// Bad - inconsistent ordering\ntype User struct {\n    Username string `validate:\"required,min=3,max=20\" json:\"username\" db:\"username\"`\n    Email    string `db:\"email\" validate:\"required,email\" json:\"email\"`\n}\n</code></pre></p> </li> <li> <p>Use Multiple Tags for Different Purposes <pre><code>type User struct {\n    Password string `json:\"-\" db:\"password_hash\" validate:\"required,min=8\"`\n}\n</code></pre></p> </li> <li> <p>Document Custom Tags <pre><code>// Custom tag for our application\n// format: \"permission:read|write|admin\"\ntype Resource struct {\n    Name string `access:\"permission:read\"`\n}\n</code></pre></p> </li> <li> <p>Handle Tag Parsing Errors Gracefully <pre><code>func parseTag(tag string) (map[string]string, error) {\n    // Implementation with error handling\n}\n</code></pre></p> </li> </ol>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li> <p>Incorrect Tag Syntax <pre><code>// Wrong - missing quotes\ntype User struct {\n    Username string `json:username`\n}\n\n// Correct\ntype User struct {\n    Username string `json:\"username\"`\n}\n</code></pre></p> </li> <li> <p>Case Sensitivity <pre><code>// JSON field names are case-sensitive\ntype User struct {\n    Username string `json:\"username\"` // Correct\n    // Username string `json:\"UserName\"` // Different field name\n}\n</code></pre></p> </li> <li> <p>Forgetting omitempty <pre><code>// Without omitempty, zero values will be included\ntype User struct {\n    Age int `json:\"age\"` // Will include \"age\": 0 even if not set\n}\n\n// With omitempty\ntype User struct {\n    Age int `json:\"age,omitempty\"` // Will omit age if 0\n}\n</code></pre></p> </li> <li> <p>Mixing Tag Formats <pre><code>// Inconsistent tag formats\ntype User struct {\n    Username string `json:\"username\" validate:\"required\"`\n    Email    string `validate:\"required,email\" json:\"email\"` // Different order\n}\n</code></pre></p> </li> <li> <p>Overusing Custom Tags <pre><code>// Sometimes simpler is better\ntype User struct {\n    Username string `myapp:\"username;required;min=3;max=20\"`\n}\n\n// Consider using a standard library or a more established approach\ntype User struct {\n    Username string `json:\"username\" validate:\"required,min=3,max=20\"`\n}\n</code></pre></p> </li> </ol>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#real-world-example-complete-application-with-struct-tags","title":"Real-World Example: Complete Application with Struct Tags","text":"<p>Let's create a comprehensive example that demonstrates various uses of struct tags in a web application:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"time\"\n\n    \"github.com/go-playground/validator/v10\"\n    \"github.com/gorilla/mux\"\n    \"gorm.io/driver/sqlite\"\n    \"gorm.io/gorm\"\n)\n\n// User model with multiple struct tags\ntype User struct {\n    ID        uint           `json:\"id\" gorm:\"primaryKey\" example:\"1\"`\n    Username  string         `json:\"username\" gorm:\"uniqueIndex;size:255\" validate:\"required,min=3,max=20\" example:\"johndoe\"`\n    Email     string         `json:\"email\" gorm:\"uniqueIndex;size:255\" validate:\"required,email\" example:\"john@example.com\"`\n    Password  string         `json:\"-\" gorm:\"size:255\" validate:\"required,min=8\"`\n    Age       int            `json:\"age\" validate:\"gte=18\" example:\"30\"`\n    IsActive  bool           `json:\"is_active\" gorm:\"default:true\" example:\"true\"`\n    CreatedAt time.Time      `json:\"created_at\" gorm:\"autoCreateTime\"`\n    UpdatedAt time.Time      `json:\"updated_at\" gorm:\"autoUpdateTime\"`\n    DeletedAt gorm.DeletedAt `json:\"deleted_at,omitempty\" gorm:\"index\"`\n}\n\n// UserRequest represents a user creation/update request\ntype UserRequest struct {\n    Username string `json:\"username\" validate:\"required,min=3,max=20\"`\n    Email    string `json:\"email\" validate:\"required,email\"`\n    Password string `json:\"password\" validate:\"required,min=8\"`\n    Age      int    `json:\"age\" validate:\"gte=18\"`\n}\n\n// UserResponse represents a user response (without password)\ntype UserResponse struct {\n    ID        uint      `json:\"id\"`\n    Username  string    `json:\"username\"`\n    Email     string    `json:\"email\"`\n    Age       int       `json:\"age\"`\n    IsActive  bool      `json:\"is_active\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n\nvar (\n    db       *gorm.DB\n    validate = validator.New()\n)\n\nfunc main() {\n    // Initialize database\n    var err error\n    db, err = gorm.Open(sqlite.Open(\"test.db\"), &amp;gorm.Config{})\n    if err != nil {\n        log.Fatal(\"Failed to connect to database:\", err)\n    }\n\n    // Auto migrate the schema\n    err = db.AutoMigrate(&amp;User{})\n    if err != nil {\n        log.Fatal(\"Failed to migrate database:\", err)\n    }\n\n    // Create router\n    r := mux.NewRouter()\n\n    // Define routes\n    r.HandleFunc(\"/users\", getUsers).Methods(\"GET\")\n    r.HandleFunc(\"/users/{id:[0-9]+}\", getUser).Methods(\"GET\")\n    r.HandleFunc(\"/users\", createUser).Methods(\"POST\")\n    r.HandleFunc(\"/users/{id:[0-9]+}\", updateUser).Methods(\"PUT\")\n    r.HandleFunc(\"/users/{id:[0-9]+}\", deleteUser).Methods(\"DELETE\")\n\n    // Start server\n    log.Println(\"Server started on :8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n    var users []User\n    result := db.Find(&amp;users)\n    if result.Error != nil {\n        http.Error(w, result.Error.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    // Convert to response (without passwords)\n    var responses []UserResponse\n    for _, user := range users {\n        responses = append(responses, UserResponse{\n            ID:        user.ID,\n            Username:  user.Username,\n            Email:     user.Email,\n            Age:       user.Age,\n            IsActive:  user.IsActive,\n            CreatedAt: user.CreatedAt,\n            UpdatedAt: user.UpdatedAt,\n        })\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(responses)\n}\n\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id := params[\"id\"]\n\n    var user User\n    result := db.First(&amp;user, id)\n    if result.Error != nil {\n        if result.Error == gorm.ErrRecordNotFound {\n            http.Error(w, \"User not found\", http.StatusNotFound)\n        } else {\n            http.Error(w, result.Error.Error(), http.StatusInternalServerError)\n        }\n        return\n    }\n\n    // Convert to response (without password)\n    response := UserResponse{\n        ID:        user.ID,\n        Username:  user.Username,\n        Email:     user.Email,\n        Age:       user.Age,\n        IsActive:  user.IsActive,\n        CreatedAt: user.CreatedAt,\n        UpdatedAt: user.UpdatedAt,\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(response)\n}\n\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n    var req UserRequest\n    err := json.NewDecoder(r.Body).Decode(&amp;req)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    // Validate request\n    err = validate.Struct(req)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    // Create user\n    user := User{\n        Username: req.Username,\n        Email:    req.Email,\n        Password: req.Password, // In a real app, hash this password\n        Age:      req.Age,\n        IsActive: true,\n    }\n\n    result := db.Create(&amp;user)\n    if result.Error != nil {\n        http.Error(w, result.Error.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    // Convert to response (without password)\n    response := UserResponse{\n        ID:        user.ID,\n        Username:  user.Username,\n        Email:     user.Email,\n        Age:       user.Age,\n        IsActive:  user.IsActive,\n        CreatedAt: user.CreatedAt,\n        UpdatedAt: user.UpdatedAt,\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(response)\n}\n\nfunc updateUser(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id := params[\"id\"]\n\n    var user User\n    result := db.First(&amp;user, id)\n    if result.Error != nil {\n        if result.Error == gorm.ErrRecordNotFound {\n            http.Error(w, \"User not found\", http.StatusNotFound)\n        } else {\n            http.Error(w, result.Error.Error(), http.StatusInternalServerError)\n        }\n        return\n    }\n\n    var req UserRequest\n    err := json.NewDecoder(r.Body).Decode(&amp;req)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    // Validate request\n    err = validate.Struct(req)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    // Update user\n    user.Username = req.Username\n    user.Email = req.Email\n    user.Password = req.Password // In a real app, hash this password\n    user.Age = req.Age\n\n    result = db.Save(&amp;user)\n    if result.Error != nil {\n        http.Error(w, result.Error.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    // Convert to response (without password)\n    response := UserResponse{\n        ID:        user.ID,\n        Username:  user.Username,\n        Email:     user.Email,\n        Age:       user.Age,\n        IsActive:  user.IsActive,\n        CreatedAt: user.CreatedAt,\n        UpdatedAt: user.UpdatedAt,\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(response)\n}\n\nfunc deleteUser(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id := params[\"id\"]\n\n    result := db.Delete(&amp;User{}, id)\n    if result.Error != nil {\n        http.Error(w, result.Error.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    if result.RowsAffected == 0 {\n        http.Error(w, \"User not found\", http.StatusNotFound)\n        return\n    }\n\n    w.WriteHeader(http.StatusNoContent)\n}\n</code></pre>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#how-this-example-demonstrates-struct-tags","title":"How This Example Demonstrates Struct Tags:","text":"<ol> <li>JSON Serialization:</li> <li><code>json:\"id\"</code> controls JSON field names</li> <li><code>json:\"-\"</code> excludes the password field from JSON output</li> <li> <p><code>json:\"deleted_at,omitempty\"</code> omits the field if it's zero</p> </li> <li> <p>Database Mapping (GORM):</p> </li> <li><code>gorm:\"primaryKey\"</code> marks the ID as primary key</li> <li><code>gorm:\"uniqueIndex\"</code> creates unique indexes</li> <li><code>gorm:\"size:255\"</code> specifies column size</li> <li><code>gorm:\"autoCreateTime\"</code> and <code>gorm:\"autoUpdateTime\"</code> handle timestamps</li> <li> <p><code>gorm:\"index\"</code> creates an index for soft deletes</p> </li> <li> <p>Validation:</p> </li> <li><code>validate:\"required\"</code> marks fields as required</li> <li><code>validate:\"min=3,max=20\"</code> sets length constraints</li> <li><code>validate:\"email\"</code> validates email format</li> <li> <p><code>validate:\"gte=18\"</code> sets minimum value</p> </li> <li> <p>Documentation:</p> </li> <li> <p><code>example:\"johndoe\"</code> provides example values for API documentation</p> </li> <li> <p>Separation of Concerns:</p> </li> <li>Different structs for requests and responses with appropriate tags</li> <li>Password excluded from response struct</li> </ol>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#conclusion","title":"Conclusion","text":"<p>Struct tags are a powerful feature in Go that enable metadata-driven programming:</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#key-takeaways","title":"Key Takeaways:","text":"<ol> <li>Basic Syntax:</li> <li>Struct tags are string literals in backticks after field types</li> <li> <p>Format: <code>key:\"value\" key2:\"value2\"</code></p> </li> <li> <p>Common Uses:</p> </li> <li>JSON/XML encoding with <code>encoding/json</code> and <code>encoding/xml</code></li> <li>Database mapping with ORM libraries like GORM</li> <li>Validation with libraries like <code>go-playground/validator</code></li> <li> <p>Configuration management with libraries like Viper</p> </li> <li> <p>Custom Tags:</p> </li> <li>You can create your own struct tags</li> <li>Use reflection to read and parse custom tags</li> <li> <p>Implement custom logic based on tag values</p> </li> <li> <p>Best Practices:</p> </li> <li>Use descriptive tag names</li> <li>Keep tags organized and consistent</li> <li>Document custom tags</li> <li> <p>Handle tag parsing errors gracefully</p> </li> <li> <p>Common Pitfalls:</p> </li> <li>Incorrect tag syntax</li> <li>Case sensitivity issues</li> <li>Forgetting to use <code>omitempty</code></li> <li>Mixing tag formats inconsistently</li> </ol> <p>By mastering struct tags, you can write more declarative, maintainable, and flexible Go code. Struct tags enable a clean separation between your data structures and the logic that operates on them, making your code more readable and easier to maintain.</p>"},{"location":"2.%20Intermediate/34.%20XML/","title":"XML in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/34.%20XML/#introduction-to-xml","title":"Introduction to XML","text":"<p>XML (eXtensible Markup Language) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable. In Go, the <code>encoding/xml</code> package provides robust support for working with XML data, similar to the JSON package.</p>"},{"location":"2.%20Intermediate/34.%20XML/#basic-xml-operations","title":"Basic XML Operations","text":""},{"location":"2.%20Intermediate/34.%20XML/#marshaling-go-to-xml","title":"Marshaling (Go to XML)","text":"<p>Marshaling converts Go data structures into XML format:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"log\"\n)\n\ntype Person struct {\n    XMLName   xml.Name `xml:\"person\"`\n    FirstName string   `xml:\"firstName\"`\n    LastName  string   `xml:\"lastName\"`\n    Age       int      `xml:\"age,omitempty\"`\n}\n\nfunc main() {\n    person := Person{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        // Age is left empty to demonstrate omitempty\n    }\n\n    // Marshal to XML\n    xmlData, err := xml.Marshal(person)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(xmlData))\n    // Output: &lt;person&gt;&lt;firstName&gt;John&lt;/firstName&gt;&lt;lastName&gt;Doe&lt;/lastName&gt;&lt;/person&gt;\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#unmarshaling-xml-to-go","title":"Unmarshaling (XML to Go)","text":"<p>Unmarshaling converts XML data into Go data structures:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"log\"\n)\n\ntype Person struct {\n    XMLName   xml.Name `xml:\"person\"`\n    FirstName string   `xml:\"firstName\"`\n    LastName  string   `xml:\"lastName\"`\n    Age       int      `xml:\"age,omitempty\"`\n}\n\nfunc main() {\n    xmlStr := `&lt;person&gt;&lt;firstName&gt;Bob&lt;/firstName&gt;&lt;lastName&gt;Smith&lt;/lastName&gt;&lt;age&gt;25&lt;/age&gt;&lt;/person&gt;`\n\n    var person Person\n    err := xml.Unmarshal([]byte(xmlStr), &amp;person)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"%+v\\n\", person)\n    // Output: {XMLName:{Space: Local:person} FirstName:Bob LastName:Smith Age:25}\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#xml-struct-tags","title":"XML Struct Tags","text":"<p>Struct tags provide metadata that control how fields are encoded and decoded in XML:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"log\"\n)\n\ntype Employee struct {\n    XMLName   xml.Name `xml:\"employee\"`\n    ID        int      `xml:\"id,attr\"`\n    FirstName string   `xml:\"name&gt;first\"`\n    LastName  string   `xml:\"name&gt;last\"`\n    Email     string   `xml:\"email,omitempty\"`\n    IsActive  bool     `xml:\"active,attr\"`\n    Roles     []string `xml:\"roles&gt;role\"`\n    Salary    float64  `xml:\"salary,omitempty\"`\n    // Field will be ignored\n    password string `xml:\"-\"`\n}\n\nfunc main() {\n    employee := Employee{\n        ID:        1001,\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        IsActive:  true,\n        Roles:     []string{\"admin\", \"developer\"},\n        password:  \"secret\",\n    }\n\n    xmlData, err := xml.MarshalIndent(employee, \"\", \"  \")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(xmlData))\n    /*\n    Output:\n    &lt;employee id=\"1001\" active=\"true\"&gt;\n      &lt;name&gt;\n        &lt;first&gt;John&lt;/first&gt;\n        &lt;last&gt;Doe&lt;/last&gt;\n      &lt;/name&gt;\n      &lt;roles&gt;\n        &lt;role&gt;admin&lt;/role&gt;\n        &lt;role&gt;developer&lt;/role&gt;\n      &lt;/roles&gt;\n    &lt;/employee&gt;\n    */\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#common-xml-struct-tags","title":"Common XML Struct Tags","text":"Tag Description <code>xml:\"element_name\"</code> Specifies the XML element name <code>xml:\"element_name,attr\"</code> Encodes the field as an attribute <code>xml:\"parent&gt;child\"</code> Creates nested elements <code>xml:\"-\"</code> Omits the field from XML output <code>xml:\",omitempty\"</code> Omits the field if it has a zero value <code>xml:\",chardata\"</code> Encodes the field as character data <code>xml:\",innerxml\"</code> Uses the raw XML <code>xml:\",comment\"</code> Encodes the field as an XML comment"},{"location":"2.%20Intermediate/34.%20XML/#working-with-xml-namespaces","title":"Working with XML Namespaces","text":"<p>XML namespaces are used to avoid element name conflicts. Go's XML package supports namespaces through struct tags:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"log\"\n)\n\ntype Envelope struct {\n    XMLName xml.Name `xml:\"soap:Envelope\"`\n    Soap    string   `xml:\"xmlns:soap,attr\"`\n    Xsi     string   `xml:\"xmlns:xsi,attr\"`\n    Body    Body     `xml:\"soap:Body\"`\n}\n\ntype Body struct {\n    XMLName  xml.Name `xml:\"soap:Body\"`\n    GetPrice GetPrice `xml:\"m:GetPrice\"`\n}\n\ntype GetPrice struct {\n    XMLName xml.Name `xml:\"m:GetPrice\"`\n    M       string   `xml:\"xmlns:m,attr\"`\n    Item    Item     `xml:\"m:Item\"`\n}\n\ntype Item struct {\n    XMLName xml.Name `xml:\"m:Item\"`\n    Name    string   `xml:\"m:Name\"`\n}\n\nfunc main() {\n    envelope := Envelope{\n        Soap: \"http://www.w3.org/2003/05/soap-envelope\",\n        Xsi:  \"http://www.w3.org/2001/XMLSchema-instance\",\n        Body: Body{\n            GetPrice: GetPrice{\n                M: \"http://www.example.org/prices\",\n                Item: Item{\n                    Name: \"Apple\",\n                },\n            },\n        },\n    }\n\n    xmlData, err := xml.MarshalIndent(envelope, \"\", \"  \")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(xmlData))\n    /*\n    Output:\n    &lt;soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;\n      &lt;soap:Body&gt;\n        &lt;m:GetPrice xmlns:m=\"http://www.example.org/prices\"&gt;\n          &lt;m:Item&gt;\n            &lt;m:Name&gt;Apple&lt;/m:Name&gt;\n          &lt;/m:Item&gt;\n        &lt;/m:GetPrice&gt;\n      &lt;/soap:Body&gt;\n    &lt;/soap:Envelope&gt;\n    */\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#handling-dynamic-xml","title":"Handling Dynamic XML","text":"<p>Sometimes you need to work with XML that doesn't have a fixed structure:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"log\"\n    \"strings\"\n)\n\nfunc main() {\n    // XML with unknown structure\n    xmlStr := `\n    &lt;person&gt;\n        &lt;name&gt;John Doe&lt;/name&gt;\n        &lt;age&gt;30&lt;/age&gt;\n        &lt;address&gt;\n            &lt;street&gt;123 Main St&lt;/street&gt;\n            &lt;city&gt;New York&lt;/city&gt;\n            &lt;zip&gt;10001&lt;/zip&gt;\n        &lt;/address&gt;\n        &lt;hobbies&gt;\n            &lt;hobby&gt;reading&lt;/hobby&gt;\n            &lt;hobby&gt;hiking&lt;/hobby&gt;\n        &lt;/hobbies&gt;\n    &lt;/person&gt;\n    `\n\n    // Unmarshal into a generic structure\n    var data struct {\n        XMLName  xml.Name         `xml:\"person\"`\n        Name     string           `xml:\"name\"`\n        Age      int              `xml:\"age\"`\n        Address  map[string]string `xml:\"address\"`\n        Hobbies  []string         `xml:\"hobbies&gt;hobby\"`\n        Other    []xml.Name       `xml:\",any\"`\n    }\n\n    decoder := xml.NewDecoder(strings.NewReader(xmlStr))\n    err := decoder.Decode(&amp;data)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Name: %s\\n\", data.Name)\n    fmt.Printf(\"Age: %d\\n\", data.Age)\n    fmt.Printf(\"Address: %+v\\n\", data.Address)\n    fmt.Printf(\"Hobbies: %v\\n\", data.Hobbies)\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#custom-marshaling-and-unmarshaling","title":"Custom Marshaling and Unmarshaling","text":"<p>You can implement custom XML encoding and decoding by implementing the <code>xml.Marshaler</code> and <code>xml.Unmarshaler</code> interfaces:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"strings\"\n    \"time\"\n)\n\ntype Date struct {\n    time.Time\n}\n\n// Implement Marshaler interface\nfunc (d Date) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n    xmlDate := d.Time.Format(\"2006-01-02\")\n    return e.EncodeElement(xmlDate, start)\n}\n\n// Implement Unmarshaler interface\nfunc (d *Date) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {\n    var content string\n    if err := dec.DecodeElement(&amp;content, &amp;start); err != nil {\n        return err\n    }\n\n    t, err := time.Parse(\"2006-01-02\", content)\n    if err != nil {\n        return err\n    }\n\n    d.Time = t\n    return nil\n}\n\ntype Event struct {\n    XMLName xml.Name `xml:\"event\"`\n    Name    string   `xml:\"name\"`\n    Date    Date     `xml:\"date\"`\n}\n\nfunc main() {\n    // Custom marshaling\n    event := Event{\n        Name: \"Conference\",\n        Date: Date{time.Date(2023, 10, 15, 0, 0, 0, 0, time.UTC)},\n    }\n\n    xmlData, err := xml.MarshalIndent(event, \"\", \"  \")\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(string(xmlData))\n    /*\n    Output:\n    &lt;event&gt;\n      &lt;name&gt;Conference&lt;/name&gt;\n      &lt;date&gt;2023-10-15&lt;/date&gt;\n    &lt;/event&gt;\n    */\n\n    // Custom unmarshaling\n    xmlStr := `&lt;event&gt;&lt;name&gt;Meeting&lt;/name&gt;&lt;date&gt;2023-11-20&lt;/date&gt;&lt;/event&gt;`\n    var newEvent Event\n    err = xml.Unmarshal([]byte(xmlStr), &amp;newEvent)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"%+v\\n\", newEvent)\n    // Output: {XMLName:{Space: Local:event} Name:Meeting Date:{Time:2023-11-20 00:00:00 +0000 UTC}}\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#streaming-xml","title":"Streaming XML","text":"<p>For large XML documents, streaming can be more memory-efficient:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strings\"\n)\n\ntype Product struct {\n    XMLName xml.Name `xml:\"product\"`\n    ID      int      `xml:\"id,attr\"`\n    Name    string   `xml:\"name\"`\n    Price   float64  `xml:\"price\"`\n}\n\nfunc main() {\n    // Create a large XML document\n    var builder strings.Builder\n    builder.WriteString(`&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;products&gt;`)\n\n    for i := 1; i &lt;= 1000; i++ {\n        builder.WriteString(fmt.Sprintf(`&lt;product id=\"%d\"&gt;&lt;name&gt;Product %d&lt;/name&gt;&lt;price&gt;%.2f&lt;/price&gt;&lt;/product&gt;`, i, i, float64(i)*0.99))\n    }\n\n    builder.WriteString(`&lt;/products&gt;`)\n    xmlData := builder.String()\n\n    // Create a decoder\n    decoder := xml.NewDecoder(strings.NewReader(xmlData))\n\n    // Process the XML in a streaming fashion\n    for {\n        // Read tokens from the XML document\n        token, err := decoder.Token()\n        if err != nil {\n            break\n        }\n\n        // Check for start elements\n        if se, ok := token.(xml.StartElement); ok {\n            if se.Name.Local == \"product\" {\n                var product Product\n                // Decode the product element\n                err := decoder.DecodeElement(&amp;product, &amp;se)\n                if err != nil {\n                    log.Fatal(err)\n                }\n\n                // Process the product (e.g., print every 100th product)\n                if product.ID%100 == 0 {\n                    fmt.Printf(\"Processed product ID: %d, Name: %s, Price: %.2f\\n\", \n                        product.ID, product.Name, product.Price)\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#working-with-xml-in-web-applications","title":"Working with XML in Web Applications","text":"<p>XML is commonly used in web applications, especially for SOAP APIs and RSS feeds:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"net/http\"\n)\n\ntype User struct {\n    XMLName xml.Name `xml:\"user\"`\n    ID      int      `xml:\"id,attr\"`\n    Name    string   `xml:\"name\"`\n    Email   string   `xml:\"email\"`\n}\n\nvar users = []User{\n    {ID: 1, Name: \"Alice\", Email: \"alice@example.com\"},\n    {ID: 2, Name: \"Bob\", Email: \"bob@example.com\"},\n}\n\nfunc main() {\n    http.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Content-Type\", \"application/xml\")\n        xml.NewEncoder(w).Encode(users)\n    })\n\n    http.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n        // Parse XML from request body\n        var newUser User\n        err := xml.NewDecoder(r.Body).Decode(&amp;newUser)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusBadRequest)\n            return\n        }\n\n        // Add new user\n        newUser.ID = len(users) + 1\n        users = append(users, newUser)\n\n        // Return the created user\n        w.Header().Set(\"Content-Type\", \"application/xml\")\n        w.WriteHeader(http.StatusCreated)\n        xml.NewEncoder(w).Encode(newUser)\n    })\n\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#handling-xml-errors","title":"Handling XML Errors","text":"<p>Proper error handling is crucial when working with XML:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"log\"\n    \"strings\"\n)\n\nfunc main() {\n    // Invalid XML\n    invalidXML := `&lt;person&gt;&lt;name&gt;Alice&lt;/name&gt;&lt;age&gt;30` // Missing closing tags\n\n    var person struct {\n        XMLName xml.Name `xml:\"person\"`\n        Name    string   `xml:\"name\"`\n        Age     int      `xml:\"age\"`\n    }\n\n    decoder := xml.NewDecoder(strings.NewReader(invalidXML))\n    err := decoder.Decode(&amp;person)\n    if err != nil {\n        // Type assertion to get more details about the error\n        if syntaxErr, ok := err.(*xml.SyntaxError); ok {\n            fmt.Printf(\"Syntax error at line %d, column %d: %v\\n\", \n                syntaxErr.Line, syntaxErr.Column, syntaxErr)\n        } else {\n            fmt.Printf(\"Error unmarshaling XML: %v\\n\", err)\n        }\n        return\n    }\n\n    fmt.Printf(\"%+v\\n\", person)\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#pretty-printing-xml","title":"Pretty-Printing XML","text":"<p>For debugging or display purposes, you might want to format XML:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n)\n\ntype Person struct {\n    XMLName  xml.Name `xml:\"person\"`\n    Name     string   `xml:\"name\"`\n    Age      int      `xml:\"age,omitempty\"`\n    Hobbies  []string `xml:\"hobbies&gt;hobby\"`\n    Address  struct {\n        Street string `xml:\"street\"`\n        City   string `xml:\"city\"`\n    } `xml:\"address\"`\n}\n\nfunc main() {\n    person := Person{\n        Name: \"Alice\",\n        Age:  30,\n        Hobbies: []string{\"reading\", \"hiking\", \"coding\"},\n        Address: struct {\n            Street string `xml:\"street\"`\n            City   string `xml:\"city\"`\n        }{\n            Street: \"123 Main St\",\n            City:   \"New York\",\n        },\n    }\n\n    // Marshal with indentation\n    xmlData, err := xml.MarshalIndent(person, \"\", \"  \")\n    if err != nil {\n        panic(err)\n    }\n\n    // Add XML declaration\n    output := xml.Header + string(xmlData)\n    fmt.Println(output)\n    /*\n    Output:\n    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n    &lt;person&gt;\n      &lt;name&gt;Alice&lt;/name&gt;\n      &lt;age&gt;30&lt;/age&gt;\n      &lt;hobbies&gt;\n        &lt;hobby&gt;reading&lt;/hobby&gt;\n        &lt;hobby&gt;hiking&lt;/hobby&gt;\n        &lt;hobby&gt;coding&lt;/hobby&gt;\n      &lt;/hobbies&gt;\n      &lt;address&gt;\n        &lt;street&gt;123 Main St&lt;/street&gt;\n        &lt;city&gt;New York&lt;/city&gt;\n      &lt;/address&gt;\n    &lt;/person&gt;\n    */\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#working-with-xml-and-cdata","title":"Working with XML and CDATA","text":"<p>CDATA sections are used to include text that might contain characters that could be interpreted as XML markup:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n)\n\ntype Message struct {\n    XMLName xml.Name `xml:\"message\"`\n    From    string   `xml:\"from\"`\n    To      string   `xml:\"to\"`\n    Content string   `xml:\",innerxml\"` // Use innerxml to preserve CDATA\n}\n\nfunc main() {\n    message := Message{\n        From:    \"alice@example.com\",\n        To:      \"bob@example.com\",\n        Content: \"&lt;![CDATA[This message contains &lt;special&gt; &amp; characters]]&gt;\",\n    }\n\n    xmlData, err := xml.MarshalIndent(message, \"\", \"  \")\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(string(xmlData))\n    /*\n    Output:\n    &lt;message&gt;\n      &lt;from&gt;alice@example.com&lt;/from&gt;\n      &lt;to&gt;bob@example.com&lt;/to&gt;\n      &lt;![CDATA[This message contains &lt;special&gt; &amp; characters]]&gt;\n    &lt;/message&gt;\n    */\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#real-world-example-rss-feed-parser","title":"Real-World Example: RSS Feed Parser","text":"<p>Let's create a comprehensive example that demonstrates parsing an RSS feed:</p> <pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"time\"\n)\n\n// RSS 2.0 structure\ntype RSS struct {\n    XMLName xml.Name `xml:\"rss\"`\n    Version string   `xml:\"version,attr\"`\n    Channel Channel  `xml:\"channel\"`\n}\n\ntype Channel struct {\n    Title         string `xml:\"title\"`\n    Link          string `xml:\"link\"`\n    Description   string `xml:\"description\"`\n    Language      string `xml:\"language\"`\n    LastBuildDate string `xml:\"lastBuildDate\"`\n    Items         []Item `xml:\"item\"`\n}\n\ntype Item struct {\n    Title       string `xml:\"title\"`\n    Link        string `xml:\"link\"`\n    Description string `xml:\"description\"`\n    PubDate     string `xml:\"pubDate\"`\n    Guid        string `xml:\"guid\"`\n}\n\n// Custom unmarshaler for date\nfunc (i *Item) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n    type ItemAlias Item\n    var alias ItemAlias\n\n    if err := d.DecodeElement(&amp;alias, &amp;start); err != nil {\n        return err\n    }\n\n    *i = Item(alias)\n    return nil\n}\n\nfunc main() {\n    // Fetch RSS feed\n    resp, err := http.Get(\"https://example.com/rss.xml\")\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        panic(err)\n    }\n\n    // Parse RSS feed\n    var rss RSS\n    err = xml.Unmarshal(body, &amp;rss)\n    if err != nil {\n        panic(err)\n    }\n\n    // Print channel information\n    fmt.Printf(\"Channel: %s\\n\", rss.Channel.Title)\n    fmt.Printf(\"Link: %s\\n\", rss.Channel.Link)\n    fmt.Printf(\"Description: %s\\n\", rss.Channel.Description)\n    fmt.Printf(\"Language: %s\\n\", rss.Channel.Language)\n    fmt.Printf(\"Last Build Date: %s\\n\", rss.Channel.LastBuildDate)\n    fmt.Println()\n\n    // Print items\n    fmt.Printf(\"Found %d items:\\n\", len(rss.Channel.Items))\n    for i, item := range rss.Channel.Items {\n        fmt.Printf(\"%d. %s\\n\", i+1, item.Title)\n        fmt.Printf(\"   Link: %s\\n\", item.Link)\n        fmt.Printf(\"   Published: %s\\n\", item.PubDate)\n        fmt.Printf(\"   Description: %.50s...\\n\", item.Description)\n        fmt.Println()\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#how-this-example-demonstrates-xml-concepts","title":"How This Example Demonstrates XML Concepts:","text":"<ol> <li>Complex XML Structure:</li> <li>Handles nested XML elements (RSS &gt; Channel &gt; Item)</li> <li> <p>Works with XML attributes (version)</p> </li> <li> <p>Real-World Data:</p> </li> <li>Fetches XML from a real URL</li> <li> <p>Parses a standard format (RSS)</p> </li> <li> <p>Date Handling:</p> </li> <li>Includes a custom unmarshaler for date fields</li> <li> <p>Demonstrates how to handle special data types</p> </li> <li> <p>Error Handling:</p> </li> <li>Includes proper error handling for network and parsing operations</li> </ol>"},{"location":"2.%20Intermediate/34.%20XML/#best-practices-for-xml-in-go","title":"Best Practices for XML in Go","text":""},{"location":"2.%20Intermediate/34.%20XML/#1-use-struct-tags-effectively","title":"1. Use Struct Tags Effectively","text":"<pre><code>type User struct {\n    ID       int    `xml:\"id,attr\"`\n    Username string `xml:\"username\"`\n    Email    string `xml:\"email,omitempty\"`\n    Password string `xml:\"-\"` // Never expose passwords\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#2-handle-namespaces-properly","title":"2. Handle Namespaces Properly","text":"<pre><code>type SOAPEnvelope struct {\n    XMLName xml.Name `xml:\"soap:Envelope\"`\n    SoapNS  string   `xml:\"xmlns:soap,attr\"`\n    Body    SOAPBody `xml:\"soap:Body\"`\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#3-use-streaming-for-large-documents","title":"3. Use Streaming for Large Documents","text":"<pre><code>func processLargeXML(r io.Reader) error {\n    decoder := xml.NewDecoder(r)\n\n    for {\n        token, err := decoder.Token()\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return err\n        }\n\n        // Process tokens\n        if se, ok := token.(xml.StartElement); ok {\n            // Handle start elements\n        }\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#4-validate-xml-input","title":"4. Validate XML Input","text":"<pre><code>func validateUserXML(xmlData []byte) error {\n    var user User\n    if err := xml.Unmarshal(xmlData, &amp;user); err != nil {\n        return err\n    }\n\n    if user.Name == \"\" {\n        return errors.New(\"name is required\")\n    }\n\n    if user.Age &lt; 0 || user.Age &gt; 120 {\n        return errors.New(\"invalid age\")\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#5-use-cdata-for-special-content","title":"5. Use CDATA for Special Content","text":"<pre><code>type Message struct {\n    Content string `xml:\",innerxml\"`\n}\n\nfunc main() {\n    msg := Message{\n        Content: \"&lt;![CDATA[This contains &lt;special&gt; &amp; characters]]&gt;\",\n    }\n\n    xmlData, _ := xml.Marshal(msg)\n    fmt.Println(string(xmlData))\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":""},{"location":"2.%20Intermediate/34.%20XML/#1-case-sensitivity","title":"1. Case Sensitivity","text":"<p>XML element names are case-sensitive, but Go struct tags can handle this:</p> <pre><code>type Person struct {\n    FirstName string `xml:\"firstName\"` // Maps to XML \"firstName\"\n    LastName  string `xml:\"lastName\"`  // Maps to XML \"lastName\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#2-handling-mixed-content","title":"2. Handling Mixed Content","text":"<p>XML can contain mixed content (text and elements mixed together):</p> <pre><code>type Description struct {\n    Text string `xml:\",chardata\"`\n    Em   string `xml:\"em\"`\n}\n\nfunc main() {\n    xmlStr := `&lt;description&gt;This is &lt;em&gt;important&lt;/em&gt; text&lt;/description&gt;`\n\n    var desc Description\n    xml.Unmarshal([]byte(xmlStr), &amp;desc)\n\n    fmt.Println(desc.Text) // \"This is \"\n    fmt.Println(desc.Em)   // \"important\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#3-xml-namespaces","title":"3. XML Namespaces","text":"<p>Namespaces can be tricky to handle correctly:</p> <pre><code>type Element struct {\n    XMLName  xml.Name\n    Value    string `xml:\",chardata\"`\n    LocalNS  string `xml:\"local,attr\"`\n    GlobalNS string `xml:\"http://example.com/ns,attr\"`\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#4-character-encoding","title":"4. Character Encoding","text":"<p>XML documents can have different character encodings:</p> <pre><code>func decodeXML(r io.Reader) error {\n    decoder := xml.NewDecoder(r)\n    // Set the charset reader if needed\n    decoder.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) {\n        if charset == \"iso-8859-1\" {\n            return charmap.ISO8859_1.NewDecoder().Reader(input), nil\n        }\n        return input, nil\n    }\n\n    // Decode as usual\n    var data interface{}\n    return decoder.Decode(&amp;data)\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#5-xml-comments-and-processing-instructions","title":"5. XML Comments and Processing Instructions","text":"<p>Special XML elements like comments and processing instructions:</p> <pre><code>type Document struct {\n    XMLName  xml.Name `xml:\"document\"`\n    Comment  string   `xml:\",comment\"`\n    PI       string   `xml:\",innerxml\"`\n    Content  string   `xml:\"content\"`\n}\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#conclusion","title":"Conclusion","text":"<p>XML handling in Go is powerful and flexible:</p>"},{"location":"2.%20Intermediate/34.%20XML/#key-takeaways","title":"Key Takeaways:","text":"<ol> <li>Basic Operations:</li> <li>Use <code>xml.Marshal</code> and <code>xml.Unmarshal</code> for simple cases</li> <li> <p>Struct tags control XML element names, attributes, and nesting</p> </li> <li> <p>Advanced Techniques:</p> </li> <li>Implement custom marshaling/unmarshaling for special cases</li> <li>Use streaming for large XML documents</li> <li> <p>Handle dynamic XML with generic structures</p> </li> <li> <p>Web Applications:</p> </li> <li>XML is commonly used in SOAP APIs and RSS feeds</li> <li> <p>Use <code>xml.Encoder</code> and <code>xml.Decoder</code> for HTTP request/response handling</p> </li> <li> <p>Best Practices:</p> </li> <li>Use struct tags effectively</li> <li>Handle namespaces properly</li> <li>Consider performance for large data</li> <li> <p>Validate XML input</p> </li> <li> <p>Common Pitfalls:</p> </li> <li>Be aware of case sensitivity</li> <li>Understand how to handle mixed content</li> <li>Handle namespaces correctly</li> <li>Consider character encoding issues</li> </ol> <p>By mastering XML handling in Go, you can effectively work with APIs, configuration files, and data interchange in your applications. The <code>encoding/xml</code> package provides all the tools you need for robust XML processing, from simple data structures to complex document formats.</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/","title":"Go Extensions: Extending Go Functionality","text":""},{"location":"2.%20Intermediate/35.%20Go-Extensions/#introduction-to-go-extensions","title":"Introduction to Go Extensions","text":"<p>Go provides several mechanisms for extending the language's functionality beyond its standard library. Unlike some languages that have built-in extension systems, Go offers different approaches to integrate with external code, libraries, and even other programming languages.</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#1-cgo-integrating-with-c-libraries","title":"1. CGO: Integrating with C Libraries","text":"<p>CGO is Go's foreign function interface that allows Go programs to call C code and use C libraries.</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#basic-cgo-usage","title":"Basic CGO Usage","text":"<pre><code>package main\n\n/*\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid printMessage(char* message) {\n    printf(\"C says: %s\\n\", message);\n}\n\nint add(int a, int b) {\n    return a + b;\n}\n*/\nimport \"C\"\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {\n    // Call C function\n    message := C.CString(\"Hello from Go!\")\n    C.printMessage(message)\n    C.free(unsafe.Pointer(message))\n\n    // Call C function with return value\n    result := C.add(C.int(5), C.int(3))\n    fmt.Printf(\"Go received result from C: %d\\n\", result)\n}\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#using-external-c-libraries","title":"Using External C Libraries","text":"<pre><code>package main\n\n/*\n#cgo pkg-config: zlib\n#include &lt;zlib.h&gt;\n*/\nimport \"C\"\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {\n    // Compress data using zlib\n    data := []byte(\"Hello, World! This is a test string for compression.\")\n\n    // Calculate required buffer size\n    destSize := C.compressBound(C.uLong(len(data)))\n    dest := make([]byte, destSize)\n\n    // Compress\n    result := C.compress(\n        (*C.Bytef)(unsafe.Pointer(&amp;dest[0])),\n        (*C.uLongf)(&amp;destSize),\n        (*C.Bytef)(unsafe.Pointer(&amp;data[0])),\n        C.uLong(len(data)),\n    )\n\n    if result != C.Z_OK {\n        fmt.Println(\"Compression failed\")\n        return\n    }\n\n    fmt.Printf(\"Original size: %d, Compressed size: %d\\n\", len(data), destSize)\n    fmt.Printf(\"Compressed data: %v\\n\", dest[:destSize])\n}\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#cgo-best-practices","title":"CGO Best Practices","text":"<ol> <li>Minimize CGO Usage: CGO adds overhead and complexity, so use it sparingly.</li> <li>Memory Management: Be careful with memory allocation and deallocation across Go and C.</li> <li>Error Handling: Check return values from C functions and handle errors appropriately.</li> <li>Concurrency: Be aware that CGO calls block the OS thread, which can impact Go's scheduler.</li> </ol>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#2-shared-libraries-and-plugins","title":"2. Shared Libraries and Plugins","text":"<p>Go can build shared libraries that can be used by other programming languages, and load plugins dynamically at runtime.</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#building-a-shared-library","title":"Building a Shared Library","text":"<pre><code>package main\n\nimport \"C\"\n\n//export Add\nfunc Add(a, b int) int {\n    return a + b\n}\n\n//export Hello\nfunc Hello() *C.char {\n    return C.CString(\"Hello from Go shared library!\")\n}\n\nfunc main() {}\n</code></pre> <p>Build with: <pre><code>go build -buildmode=c-shared -o libmath.so\n</code></pre></p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#using-go-shared-library-in-c","title":"Using Go Shared Library in C","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;dlfcn.h&gt;\n#include \"libmath.h\"\n\nint main() {\n    void* handle = dlopen(\"./libmath.so\", RTLD_LAZY);\n    if (!handle) {\n        fprintf(stderr, \"Error: %s\\n\", dlerror());\n        return 1;\n    }\n\n    // Load functions\n    int (*add)(int, int) = dlsym(handle, \"Add\");\n    char* (*hello)() = dlsym(handle, \"Hello\");\n\n    if (!add || !hello) {\n        fprintf(stderr, \"Error: %s\\n\", dlerror());\n        return 1;\n    }\n\n    // Use functions\n    printf(\"5 + 3 = %d\\n\", add(5, 3));\n    printf(\"%s\\n\", hello());\n\n    dlclose(handle);\n    return 0;\n}\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#dynamic-plugins-with-the-plugin-package","title":"Dynamic Plugins with the plugin Package","text":"<p>Go's <code>plugin</code> package allows loading Go plugins at runtime.</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#plugin-code-plugingo","title":"Plugin Code (plugin.go)","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype Greeter interface {\n    Greet() string\n}\n\ntype EnglishGreeter struct{}\n\nfunc (g EnglishGreeter) Greet() string {\n    return \"Hello!\"\n}\n\ntype SpanishGreeter struct{}\n\nfunc (g SpanishGreeter) Greet() string {\n    return \"\u00a1Hola!\"\n}\n\n// Export symbols\nvar English = EnglishGreeter{}\nvar Spanish = SpanishGreeter{}\n\nfunc init() {\n    fmt.Println(\"Plugin loaded\")\n}\n</code></pre> <p>Build with: <pre><code>go build -buildmode=plugin -o greeter.so plugin.go\n</code></pre></p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#main-application-maingo","title":"Main Application (main.go)","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"plugin\"\n)\n\ntype Greeter interface {\n    Greet() string\n}\n\nfunc main() {\n    // Load plugin\n    p, err := plugin.Open(\"greeter.so\")\n    if err != nil {\n        fmt.Printf(\"Failed to load plugin: %v\\n\", err)\n        return\n    }\n\n    // Look up symbols\n    englishSym, err := p.Lookup(\"English\")\n    if err != nil {\n        fmt.Printf(\"Failed to look up English: %v\\n\", err)\n        return\n    }\n\n    spanishSym, err := p.Lookup(\"Spanish\")\n    if err != nil {\n        fmt.Printf(\"Failed to look up Spanish: %v\\n\", err)\n        return\n    }\n\n    // Type assert symbols\n    english, ok := englishSym.(Greeter)\n    if !ok {\n        fmt.Println(\"English symbol is not a Greeter\")\n        return\n    }\n\n    spanish, ok := spanishSym.(Greeter)\n    if !ok {\n        fmt.Println(\"Spanish symbol is not a Greeter\")\n        return\n    }\n\n    // Use the plugins\n    fmt.Println(\"English:\", english.Greet())\n    fmt.Println(\"Spanish:\", spanish.Greet())\n}\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#3-webassembly-wasm-extensions","title":"3. WebAssembly (WASM) Extensions","text":"<p>Go can compile to WebAssembly, allowing Go code to run in browsers and other WASM environments.</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#basic-wasm-example","title":"Basic WASM Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"syscall/js\"\n)\n\nfunc main() {\n    // Create a channel to keep the program running\n    c := make(chan struct{}, 0)\n\n    // Register a function to be called from JavaScript\n    js.Global().Set(\"add\", js.FuncOf(add))\n\n    fmt.Println(\"Go WebAssembly module initialized\")\n    &lt;-c // Wait forever\n}\n\nfunc add(this js.Value, args []js.Value) interface{} {\n    if len(args) != 2 {\n        return \"Invalid number of arguments\"\n    }\n\n    a := args[0].Int()\n    b := args[1].Int()\n\n    return a + b\n}\n</code></pre> <p>Build with: <pre><code>GOOS=js GOARCH=wasm go build -o main.wasm\n</code></pre></p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#html-to-load-wasm","title":"HTML to Load WASM","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"/&gt;\n    &lt;title&gt;Go WASM Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script src=\"wasm_exec.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        const go = new Go();\n        WebAssembly.instantiateStreaming(fetch(\"main.wasm\"), go.importObject)\n            .then(result =&gt; {\n                go.run(result.instance);\n            });\n\n        function callAdd() {\n            const a = parseInt(document.getElementById(\"a\").value);\n            const b = parseInt(document.getElementById(\"b\").value);\n            const result = add(a, b);\n            document.getElementById(\"result\").textContent = result;\n        }\n    &lt;/script&gt;\n\n    &lt;input type=\"number\" id=\"a\" value=\"5\"&gt;\n    &lt;input type=\"number\" id=\"b\" value=\"3\"&gt;\n    &lt;button onclick=\"callAdd()\"&gt;Add&lt;/button&gt;\n    &lt;p&gt;Result: &lt;span id=\"result\"&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#4-extending-go-with-other-languages","title":"4. Extending Go with Other Languages","text":""},{"location":"2.%20Intermediate/35.%20Go-Extensions/#python-extensions","title":"Python Extensions","text":"<p>You can create Python extensions in Go using CGO and Python's C API.</p> <pre><code>package main\n\n/*\n#include &lt;Python.h&gt;\n*/\nimport \"C\"\nimport (\n    \"unsafe\"\n)\n\n//export add_numbers\nfunc add_numbers(self, args *C.PyObject) *C.PyObject {\n    var a, b C.int\n\n    // Parse arguments\n    if C.PyArg_ParseTuple(args, \"ii\", &amp;a, &amp;b) == 0 {\n        return nil\n    }\n\n    // Call Go function\n    result := add(int(a), int(b))\n\n    // Return result as Python int\n    return C.PyLong_FromLong(C.long(result))\n}\n\nfunc add(a, b int) int {\n    return a + b\n}\n\n//export initmath\nfunc initmath() {\n    // Create module\n    module := C.PyImport_AddModule(\"math\")\n\n    // Add function to module\n    methods := [1]C.PyMethodDef{\n        {C.CString(\"add_numbers\"), C.PyCFunction(add_numbers), C.METH_VARARGS, C.CString(\"Add two numbers\")},\n        {nil, nil, 0, nil},\n    }\n\n    C.PyModule_Create(module, &amp;methods[0])\n}\n\nfunc main() {}\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#ruby-extensions","title":"Ruby Extensions","text":"<p>Similarly, you can create Ruby extensions in Go.</p> <pre><code>package main\n\n/*\n#include &lt;ruby.h&gt;\n*/\nimport \"C\"\nimport (\n    \"unsafe\"\n)\n\n//export add\nfunc add(argc C.int, argv *C.VALUE, self C.VALUE) C.VALUE {\n    // Check argument count\n    if argc != 2 {\n        C.rb_raise(C.rb_eArgError, C.CString(\"wrong number of arguments (expected 2)\"))\n    }\n\n    // Convert arguments to Go values\n    a := int(C.NUM2INT(*(*C.VALUE)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)))))\n    b := int(C.NUM2INT(*(*C.VALUE)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + unsafe.Sizeof(C.VALUE{})))))\n\n    // Call Go function\n    result := a + b\n\n    // Return result as Ruby int\n    return C.INT2NUM(C.long(result))\n}\n\n//export Init_math\nfunc Init_math() {\n    // Define module\n    module := C.rb_define_module(C.CString(\"Math\"))\n\n    // Define method\n    C.rb_define_module_function(module, C.CString(\"add\"), C.PyCFunction(add), -1)\n}\n\nfunc main() {}\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#5-extending-go-with-scripting-languages","title":"5. Extending Go with Scripting Languages","text":""},{"location":"2.%20Intermediate/35.%20Go-Extensions/#embedding-lua-in-go","title":"Embedding Lua in Go","text":"<pre><code>package main\n\n/*\n#cgo pkg-config: lua5.3\n#include &lt;lua.h&gt;\n#include &lt;lauxlib.h&gt;\n#include &lt;lualib.h&gt;\n*/\nimport \"C\"\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {\n    // Create Lua state\n    L := C.luaL_newstate()\n    defer C.lua_close(L)\n\n    // Load Lua libraries\n    C.luaL_openlibs(L)\n\n    // Define a Go function to be called from Lua\n    C.lua_pushcfunction(L, (*[0]byte)(C.goAdd))\n    C.lua_setglobal(L, C.CString(\"go_add\"))\n\n    // Execute Lua script\n    script := `\n    print(\"Lua script started\")\n    result = go_add(5, 3)\n    print(\"5 + 3 =\", result)\n    `\n\n    if C.luaL_dostring(L, C.CString(script)) != 0 {\n        fmt.Printf(\"Error: %s\\n\", C.GoString(C.lua_tostring(L, -1)))\n    }\n}\n\n//export goAdd\nfunc goAdd(L *C.lua_State) C.int {\n    // Get arguments\n    a := int(C.lua_tonumber(L, 1))\n    b := int(C.lua_tonumber(L, 2))\n\n    // Call Go function\n    result := a + b\n\n    // Push result\n    C.lua_pushnumber(L, C.lua_Number(result))\n\n    // Return number of results\n    return 1\n}\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#embedding-javascript-in-go-with-otto","title":"Embedding JavaScript in Go with Otto","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/robertkrimen/otto\"\n)\n\nfunc main() {\n    vm := otto.New()\n\n    // Define a Go function to be called from JavaScript\n    vm.Set(\"goAdd\", func(call otto.FunctionCall) otto.Value {\n        a, _ := call.Argument(0).ToInteger()\n        b, _ := call.Argument(1).ToInteger()\n\n        result, _ := vm.ToValue(a + b)\n        return result\n    })\n\n    // Execute JavaScript\n    script := `\n    console.log(\"JavaScript script started\");\n    var result = goAdd(5, 3);\n    console.log(\"5 + 3 =\", result);\n    `\n\n    _, err := vm.Run(script)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#best-practices-for-go-extensions","title":"Best Practices for Go Extensions","text":""},{"location":"2.%20Intermediate/35.%20Go-Extensions/#1-minimize-cgo-usage","title":"1. Minimize CGO Usage","text":"<ul> <li>CGO adds overhead and complexity</li> <li>Use pure Go implementations when possible</li> <li>Isolate CGO code to specific packages</li> </ul>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#2-memory-management","title":"2. Memory Management","text":"<ul> <li>Be careful with memory allocation and deallocation across language boundaries</li> <li>Use finalizers to ensure proper cleanup</li> <li>Avoid circular references between Go and C</li> </ul>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#3-error-handling","title":"3. Error Handling","text":"<ul> <li>Translate errors between Go and the target language appropriately</li> <li>Provide meaningful error messages</li> <li>Handle panics and exceptions gracefully</li> </ul>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#4-performance-considerations","title":"4. Performance Considerations","text":"<ul> <li>Be aware of the overhead of language boundaries</li> <li>Minimize data copying between languages</li> <li>Use efficient data structures for cross-language communication</li> </ul>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#5-security","title":"5. Security","text":"<ul> <li>Validate input from external code</li> <li>Use appropriate sandboxing for untrusted code</li> <li>Be cautious with dynamic loading of plugins</li> </ul>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#conclusion","title":"Conclusion","text":"<p>Go provides several mechanisms for extending its functionality:</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#key-takeaways","title":"Key Takeaways:","text":"<ol> <li>CGO:</li> <li>Allows integration with C libraries</li> <li>Useful for leveraging existing C code</li> <li> <p>Adds complexity and overhead</p> </li> <li> <p>Shared Libraries and Plugins:</p> </li> <li>Enable dynamic loading of Go code</li> <li>Useful for plugin architectures</li> <li> <p>Platform-specific limitations</p> </li> <li> <p>WebAssembly:</p> </li> <li>Allows Go code to run in browsers</li> <li>Enables cross-platform extensions</li> <li> <p>Growing ecosystem and tooling</p> </li> <li> <p>Multi-Language Integration:</p> </li> <li>Go can extend and be extended by other languages</li> <li>Useful for leveraging existing codebases</li> <li> <p>Requires careful handling of language boundaries</p> </li> <li> <p>Scripting Language Embedding:</p> </li> <li>Enables runtime extensibility</li> <li>Useful for configuration and plugins</li> <li>Multiple options available (Lua, JavaScript, etc.)</li> </ol> <p>By understanding these extension mechanisms, you can leverage Go's strengths while integrating with existing codebases and extending your applications' functionality. Whether you need to use C libraries, create plugin systems, or embed scripting languages, Go provides the tools you need to build flexible and extensible applications.</p>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/","title":"Type Conversions in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/36.%20Type-Conversions/#introduction-to-type-conversions","title":"Introduction to Type Conversions","text":"<p>In Go, type conversions (also called type casting) are explicit operations that change the type of a value. Unlike some languages that allow implicit conversions, Go requires explicit conversions between different types. This strict approach helps prevent bugs and makes code more predictable.</p>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#basic-type-conversions","title":"Basic Type Conversions","text":""},{"location":"2.%20Intermediate/36.%20Type-Conversions/#numeric-conversions","title":"Numeric Conversions","text":"<p>Go provides explicit conversions between numeric types. When converting between types of different sizes or signedness, you must be aware of potential data loss or overflow.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Integer to integer\n    var i int = 42\n    var i8 int8 = int8(i)\n    var i16 int16 = int16(i)\n    var i32 int32 = int32(i)\n    var i64 int64 = int64(i)\n    var u uint = uint(i)\n    var u8 uint8 = uint8(i)\n    var u16 uint16 = uint16(i)\n    var u32 uint32 = uint32(i)\n    var u64 uint64 = uint64(i)\n\n    fmt.Printf(\"Original: %d (type: %T)\\n\", i, i)\n    fmt.Printf(\"int8: %d (type: %T)\\n\", i8, i8)\n    fmt.Printf(\"uint: %d (type: %T)\\n\", u, u)\n\n    // Floating-point to floating-point\n    var f32 float32 = 3.14\n    var f64 float64 = float64(f32)\n    fmt.Printf(\"float32: %f (type: %T)\\n\", f32, f32)\n    fmt.Printf(\"float64: %f (type: %T)\\n\", f64, f64)\n\n    // Integer to floating-point\n    var x int = 10\n    var y float64 = float64(x)\n    fmt.Printf(\"int to float64: %f (type: %T)\\n\", y, y)\n\n    // Floating-point to integer (truncates decimal part)\n    var z float64 = 3.9\n    var w int = int(z)\n    fmt.Printf(\"float64 to int: %d (type: %T)\\n\", w, w)\n\n    // Handling overflow\n    var bigInt int64 = math.MaxInt64\n    var smallInt int8 = int8(bigInt) // This will overflow\n    fmt.Printf(\"Overflow example: %d (type: %T)\\n\", smallInt, smallInt)\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#string-and-byte-conversions","title":"String and Byte Conversions","text":"<p>Converting between strings and byte slices is a common operation in Go:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    // String to byte slice\n    s := \"Hello, World!\"\n    b := []byte(s)\n    fmt.Printf(\"String: %s (type: %T)\\n\", s, s)\n    fmt.Printf(\"Byte slice: %v (type: %T)\\n\", b, b)\n\n    // Byte slice to string\n    s2 := string(b)\n    fmt.Printf(\"Back to string: %s (type: %T)\\n\", s2, s2)\n\n    // Rune to string\n    r := 'G'\n    s3 := string(r)\n    fmt.Printf(\"Rune: %c (type: %T)\\n\", r, r)\n    fmt.Printf(\"Rune to string: %s (type: %T)\\n\", s3, s3)\n\n    // String to rune slice\n    s4 := \"Hello\"\n    runes := []rune(s4)\n    fmt.Printf(\"String: %s (type: %T)\\n\", s4, s4)\n    fmt.Printf(\"Rune slice: %v (type: %T)\\n\", runes, runes)\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#boolean-conversions","title":"Boolean Conversions","text":"<p>There are no direct conversions between booleans and other types in Go. You must use conditional expressions:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc main() {\n    // Boolean to string\n    b := true\n    s := strconv.FormatBool(b)\n    fmt.Printf(\"Boolean: %t (type: %T)\\n\", b, b)\n    fmt.Printf(\"Boolean to string: %s (type: %T)\\n\", s, s)\n\n    // String to boolean\n    s2 := \"true\"\n    b2, err := strconv.ParseBool(s2)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"String: %s (type: %T)\\n\", s2, s2)\n        fmt.Printf(\"String to boolean: %t (type: %T)\\n\", b2, b2)\n    }\n\n    // Numeric to boolean (no direct conversion)\n    i := 1\n    b3 := i != 0\n    fmt.Printf(\"Numeric: %d (type: %T)\\n\", i, i)\n    fmt.Printf(\"Numeric to boolean: %t (type: %T)\\n\", b3, b3)\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#type-assertions","title":"Type Assertions","text":"<p>Type assertions are used to extract the concrete value from an interface variable.</p>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#basic-type-assertions","title":"Basic Type Assertions","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    var i interface{} = \"Hello, World!\"\n\n    // Type assertion\n    s, ok := i.(string)\n    if ok {\n        fmt.Printf(\"i is a string: %s\\n\", s)\n    } else {\n        fmt.Println(\"i is not a string\")\n    }\n\n    // Type assertion with panic if wrong type\n    s2 := i.(string)\n    fmt.Printf(\"i is definitely a string: %s\\n\", s2)\n\n    // This would panic:\n    // n := i.(int)\n    // fmt.Println(n)\n\n    // Safe type assertion\n    if n, ok := i.(int); ok {\n        fmt.Printf(\"i is an int: %d\\n\", n)\n    } else {\n        fmt.Println(\"i is not an int\")\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#type-switches","title":"Type Switches","text":"<p>Type switches are a convenient way to handle multiple possible types:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc processValue(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", v)\n    case float64:\n        fmt.Printf(\"Float: %f\\n\", v)\n    case string:\n        fmt.Printf(\"String: %s\\n\", v)\n    case bool:\n        fmt.Printf(\"Boolean: %t\\n\", v)\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n\nfunc main() {\n    processValue(42)\n    processValue(3.14)\n    processValue(\"Hello\")\n    processValue(true)\n    processValue([]int{1, 2, 3})\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#custom-type-conversions","title":"Custom Type Conversions","text":"<p>You can define methods on your types to enable conversions between custom types.</p>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#creating-conversion-methods","title":"Creating Conversion Methods","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\ntype Celsius float64\ntype Fahrenheit float64\n\nfunc (c Celsius) String() string {\n    return fmt.Sprintf(\"%.2f\u00b0C\", c)\n}\n\nfunc (f Fahrenheit) String() string {\n    return fmt.Sprintf(\"%.2f\u00b0F\", f)\n}\n\n// Conversion methods\nfunc (c Celsius) Fahrenheit() Fahrenheit {\n    return Fahrenheit(c*9/5 + 32)\n}\n\nfunc (f Fahrenheit) Celsius() Celsius {\n    return Celsius((f - 32) * 5 / 9)\n}\n\ntype Money float64\n\nfunc (m Money) String() string {\n    return fmt.Sprintf(\"$%.2f\", m)\n}\n\nfunc (m Money) Dollars() int {\n    return int(m)\n}\n\nfunc (m Money) Cents() int {\n    return int(m*100) % 100\n}\n\nfunc Dollars(d int, c int) Money {\n    return Money(float64(d) + float64(c)/100)\n}\n\nfunc main() {\n    // Temperature conversions\n    c := Celsius(100)\n    f := c.Fahrenheit()\n    fmt.Printf(\"%s is %s\\n\", c, f)\n\n    f2 := Fahrenheit(32)\n    c2 := f2.Celsius()\n    fmt.Printf(\"%s is %s\\n\", f2, c2)\n\n    // Money conversions\n    m := Money(12.49)\n    fmt.Printf(\"%s is %d dollars and %d cents\\n\", m, m.Dollars(), m.Cents())\n\n    m2 := Dollars(5, 99)\n    fmt.Printf(\"Dollars and cents: %s\\n\", m2)\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#converting-to-and-from-strings","title":"Converting to and from Strings","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"time\"\n)\n\ntype Date struct {\n    Year  int\n    Month time.Month\n    Day   int\n}\n\nfunc (d Date) String() string {\n    return fmt.Sprintf(\"%04d-%02d-%02d\", d.Year, d.Month, d.Day)\n}\n\nfunc ParseDate(s string) (Date, error) {\n    parts := []string{s[0:4], s[5:7], s[8:10]}\n\n    year, err := strconv.Atoi(parts[0])\n    if err != nil {\n        return Date{}, err\n    }\n\n    month, err := strconv.Atoi(parts[1])\n    if err != nil {\n        return Date{}, err\n    }\n\n    day, err := strconv.Atoi(parts[2])\n    if err != nil {\n        return Date{}, err\n    }\n\n    return Date{\n        Year:  year,\n        Month: time.Month(month),\n        Day:   day,\n    }, nil\n}\n\nfunc main() {\n    // Date to string\n    d := Date{2023, 10, 15}\n    s := d.String()\n    fmt.Printf(\"Date: %s (type: %T)\\n\", d, d)\n    fmt.Printf(\"String: %s (type: %T)\\n\", s, s)\n\n    // String to date\n    s2 := \"2023-11-20\"\n    d2, err := ParseDate(s2)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Printf(\"String: %s (type: %T)\\n\", s2, s2)\n        fmt.Printf(\"Date: %s (type: %T)\\n\", d2, d2)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#common-pitfalls-and-best-practices","title":"Common Pitfalls and Best Practices","text":""},{"location":"2.%20Intermediate/36.%20Type-Conversions/#1-overflow-and-underflow","title":"1. Overflow and Underflow","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Integer overflow\n    var bigInt int64 = math.MaxInt64\n    var smallInt int8 = int8(bigInt) // This will overflow\n    fmt.Printf(\"Max int64: %d\\n\", bigInt)\n    fmt.Printf(\"Converted to int8: %d\\n\", smallInt)\n\n    // Floating-point precision loss\n    var bigFloat float64 = 1.23456789012345\n    var smallFloat float32 = float32(bigFloat)\n    fmt.Printf(\"Original float64: %.15f\\n\", bigFloat)\n    fmt.Printf(\"Converted to float32: %.15f\\n\", smallFloat)\n\n    // Safe conversion with checking\n    var x int32 = 1000\n    var y int8\n\n    if x &lt; math.MinInt8 || x &gt; math.MaxInt8 {\n        fmt.Println(\"Conversion would overflow\")\n    } else {\n        y = int8(x)\n        fmt.Printf(\"Safe conversion: %d\\n\", y)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#2-loss-of-precision","title":"2. Loss of Precision","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    // Floating-point to integer\n    f := 3.9\n    i := int(f) // Truncates, doesn't round\n    fmt.Printf(\"Original float: %f\\n\", f)\n    fmt.Printf(\"Converted to int: %d\\n\", i)\n\n    // For rounding, use math.Round\n    import \"math\"\n    i2 := int(math.Round(f))\n    fmt.Printf(\"Rounded to int: %d\\n\", i2)\n\n    // Large integers to floating-point\n    bigInt := int64(9007199254740993) // 2^53 + 1\n    bigFloat := float64(bigInt)\n    backToInt := int64(bigFloat)\n    fmt.Printf(\"Original int64: %d\\n\", bigInt)\n    fmt.Printf(\"Converted to float64: %f\\n\", bigFloat)\n    fmt.Printf(\"Back to int64: %d\\n\", backToInt)\n    fmt.Printf(\"Values equal? %t\\n\", bigInt == backToInt) // May be false due to precision loss\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#3-type-assertion-safety","title":"3. Type Assertion Safety","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    var i interface{} = \"Hello\"\n\n    // Safe type assertion\n    if s, ok := i.(string); ok {\n        fmt.Printf(\"i is a string: %s\\n\", s)\n    } else {\n        fmt.Println(\"i is not a string\")\n    }\n\n    // Unsafe type assertion (would panic)\n    // n := i.(int)\n    // fmt.Println(n)\n\n    // Using type switches for safety\n    switch v := i.(type) {\n    case string:\n        fmt.Printf(\"i is a string: %s\\n\", v)\n    case int:\n        fmt.Printf(\"i is an int: %d\\n\", v)\n    default:\n        fmt.Printf(\"i is of type %T\\n\", v)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#4-string-conversion-efficiency","title":"4. String Conversion Efficiency","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n)\n\nfunc main() {\n    // Inefficient string concatenation in loops\n    var s1 string\n    for i := 0; i &lt; 1000; i++ {\n        s1 += strconv.Itoa(i) // Creates a new string each time\n    }\n    fmt.Printf(\"Length of inefficient concatenation: %d\\n\", len(s1))\n\n    // Efficient string building\n    var builder strings.Builder\n    for i := 0; i &lt; 1000; i++ {\n        builder.WriteString(strconv.Itoa(i))\n    }\n    s2 := builder.String()\n    fmt.Printf(\"Length of efficient concatenation: %d\\n\", len(s2))\n\n    // Byte slice to string conversion\n    b := []byte{'H', 'e', 'l', 'l', 'o'}\n    s3 := string(b) // Creates a new string\n    fmt.Printf(\"Byte slice to string: %s\\n\", s3)\n\n    // String to byte slice conversion\n    s4 := \"World\"\n    b2 := []byte(s4) // Creates a new byte slice\n    fmt.Printf(\"String to byte slice: %v\\n\", b2)\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#real-world-example-data-processing-pipeline","title":"Real-World Example: Data Processing Pipeline","text":"<p>Let's create a comprehensive example that demonstrates various type conversions in a data processing context:</p> <pre><code>package main\n\nimport (\n    \"encoding/csv\"\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"math\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n)\n\ntype Person struct {\n    ID        int       `json:\"id\"`\n    Name      string    `json:\"name\"`\n    Age       int       `json:\"age\"`\n    Salary    float64   `json:\"salary\"`\n    HireDate  time.Time `json:\"hire_date\"`\n    IsActive  bool      `json:\"is_active\"`\n}\n\ntype PersonCSV struct {\n    ID        string `csv:\"id\"`\n    Name      string `csv:\"name\"`\n    Age       string `csv:\"age\"`\n    Salary    string `csv:\"salary\"`\n    HireDate  string `csv:\"hire_date\"`\n    IsActive  string `csv:\"is_active\"`\n}\n\nfunc main() {\n    // Read CSV file\n    file, err := os.Open(\"people.csv\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n\n    reader := csv.NewReader(file)\n    records, err := reader.ReadAll()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Skip header\n    var people []Person\n    for i, record := range records {\n        if i == 0 {\n            continue // Skip header\n        }\n\n        // Parse CSV record\n        csvPerson := PersonCSV{\n            ID:       record[0],\n            Name:     record[1],\n            Age:      record[2],\n            Salary:   record[3],\n            HireDate: record[4],\n            IsActive: record[5],\n        }\n\n        // Convert CSV to Person\n        person, err := csvToPerson(csvPerson)\n        if err != nil {\n            log.Printf(\"Error converting record %d: %v\", i, err)\n            continue\n        }\n\n        people = append(people, person)\n    }\n\n    // Process people\n    var totalSalary float64\n    var activeCount int\n    var ageSum int\n\n    for _, person := range people {\n        totalSalary += person.Salary\n        if person.IsActive {\n            activeCount++\n        }\n        ageSum += person.Age\n    }\n\n    // Calculate statistics\n    avgSalary := totalSalary / float64(len(people))\n    avgAge := float64(ageSum) / float64(len(people))\n    activePercentage := float64(activeCount) / float64(len(people)) * 100\n\n    // Create statistics\n    stats := map[string]interface{}{\n        \"total_people\":      len(people),\n        \"total_salary\":      totalSalary,\n        \"average_salary\":    avgSalary,\n        \"average_age\":       avgAge,\n        \"active_count\":      activeCount,\n        \"active_percentage\": activePercentage,\n    }\n\n    // Print statistics\n    fmt.Println(\"Statistics:\")\n    for key, value := range stats {\n        switch v := value.(type) {\n        case int:\n            fmt.Printf(\"%s: %d\\n\", key, v)\n        case float64:\n            fmt.Printf(\"%s: %.2f\\n\", key, v)\n        default:\n            fmt.Printf(\"%s: %v\\n\", key, v)\n        }\n    }\n\n    // Convert to JSON\n    jsonData, err := json.MarshalIndent(people, \"\", \"  \")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Write JSON file\n    jsonFile, err := os.Create(\"people.json\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer jsonFile.Close()\n\n    _, err = jsonFile.Write(jsonData)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(\"Data processed and saved to people.json\")\n}\n\nfunc csvToPerson(csvPerson PersonCSV) (Person, error) {\n    var person Person\n    var err error\n\n    // Convert ID\n    person.ID, err = strconv.Atoi(csvPerson.ID)\n    if err != nil {\n        return Person{}, fmt.Errorf(\"invalid ID: %v\", err)\n    }\n\n    // Convert Name\n    person.Name = strings.TrimSpace(csvPerson.Name)\n    if person.Name == \"\" {\n        return Person{}, fmt.Errorf(\"name is empty\")\n    }\n\n    // Convert Age\n    person.Age, err = strconv.Atoi(csvPerson.Age)\n    if err != nil {\n        return Person{}, fmt.Errorf(\"invalid age: %v\", err)\n    }\n    if person.Age &lt; 0 || person.Age &gt; 120 {\n        return Person{}, fmt.Errorf(\"age out of range: %d\", person.Age)\n    }\n\n    // Convert Salary\n    person.Salary, err = strconv.ParseFloat(csvPerson.Salary, 64)\n    if err != nil {\n        return Person{}, fmt.Errorf(\"invalid salary: %v\", err)\n    }\n    if person.Salary &lt; 0 {\n        return Person{}, fmt.Errorf(\"salary cannot be negative: %f\", person.Salary)\n    }\n\n    // Convert HireDate\n    person.HireDate, err = time.Parse(\"2006-01-02\", csvPerson.HireDate)\n    if err != nil {\n        return Person{}, fmt.Errorf(\"invalid hire date: %v\", err)\n    }\n\n    // Convert IsActive\n    person.IsActive, err = strconv.ParseBool(csvPerson.IsActive)\n    if err != nil {\n        return Person{}, fmt.Errorf(\"invalid active status: %v\", err)\n    }\n\n    return person, nil\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#how-this-example-demonstrates-type-conversions","title":"How This Example Demonstrates Type Conversions:","text":"<ol> <li>String to Numeric Conversions:</li> <li><code>strconv.Atoi</code> for string to int</li> <li><code>strconv.ParseFloat</code> for string to float64</li> <li> <p><code>strconv.ParseBool</code> for string to bool</p> </li> <li> <p>Date Parsing:</p> </li> <li> <p><code>time.Parse</code> for string to time.Time</p> </li> <li> <p>Custom Type Conversions:</p> </li> <li><code>csvToPerson</code> function converts from CSV struct to Person struct</li> <li> <p>Includes validation and error handling</p> </li> <li> <p>Interface Type Handling:</p> </li> <li>Type switch in statistics printing to handle different types</li> <li> <p>JSON marshaling uses interface{} for flexible data representation</p> </li> <li> <p>Error Handling:</p> </li> <li>Proper error handling for all conversions</li> <li>Meaningful error messages</li> </ol>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#best-practices-for-type-conversions","title":"Best Practices for Type Conversions","text":""},{"location":"2.%20Intermediate/36.%20Type-Conversions/#1-always-check-for-errors","title":"1. Always Check for Errors","text":"<pre><code>// Good\ns := \"123\"\ni, err := strconv.Atoi(s)\nif err != nil {\n    // Handle error\n}\n\n// Bad (panics on invalid input)\ni := int(s.(int))\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#2-use-safe-type-assertions","title":"2. Use Safe Type Assertions","text":"<pre><code>// Good\nif s, ok := i.(string); ok {\n    // Use s\n}\n\n// Bad (panics if wrong type)\ns := i.(string)\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#3-be-aware-of-precision-loss","title":"3. Be Aware of Precision Loss","text":"<pre><code>// Good - check for overflow\nvar x int32 = 1000\nvar y int8\n\nif x &lt; math.MinInt8 || x &gt; math.MaxInt8 {\n    // Handle overflow\n} else {\n    y = int8(x)\n}\n\n// Bad - potential overflow\ny = int8(x)\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#4-use-appropriate-conversion-functions","title":"4. Use Appropriate Conversion Functions","text":"<pre><code>// Good - use strconv for string conversions\ns := \"3.14\"\nf, err := strconv.ParseFloat(s, 64)\n\n// Bad - potential precision loss\nf := float64(int(s))\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#5-create-conversion-methods-for-custom-types","title":"5. Create Conversion Methods for Custom Types","text":"<pre><code>// Good\ntype Celsius float64\ntype Fahrenheit float64\n\nfunc (c Celsius) Fahrenheit() Fahrenheit {\n    return Fahrenheit(c*9/5 + 32)\n}\n\n// Usage\nc := Celsius(100)\nf := c.Fahrenheit()\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#conclusion","title":"Conclusion","text":"<p>Type conversions are a fundamental aspect of Go programming:</p>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#key-takeaways","title":"Key Takeaways:","text":"<ol> <li>Explicit Conversions:</li> <li>Go requires explicit conversions between different types</li> <li> <p>This prevents implicit conversion bugs</p> </li> <li> <p>Numeric Conversions:</p> </li> <li>Be aware of overflow and underflow</li> <li> <p>Check bounds when converting between types of different sizes</p> </li> <li> <p>String Conversions:</p> </li> <li>Use <code>strconv</code> package for string to numeric conversions</li> <li> <p>Be efficient with string concatenation using <code>strings.Builder</code></p> </li> <li> <p>Type Assertions:</p> </li> <li>Use safe assertions with the comma-ok idiom</li> <li> <p>Use type switches for handling multiple possible types</p> </li> <li> <p>Custom Conversions:</p> </li> <li>Create conversion methods for custom types</li> <li> <p>Include validation and error handling</p> </li> <li> <p>Best Practices:</p> </li> <li>Always check for errors</li> <li>Be aware of precision loss</li> <li>Use appropriate conversion functions</li> <li>Create meaningful conversion methods</li> </ol> <p>By understanding and properly using type conversions, you can write more robust, predictable, and maintainable Go code. Type safety is one of Go's strengths, and mastering type conversions will help you leverage this safety effectively.</p>"},{"location":"2.%20Intermediate/37.%20IO-Package/","title":"The IO Package in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/37.%20IO-Package/#introduction-to-the-io-package","title":"Introduction to the IO Package","text":"<p>The <code>io</code> package in Go provides fundamental interfaces and primitives for I/O operations. It forms the foundation for many other packages in the standard library that deal with input and output, including files, network connections, compression, and more. Understanding the <code>io</code> package is essential for effective Go programming.</p>"},{"location":"2.%20Intermediate/37.%20IO-Package/#core-interfaces","title":"Core Interfaces","text":""},{"location":"2.%20Intermediate/37.%20IO-Package/#reader-interface","title":"Reader Interface","text":"<p>The <code>Reader</code> interface is the cornerstone of input operations in Go:</p> <pre><code>type Reader interface {\n    Read(p []byte) (n int, err error)\n}\n</code></pre> <p>The <code>Read</code> method reads up to <code>len(p)</code> bytes into <code>p</code> and returns the number of bytes read and any error encountered. When the stream ends, it returns <code>io.EOF</code> error.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // Using strings.Reader as an example\n    r := strings.NewReader(\"Hello, World!\")\n\n    // Create a buffer to read into\n    buf := make([]byte, 8)\n\n    // Read into the buffer\n    n, err := r.Read(buf)\n    if err != nil &amp;&amp; err != io.EOF {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Printf(\"Read %d bytes: %s\\n\", n, buf[:n])\n\n    // Read the rest\n    n, err = r.Read(buf)\n    if err != nil &amp;&amp; err != io.EOF {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Printf(\"Read %d bytes: %s\\n\", n, buf[:n])\n\n    // Try to read more (should get EOF)\n    n, err = r.Read(buf)\n    if err == io.EOF {\n        fmt.Println(\"Reached end of file\")\n    } else if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#writer-interface","title":"Writer Interface","text":"<p>The <code>Writer</code> interface handles output operations:</p> <pre><code>type Writer interface {\n    Write(p []byte) (n int, err error)\n}\n</code></pre> <p>The <code>Write</code> method writes <code>len(p)</code> bytes from <code>p</code> to the underlying data stream and returns the number of bytes written and any error encountered.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n)\n\nfunc main() {\n    // Using os.Stdout as a Writer\n    data := []byte(\"Hello, World!\\n\")\n\n    n, err := os.Stdout.Write(data)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Printf(\"Wrote %d bytes\\n\", n)\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#closer-interface","title":"Closer Interface","text":"<p>The <code>Closer</code> interface is for resources that need to be cleaned up:</p> <pre><code>type Closer interface {\n    Close() error\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Open a file\n    file, err := os.Open(\"example.txt\")\n    if err != nil {\n        fmt.Println(\"Error opening file:\", err)\n        return\n    }\n\n    // Defer closing the file\n    defer func() {\n        err := file.Close()\n        if err != nil {\n            fmt.Println(\"Error closing file:\", err)\n        }\n    }()\n\n    // Use the file...\n    fmt.Println(\"File opened successfully\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#seeker-interface","title":"Seeker Interface","text":"<p>The <code>Seeker</code> interface supports random access to a stream:</p> <pre><code>type Seeker interface {\n    Seek(offset int64, whence int) (int64, error)\n}\n</code></pre> <p>The <code>whence</code> parameter determines the reference point for the offset: - <code>io.SeekStart</code> (0): Relative to the start of the file - <code>io.SeekCurrent</code> (1): Relative to the current position - <code>io.SeekEnd</code> (2): Relative to the end of the file</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // Create a temporary file\n    tmpfile, err := os.CreateTemp(\"\", \"example\")\n    if err != nil {\n        fmt.Println(\"Error creating temp file:\", err)\n        return\n    }\n    defer os.Remove(tmpfile.Name()) // Clean up\n    defer tmpfile.Close()\n\n    // Write some data\n    data := \"0123456789\"\n    _, err = tmpfile.WriteString(data)\n    if err != nil {\n        fmt.Println(\"Error writing to file:\", err)\n        return\n    }\n\n    // Read from the beginning\n    buf := make([]byte, 3)\n    _, err = tmpfile.Seek(0, io.SeekStart)\n    if err != nil {\n        fmt.Println(\"Error seeking:\", err)\n        return\n    }\n\n    n, err := tmpfile.Read(buf)\n    if err != nil {\n        fmt.Println(\"Error reading:\", err)\n        return\n    }\n    fmt.Printf(\"Read from start: %s\\n\", buf[:n])\n\n    // Read from position 5\n    _, err = tmpfile.Seek(5, io.SeekStart)\n    if err != nil {\n        fmt.Println(\"Error seeking:\", err)\n        return\n    }\n\n    n, err = tmpfile.Read(buf)\n    if err != nil {\n        fmt.Println(\"Error reading:\", err)\n        return\n    }\n    fmt.Printf(\"Read from position 5: %s\\n\", buf[:n])\n\n    // Read from the end\n    _, err = tmpfile.Seek(-3, io.SeekEnd)\n    if err != nil {\n        fmt.Println(\"Error seeking:\", err)\n        return\n    }\n\n    n, err = tmpfile.Read(buf)\n    if err != nil {\n        fmt.Println(\"Error reading:\", err)\n        return\n    }\n    fmt.Printf(\"Read from end: %s\\n\", buf[:n])\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#combined-interfaces","title":"Combined Interfaces","text":"<p>The <code>io</code> package also defines several combined interfaces for convenience:</p> <pre><code>type ReadCloser interface {\n    Reader\n    Closer\n}\n\ntype WriteCloser interface {\n    Writer\n    Closer\n}\n\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\ntype ReadSeeker interface {\n    Reader\n    Seeker\n}\n\ntype WriteSeeker interface {\n    Writer\n    Seeker\n}\n\ntype ReadWriteSeeker interface {\n    Reader\n    Writer\n    Seeker\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#utility-functions","title":"Utility Functions","text":""},{"location":"2.%20Intermediate/37.%20IO-Package/#copy-and-copybuffer","title":"Copy and CopyBuffer","text":"<p>The <code>Copy</code> function copies from a Reader to a Writer:</p> <pre><code>func Copy(dst Writer, src Reader) (written int64, err error)\n</code></pre> <p><code>CopyBuffer</code> is similar but allows you to provide your own buffer:</p> <pre><code>func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // Create a reader and a writer\n    src := strings.NewReader(\"This is a test string for copying.\")\n    dst := &amp;strings.Builder{}\n\n    // Copy from reader to writer\n    written, err := io.Copy(dst, src)\n    if err != nil {\n        fmt.Println(\"Error copying:\", err)\n        return\n    }\n\n    fmt.Printf(\"Copied %d bytes: %s\\n\", written, dst.String())\n\n    // Using CopyBuffer with a custom buffer\n    src2 := strings.NewReader(\"Another test string for copying with a custom buffer.\")\n    dst2 := &amp;strings.Builder{}\n    buf := make([]byte, 8) // Custom buffer size\n\n    written, err = io.CopyBuffer(dst2, src2, buf)\n    if err != nil {\n        fmt.Println(\"Error copying with buffer:\", err)\n        return\n    }\n\n    fmt.Printf(\"Copied %d bytes with buffer: %s\\n\", written, dst2.String())\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#readatleast-and-readfull","title":"ReadAtLeast and ReadFull","text":"<p><code>ReadAtLeast</code> reads from a Reader into a buffer until at least the specified number of bytes have been read:</p> <pre><code>func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)\n</code></pre> <p><code>ReadFull</code> reads exactly <code>len(buf)</code> bytes from the Reader:</p> <pre><code>func ReadFull(r Reader, buf []byte) (n int, err error)\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"strings\"\n)\n\nfunc main() {\n    // Create a reader\n    r := strings.NewReader(\"Hello, World!\")\n\n    // Read at least 5 bytes\n    buf := make([]byte, 10)\n    n, err := io.ReadAtLeast(r, buf, 5)\n    if err != nil {\n        fmt.Println(\"Error reading at least:\", err)\n        return\n    }\n    fmt.Printf(\"Read at least 5 bytes (%d total): %s\\n\", n, buf[:n])\n\n    // Reset the reader\n    r = strings.NewReader(\"Short\")\n\n    // Try to read 10 bytes (will fail)\n    buf = make([]byte, 10)\n    n, err = io.ReadFull(r, buf)\n    if err != nil {\n        if err == io.ErrUnexpectedEOF {\n            fmt.Printf(\"ReadFull failed: %v (only read %d bytes)\\n\", err, n)\n        } else {\n            fmt.Println(\"Error reading full:\", err)\n        }\n    }\n\n    // Reset the reader\n    r = strings.NewReader(\"Exactly 10!\")\n\n    // Read exactly 10 bytes\n    buf = make([]byte, 10)\n    n, err = io.ReadFull(r, buf)\n    if err != nil {\n        fmt.Println(\"Error reading full:\", err)\n        return\n    }\n    fmt.Printf(\"Read exactly 10 bytes: %s\\n\", buf)\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#writestring","title":"WriteString","text":"<p><code>WriteString</code> writes a string to a Writer:</p> <pre><code>func WriteString(w Writer, s string) (n int, err error)\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n)\n\nfunc main() {\n    // Write a string to stdout\n    n, err := io.WriteString(os.Stdout, \"Hello, World!\\n\")\n    if err != nil {\n        fmt.Println(\"Error writing string:\", err)\n        return\n    }\n    fmt.Printf(\"Wrote %d bytes\\n\", n)\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#limitreader","title":"LimitReader","text":"<p><code>LimitReader</code> returns a Reader that reads from the given Reader but stops with EOF after n bytes:</p> <pre><code>func LimitReader(r Reader, n int64) Reader\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"strings\"\n)\n\nfunc main() {\n    // Create a reader\n    r := strings.NewReader(\"This is a long string that we want to limit.\")\n\n    // Create a limited reader that reads only 10 bytes\n    limitedR := io.LimitReader(r, 10)\n\n    // Read from the limited reader\n    buf := make([]byte, 20)\n    n, err := limitedR.Read(buf)\n    if err != nil &amp;&amp; err != io.EOF {\n        fmt.Println(\"Error reading:\", err)\n        return\n    }\n\n    fmt.Printf(\"Read %d bytes from limited reader: %s\\n\", n, buf[:n])\n\n    // Try to read more (should get EOF)\n    n, err = limitedR.Read(buf)\n    if err == io.EOF {\n        fmt.Println(\"Reached end of limited reader\")\n    } else if err != nil {\n        fmt.Println(\"Error reading:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#sectionreader","title":"SectionReader","text":"<p><code>SectionReader</code> returns a <code>ReadSeeker</code> that reads from the given Reader starting at offset off and stops with EOF after n bytes:</p> <pre><code>func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // Create a reader\n    r := strings.NewReader(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n    // Create a section reader that reads from position 10 to 20\n    sectionR := io.NewSectionReader(r, 10, 10)\n\n    // Read from the section reader\n    buf := make([]byte, 20)\n    n, err := sectionR.Read(buf)\n    if err != nil &amp;&amp; err != io.EOF {\n        fmt.Println(\"Error reading:\", err)\n        return\n    }\n\n    fmt.Printf(\"Read %d bytes from section reader: %s\\n\", n, buf[:n])\n\n    // Seek within the section reader\n    _, err = sectionR.Seek(0, io.SeekStart)\n    if err != nil {\n        fmt.Println(\"Error seeking:\", err)\n        return\n    }\n\n    n, err = sectionR.Read(buf)\n    if err != nil &amp;&amp; err != io.EOF {\n        fmt.Println(\"Error reading:\", err)\n        return\n    }\n\n    fmt.Printf(\"Read from start of section: %s\\n\", buf[:n])\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#teereader","title":"TeeReader","text":"<p><code>TeeReader</code> returns a Reader that writes to the given Writer what it reads from the given Reader:</p> <pre><code>func TeeReader(r Reader, w Writer) Reader\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // Create a reader and a writer\n    r := strings.NewReader(\"This will be both read and written.\")\n    w := &amp;strings.Builder{}\n\n    // Create a tee reader\n    teeR := io.TeeReader(r, w)\n\n    // Read from the tee reader (which also writes to the writer)\n    buf := make([]byte, 20)\n    n, err := teeR.Read(buf)\n    if err != nil &amp;&amp; err != io.EOF {\n        fmt.Println(\"Error reading:\", err)\n        return\n    }\n\n    fmt.Printf(\"Read %d bytes: %s\\n\", n, buf[:n])\n    fmt.Printf(\"Writer contains: %s\\n\", w.String())\n\n    // Read the rest\n    n, err = teeR.Read(buf)\n    if err != nil &amp;&amp; err != io.EOF {\n        fmt.Println(\"Error reading:\", err)\n        return\n    }\n\n    fmt.Printf(\"Read %d more bytes: %s\\n\", n, buf[:n])\n    fmt.Printf(\"Writer now contains: %s\\n\", w.String())\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#multireader-and-multiwriter","title":"MultiReader and MultiWriter","text":"<p><code>MultiReader</code> returns a Reader that's the logical concatenation of the provided input Readers:</p> <pre><code>func MultiReader(readers ...Reader) Reader\n</code></pre> <p><code>MultiWriter</code> creates a Writer that duplicates its writes to all the provided Writers:</p> <pre><code>func MultiWriter(writers ...Writer) Writer\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // MultiReader example\n    r1 := strings.NewReader(\"Hello, \")\n    r2 := strings.NewReader(\"World!\")\n    multiR := io.MultiReader(r1, r2)\n\n    // Read from the multi reader\n    buf := make([]byte, 20)\n    n, err := multiR.Read(buf)\n    if err != nil &amp;&amp; err != io.EOF {\n        fmt.Println(\"Error reading:\", err)\n        return\n    }\n\n    fmt.Printf(\"Read %d bytes from multi reader: %s\\n\", n, buf[:n])\n\n    // MultiWriter example\n    w1 := &amp;strings.Builder{}\n    w2 := os.Stdout\n    multiW := io.MultiWriter(w1, w2)\n\n    // Write to the multi writer\n    n, err = multiW.Write([]byte(\"This will be written to both writers.\\n\"))\n    if err != nil {\n        fmt.Println(\"Error writing:\", err)\n        return\n    }\n\n    fmt.Printf(\"Wrote %d bytes to multi writer\\n\", n)\n    fmt.Printf(\"First writer contains: %s\", w1.String())\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#pipereader-and-pipewriter","title":"PipeReader and PipeWriter","text":"<p><code>PipeReader</code> and <code>PipeWriter</code> implement an in-memory pipe:</p> <pre><code>func Pipe() (*PipeReader, *PipeWriter)\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"time\"\n)\n\nfunc main() {\n    // Create a pipe\n    pr, pw := io.Pipe()\n\n    // Start a goroutine to write to the pipe\n    go func() {\n        defer pw.Close()\n\n        for i := 0; i &lt; 5; i++ {\n            _, err := pw.Write([]byte(fmt.Sprintf(\"Message %d\\n\", i)))\n            if err != nil {\n                fmt.Println(\"Error writing to pipe:\", err)\n                return\n            }\n            time.Sleep(100 * time.Millisecond)\n        }\n    }()\n\n    // Read from the pipe\n    buf := make([]byte, 32)\n    for {\n        n, err := pr.Read(buf)\n        if err != nil {\n            if err == io.EOF {\n                fmt.Println(\"Pipe closed\")\n            } else {\n                fmt.Println(\"Error reading from pipe:\", err)\n            }\n            break\n        }\n\n        fmt.Printf(\"Read %d bytes from pipe: %s\", n, buf[:n])\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#working-with-files","title":"Working with Files","text":"<p>The <code>os</code> package implements many of the <code>io</code> interfaces for file operations:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n)\n\nfunc main() {\n    // Create a temporary file\n    tmpfile, err := os.CreateTemp(\"\", \"example\")\n    if err != nil {\n        fmt.Println(\"Error creating temp file:\", err)\n        return\n    }\n    defer os.Remove(tmpfile.Name()) // Clean up\n    defer tmpfile.Close()\n\n    // Write to the file\n    data := []byte(\"Hello, World!\\nThis is a test file.\\n\")\n    _, err = tmpfile.Write(data)\n    if err != nil {\n        fmt.Println(\"Error writing to file:\", err)\n        return\n    }\n\n    // Seek to the beginning\n    _, err = tmpfile.Seek(0, io.SeekStart)\n    if err != nil {\n        fmt.Println(\"Error seeking:\", err)\n        return\n    }\n\n    // Read from the file\n    buf := make([]byte, 32)\n    n, err := tmpfile.Read(buf)\n    if err != nil &amp;&amp; err != io.EOF {\n        fmt.Println(\"Error reading from file:\", err)\n        return\n    }\n\n    fmt.Printf(\"Read %d bytes: %s\\n\", n, buf[:n])\n\n    // Copy the file to stdout\n    _, err = tmpfile.Seek(0, io.SeekStart)\n    if err != nil {\n        fmt.Println(\"Error seeking:\", err)\n        return\n    }\n\n    _, err = io.Copy(os.Stdout, tmpfile)\n    if err != nil {\n        fmt.Println(\"Error copying file:\", err)\n        return\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/37.%20IO-Package/#1-always-check-for-errors","title":"1. Always Check for Errors","text":"<pre><code>// Good\nn, err := r.Read(buf)\nif err != nil &amp;&amp; err != io.EOF {\n    // Handle error\n}\n\n// Bad (ignores errors)\nn, _ := r.Read(buf)\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#2-handle-eof-properly","title":"2. Handle EOF Properly","text":"<pre><code>// Good\nn, err := r.Read(buf)\nif err != nil {\n    if err == io.EOF {\n        // Handle end of stream\n    } else {\n        // Handle other errors\n    }\n}\n\n// Bad (treats EOF as an error)\nn, err := r.Read(buf)\nif err != nil {\n    // This will trigger on EOF\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#3-use-the-right-tool-for-the-job","title":"3. Use the Right Tool for the Job","text":"<pre><code>// Good - use io.Copy for copying streams\n_, err := io.Copy(dst, src)\n\n// Bad - manual copying is less efficient\nbuf := make([]byte, 4096)\nfor {\n    n, err := src.Read(buf)\n    if err != nil {\n        if err == io.EOF {\n            break\n        }\n        return err\n    }\n    if _, err := dst.Write(buf[:n]); err != nil {\n        return err\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#4-close-resources-properly","title":"4. Close Resources Properly","text":"<pre><code>// Good - use defer to ensure resources are closed\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n    return err\n}\ndefer file.Close()\n\n// Bad - resources might not be closed if an error occurs\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n    return err\n}\n// Use file...\nfile.Close() // This might not be reached if an error occurs\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#5-use-buffered-io-for-performance","title":"5. Use Buffered I/O for Performance","text":"<pre><code>// Good - use bufio for better performance\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n    return err\n}\ndefer file.Close()\n\nreader := bufio.NewReader(file)\nline, err := reader.ReadString('\\n')\nif err != nil {\n    return err\n}\n\n// Bad - reading byte by byte is inefficient\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n    return err\n}\ndefer file.Close()\n\nvar line []byte\nvar b [1]byte\nfor {\n    _, err := file.Read(b[:])\n    if err != nil {\n        if err == io.EOF {\n            break\n        }\n        return err\n    }\n    if b[0] == '\\n' {\n        break\n    }\n    line = append(line, b[0])\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#real-world-example-file-processing-pipeline","title":"Real-World Example: File Processing Pipeline","text":"<p>Let's create a comprehensive example that demonstrates various <code>io</code> package features in a file processing context:</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"compress/gzip\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\nfunc main() {\n    // Create a source file\n    srcFile, err := os.CreateTemp(\"\", \"source\")\n    if err != nil {\n        fmt.Println(\"Error creating source file:\", err)\n        return\n    }\n    defer os.Remove(srcFile.Name())\n    defer srcFile.Close()\n\n    // Write some data to the source file\n    data := \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\n\"\n    _, err = srcFile.WriteString(data)\n    if err != nil {\n        fmt.Println(\"Error writing to source file:\", err)\n        return\n    }\n\n    // Create a compressed file\n    compressedFile, err := os.CreateTemp(\"\", \"compressed.gz\")\n    if err != nil {\n        fmt.Println(\"Error creating compressed file:\", err)\n        return\n    }\n    defer os.Remove(compressedFile.Name())\n    defer compressedFile.Close()\n\n    // Compress the source file\n    srcFile.Seek(0, io.SeekStart)\n    gzipWriter := gzip.NewWriter(compressedFile)\n    _, err = io.Copy(gzipWriter, srcFile)\n    if err != nil {\n        fmt.Println(\"Error compressing file:\", err)\n        return\n    }\n    gzipWriter.Close()\n\n    // Create a processed file\n    processedFile, err := os.CreateTemp(\"\", \"processed\")\n    if err != nil {\n        fmt.Println(\"Error creating processed file:\", err)\n        return\n    }\n    defer os.Remove(processedFile.Name())\n    defer processedFile.Close()\n\n    // Process the compressed file (decompress, transform, and write)\n    compressedFile.Seek(0, io.SeekStart)\n    gzipReader, err := gzip.NewReader(compressedFile)\n    if err != nil {\n        fmt.Println(\"Error creating gzip reader:\", err)\n        return\n    }\n    defer gzipReader.Close()\n\n    // Create a buffered reader for line-by-line processing\n    bufReader := bufio.NewReader(gzipReader)\n\n    // Process each line\n    lineNum := 0\n    for {\n        lineNum++\n        line, err := bufReader.ReadString('\\n')\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            fmt.Println(\"Error reading line:\", err)\n            return\n        }\n\n        // Transform the line (convert to uppercase and add line number)\n        transformed := fmt.Sprintf(\"%d: %s\", lineNum, strings.ToUpper(strings.TrimSpace(line)))\n\n        // Write the transformed line\n        _, err = processedFile.WriteString(transformed + \"\\n\")\n        if err != nil {\n            fmt.Println(\"Error writing to processed file:\", err)\n            return\n        }\n    }\n\n    // Create a final output file\n    outputFile, err := os.CreateTemp(\"\", \"output\")\n    if err != nil {\n        fmt.Println(\"Error creating output file:\", err)\n        return\n    }\n    defer os.Remove(outputFile.Name())\n    defer outputFile.Close()\n\n    // Copy the processed file to the output file and to stdout\n    processedFile.Seek(0, io.SeekStart)\n    multiWriter := io.MultiWriter(outputFile, os.Stdout)\n    _, err = io.Copy(multiWriter, processedFile)\n    if err != nil {\n        fmt.Println(\"Error copying to output:\", err)\n        return\n    }\n\n    fmt.Println(\"\\nFile processing pipeline completed successfully!\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#how-this-example-demonstrates-io-concepts","title":"How This Example Demonstrates IO Concepts:","text":"<ol> <li>File Operations:</li> <li>Creating, writing to, and reading from files</li> <li> <p>Using <code>Seek</code> to reset file positions</p> </li> <li> <p>Compression:</p> </li> <li>Using <code>gzip</code> package which implements <code>io.Reader</code> and <code>io.Writer</code></li> <li> <p>Compressing and decompressing data streams</p> </li> <li> <p>Buffered I/O:</p> </li> <li>Using <code>bufio.Reader</code> for efficient line-by-line processing</li> <li> <p>Reading strings with delimiters</p> </li> <li> <p>MultiWriter:</p> </li> <li>Writing to multiple destinations simultaneously</li> <li> <p>Copying to both a file and stdout</p> </li> <li> <p>Error Handling:</p> </li> <li>Proper error handling for all I/O operations</li> <li> <p>Distinguishing between EOF and other errors</p> </li> <li> <p>Resource Management:</p> </li> <li>Using <code>defer</code> to ensure files are closed</li> <li>Cleaning up temporary files</li> </ol>"},{"location":"2.%20Intermediate/37.%20IO-Package/#conclusion","title":"Conclusion","text":"<p>The <code>io</code> package is fundamental to Go's I/O system:</p>"},{"location":"2.%20Intermediate/37.%20IO-Package/#key-takeaways","title":"Key Takeaways:","text":"<ol> <li>Core Interfaces:</li> <li><code>Reader</code>, <code>Writer</code>, <code>Closer</code>, and <code>Seeker</code> form the foundation</li> <li> <p>Combined interfaces like <code>ReadCloser</code> provide convenience</p> </li> <li> <p>Utility Functions:</p> </li> <li><code>Copy</code> and <code>CopyBuffer</code> for efficient stream copying</li> <li><code>ReadAtLeast</code> and <code>ReadFull</code> for precise reading</li> <li> <p><code>WriteString</code> for writing strings to Writers</p> </li> <li> <p>Reader and Writer Implementations:</p> </li> <li><code>LimitReader</code> for reading a limited number of bytes</li> <li><code>SectionReader</code> for reading a section of a ReaderAt</li> <li><code>TeeReader</code> for reading and writing simultaneously</li> <li> <p><code>MultiReader</code> and <code>MultiWriter</code> for combining multiple streams</p> </li> <li> <p>In-Memory Pipes:</p> </li> <li><code>PipeReader</code> and <code>PipeWriter</code> for in-memory communication</li> <li> <p>Useful for connecting different parts of an application</p> </li> <li> <p>Best Practices:</p> </li> <li>Always check for errors</li> <li>Handle EOF properly</li> <li>Use the right tool for the job</li> <li>Close resources properly</li> <li>Use buffered I/O for performance</li> </ol> <p>By mastering the <code>io</code> package, you'll be able to handle I/O operations efficiently and correctly in your Go applications. The interfaces and utilities provided by this package are used throughout the Go standard library and ecosystem, making it an essential part of any Go programmer's toolkit.</p>"},{"location":"2.%20Intermediate/38.%20Math-Package/","title":"The Math Package in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/38.%20Math-Package/#introduction-to-the-math-package","title":"Introduction to the Math Package","text":"<p>The <code>math</code> package in Go provides basic constants and mathematical functions for floating-point numbers. It includes operations for trigonometry, logarithms, exponentiation, rounding, and more. This package is essential for scientific computing, graphics programming, statistics, and any application that requires mathematical operations beyond basic arithmetic.</p>"},{"location":"2.%20Intermediate/38.%20Math-Package/#basic-constants","title":"Basic Constants","text":"<p>The <code>math</code> package defines several important mathematical constants:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    fmt.Println(\"Mathematical Constants:\")\n    fmt.Printf(\"Pi (\u03c0): %.15f\\n\", math.Pi)\n    fmt.Printf(\"E (e): %.15f\\n\", math.E)\n    fmt.Printf(\"Phi (\u03c6): %.15f\\n\", math.Phi)\n    fmt.Printf(\"Sqrt(2): %.15f\\n\", math.Sqrt2)\n    fmt.Printf(\"Sqrt(E): %.15f\\n\", math.SqrtE)\n    fmt.Printf(\"Sqrt(Pi): %.15f\\n\", math.SqrtPi)\n    fmt.Printf(\"Sqrt(Phi): %.15f\\n\", math.SqrtPhi)\n    fmt.Printf(\"Ln(2): %.15f\\n\", math.Ln2)\n    fmt.Printf(\"Ln(10): %.15f\\n\", math.Ln10)\n    fmt.Printf(\"Log2(e): %.15f\\n\", math.Log2E)\n    fmt.Printf(\"Log10(e): %.15f\\n\", math.Log10E)\n\n    // Machine-specific constants\n    fmt.Println(\"\\nMachine-Specific Constants:\")\n    fmt.Printf(\"Max float64: %g\\n\", math.MaxFloat64)\n    fmt.Printf(\"Smallest positive float64: %g\\n\", math.SmallestNonzeroFloat64)\n    fmt.Printf(\"Max int: %d\\n\", math.MaxInt)\n    fmt.Printf(\"Min int: %d\\n\", math.MinInt)\n    fmt.Printf(\"Max int8: %d\\n\", math.MaxInt8)\n    fmt.Printf(\"Min int8: %d\\n\", math.MinInt8)\n    fmt.Printf(\"Max int16: %d\\n\", math.MaxInt16)\n    fmt.Printf(\"Min int16: %d\\n\", math.MinInt16)\n    fmt.Printf(\"Max int32: %d\\n\", math.MaxInt32)\n    fmt.Printf(\"Min int32: %d\\n\", math.MinInt32)\n    fmt.Printf(\"Max int64: %d\\n\", math.MaxInt64)\n    fmt.Printf(\"Min int64: %d\\n\", math.MinInt64)\n    fmt.Printf(\"Max uint: %d\\n\", math.MaxUint)\n    fmt.Printf(\"Max uint8: %d\\n\", math.MaxUint8)\n    fmt.Printf(\"Max uint16: %d\\n\", math.MaxUint16)\n    fmt.Printf(\"Max uint32: %d\\n\", math.MaxUint32)\n    fmt.Printf(\"Max uint64: %d\\n\", math.MaxUint64)\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#basic-operations","title":"Basic Operations","text":""},{"location":"2.%20Intermediate/38.%20Math-Package/#minimum-and-maximum","title":"Minimum and Maximum","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Find minimum and maximum values\n    a, b := 3.14, 2.71\n    fmt.Printf(\"Min(%.2f, %.2f) = %.2f\\n\", a, b, math.Min(a, b))\n    fmt.Printf(\"Max(%.2f, %.2f) = %.2f\\n\", a, b, math.Max(a, b))\n\n    // Works with multiple values\n    values := []float64{1.2, 3.4, 0.5, 7.8, 2.3}\n    minVal := values[0]\n    maxVal := values[0]\n\n    for _, v := range values[1:] {\n        minVal = math.Min(minVal, v)\n        maxVal = math.Max(maxVal, v)\n    }\n\n    fmt.Printf(\"Min of %v = %.2f\\n\", values, minVal)\n    fmt.Printf(\"Max of %v = %.2f\\n\", values, maxVal)\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#absolute-value","title":"Absolute Value","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Absolute value\n    values := []float64{3.14, -2.71, 0, -0.0, 1.0}\n\n    for _, v := range values {\n        abs := math.Abs(v)\n        fmt.Printf(\"Abs(%.2f) = %.2f\\n\", v, abs)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#rounding-functions","title":"Rounding Functions","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    values := []float64{1.2, 1.5, 1.8, -1.2, -1.5, -1.8}\n\n    fmt.Println(\"Rounding Functions:\")\n    for _, v := range values {\n        fmt.Printf(\"Value: %.1f\\n\", v)\n        fmt.Printf(\"  Floor: %.1f (nearest integer &lt;= value)\\n\", math.Floor(v))\n        fmt.Printf(\"  Ceil:  %.1f (nearest integer &gt;= value)\\n\", math.Ceil(v))\n        fmt.Printf(\"  Round: %.1f (nearest integer, half away from zero)\\n\", math.Round(v))\n        fmt.Printf(\"  Trunc: %.1f (integer part)\\n\", math.Trunc(v))\n        fmt.Println()\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#exponentiation-and-logarithms","title":"Exponentiation and Logarithms","text":""},{"location":"2.%20Intermediate/38.%20Math-Package/#exponentiation","title":"Exponentiation","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Exponentiation\n    base := 2.0\n    exponents := []float64{0, 1, 2, 3, 0.5, -1, -2}\n\n    fmt.Println(\"Exponentiation:\")\n    for _, exp := range exponents {\n        result := math.Pow(base, exp)\n        fmt.Printf(\"%.1f^%.1f = %.4f\\n\", base, exp, result)\n    }\n\n    // Square root\n    values := []float64{4, 9, 16, 2, 0.25}\n    fmt.Println(\"\\nSquare Roots:\")\n    for _, v := range values {\n        sqrt := math.Sqrt(v)\n        fmt.Printf(\"Sqrt(%.2f) = %.4f\\n\", v, sqrt)\n    }\n\n    // Cube root\n    fmt.Println(\"\\nCube Roots:\")\n    for _, v := range values {\n        cbrt := math.Cbrt(v)\n        fmt.Printf(\"Cbrt(%.2f) = %.4f\\n\", v, cbrt)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#logarithms","title":"Logarithms","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Natural logarithm (base e)\n    values := []float64{1, math.E, math.E * math.E, 10}\n    fmt.Println(\"Natural Logarithms:\")\n    for _, v := range values {\n        ln := math.Log(v)\n        fmt.Printf(\"Ln(%.4f) = %.4f\\n\", v, ln)\n    }\n\n    // Base-2 logarithm\n    fmt.Println(\"\\nBase-2 Logarithms:\")\n    for _, v := range values {\n        log2 := math.Log2(v)\n        fmt.Printf(\"Log2(%.4f) = %.4f\\n\", v, log2)\n    }\n\n    // Base-10 logarithm\n    fmt.Println(\"\\nBase-10 Logarithms:\")\n    for _, v := range values {\n        log10 := math.Log10(v)\n        fmt.Printf(\"Log10(%.4f) = %.4f\\n\", v, log10)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#trigonometric-functions","title":"Trigonometric Functions","text":""},{"location":"2.%20Intermediate/38.%20Math-Package/#basic-trigonometry","title":"Basic Trigonometry","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Convert degrees to radians\n    degToRad := func(deg float64) float64 {\n        return deg * math.Pi / 180\n    }\n\n    angles := []float64{0, 30, 45, 60, 90, 180, 270, 360}\n\n    fmt.Println(\"Trigonometric Functions:\")\n    fmt.Println(\"Angle (deg) | Angle (rad) | Sin     | Cos     | Tan\")\n    fmt.Println(\"-----------|-------------|---------|---------|---------\")\n\n    for _, deg := range angles {\n        rad := degToRad(deg)\n        sin := math.Sin(rad)\n        cos := math.Cos(rad)\n        tan := math.Tan(rad)\n\n        fmt.Printf(\"%9.0f   | %11.4f | %7.4f | %7.4f | %7.4f\\n\", deg, rad, sin, cos, tan)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#inverse-trigonometric-functions","title":"Inverse Trigonometric Functions","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Convert radians to degrees\n    radToDeg := func(rad float64) float64 {\n        return rad * 180 / math.Pi\n    }\n\n    values := []float64{-1, -0.5, 0, 0.5, 1}\n\n    fmt.Println(\"Inverse Trigonometric Functions:\")\n    fmt.Println(\"Value | Asin (rad) | Asin (deg) | Acos (rad) | Acos (deg) | Atan (rad) | Atan (deg)\")\n    fmt.Println(\"------|------------|------------|------------|------------|------------|------------\")\n\n    for _, v := range values {\n        asin := math.Asin(v)\n        acos := math.Acos(v)\n        atan := math.Atan(v)\n\n        fmt.Printf(\"%5.1f | %10.4f | %10.4f | %10.4f | %10.4f | %10.4f | %10.4f\\n\", \n            v, asin, radToDeg(asin), acos, radToDeg(acos), atan, radToDeg(atan))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#hyperbolic-functions","title":"Hyperbolic Functions","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    values := []float64{-2, -1, 0, 1, 2}\n\n    fmt.Println(\"Hyperbolic Functions:\")\n    fmt.Println(\"Value | Sinh    | Cosh    | Tanh\")\n    fmt.Println(\"------|---------|---------|---------\")\n\n    for _, v := range values {\n        sinh := math.Sinh(v)\n        cosh := math.Cosh(v)\n        tanh := math.Tanh(v)\n\n        fmt.Printf(\"%5.1f | %7.4f | %7.4f | %7.4f\\n\", v, sinh, cosh, tanh)\n    }\n\n    // Inverse hyperbolic functions\n    fmt.Println(\"\\nInverse Hyperbolic Functions:\")\n    fmt.Println(\"Value | Asinh   | Acosh   | Atanh\")\n    fmt.Println(\"------|---------|---------|---------\")\n\n    for _, v := range values {\n        // Acosh is only defined for v &gt;= 1\n        // Atanh is only defined for -1 &lt; v &lt; 1\n        asinh := math.Asinh(v)\n        var acosh float64\n        if v &gt;= 1 {\n            acosh = math.Acosh(v)\n        } else {\n            acosh = math.NaN()\n        }\n        var atanh float64\n        if v &gt; -1 &amp;&amp; v &lt; 1 {\n            atanh = math.Atanh(v)\n        } else {\n            atanh = math.NaN()\n        }\n\n        fmt.Printf(\"%5.1f | %7.4f | %7.4f | %7.4f\\n\", v, asinh, acosh, atanh)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#special-functions","title":"Special Functions","text":""},{"location":"2.%20Intermediate/38.%20Math-Package/#modulo-operation","title":"Modulo Operation","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Modulo operation (remainder after division)\n    values := []struct {\n        x float64\n        y float64\n    }{\n        {5, 3},\n        {5, -3},\n        {-5, 3},\n        {-5, -3},\n        {10.5, 3},\n        {10.5, 2.5},\n    }\n\n    fmt.Println(\"Modulo Operation:\")\n    fmt.Println(\"x     | y     | x mod y\")\n    fmt.Println(\"------|-------|--------\")\n\n    for _, v := range values {\n        mod := math.Mod(v.x, v.y)\n        fmt.Printf(\"%5.1f | %5.1f | %7.4f\\n\", v.x, v.y, mod)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#signum-function","title":"Signum Function","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Signum function (returns -1, 0, or 1)\n    values := []float64{-5.2, -0.0, 0, 0.0, 3.14}\n\n    fmt.Println(\"Signum Function:\")\n    for _, v := range values {\n        sign := math.Copysign(1, v)\n        if v == 0 {\n            sign = 0\n        }\n        fmt.Printf(\"Sign(%.2f) = %.0f\\n\", v, sign)\n    }\n\n    // CopySign function\n    fmt.Println(\"\\nCopySign Function:\")\n    magnitudes := []float64{5.2, 3.14, 1.0}\n    signs := []float64{-1.0, 1.0, -0.0}\n\n    for _, mag := range magnitudes {\n        for _, sign := range signs {\n            result := math.Copysign(mag, sign)\n            fmt.Printf(\"CopySign(%.2f, %.2f) = %.2f\\n\", mag, sign, result)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#remainder-function","title":"Remainder Function","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Remainder function (similar to Mod but with different behavior for negative numbers)\n    values := []struct {\n        x float64\n        y float64\n    }{\n        {5, 3},\n        {5, -3},\n        {-5, 3},\n        {-5, -3},\n        {10.5, 3},\n        {10.5, 2.5},\n    }\n\n    fmt.Println(\"Remainder Function:\")\n    fmt.Println(\"x     | y     | Remainder\")\n    fmt.Println(\"------|-------|----------\")\n\n    for _, v := range values {\n        rem := math.Remainder(v.x, v.y)\n        fmt.Printf(\"%5.1f | %5.1f | %9.4f\\n\", v.x, v.y, rem)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#special-values","title":"Special Values","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Special values\n    fmt.Println(\"Special Values:\")\n    fmt.Printf(\"Positive Infinity: %g\\n\", math.Inf(1))\n    fmt.Printf(\"Negative Infinity: %g\\n\", math.Inf(-1))\n    fmt.Printf(\"Not a Number (NaN): %g\\n\", math.NaN())\n\n    // Check for special values\n    values := []float64{1.0, math.Inf(1), math.Inf(-1), math.NaN()}\n\n    fmt.Println(\"\\nChecking Special Values:\")\n    for _, v := range values {\n        fmt.Printf(\"Value: %g\\n\", v)\n        fmt.Printf(\"  IsInf(1): %t\\n\", math.IsInf(v, 1))\n        fmt.Printf(\"  IsInf(-1): %t\\n\", math.IsInf(v, -1))\n        fmt.Printf(\"  IsNaN: %t\\n\", math.IsNaN(v))\n        fmt.Printf(\"  IsFinite: %t\\n\", !math.IsInf(v, 0) &amp;&amp; !math.IsNaN(v))\n        fmt.Println()\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#random-number-generation","title":"Random Number Generation","text":"<p>While the <code>math</code> package doesn't directly provide random number generation, it's often used in conjunction with the <code>math/rand</code> package for mathematical operations on random numbers.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    // Seed the random number generator\n    rand.Seed(time.Now().UnixNano())\n\n    // Generate random numbers in different ranges\n    fmt.Println(\"Random Numbers:\")\n\n    // Random float between 0 and 1\n    for i := 0; i &lt; 5; i++ {\n        r := rand.Float64()\n        fmt.Printf(\"Random [0,1): %f\\n\", r)\n    }\n\n    // Random float in a custom range [min, max)\n    min, max := 5.0, 10.0\n    fmt.Printf(\"\\nRandom numbers in range [%.1f, %.1f):\\n\", min, max)\n    for i := 0; i &lt; 5; i++ {\n        r := min + rand.Float64()*(max-min)\n        fmt.Printf(\"%.2f\\n\", r)\n    }\n\n    // Random integer in a range [min, max]\n    minInt, maxInt := 1, 100\n    fmt.Printf(\"\\nRandom integers in range [%d, %d]:\\n\", minInt, maxInt)\n    for i := 0; i &lt; 5; i++ {\n        r := minInt + rand.Intn(maxInt-minInt+1)\n        fmt.Printf(\"%d\\n\", r)\n    }\n\n    // Normally distributed random numbers\n    fmt.Println(\"\\nNormally distributed random numbers (mean=0, stddev=1):\")\n    for i := 0; i &lt; 5; i++ {\n        r := rand.NormFloat64()\n        fmt.Printf(\"%.4f\\n\", r)\n    }\n\n    // Exponentially distributed random numbers\n    fmt.Println(\"\\nExponentially distributed random numbers (rate=1):\")\n    for i := 0; i &lt; 5; i++ {\n        r := rand.ExpFloat64()\n        fmt.Printf(\"%.4f\\n\", r)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#complex-numbers","title":"Complex Numbers","text":"<p>The <code>math/cmplx</code> package provides functions for complex numbers, which are built on top of the <code>math</code> package.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/cmplx\"\n)\n\nfunc main() {\n    // Create complex numbers\n    a := complex(3, 4)  // 3 + 4i\n    b := complex(1, -2) // 1 - 2i\n\n    fmt.Printf(\"a = %v\\n\", a)\n    fmt.Printf(\"b = %v\\n\", b)\n\n    // Basic operations\n    fmt.Println(\"\\nBasic Operations:\")\n    fmt.Printf(\"a + b = %v\\n\", a+b)\n    fmt.Printf(\"a - b = %v\\n\", a-b)\n    fmt.Printf(\"a * b = %v\\n\", a*b)\n    fmt.Printf(\"a / b = %v\\n\", a/b)\n\n    // Complex number functions\n    fmt.Println(\"\\nComplex Number Functions:\")\n    fmt.Printf(\"Real(a) = %v\\n\", real(a))\n    fmt.Printf(\"Imag(a) = %v\\n\", imag(a))\n    fmt.Printf(\"Conj(a) = %v\\n\", cmplx.Conj(a))\n    fmt.Printf(\"Abs(a) = %v\\n\", cmplx.Abs(a))\n    fmt.Printf(\"Phase(a) = %v\\n\", cmplx.Phase(a))\n\n    // Polar form\n    r, theta := cmplx.Polar(a)\n    fmt.Printf(\"Polar form of a: r = %v, \u03b8 = %v\\n\", r, theta)\n    fmt.Printf(\"Back to rectangular: %v\\n\", cmplx.Rect(r, theta))\n\n    // Complex exponentials and logarithms\n    fmt.Println(\"\\nComplex Exponentials and Logarithms:\")\n    fmt.Printf(\"Exp(a) = %v\\n\", cmplx.Exp(a))\n    fmt.Printf(\"Log(a) = %v\\n\", cmplx.Log(a))\n    fmt.Printf(\"Sqrt(a) = %v\\n\", cmplx.Sqrt(a))\n\n    // Complex trigonometric functions\n    fmt.Println(\"\\nComplex Trigonometric Functions:\")\n    fmt.Printf(\"Sin(a) = %v\\n\", cmplx.Sin(a))\n    fmt.Printf(\"Cos(a) = %v\\n\", cmplx.Cos(a))\n    fmt.Printf(\"Tan(a) = %v\\n\", cmplx.Tan(a))\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#best-practices","title":"Best Practices","text":""},{"location":"2.%20Intermediate/38.%20Math-Package/#1-handle-special-values","title":"1. Handle Special Values","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc safeSqrt(x float64) (float64, error) {\n    if x &lt; 0 {\n        return 0, fmt.Errorf(\"square root of negative number\")\n    }\n    return math.Sqrt(x), nil\n}\n\nfunc main() {\n    values := []float64{4, -1, 0}\n\n    for _, v := range values {\n        result, err := safeSqrt(v)\n        if err != nil {\n            fmt.Printf(\"Sqrt(%.1f): Error - %v\\n\", v, err)\n        } else {\n            fmt.Printf(\"Sqrt(%.1f): %.4f\\n\", v, result)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#2-use-appropriate-precision","title":"2. Use Appropriate Precision","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Be aware of floating-point precision\n    a := 0.1\n    b := 0.2\n    sum := a + b\n\n    fmt.Printf(\"%.20f + %.20f = %.20f\\n\", a, b, sum)\n    fmt.Printf(\"Expected: %.20f\\n\", 0.3)\n    fmt.Printf(\"Equal: %t\\n\", sum == 0.3) // This will be false due to precision issues\n\n    // Use a tolerance for comparison\n    tolerance := 1e-10\n    equal := math.Abs(sum-0.3) &lt; tolerance\n    fmt.Printf(\"Equal with tolerance: %t\\n\", equal)\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#3-avoid-division-by-zero","title":"3. Avoid Division by Zero","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc safeDivide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, fmt.Errorf(\"division by zero\")\n    }\n    return a / b, nil\n}\n\nfunc main() {\n    values := []struct {\n        a float64\n        b float64\n    }{\n        {10, 2},\n        {10, 0},\n        {0, 5},\n    }\n\n    for _, v := range values {\n        result, err := safeDivide(v.a, v.b)\n        if err != nil {\n            fmt.Printf(\"%.1f / %.1f: Error - %v\\n\", v.a, v.b, err)\n        } else {\n            fmt.Printf(\"%.1f / %.1f = %.4f\\n\", v.a, v.b, result)\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#4-use-constants-for-readability","title":"4. Use Constants for Readability","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    // Use math constants for readability and precision\n    radius := 5.0\n\n    // Calculate circumference\n    circumference := 2 * math.Pi * radius\n    fmt.Printf(\"Circumference: %.2f\\n\", circumference)\n\n    // Calculate area\n    area := math.Pi * math.Pow(radius, 2)\n    fmt.Printf(\"Area: %.2f\\n\", area)\n\n    // Calculate volume of a sphere\n    volume := (4.0 / 3.0) * math.Pi * math.Pow(radius, 3)\n    fmt.Printf(\"Volume: %.2f\\n\", volume)\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#5-be-aware-of-performance","title":"5. Be Aware of Performance","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"time\"\n)\n\nfunc main() {\n    // Compare performance of different approaches\n    n := 10000000\n    values := make([]float64, n)\n    for i := range values {\n        values[i] = float64(i)\n    }\n\n    // Using math.Pow\n    start := time.Now()\n    sum1 := 0.0\n    for _, v := range values {\n        sum1 += math.Pow(v, 2)\n    }\n    elapsed1 := time.Since(start)\n\n    // Using multiplication\n    start = time.Now()\n    sum2 := 0.0\n    for _, v := range values {\n        sum2 += v * v\n    }\n    elapsed2 := time.Since(start)\n\n    fmt.Printf(\"Using math.Pow: %v, sum = %.0f\\n\", elapsed1, sum1)\n    fmt.Printf(\"Using multiplication: %v, sum = %.0f\\n\", elapsed2, sum2)\n    fmt.Printf(\"Multiplication is %.2fx faster\\n\", float64(elapsed1)/float64(elapsed2))\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#real-world-example-statistical-analysis","title":"Real-World Example: Statistical Analysis","text":"<p>Let's create a comprehensive example that demonstrates various mathematical functions in a statistical analysis context:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/rand\"\n    \"sort\"\n    \"time\"\n)\n\ntype Stats struct {\n    Count     int\n    Min       float64\n    Max       float64\n    Sum       float64\n    Mean      float64\n    Median    float64\n    Mode      float64\n    Variance  float64\n    StdDev    float64\n    Skewness  float64\n    Kurtosis  float64\n}\n\nfunc main() {\n    // Generate some sample data\n    rand.Seed(time.Now().UnixNano())\n    data := make([]float64, 1000)\n    for i := range data {\n        // Generate normally distributed data\n        data[i] = rand.NormFloat64()*2 + 10\n    }\n\n    // Calculate statistics\n    stats := CalculateStats(data)\n\n    // Print results\n    fmt.Println(\"Statistical Analysis:\")\n    fmt.Printf(\"Count: %d\\n\", stats.Count)\n    fmt.Printf(\"Min: %.4f\\n\", stats.Min)\n    fmt.Printf(\"Max: %.4f\\n\", stats.Max)\n    fmt.Printf(\"Sum: %.4f\\n\", stats.Sum)\n    fmt.Printf(\"Mean: %.4f\\n\", stats.Mean)\n    fmt.Printf(\"Median: %.4f\\n\", stats.Median)\n    fmt.Printf(\"Mode: %.4f\\n\", stats.Mode)\n    fmt.Printf(\"Variance: %.4f\\n\", stats.Variance)\n    fmt.Printf(\"Standard Deviation: %.4f\\n\", stats.StdDev)\n    fmt.Printf(\"Skewness: %.4f\\n\", stats.Skewness)\n    fmt.Printf(\"Kurtosis: %.4f\\n\", stats.Kurtosis)\n\n    // Calculate percentiles\n    percentiles := []float64{10, 25, 50, 75, 90}\n    fmt.Println(\"\\nPercentiles:\")\n    for _, p := range percentiles {\n        value := Percentile(data, p)\n        fmt.Printf(\"%dth percentile: %.4f\\n\", int(p), value)\n    }\n\n    // Histogram\n    fmt.Println(\"\\nHistogram:\")\n    bins := 10\n    hist := Histogram(data, bins)\n    min := stats.Min\n    max := stats.Max\n    binWidth := (max - min) / float64(bins)\n\n    for i, count := range hist {\n        binStart := min + float64(i)*binWidth\n        binEnd := binStart + binWidth\n        bar := strings.Repeat(\"*\", count/10) // Scale down for display\n        fmt.Printf(\"[%.2f, %.2f): %d %s\\n\", binStart, binEnd, count, bar)\n    }\n}\n\nfunc CalculateStats(data []float64) Stats {\n    if len(data) == 0 {\n        return Stats{}\n    }\n\n    // Sort data for median and percentiles\n    sorted := make([]float64, len(data))\n    copy(sorted, data)\n    sort.Float64s(sorted)\n\n    // Basic statistics\n    count := len(data)\n    min := sorted[0]\n    max := sorted[count-1]\n    sum := 0.0\n    for _, v := range data {\n        sum += v\n    }\n    mean := sum / float64(count)\n\n    // Median\n    var median float64\n    if count%2 == 0 {\n        median = (sorted[count/2-1] + sorted[count/2]) / 2\n    } else {\n        median = sorted[count/2]\n    }\n\n    // Mode (simplified implementation)\n    freq := make(map[float64]int)\n    for _, v := range data {\n        freq[v]++\n    }\n\n    mode := sorted[0]\n    maxFreq := 1\n    for v, f := range freq {\n        if f &gt; maxFreq {\n            maxFreq = f\n            mode = v\n        }\n    }\n\n    // Variance and standard deviation\n    variance := 0.0\n    for _, v := range data {\n        variance += math.Pow(v-mean, 2)\n    }\n    variance /= float64(count)\n    stdDev := math.Sqrt(variance)\n\n    // Skewness and kurtosis\n    skewness := 0.0\n    kurtosis := 0.0\n    for _, v := range data {\n        z := (v - mean) / stdDev\n        skewness += math.Pow(z, 3)\n        kurtosis += math.Pow(z, 4)\n    }\n    skewness /= float64(count)\n    kurtosis = kurtosis/float64(count) - 3\n\n    return Stats{\n        Count:    count,\n        Min:      min,\n        Max:      max,\n        Sum:      sum,\n        Mean:     mean,\n        Median:   median,\n        Mode:     mode,\n        Variance: variance,\n        StdDev:   stdDev,\n        Skewness: skewness,\n        Kurtosis: kurtosis,\n    }\n}\n\nfunc Percentile(data []float64, p float64) float64 {\n    if len(data) == 0 {\n        return math.NaN()\n    }\n\n    // Sort data if not already sorted\n    sorted := make([]float64, len(data))\n    copy(sorted, data)\n    sort.Float64s(sorted)\n\n    // Calculate percentile\n    n := float64(len(sorted))\n    pos := p / 100 * (n - 1)\n\n    lower := math.Floor(pos)\n    upper := math.Ceil(pos)\n\n    if lower == upper {\n        return sorted[int(lower)]\n    }\n\n    d := pos - lower\n    return sorted[int(lower)] + d*(sorted[int(upper)]-sorted[int(lower)])\n}\n\nfunc Histogram(data []float64, bins int) []int {\n    if len(data) == 0 || bins &lt;= 0 {\n        return nil\n    }\n\n    // Find min and max\n    min, max := data[0], data[0]\n    for _, v := range data {\n        if v &lt; min {\n            min = v\n        }\n        if v &gt; max {\n            max = v\n        }\n    }\n\n    // Create histogram\n    hist := make([]int, bins)\n    binWidth := (max - min) / float64(bins)\n\n    for _, v := range data {\n        bin := int((v - min) / binWidth)\n        if bin &gt;= bins {\n            bin = bins - 1\n        }\n        hist[bin]++\n    }\n\n    return hist\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#how-this-example-demonstrates-math-concepts","title":"How This Example Demonstrates Math Concepts:","text":"<ol> <li>Basic Statistics:</li> <li>Calculating min, max, sum, and mean</li> <li>Finding median and mode</li> <li> <p>Computing variance and standard deviation</p> </li> <li> <p>Advanced Statistics:</p> </li> <li>Calculating skewness and kurtosis</li> <li>Computing percentiles</li> <li> <p>Creating histograms</p> </li> <li> <p>Math Functions:</p> </li> <li>Using <code>math.Pow</code> for variance calculation</li> <li>Using <code>math.Sqrt</code> for standard deviation</li> <li> <p>Using <code>math.Floor</code> and <code>math.Ceil</code> for percentile calculation</p> </li> <li> <p>Data Analysis:</p> </li> <li>Sorting data for statistical calculations</li> <li>Binning data for histogram creation</li> <li> <p>Visualizing data distribution</p> </li> <li> <p>Real-World Application:</p> </li> <li>Statistical analysis of normally distributed data</li> <li>Visualization of data distribution through histograms</li> <li>Calculation of various statistical measures</li> </ol>"},{"location":"2.%20Intermediate/38.%20Math-Package/#conclusion","title":"Conclusion","text":"<p>The <code>math</code> package is a fundamental part of Go's standard library for mathematical operations:</p>"},{"location":"2.%20Intermediate/38.%20Math-Package/#key-takeaways","title":"Key Takeaways:","text":"<ol> <li>Constants:</li> <li>Provides important mathematical constants like Pi, E, and Phi</li> <li> <p>Includes machine-specific constants for numeric limits</p> </li> <li> <p>Basic Operations:</p> </li> <li>Min, Max, Abs for basic comparisons</li> <li> <p>Floor, Ceil, Round, Trunc for rounding operations</p> </li> <li> <p>Exponentiation and Logarithms:</p> </li> <li>Pow, Sqrt, Cbrt for power operations</li> <li> <p>Log, Log2, Log10 for logarithmic functions</p> </li> <li> <p>Trigonometric Functions:</p> </li> <li>Sin, Cos, Tan and their inverses</li> <li> <p>Hyperbolic functions and their inverses</p> </li> <li> <p>Special Functions:</p> </li> <li>Mod, Remainder for modulo operations</li> <li>Copysign for sign manipulation</li> <li> <p>Functions for handling special values like Inf and NaN</p> </li> <li> <p>Best Practices:</p> </li> <li>Handle special values and edge cases</li> <li>Be aware of floating-point precision limitations</li> <li>Avoid division by zero</li> <li>Use constants for readability</li> <li>Consider performance implications</li> </ol> <p>By mastering the <code>math</code> package, you'll be able to perform a wide range of mathematical operations in your Go applications, from basic arithmetic to complex statistical analysis. The functions provided by this package are optimized for performance and accuracy, making them suitable for scientific computing, graphics programming, and any application that requires mathematical operations.</p>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/","title":"Go Strings and Runes: Text Processing and Unicode","text":"<p>Overview</p> <p>Master Go's string and rune handling for effective text processing. Learn the difference between bytes and Unicode characters, string manipulation techniques, and best practices for international text handling.</p> <p>Key Points</p> <ul> <li>Strings are immutable sequences of bytes</li> <li>Runes represent Unicode code points</li> <li>UTF-8 encoding is used by default</li> <li><code>len()</code> returns bytes, not character count</li> <li>Use runes for proper Unicode handling</li> </ul>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#understanding-strings-and-runes","title":"Understanding Strings and Runes","text":"<p>In Go, strings are immutable sequences of bytes, UTF-8 encoded by default. This makes them powerful for international text but requires understanding the distinction between bytes and Unicode characters.</p>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#basic-string-declaration","title":"Basic String Declaration","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // String literals\n    s1 := \"Hello, World!\"\n    s2 := `This is a raw string literal\n    that can span multiple lines\n    and include \"quotes\" without escaping`\n\n    fmt.Println(s1)\n    fmt.Println(s2)\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#strings-are-immutable","title":"Strings are Immutable","text":"<p>Once created, strings in Go cannot be modified. Any operation that appears to modify a string actually creates a new one.</p> <pre><code>func main() {\n    s := \"hello\"\n    // s[0] = 'H' // This would cause a compilation error\n\n    // To \"modify\", we create a new string\n    s = \"H\" + s[1:]\n    fmt.Println(s) // \"Hello\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#utf-8-encoding-and-runes","title":"UTF-8 Encoding and Runes","text":"<p>Go strings are UTF-8 encoded, which means: - Each Unicode character (code point) can be represented by 1 to 4 bytes - ASCII characters use 1 byte - Non-Latin characters (like Chinese, Arabic, emojis) use multiple bytes</p>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#what-is-a-rune","title":"What is a Rune?","text":"<p>In Go, a <code>rune</code> is an alias for <code>int32</code> and represents a single Unicode code point. It's Go's way of handling characters properly.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    s := \"Hello, \u4e16\u754c\"\n\n    // Length in bytes\n    fmt.Println(\"Byte length:\", len(s)) // 13\n\n    // Length in runes (characters)\n    fmt.Println(\"Rune length:\", utf8.RuneCountInString(s)) // 9\n\n    // Iterate as runes\n    for i, r := range s {\n        fmt.Printf(\"%d: %q (%d bytes)\\n\", i, r, utf8.RuneLen(r))\n    }\n}\n</code></pre> <p>Output: <pre><code>Byte length: 13\nRune length: 9\n0: 'H' (1 bytes)\n1: 'e' (1 bytes)\n2: 'l' (1 bytes)\n3: 'l' (1 bytes)\n4: 'o' (1 bytes)\n5: ',' (1 bytes)\n6: ' ' (1 bytes)\n7: '\u4e16' (3 bytes)\n10: '\u754c' (3 bytes)\n</code></pre></p>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#working-with-runes","title":"Working with Runes","text":""},{"location":"2.%20Intermediate/4.%20String-and-Runes/#converting-between-strings-and-runes","title":"Converting Between Strings and Runes","text":"<pre><code>func main() {\n    // String to rune slice\n    s := \"Hello, \u4e16\u754c\"\n    runes := []rune(s)\n    fmt.Println(runes) // [72 101 108 108 111 44 32 19990 30028]\n\n    // Rune slice to string\n    s2 := string(runes)\n    fmt.Println(s2) // \"Hello, \u4e16\u754c\"\n\n    // Individual rune to string\n    r := '\u4e16'\n    s3 := string(r)\n    fmt.Println(s3) // \"\u4e16\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#accessing-individual-characters","title":"Accessing Individual Characters","text":"<pre><code>func main() {\n    s := \"Hello, \u4e16\u754c\"\n\n    // WRONG: This would give a byte, not a character\n    // fmt.Println(s[7]) // This would print 228 (first byte of '\u4e16')\n\n    // CORRECT: Convert to rune slice first\n    runes := []rune(s)\n    fmt.Printf(\"%c\\n\", runes[7]) // '\u4e16'\n\n    // Or use range\n    for i, r := range s {\n        if i == 7 {\n            fmt.Printf(\"%c\\n\", r) // '\u4e16'\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#common-string-operations","title":"Common String Operations","text":""},{"location":"2.%20Intermediate/4.%20String-and-Runes/#1-concatenation","title":"1. Concatenation","text":"<pre><code>func main() {\n    s1 := \"Hello\"\n    s2 := \"World\"\n\n    // Using + operator\n    s3 := s1 + \", \" + s2\n    fmt.Println(s3) // \"Hello, World\"\n\n    // Using fmt.Sprintf\n    s4 := fmt.Sprintf(\"%s, %s\", s1, s2)\n    fmt.Println(s4) // \"Hello, World\"\n\n    // Using strings.Builder (efficient for multiple concatenations)\n    var builder strings.Builder\n    builder.WriteString(s1)\n    builder.WriteString(\", \")\n    builder.WriteString(s2)\n    s5 := builder.String()\n    fmt.Println(s5) // \"Hello, World\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#2-substrings","title":"2. Substrings","text":"<pre><code>func main() {\n    s := \"Hello, \u4e16\u754c\"\n\n    // Get substring by byte indices (DANGEROUS for multi-byte characters)\n    sub1 := s[0:5] // \"Hello\"\n    fmt.Println(sub1)\n\n    // Safe substring using runes\n    runes := []rune(s)\n    sub2 := string(runes[7:9]) // \"\u4e16\u754c\"\n    fmt.Println(sub2)\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#3-searching-and-replacing","title":"3. Searching and Replacing","text":"<pre><code>func main() {\n    s := \"Hello, \u4e16\u754c! Hello, Go!\"\n\n    // Contains\n    fmt.Println(strings.Contains(s, \"Hello\")) // true\n\n    // Index\n    fmt.Println(strings.Index(s, \"Hello\")) // 0\n    fmt.Println(strings.Index(s, \"\u4e16\u754c\"))   // 7\n\n    // Replace\n    s2 := strings.ReplaceAll(s, \"Hello\", \"Hi\")\n    fmt.Println(s2) // \"Hi, \u4e16\u754c! Hi, Go!\"\n\n    // Split\n    parts := strings.Split(s, \", \")\n    fmt.Println(parts) // [\"Hello\" \"\u4e16\u754c! Hello\" \"Go!\"]\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#4-trimming-and-padding","title":"4. Trimming and Padding","text":"<pre><code>func main() {\n    s := \"   Hello, World!   \"\n\n    // Trim spaces\n    trimmed := strings.TrimSpace(s)\n    fmt.Println(trimmed) // \"Hello, World!\"\n\n    // Trim specific characters\n    s2 := \"!!!Hello, World!!!\"\n    trimmed2 := strings.Trim(s2, \"!\")\n    fmt.Println(trimmed2) // \"Hello, World\"\n\n    // Padding\n    padded := fmt.Sprintf(\"%-20s\", \"Hello\")\n    fmt.Printf(\"'%s'\\n\", padded) // 'Hello               '\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#5-case-conversion","title":"5. Case Conversion","text":"<pre><code>func main() {\n    s := \"Hello, \u4e16\u754c\"\n\n    // To lower\n    lower := strings.ToLower(s)\n    fmt.Println(lower) // \"hello, \u4e16\u754c\"\n\n    // To upper\n    upper := strings.ToUpper(s)\n    fmt.Println(upper) // \"HELLO, \u4e16\u754c\"\n\n    // To title\n    title := strings.ToTitle(s)\n    fmt.Println(title) // \"HELLO, \u4e16\u754c\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#real-world-example-text-processing-with-unicode","title":"Real-World Example: Text Processing with Unicode","text":"<p>Let's build a practical text processing utility that: 1. Counts characters (not bytes) 2. Finds unique characters 3. Reverses the string properly 4. Handles emojis and complex scripts</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n    \"unicode\"\n    \"unicode/utf8\"\n)\n\n// TextProcessor handles Unicode-aware text operations\ntype TextProcessor struct {\n    text string\n}\n\n// NewTextProcessor creates a new processor\nfunc NewTextProcessor(text string) *TextProcessor {\n    return &amp;TextProcessor{text: text}\n}\n\n// CharacterCount returns the number of characters (runes)\nfunc (tp *TextProcessor) CharacterCount() int {\n    return utf8.RuneCountInString(tp.text)\n}\n\n// UniqueCharacters returns a sorted slice of unique characters\nfunc (tp *TextProcessor) UniqueCharacters() []rune {\n    seen := make(map[rune]bool)\n    for _, r := range tp.text {\n        seen[r] = true\n    }\n\n    unique := make([]rune, 0, len(seen))\n    for r := range seen {\n        unique = append(unique, r)\n    }\n\n    sort.Slice(unique, func(i, j int) bool {\n        return unique[i] &lt; unique[j]\n    })\n\n    return unique\n}\n\n// Reverse returns the string with characters in reverse order\nfunc (tp *TextProcessor) Reverse() string {\n    runes := []rune(tp.text)\n    for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\n// WordCount returns the number of words (Unicode-aware)\nfunc (tp *TextProcessor) WordCount() int {\n    // Simple word count by splitting on whitespace\n    words := strings.Fields(tp.text)\n    return len(words)\n}\n\n// ContainsEmoji checks if the text contains any emoji\nfunc (tp *TextProcessor) ContainsEmoji() bool {\n    for _, r := range tp.text {\n        // Check if the rune is in the emoji ranges\n        if unicode.Is(unicode.So, r) || // Symbols, Other (includes many emojis)\n           (r &gt;= 0x1F600 &amp;&amp; r &lt;= 0x1F64F) || // Emoticons\n           (r &gt;= 0x1F300 &amp;&amp; r &lt;= 0x1F5FF) || // Misc Symbols and Pictographs\n           (r &gt;= 0x1F680 &amp;&amp; r &lt;= 0x1F6FF) || // Transport and Map\n           (r &gt;= 0x2600 &amp;&amp; r &lt;= 0x26FF) ||   // Misc Symbols\n           (r &gt;= 0x2700 &amp;&amp; r &lt;= 0x27BF) {    // Dingbats\n            return true\n        }\n    }\n    return false\n}\n\n// NormalizeSpaces replaces multiple whitespace with single space\nfunc (tp *TextProcessor) NormalizeSpaces() string {\n    // Split on whitespace to get words\n    words := strings.Fields(tp.text)\n    return strings.Join(words, \" \")\n}\n\nfunc main() {\n    // Test with a complex string containing:\n    // - ASCII characters\n    // - Chinese characters\n    // - Emojis\n    // - Multiple spaces\n    text := \"Hello \u4e16\u754c! \ud83c\udf0d Go is awesome!   \ud83d\ude0a\"\n\n    processor := NewTextProcessor(text)\n\n    fmt.Println(\"Original text:\", text)\n    fmt.Println(\"Byte length:\", len(text))\n    fmt.Println(\"Character count:\", processor.CharacterCount())\n    fmt.Println(\"Word count:\", processor.WordCount())\n    fmt.Println(\"Contains emoji:\", processor.ContainsEmoji())\n\n    fmt.Println(\"\\nUnique characters:\")\n    for _, r := range processor.UniqueCharacters() {\n        fmt.Printf(\"%q \", r)\n    }\n\n    fmt.Println(\"\\n\\nReversed text:\", processor.Reverse())\n\n    normalized := processor.NormalizeSpaces()\n    fmt.Println(\"\\nNormalized text:\", normalized)\n\n    // Demonstrate the difference between byte and rune operations\n    fmt.Println(\"\\n--- Byte vs Rune Operations ---\")\n    fmt.Println(\"First 5 bytes:\", text[:5]) // \"Hello\"\n    fmt.Println(\"First 5 runes:\", string([]rune(text)[:5])) // \"Hello \u4e16\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#output","title":"Output:","text":"<pre><code>Original text: Hello \u4e16\u754c! \ud83c\udf0d Go is awesome!   \ud83d\ude0a\nByte length: 39\nCharacter count: 23\nWord count: 6\nContains emoji: true\n\nUnique characters:\n' ' '!' 'G' 'H' 'a' 'e' 'h' 'i' 'l' 'm' 'o' 's' 'v' 'w' '\u4e16' '\ud83d\ude0a' '\ud83c\udf0d' \n\nReversed text: \ud83d\ude0a   !emosewa si oG \ud83c\udf0d !\u754c\u4e16 olleH\n\nNormalized text: Hello \u4e16\u754c! \ud83c\udf0d Go is awesome! \ud83d\ude0a\n\n--- Byte vs Rune Operations ---\nFirst 5 bytes: Hello\nFirst 5 runes: Hello \u4e16\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#how-this-example-demonstrates-key-concepts","title":"How This Example Demonstrates Key Concepts:","text":"<ol> <li>Unicode Awareness:</li> <li>Correctly counts characters (23) rather than bytes (39)</li> <li>Properly handles multi-byte characters like Chinese and emojis</li> <li> <p>Reverses the string by characters, not bytes</p> </li> <li> <p>Rune Processing:</p> </li> <li>Uses <code>[]rune</code> conversion for character-level operations</li> <li>Implements Unicode-aware word counting</li> <li> <p>Detects emojis by checking Unicode ranges</p> </li> <li> <p>String Immutability:</p> </li> <li>All operations return new strings rather than modifying the original</li> <li> <p>Uses <code>strings.Builder</code> for efficient concatenation (in the full implementation)</p> </li> <li> <p>Real-World Text Processing:</p> </li> <li>Normalizes whitespace (common in text cleaning)</li> <li>Identifies unique characters (useful for analysis)</li> <li>Demonstrates safe substring operations</li> </ol>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#real-world-applications-of-this-pattern","title":"Real-World Applications of This Pattern:","text":"<ol> <li>Text Analysis Tools:</li> <li>Character frequency analysis</li> <li>Language detection</li> <li> <p>Text normalization for NLP</p> </li> <li> <p>Content Processing Systems:</p> </li> <li>Blog post processors that handle international text</li> <li>Social media content analyzers</li> <li> <p>Chat systems that need to process emojis</p> </li> <li> <p>Data Validation:</p> </li> <li>Input sanitization for web forms</li> <li>Password strength checkers that handle Unicode</li> <li> <p>Username validation systems</p> </li> <li> <p>Localization Tools:</p> </li> <li>Translation systems that preserve character counts</li> <li>Text fitting algorithms for UI elements</li> <li>Right-to-left text processing</li> </ol>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#benefits-of-this-approach","title":"Benefits of This Approach:","text":"<ol> <li>Correctness:</li> <li>Properly handles all Unicode characters</li> <li>Avoids common pitfalls with multi-byte characters</li> <li> <p>Produces accurate results for international text</p> </li> <li> <p>Efficiency:</p> </li> <li>Uses <code>strings.Builder</code> for efficient concatenation</li> <li>Minimizes allocations where possible</li> <li> <p>Processes text in a single pass when feasible</p> </li> <li> <p>Maintainability:</p> </li> <li>Encapsulates text processing logic</li> <li>Provides clear, reusable methods</li> <li>Separates concerns for different operations</li> </ol>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#conclusion","title":"Conclusion","text":"<p>Understanding strings and runes in Go is essential for: 1. Internationalization: Building applications that work with all languages 2. Text Processing: Correctly manipulating user input and content 3. Data Validation: Ensuring proper handling of all character types 4. Performance: Writing efficient string operations</p> <p>Key takeaways: 1. Go strings are UTF-8 encoded sequences of bytes 2. Use <code>rune</code> (<code>int32</code>) to represent Unicode code points 3. Always prefer <code>range</code> or <code>[]rune</code> conversion for character-level operations 4. Be aware of the difference between byte length and character count 5. Use the <code>strings</code> and <code>unicode</code> packages for common operations</p> <p>The text processing example demonstrates how to build robust, Unicode-aware applications in Go. By properly handling runes and understanding UTF-8 encoding, you can create applications that work seamlessly with text from any language, including emojis and complex scripts.</p> <p>Mastering strings and runes is fundamental to writing effective Go applications, especially those that process user input, handle internationalization, or work with text data. This knowledge will help you avoid common pitfalls and build more reliable, global-ready software.</p>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/","title":"Formatting Verbs in Go: A Comprehensive Guide","text":""},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#introduction-to-formatting-verbs","title":"Introduction to Formatting Verbs","text":"<p>In Go, formatting verbs are special placeholders used with the <code>fmt</code> package to control how values are formatted when printed. These verbs provide powerful control over output formatting, essential for creating readable logs, user-friendly displays, and properly structured data.</p>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#basic-formatting-with-fmtprintf","title":"Basic Formatting with fmt.Printf","text":"<p>The most common formatting function is <code>fmt.Printf</code>, which uses verbs to format values:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Alice\"\n    age := 30\n    fmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n    // Output: Name: Alice, Age: 30\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#general-formatting-verbs","title":"General Formatting Verbs","text":"Verb Description Example <code>%v</code> Default format <code>fmt.Printf(\"%v\", 42)</code> \u2192 <code>42</code> <code>%+v</code> Adds struct field names <code>fmt.Printf(\"%+v\", p)</code> <code>%#v</code> Go syntax representation <code>fmt.Printf(\"%#v\", []int{1,2})</code> <code>%T</code> Type of value <code>fmt.Printf(\"%T\", 42)</code> \u2192 <code>int</code> <code>%%</code> Literal percent sign <code>fmt.Printf(\"%%\")</code> \u2192 <code>%</code>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#example-general-verbs","title":"Example: General Verbs","text":"<pre><code>type Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    p := Person{\"Bob\", 25}\n    fmt.Printf(\"%v\\n\", p)     // {Bob 25}\n    fmt.Printf(\"%+v\\n\", p)    // {Name:Bob Age:25}\n    fmt.Printf(\"%#v\\n\", p)    // main.Person{Name:\"Bob\", Age:25}\n    fmt.Printf(\"%T\\n\", p)     // main.Person\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#integer-formatting-verbs","title":"Integer Formatting Verbs","text":"Verb Description Example <code>%b</code> Base 2 (binary) <code>fmt.Printf(\"%b\", 5)</code> \u2192 <code>101</code> <code>%c</code> Character represented by Unicode code <code>fmt.Printf(\"%c\", 0x41)</code> \u2192 <code>A</code> <code>%d</code> Base 10 (decimal) <code>fmt.Printf(\"%d\", 42)</code> \u2192 <code>42</code> <code>%o</code> Base 8 (octal) <code>fmt.Printf(\"%o\", 8)</code> \u2192 <code>10</code> <code>%O</code> Base 8 with 0o prefix <code>fmt.Printf(\"%O\", 8)</code> \u2192 <code>0o10</code> <code>%q</code> Single-quoted character <code>fmt.Printf(\"%q\", 'A')</code> \u2192 <code>'A'</code> <code>%x</code> Base 16 (hexadecimal), lowercase <code>fmt.Printf(\"%x\", 255)</code> \u2192 <code>ff</code> <code>%X</code> Base 16 (hexadecimal), uppercase <code>fmt.Printf(\"%X\", 255)</code> \u2192 <code>FF</code> <code>%U</code> Unicode format (U+XXXX) <code>fmt.Printf(\"%U\", 'A')</code> \u2192 <code>U+0041</code>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#example-integer-formatting","title":"Example: Integer Formatting","text":"<pre><code>func main() {\n    num := 42\n    fmt.Printf(\"Decimal: %d\\n\", num)        // Decimal: 42\n    fmt.Printf(\"Binary: %b\\n\", num)         // Binary: 101010\n    fmt.Printf(\"Octal: %o\\n\", num)          // Octal: 52\n    fmt.Printf(\"Hexadecimal: %x\\n\", num)    // Hexadecimal: 2a\n    fmt.Printf(\"Hexadecimal (upper): %X\\n\", num)  // Hexadecimal (upper): 2A\n    fmt.Printf(\"Unicode: %U\\n\", 'A')       // Unicode: U+0041\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#floating-point-and-complex-formatting","title":"Floating-Point and Complex Formatting","text":"Verb Description Example <code>%b</code> Scientific notation with binary exponent <code>fmt.Printf(\"%b\", 3.14)</code> <code>%e</code> Scientific notation (lowercase e) <code>fmt.Printf(\"%e\", 3.14)</code> \u2192 <code>3.140000e+00</code> <code>%E</code> Scientific notation (uppercase E) <code>fmt.Printf(\"%E\", 3.14)</code> \u2192 <code>3.140000E+00</code> <code>%f</code> Decimal notation <code>fmt.Printf(\"%f\", 3.14)</code> \u2192 <code>3.140000</code> <code>%F</code> Same as %f <code>fmt.Printf(\"%F\", 3.14)</code> \u2192 <code>3.140000</code> <code>%g</code> %e for large exponents, %f otherwise <code>fmt.Printf(\"%g\", 3.14)</code> \u2192 <code>3.14</code> <code>%G</code> %E for large exponents, %F otherwise <code>fmt.Printf(\"%G\", 3.14)</code> \u2192 <code>3.14</code> <code>%x</code> Hexadecimal notation (fractional part) <code>fmt.Printf(\"%x\", 3.14)</code> <code>%X</code> Uppercase hexadecimal notation <code>fmt.Printf(\"%X\", 3.14)</code>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#example-floating-point-formatting","title":"Example: Floating-Point Formatting","text":"<pre><code>func main() {\n    pi := 3.14159\n    fmt.Printf(\"Default: %f\\n\", pi)        // Default: 3.141590\n    fmt.Printf(\"Precision 2: %.2f\\n\", pi)  // Precision 2: 3.14\n    fmt.Printf(\"Scientific: %e\\n\", pi)     // Scientific: 3.141590e+00\n    fmt.Printf(\"Compact: %g\\n\", pi)        // Compact: 3.14159\n    fmt.Printf(\"Hex: %x\\n\", pi)            // Hex: 1.921f9f01b866ep+1\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#string-and-byte-formatting","title":"String and Byte Formatting","text":"Verb Description Example <code>%s</code> String <code>fmt.Printf(\"%s\", \"hello\")</code> \u2192 <code>hello</code> <code>%q</code> Double-quoted string <code>fmt.Printf(\"%q\", \"hello\")</code> \u2192 <code>\"hello\"</code> <code>%x</code> Hexadecimal dump of bytes <code>fmt.Printf(\"%x\", \"hi\")</code> \u2192 <code>6869</code> <code>%X</code> Uppercase hexadecimal dump <code>fmt.Printf(\"%X\", \"hi\")</code> \u2192 <code>6869</code>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#example-string-formatting","title":"Example: String Formatting","text":"<pre><code>func main() {\n    str := \"hello\"\n    fmt.Printf(\"String: %s\\n\", str)        // String: hello\n    fmt.Printf(\"Quoted: %q\\n\", str)        // Quoted: \"hello\"\n    fmt.Printf(\"Hex bytes: %x\\n\", str)     // Hex bytes: 68656c6c6f\n    fmt.Printf(\"Hex bytes (upper): %X\\n\", str)  // Hex bytes (upper): 68656C6C6F\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#boolean-formatting","title":"Boolean Formatting","text":"Verb Description Example <code>%t</code> Boolean (true or false) <code>fmt.Printf(\"%t\", true)</code> \u2192 <code>true</code>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#example-boolean-formatting","title":"Example: Boolean Formatting","text":"<pre><code>func main() {\n    flag := true\n    fmt.Printf(\"Boolean: %t\\n\", flag)      // Boolean: true\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#pointer-formatting","title":"Pointer Formatting","text":"Verb Description Example <code>%p</code> Pointer address (hexadecimal) <code>fmt.Printf(\"%p\", &amp;x)</code> \u2192 <code>0x1040a124</code>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#example-pointer-formatting","title":"Example: Pointer Formatting","text":"<pre><code>func main() {\n    x := 42\n    fmt.Printf(\"Pointer: %p\\n\", &amp;x)        // Pointer: 0x1040a124\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#width-and-precision","title":"Width and Precision","text":"<p>You can control formatting width and precision using numbers between <code>%</code> and the verb:</p> <pre><code>func main() {\n    num := 42\n    str := \"hello\"\n\n    // Width: minimum number of characters to output\n    fmt.Printf(\"Width 5: |%5d|\\n\", num)    // Width 5: |   42|\n    fmt.Printf(\"Width 5: |%5s|\\n\", str)    // Width 5: |hello|\n\n    // Precision: maximum number of characters (for strings) or decimal places (for numbers)\n    fmt.Printf(\"Precision 2: |%.2f|\\n\", 3.14159)  // Precision 2: |3.14|\n    fmt.Printf(\"Precision 3: |%.3s|\\n\", str)     // Precision 3: |hel|\n\n    // Combined width and precision\n    fmt.Printf(\"Width 7, Precision 2: |%7.2f|\\n\", 3.14159)  // Width 7, Precision 2: |   3.14|\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#formatting-flags","title":"Formatting Flags","text":"<p>Flags modify formatting behavior:</p> Flag Description Example <code>+</code> Always show sign for numbers <code>fmt.Printf(\"%+d\", 42)</code> \u2192 <code>+42</code> <code>-</code> Left-justify within width <code>fmt.Printf(\"%-5d\", 42)</code> \u2192 <code>42</code> <code></code> Leave space for positive numbers <code>fmt.Printf(\"% d\", 42)</code> \u2192 <code>42</code> <code>0</code> Pad with zeros instead of spaces <code>fmt.Printf(\"%05d\", 42)</code> \u2192 <code>00042</code> <code>#</code> Alternate format (adds prefixes) <code>fmt.Printf(\"%#o\", 8)</code> \u2192 <code>010</code>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#example-formatting-flags","title":"Example: Formatting Flags","text":"<pre><code>func main() {\n    num := 42\n    fmt.Printf(\"With sign: %+d\\n\", num)    // With sign: +42\n    fmt.Printf(\"Left justified: |%-5d|\\n\", num)  // Left justified: |42   |\n    fmt.Printf(\"Space for sign: |% d|\\n\", num)   // Space for sign: | 42|\n    fmt.Printf(\"Zero padded: %05d\\n\", num)       // Zero padded: 00042\n    fmt.Printf(\"Alternate format: %#o\\n\", num)   // Alternate format: 052\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#custom-formatting-with-interfaces","title":"Custom Formatting with Interfaces","text":"<p>You can implement the <code>fmt.Formatter</code> or <code>fmt.Stringer</code> interfaces for custom formatting:</p>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#fmtstringer-interface","title":"fmt.Stringer Interface","text":"<pre><code>type Person struct {\n    Name string\n    Age  int\n}\n\nfunc (p Person) String() string {\n    return fmt.Sprintf(\"%s (%d years)\", p.Name, p.Age)\n}\n\nfunc main() {\n    p := Person{\"Alice\", 30}\n    fmt.Printf(\"%s\\n\", p)  // Alice (30 years)\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#fmtformatter-interface","title":"fmt.Formatter Interface","text":"<pre><code>type Person struct {\n    Name string\n    Age  int\n}\n\nfunc (p Person) Format(f fmt.State, verb rune) {\n    switch verb {\n    case 's':\n        fmt.Fprint(f, p.Name)\n    case 'v':\n        if f.Flag('+') {\n            fmt.Fprintf(f, \"{Name:%q Age:%d}\", p.Name, p.Age)\n        } else {\n            fmt.Fprintf(f, \"{%s %d}\", p.Name, p.Age)\n        }\n    }\n}\n\nfunc main() {\n    p := Person{\"Bob\", 25}\n    fmt.Printf(\"%s\\n\", p)    // Bob\n    fmt.Printf(\"%v\\n\", p)    // {Bob 25}\n    fmt.Printf(\"%+v\\n\", p)   // {Name:\"Bob\" Age:25}\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#real-world-example-report-generator","title":"Real-World Example: Report Generator","text":"<p>Let's create a practical report generator that demonstrates various formatting techniques:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"text/tabwriter\"\n    \"time\"\n)\n\ntype Employee struct {\n    ID        int\n    Name      string\n    Position  string\n    Salary    float64\n    HireDate  time.Time\n    IsActive  bool\n}\n\nfunc (e Employee) yearsOfService() float64 {\n    return time.Since(e.HireDate).Hours() / 24 / 365\n}\n\nfunc main() {\n    employees := []Employee{\n        {1001, \"John Doe\", \"Developer\", 75000.50, time.Date(2018, 5, 15, 0, 0, 0, 0, time.UTC), true},\n        {1002, \"Jane Smith\", \"Designer\", 68000.75, time.Date(2019, 8, 22, 0, 0, 0, 0, time.UTC), true},\n        {1003, \"Bob Johnson\", \"Manager\", 95000.00, time.Date(2016, 3, 10, 0, 0, 0, 0, time.UTC), true},\n        {1004, \"Alice Williams\", \"Developer\", 72000.25, time.Date(2020, 1, 5, 0, 0, 0, 0, time.UTC), false},\n    }\n\n    // Create a tabwriter for aligned columns\n    w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)\n    defer w.Flush()\n\n    // Print header\n    fmt.Fprintln(w, \"ID\\tName\\tPosition\\tSalary\\tHire Date\\tYears of Service\\tActive\")\n\n    // Print employee data\n    totalSalary := 0.0\n    activeCount := 0\n\n    for _, emp := range employees {\n        fmt.Fprintf(w, \"%05d\\t%s\\t%s\\t$%.2f\\t%s\\t%.1f\\t%t\\n\",\n            emp.ID,\n            emp.Name,\n            emp.Position,\n            emp.Salary,\n            emp.HireDate.Format(\"2006-01-02\"),\n            emp.yearsOfService(),\n            emp.IsActive)\n\n        totalSalary += emp.Salary\n        if emp.IsActive {\n            activeCount++\n        }\n    }\n\n    // Print summary\n    fmt.Fprintln(w, \"\\nSUMMARY\")\n    fmt.Fprintf(w, \"Total Employees: %d\\n\", len(employees))\n    fmt.Fprintf(w, \"Active Employees: %d (%.1f%%)\\n\", activeCount, float64(activeCount)/float64(len(employees))*100)\n    fmt.Fprintf(w, \"Total Salary: $%12.2f\\n\", totalSalary)\n    fmt.Fprintf(w, \"Average Salary: $%10.2f\\n\", totalSalary/float64(len(employees)))\n\n    // Print memory addresses for demonstration\n    fmt.Fprintln(w, \"\\nMEMORY ADDRESSES\")\n    for i, emp := range employees {\n        fmt.Fprintf(w, \"Employee %d: %p\\n\", i+1, &amp;emp)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#output","title":"Output:","text":"<pre><code>ID     Name        Position    Salary      Hire Date   Years of Service    Active\n01001  John Doe    Developer   $75000.50   2018-05-15  5.1                 true\n01002  Jane Smith  Designer    $68000.75   2019-08-22  4.0                 true\n01003  Bob Johnson Manager     $95000.00   2016-03-10  7.2                 true\n01004  Alice Williams Developer  $72000.25   2020-01-05  3.3                 false\n\nSUMMARY\nTotal Employees: 4\nActive Employees: 3 (75.0%)\nTotal Salary: $   310001.50\nAverage Salary: $  77500.38\n\nMEMORY ADDRESSES\nEmployee 1: 0x14000126000\nEmployee 2: 0x14000126060\nEmployee 3: 0x140001260c0\nEmployee 4: 0x14000126120\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#how-this-example-demonstrates-formatting-verbs","title":"How This Example Demonstrates Formatting Verbs:","text":"<ol> <li>Integer Formatting:</li> <li><code>%05d</code> for zero-padded employee IDs</li> <li> <p><code>%d</code> for counts and percentages</p> </li> <li> <p>Floating-Point Formatting:</p> </li> <li><code>%.2f</code> for currency values</li> <li><code>%.1f</code> for years of service</li> <li> <p><code>%+.2f</code> to show sign for total salary</p> </li> <li> <p>String Formatting:</p> </li> <li><code>%s</code> for regular strings</li> <li><code>%q</code> for quoted names</li> <li> <p>Custom date formatting with time format strings</p> </li> <li> <p>Boolean Formatting:</p> </li> <li> <p><code>%t</code> for active status</p> </li> <li> <p>Pointer Formatting:</p> </li> <li> <p><code>%p</code> to show memory addresses</p> </li> <li> <p>Width and Precision:</p> </li> <li><code>%10.2f</code> for aligned currency values</li> <li> <p><code>%12.2f</code> for detailed salary display</p> </li> <li> <p>Custom Formatting:</p> </li> <li><code>yearsOfService</code> method uses <code>fmt.Sprintf</code> for custom output</li> <li> <p>Date formatting with custom layouts</p> </li> <li> <p>Tabular Output:</p> </li> <li>Uses <code>text/tabwriter</code> for aligned columns</li> <li>Combines multiple formatting verbs for clean tables</li> </ol>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#real-world-applications-of-this-pattern","title":"Real-World Applications of This Pattern:","text":"<ol> <li>Business Reporting:</li> <li>Financial reports with properly formatted numbers</li> <li>HR reports with employee statistics</li> <li> <p>Sales reports with currency formatting</p> </li> <li> <p>Logging Systems:</p> </li> <li>Structured logging with consistent formatting</li> <li>Debug logs with memory addresses and type information</li> <li> <p>Error logs with detailed context</p> </li> <li> <p>CLI Applications:</p> </li> <li>User-friendly command output</li> <li>Progress indicators with aligned text</li> <li> <p>Help text with properly formatted examples</p> </li> <li> <p>Data Export:</p> </li> <li>CSV/TSV generation with consistent formatting</li> <li>JSON/XML with custom string representations</li> <li>Human-readable data summaries</li> </ol>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#benefits-of-this-approach","title":"Benefits of This Approach:","text":"<ol> <li>Consistency:</li> <li>Uniform formatting across all reports</li> <li>Predictable output format</li> <li> <p>Easy to parse for automated systems</p> </li> <li> <p>Readability:</p> </li> <li>Aligned columns and consistent spacing</li> <li>Proper number formatting for currency</li> <li> <p>Clear visual hierarchy</p> </li> <li> <p>Maintainability:</p> </li> <li>Centralized formatting logic</li> <li>Easy to modify formatting rules</li> <li> <p>Reusable components for different reports</p> </li> <li> <p>Flexibility:</p> </li> <li>Can output to any <code>io.Writer</code> (file, network, etc.)</li> <li>Easy to add new formatting options</li> <li>Supports both human and machine-readable formats</li> </ol>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#conclusion","title":"Conclusion","text":"<p>Formatting verbs in Go provide powerful tools for controlling output presentation:</p>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#basic-formatting","title":"Basic Formatting:","text":"<ul> <li>Use <code>%v</code> for default formatting</li> <li>Use <code>%T</code> for type information</li> <li>Use <code>%%</code> for literal percent signs</li> </ul>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#type-specific-formatting","title":"Type-Specific Formatting:","text":"<ul> <li>Integers: <code>%d</code>, <code>%b</code>, <code>%o</code>, <code>%x</code>, etc.</li> <li>Floats: <code>%f</code>, <code>%e</code>, <code>%g</code>, etc.</li> <li>Strings: <code>%s</code>, <code>%q</code>, <code>%x</code></li> <li>Booleans: <code>%t</code></li> <li>Pointers: <code>%p</code></li> </ul>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#advanced-formatting","title":"Advanced Formatting:","text":"<ul> <li>Control width and precision with numbers</li> <li>Use flags for sign, padding, and alternate formats</li> <li>Implement custom formatting with interfaces</li> </ul>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#best-practices","title":"Best Practices:","text":"<ul> <li>Use tabwriter for aligned tables</li> <li>Prefer <code>fmt.Sprintf</code> for building strings</li> <li>Implement <code>Stringer</code> for custom types</li> <li>Use consistent formatting throughout your application</li> </ul> <p>The report generator example demonstrates how combining these formatting techniques can create professional, readable output for real-world applications. Mastering formatting verbs is essential for creating effective Go applications that communicate clearly with users and other systems.</p> <p>By understanding and properly using formatting verbs, you can:</p> <ul> <li>Create more user-friendly command-line tools</li> <li>Generate professional reports and documents</li> <li>Improve the readability of logs and debug output</li> <li>Ensure consistent data presentation across your application</li> <li>Build more maintainable and flexible output systems</li> </ul>"},{"location":"2.%20Intermediate/6.%20FMT-Package/","title":"Go FMT Package: Formatted Input and Output","text":"<p>Overview</p> <p>Master the fmt package - Go's primary tool for formatted I/O operations. Learn printing functions, format verbs, scanning input, and best practices for debugging and user interaction.</p> <p>Key Points</p> <ul> <li>Provides formatted I/O similar to C's printf family</li> <li>Rich set of format verbs for different data types</li> <li>Functions for printing, scanning, and string formatting</li> <li>Essential for debugging and user interaction</li> <li>Type-safe formatting with compile-time checks</li> </ul>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#understanding-the-fmt-package","title":"Understanding the FMT Package","text":"<p>The fmt package is Go's primary tool for formatted input and output operations, offering functions for printing, scanning, and formatting data.</p>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#core-printing-functions","title":"Core Printing Functions","text":""},{"location":"2.%20Intermediate/6.%20FMT-Package/#1-basic-output-functions","title":"1. Basic Output Functions","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Print - writes to standard output without adding a newline\n    fmt.Print(\"Hello, \")\n    fmt.Print(\"World!\\n\")\n\n    // Println - adds a newline between arguments and at the end\n    fmt.Println(\"Hello,\", \"World!\")\n\n    // Printf - formatted printing with verbs\n    name := \"Alice\"\n    age := 30\n    fmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#2-formatting-to-strings","title":"2. Formatting to Strings","text":"<pre><code>func main() {\n    // Sprintf - formats into a string\n    status := fmt.Sprintf(\"Status: %s (Code: %d)\", \"OK\", 200)\n    fmt.Println(status)\n\n    // Sprintln - adds newline\n    line := fmt.Sprintln(\"Part 1\", \"Part 2\")\n    fmt.Printf(\"Length: %d, Content: %q\", len(line), line)\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#3-writing-to-different-writers","title":"3. Writing to Different Writers","text":"<pre><code>import (\n    \"bytes\"\n    \"os\"\n)\n\nfunc main() {\n    // Fprint - writes to any io.Writer\n    var buf bytes.Buffer\n    fmt.Fprint(&amp;buf, \"Buffer content: \")\n    fmt.Fprintln(&amp;buf, 42)\n    fmt.Println(buf.String())\n\n    // Fprintf - formatted writing\n    fmt.Fprintf(os.Stderr, \"Error: %s occurred at %v\\n\", \"timeout\", time.Now())\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#input-scanning-functions","title":"Input Scanning Functions","text":""},{"location":"2.%20Intermediate/6.%20FMT-Package/#1-basic-input-functions","title":"1. Basic Input Functions","text":"<pre><code>func main() {\n    var name string\n    var age int\n\n    // Scan - reads space-separated values\n    fmt.Print(\"Enter name and age: \")\n    fmt.Scan(&amp;name, &amp;age)\n    fmt.Printf(\"Read: name=%q, age=%d\\n\", name, age)\n\n    // Scanln - reads until newline\n    var city string\n    fmt.Print(\"Enter city: \")\n    fmt.Scanln(&amp;city)\n    fmt.Println(\"City:\", city)\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#2-formatted-scanning","title":"2. Formatted Scanning","text":"<pre><code>func main() {\n    var item string\n    var price float64\n    var inStock bool\n\n    // Sscanf - scans from a string\n    input := \"Widget 19.99 true\"\n    fmt.Sscanf(input, \"%s %f %t\", &amp;item, &amp;price, &amp;inStock)\n    fmt.Printf(\"Item: %s, Price: $%.2f, In Stock: %t\\n\", item, price, inStock)\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#3-scanning-from-different-readers","title":"3. Scanning from Different Readers","text":"<pre><code>import \"strings\"\n\nfunc main() {\n    // Fscan - scans from any io.Reader\n    input := \"123 456\"\n    reader := strings.NewReader(input)\n    var a, b int\n    fmt.Fscan(reader, &amp;a, &amp;b)\n    fmt.Println(\"Read:\", a, b)\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#error-handling-with-fmt","title":"Error Handling with <code>fmt</code>","text":""},{"location":"2.%20Intermediate/6.%20FMT-Package/#1-creating-formatted-errors","title":"1. Creating Formatted Errors","text":"<pre><code>func processFile(filename string) error {\n    if filename == \"\" {\n        return fmt.Errorf(\"invalid filename: %q\", filename)\n    }\n    // ... processing logic\n    return nil\n}\n\nfunc main() {\n    err := processFile(\"\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#2-error-wrapping","title":"2. Error Wrapping","text":"<pre><code>func readFile(filename string) error {\n    // Simulate file operation\n    return fmt.Errorf(\"readFile failed: %w\", \n        fmt.Errorf(\"permission denied\"))\n}\n\nfunc main() {\n    err := readFile(\"config.json\")\n    if err != nil {\n        fmt.Println(\"Full error:\", err)\n        // In Go 1.13+, you can unwrap errors\n        // fmt.Println(errors.Unwrap(err))\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#custom-formatters","title":"Custom Formatters","text":""},{"location":"2.%20Intermediate/6.%20FMT-Package/#1-implementing-stringer-interface","title":"1. Implementing <code>Stringer</code> Interface","text":"<pre><code>type User struct {\n    ID    int\n    Name  string\n    Email string\n}\n\nfunc (u User) String() string {\n    return fmt.Sprintf(\"User[%d]: %s &lt;%s&gt;\", u.ID, u.Name, u.Email)\n}\n\nfunc main() {\n    user := User{1, \"Alice\", \"alice@example.com\"}\n    fmt.Println(user) // Automatically calls String()\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#2-implementing-formatter-interface","title":"2. Implementing <code>Formatter</code> Interface","text":"<pre><code>type Money float64\n\nfunc (m Money) Format(f fmt.State, verb rune) {\n    switch verb {\n    case 'f':\n        fmt.Fprintf(f, \"$%.2f\", float64(m))\n    case 's':\n        fmt.Fprintf(f, \"$%.2f\", float64(m))\n    case 'v':\n        if f.Flag('+') {\n            fmt.Fprintf(f, \"Money(%v)\", float64(m))\n        } else {\n            fmt.Fprintf(f, \"$%.2f\", float64(m))\n        }\n    default:\n        fmt.Fprintf(f, \"%v\", float64(m))\n    }\n}\n\nfunc main() {\n    price := Money(19.99)\n    fmt.Printf(\"Price: %v\\n\", price)    // $19.99\n    fmt.Printf(\"Price: %+v\\n\", price)   // Money(19.99)\n    fmt.Printf(\"Price: %f\\n\", price)    // $19.99\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#advanced-formatting-features","title":"Advanced Formatting Features","text":""},{"location":"2.%20Intermediate/6.%20FMT-Package/#1-handling-complex-types","title":"1. Handling Complex Types","text":"<pre><code>func main() {\n    // Slices\n    nums := []int{1, 2, 3}\n    fmt.Printf(\"Slice: %v\\n\", nums)     // [1 2 3]\n    fmt.Printf(\"Slice: %#v\\n\", nums)    // []int{1, 2, 3}\n\n    // Maps\n    m := map[string]int{\"one\": 1, \"two\": 2}\n    fmt.Printf(\"Map: %v\\n\", m)          // map[one:1 two:2]\n    fmt.Printf(\"Map: %#v\\n\", m)         // map[string]int{\"one\":1, \"two\":2}\n\n    // Pointers\n    x := 42\n    fmt.Printf(\"Pointer: %p\\n\", &amp;x)     // 0x1040a124\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#2-width-and-precision-control","title":"2. Width and Precision Control","text":"<pre><code>func main() {\n    // Integer formatting\n    fmt.Printf(\"|%5d|\\n\", 42)      // |   42|\n    fmt.Printf(\"|%-5d|\\n\", 42)     // |42   |\n    fmt.Printf(\"|%05d|\\n\", 42)     // |00042|\n\n    // Floating-point formatting\n    pi := 3.14159\n    fmt.Printf(\"|%10.2f|\\n\", pi)   // |      3.14|\n    fmt.Printf(\"|%-10.2f|\\n\", pi)  // |3.14      |\n\n    // String formatting\n    s := \"hello\"\n    fmt.Printf(\"|%10s|\\n\", s)      // |     hello|\n    fmt.Printf(\"|%-10s|\\n\", s)     // |hello     |\n    fmt.Printf(\"|%.3s|\\n\", s)      // |hel|\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#3-formatting-flags","title":"3. Formatting Flags","text":"<pre><code>func main() {\n    // Sign flag\n    fmt.Printf(\"|%+d|\\n\", 42)      // |+42|\n    fmt.Printf(\"|%+d|\\n\", -42)     // |-42|\n\n    // Space flag\n    fmt.Printf(\"|% d|\\n\", 42)      // | 42|\n    fmt.Printf(\"|% d|\\n\", -42)     // |-42|\n\n    // Alternate format\n    fmt.Printf(\"%#o\\n\", 8)        // 010\n    fmt.Printf(\"%#x\\n\", 255)      // 0xff\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#real-world-example-interactive-cli-tool","title":"Real-World Example: Interactive CLI Tool","text":"<p>Let's build a practical command-line tool that demonstrates various <code>fmt</code> package features:</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n)\n\ntype Task struct {\n    ID        int\n    Title     string\n    Completed bool\n    DueDate   time.Time\n}\n\nfunc (t Task) String() string {\n    status := \"Pending\"\n    if t.Completed {\n        status = \"Completed\"\n    }\n    return fmt.Sprintf(\"#%d: %s [%s] (Due: %s)\", \n        t.ID, t.Title, status, t.DueDate.Format(\"2006-01-02\"))\n}\n\ntype TaskManager struct {\n    tasks []Task\n    nextID int\n}\n\nfunc NewTaskManager() *TaskManager {\n    return &amp;TaskManager{\n        tasks: make([]Task, 0),\n        nextID: 1,\n    }\n}\n\nfunc (tm *TaskManager) AddTask(title string, dueDate time.Time) {\n    task := Task{\n        ID:        tm.nextID,\n        Title:     title,\n        Completed: false,\n        DueDate:   dueDate,\n    }\n    tm.tasks = append(tm.tasks, task)\n    tm.nextID++\n    fmt.Printf(\"Added task: %v\\n\", task)\n}\n\nfunc (tm *TaskManager) CompleteTask(id int) error {\n    for i := range tm.tasks {\n        if tm.tasks[i].ID == id {\n            tm.tasks[i].Completed = true\n            fmt.Printf(\"Completed task: %v\\n\", tm.tasks[i])\n            return nil\n        }\n    }\n    return fmt.Errorf(\"task with ID %d not found\", id)\n}\n\nfunc (tm *TaskManager) ListTasks() {\n    if len(tm.tasks) == 0 {\n        fmt.Println(\"No tasks found.\")\n        return\n    }\n\n    fmt.Println(\"\\nTasks:\")\n    fmt.Println(\"----------------------------\")\n    for _, task := range tm.tasks {\n        fmt.Printf(\"%s\\n\", task)\n    }\n    fmt.Println(\"----------------------------\")\n}\n\nfunc (tm *TaskManager) SaveToFile(filename string) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return fmt.Errorf(\"failed to create file: %w\", err)\n    }\n    defer file.Close()\n\n    for _, task := range tm.tasks {\n        line := fmt.Sprintf(\"%d,%s,%t,%s\\n\", \n            task.ID, \n            task.Title, \n            task.Completed, \n            task.DueDate.Format(\"2006-01-02\"))\n        fmt.Fprint(file, line)\n    }\n\n    fmt.Printf(\"Saved %d tasks to %s\\n\", len(tm.tasks), filename)\n    return nil\n}\n\nfunc (tm *TaskManager) LoadFromFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return fmt.Errorf(\"failed to open file: %w\", err)\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    for scanner.Scan() {\n        line := scanner.Text()\n        parts := strings.Split(line, \",\")\n        if len(parts) != 4 {\n            fmt.Fprintf(os.Stderr, \"Invalid line format: %q\\n\", line)\n            continue\n        }\n\n        id, _ := strconv.Atoi(parts[0])\n        completed, _ := strconv.ParseBool(parts[2])\n        dueDate, _ := time.Parse(\"2006-01-02\", parts[3])\n\n        task := Task{\n            ID:        id,\n            Title:     parts[1],\n            Completed: completed,\n            DueDate:   dueDate,\n        }\n\n        tm.tasks = append(tm.tasks, task)\n        if id &gt;= tm.nextID {\n            tm.nextID = id + 1\n        }\n    }\n\n    if err := scanner.Err(); err != nil {\n        return fmt.Errorf(\"error reading file: %w\", err)\n    }\n\n    fmt.Printf(\"Loaded %d tasks from %s\\n\", len(tm.tasks), filename)\n    return nil\n}\n\nfunc displayMenu() {\n    fmt.Println(\"\\nTask Manager\")\n    fmt.Println(\"1. Add Task\")\n    fmt.Println(\"2. Complete Task\")\n    fmt.Println(\"3. List Tasks\")\n    fmt.Println(\"4. Save Tasks\")\n    fmt.Println(\"5. Load Tasks\")\n    fmt.Println(\"6. Exit\")\n    fmt.Print(\"Enter your choice: \")\n}\n\nfunc main() {\n    tm := NewTaskManager()\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for {\n        displayMenu()\n\n        if !scanner.Scan() {\n            break\n        }\n\n        choice := strings.TrimSpace(scanner.Text())\n\n        switch choice {\n        case \"1\":\n            fmt.Print(\"Enter task title: \")\n            scanner.Scan()\n            title := strings.TrimSpace(scanner.Text())\n\n            fmt.Print(\"Enter due date (YYYY-MM-DD): \")\n            scanner.Scan()\n            dateStr := strings.TrimSpace(scanner.Text())\n\n            dueDate, err := time.Parse(\"2006-01-02\", dateStr)\n            if err != nil {\n                fmt.Fprintf(os.Stderr, \"Invalid date format: %v\\n\", err)\n                continue\n            }\n\n            tm.AddTask(title, dueDate)\n\n        case \"2\":\n            fmt.Print(\"Enter task ID to complete: \")\n            scanner.Scan()\n            idStr := strings.TrimSpace(scanner.Text())\n\n            id, err := strconv.Atoi(idStr)\n            if err != nil {\n                fmt.Fprintf(os.Stderr, \"Invalid ID: %v\\n\", err)\n                continue\n            }\n\n            if err := tm.CompleteTask(id); err != nil {\n                fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n            }\n\n        case \"3\":\n            tm.ListTasks()\n\n        case \"4\":\n            fmt.Print(\"Enter filename to save: \")\n            scanner.Scan()\n            filename := strings.TrimSpace(scanner.Text())\n\n            if err := tm.SaveToFile(filename); err != nil {\n                fmt.Fprintf(os.Stderr, \"Error saving: %v\\n\", err)\n            }\n\n        case \"5\":\n            fmt.Print(\"Enter filename to load: \")\n            scanner.Scan()\n            filename := strings.TrimSpace(scanner.Text())\n\n            if err := tm.LoadFromFile(filename); err != nil {\n                fmt.Fprintf(os.Stderr, \"Error loading: %v\\n\", err)\n            }\n\n        case \"6\":\n            fmt.Println(\"Goodbye!\")\n            return\n\n        default:\n            fmt.Fprintln(os.Stderr, \"Invalid choice. Please try again.\")\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#how-this-example-demonstrates-fmt-features","title":"How This Example Demonstrates <code>fmt</code> Features:","text":"<ol> <li>User Interaction:</li> <li>Uses <code>fmt.Print</code> and <code>fmt.Println</code> for prompts and messages</li> <li><code>fmt.Fprint</code> and <code>fmt.Fprintf</code> for error output to <code>os.Stderr</code></li> <li> <p><code>fmt.Scan</code> for reading user input</p> </li> <li> <p>String Formatting:</p> </li> <li>Custom <code>String()</code> method for Task struct</li> <li><code>fmt.Sprintf</code> for building formatted strings</li> <li> <p>Various formatting verbs for different data types</p> </li> <li> <p>File I/O:</p> </li> <li><code>fmt.Fprint</code> for writing to files</li> <li><code>fmt.Fscanf</code> could be used for reading (though we use scanner here)</li> <li> <p>Formatted output for saving tasks</p> </li> <li> <p>Error Handling:</p> </li> <li><code>fmt.Errorf</code> for creating descriptive errors</li> <li>Error wrapping with <code>%w</code> verb</li> <li> <p>Formatted error messages to stderr</p> </li> <li> <p>Advanced Formatting:</p> </li> <li>Date formatting with custom layouts</li> <li>Number formatting for IDs</li> <li>Boolean formatting for completion status</li> </ol>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#real-world-applications-of-this-pattern","title":"Real-World Applications of This Pattern:","text":"<ol> <li>CLI Applications:</li> <li>Interactive command-line tools</li> <li>System administration utilities</li> <li> <p>Development tools and scripts</p> </li> <li> <p>Data Processing Tools:</p> </li> <li>Log parsers and analyzers</li> <li>Data transformation utilities</li> <li> <p>Report generators</p> </li> <li> <p>Configuration Management:</p> </li> <li>Tools that read/write configuration files</li> <li>Environment variable managers</li> <li> <p>Secret management utilities</p> </li> <li> <p>Testing and Debugging:</p> </li> <li>Test output formatters</li> <li>Debug logging utilities</li> <li>Benchmark result reporters</li> </ol>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#benefits-of-this-approach","title":"Benefits of This Approach:","text":"<ol> <li>User Experience:</li> <li>Clear, formatted prompts and messages</li> <li>Consistent output formatting</li> <li> <p>Helpful error messages</p> </li> <li> <p>Maintainability:</p> </li> <li>Centralized formatting logic</li> <li>Custom string representations for complex types</li> <li> <p>Clear separation of concerns</p> </li> <li> <p>Flexibility:</p> </li> <li>Easy to modify output formats</li> <li>Can redirect output to different writers</li> <li> <p>Supports both interactive and batch modes</p> </li> <li> <p>Robustness:</p> </li> <li>Proper error handling with formatted messages</li> <li>Input validation with clear feedback</li> <li>Graceful handling of edge cases</li> </ol>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#best-practices-for-using-fmt","title":"Best Practices for Using <code>fmt</code>","text":"<ol> <li>Choose the Right Function:</li> <li>Use <code>Print</code>/<code>Println</code> for simple output</li> <li>Use <code>Printf</code> for formatted output</li> <li>Use <code>Sprintf</code> when you need a string</li> <li> <p>Use <code>Fprintf</code> for writing to files or other writers</p> </li> <li> <p>Error Handling:</p> </li> <li>Always check errors from <code>fmt</code> functions that can return them</li> <li>Use <code>fmt.Errorf</code> for creating descriptive errors</li> <li> <p>Wrap errors with context using <code>%w</code></p> </li> <li> <p>Performance Considerations:</p> </li> <li>For high-performance logging, consider alternatives like <code>log</code></li> <li>Reuse buffers with <code>fmt.Fprintf</code> for repeated formatting</li> <li> <p>Avoid unnecessary string conversions</p> </li> <li> <p>Custom Formatting:</p> </li> <li>Implement <code>Stringer</code> for custom types</li> <li>Use <code>Formatter</code> for complex formatting needs</li> <li> <p>Keep formatting logic simple and readable</p> </li> <li> <p>Internationalization:</p> </li> <li>Be careful with formatted strings that might need translation</li> <li>Consider using specialized i18n packages for multilingual apps</li> <li>Avoid concatenating formatted strings for translation</li> </ol>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#conclusion","title":"Conclusion","text":"<p>The <code>fmt</code> package is a cornerstone of Go's standard library, providing essential tools for:</p> <ol> <li>Formatted Output:</li> <li>Printing to console with various formatting options</li> <li>Creating formatted strings for programmatic use</li> <li> <p>Writing formatted data to files and other writers</p> </li> <li> <p>Input Handling:</p> </li> <li>Reading and parsing user input</li> <li>Scanning formatted data from strings and readers</li> <li> <p>Converting string representations to Go types</p> </li> <li> <p>Error Management:</p> </li> <li>Creating descriptive error messages</li> <li>Wrapping errors with additional context</li> <li> <p>Providing consistent error formatting</p> </li> <li> <p>Custom Representation:</p> </li> <li>Implementing custom string representations for types</li> <li>Creating type-specific formatting logic</li> <li>Integrating with Go's printing ecosystem</li> </ol> <p>The task manager example demonstrates how <code>fmt</code> can be used to build a complete, interactive command-line application with proper user interaction, file I/O, and error handling. Mastering the <code>fmt</code> package is essential for any Go developer working on applications that need to communicate with users or other systems through text-based interfaces.</p> <p>By understanding and effectively using the <code>fmt</code> package, you can: - Create more user-friendly command-line tools - Build better logging and debugging systems - Implement robust data serialization and deserialization - Improve the overall quality and maintainability of your Go applications</p> <p>The <code>fmt</code> package's simplicity and power make it one of Go's most frequently used and important packages, forming the foundation for much of Go's I/O and text processing capabilities.</p>"},{"location":"2.%20Intermediate/7.%20Structs/","title":"Go Structs: Custom Data Types and Composition","text":"<p>Overview</p> <p>Master Go structs - collections of fields that form custom data types. Learn struct definition, initialization, methods, embedding, and composition patterns for building robust, maintainable applications.</p> <p>Key Points</p> <ul> <li>Structs group related data into single entities</li> <li>Support both value and pointer semantics</li> <li>Enable composition over inheritance</li> <li>Fields can be exported (public) or unexported (private)</li> <li>Zero values provide safe defaults</li> </ul>"},{"location":"2.%20Intermediate/7.%20Structs/#understanding-structs","title":"Understanding Structs","text":"<p>Structs are Go's primary mechanism for creating custom data types by grouping related fields together.</p>"},{"location":"2.%20Intermediate/7.%20Structs/#defining-structs","title":"Defining Structs","text":"<p>A struct is defined using the <code>type</code> and <code>struct</code> keywords:</p> <pre><code>type Person struct {\n    Name string\n    Age  int\n    Email string\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#struct-characteristics","title":"Struct Characteristics:","text":"<ul> <li>Fields: Each field has a name and a type</li> <li>Order: Field order matters for memory layout</li> <li>Exportability: Capitalized fields are exported (public)</li> <li>Zero Values: Each field has a zero value when uninitialized</li> </ul>"},{"location":"2.%20Intermediate/7.%20Structs/#creating-and-initializing-structs","title":"Creating and Initializing Structs","text":""},{"location":"2.%20Intermediate/7.%20Structs/#1-using-field-names","title":"1. Using Field Names","text":"<pre><code>func main() {\n    // Named initialization\n    p1 := Person{\n        Name: \"Alice\",\n        Age:  30,\n        Email: \"alice@example.com\",\n    }\n    fmt.Printf(\"%+v\\n\", p1)\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#2-using-positional-values","title":"2. Using Positional Values","text":"<pre><code>func main() {\n    // Positional initialization (must match field order)\n    p2 := Person{\"Bob\", 25, \"bob@example.com\"}\n    fmt.Printf(\"%+v\\n\", p2)\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#3-using-the-new-keyword","title":"3. Using the <code>new</code> Keyword","text":"<pre><code>func main() {\n    // new() returns a pointer to a zero-value struct\n    p3 := new(Person)\n    p3.Name = \"Charlie\"\n    p3.Age = 35\n    fmt.Printf(\"%+v\\n\", p3)\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#4-partial-initialization","title":"4. Partial Initialization","text":"<pre><code>func main() {\n    // Unspecified fields get zero values\n    p4 := Person{\n        Name: \"Diana\",\n    }\n    fmt.Printf(\"%+v\\n\", p4) // Email is empty string, Age is 0\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#accessing-and-modifying-struct-fields","title":"Accessing and Modifying Struct Fields","text":""},{"location":"2.%20Intermediate/7.%20Structs/#using-dot-notation","title":"Using Dot Notation","text":"<pre><code>func main() {\n    p := Person{Name: \"Alice\", Age: 30}\n\n    // Access fields\n    fmt.Println(\"Name:\", p.Name)\n    fmt.Println(\"Age:\", p.Age)\n\n    // Modify fields\n    p.Age = 31\n    fmt.Println(\"New Age:\", p.Age)\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#working-with-pointers","title":"Working with Pointers","text":"<pre><code>func main() {\n    p := &amp;Person{Name: \"Bob\", Age: 25}\n\n    // Go automatically dereferences pointers\n    p.Age = 26        // Same as (*p).Age = 26\n    fmt.Println(p.Age) // 26\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#structs-with-methods","title":"Structs with Methods","text":"<p>Methods are functions with a special receiver argument. They can be defined on any named type.</p>"},{"location":"2.%20Intermediate/7.%20Structs/#value-receivers","title":"Value Receivers","text":"<pre><code>type Rectangle struct {\n    Width, Height float64\n}\n\n// Method with value receiver\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc main() {\n    rect := Rectangle{Width: 10, Height: 5}\n    fmt.Println(\"Area:\", rect.Area()) // 50\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#pointer-receivers","title":"Pointer Receivers","text":"<pre><code>// Method with pointer receiver (can modify struct)\nfunc (r *Rectangle) Scale(factor float64) {\n    r.Width *= factor\n    r.Height *= factor\n}\n\nfunc main() {\n    rect := Rectangle{Width: 10, Height: 5}\n    rect.Scale(2)\n    fmt.Printf(\"Scaled: %+v\\n\", rect) // {Width:20 Height:10}\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#when-to-use-pointer-receivers","title":"When to Use Pointer Receivers:","text":"<ol> <li>When you need to modify the receiver</li> <li>When the struct is large (to avoid copying)</li> <li>When consistency is needed (mixing value and pointer receivers can be confusing)</li> </ol>"},{"location":"2.%20Intermediate/7.%20Structs/#struct-composition-embedding","title":"Struct Composition (Embedding)","text":"<p>Go supports composition through struct embedding, which allows one struct to include another, inheriting its fields and methods.</p>"},{"location":"2.%20Intermediate/7.%20Structs/#basic-embedding","title":"Basic Embedding","text":"<pre><code>type Address struct {\n    Street string\n    City   string\n}\n\ntype Person struct {\n    Name    string\n    Age     int\n    Address // Embedded struct\n}\n\nfunc main() {\n    p := Person{\n        Name: \"Alice\",\n        Age:  30,\n        Address: Address{\n            Street: \"123 Main St\",\n            City:   \"New York\",\n        },\n    }\n\n    // Access embedded fields directly\n    fmt.Println(\"City:\", p.City)       // New York\n    fmt.Println(\"Street:\", p.Street)    // 123 Main St\n\n    // Access via embedded type name\n    fmt.Println(\"City:\", p.Address.City) // New York\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#method-promotion","title":"Method Promotion","text":"<p>Methods of embedded structs are promoted to the containing struct:</p> <pre><code>func (a Address) FullAddress() string {\n    return fmt.Sprintf(\"%s, %s\", a.Street, a.City)\n}\n\nfunc main() {\n    p := Person{\n        Name: \"Alice\",\n        Address: Address{\n            Street: \"123 Main St\",\n            City:   \"New York\",\n        },\n    }\n\n    // Can call embedded method directly\n    fmt.Println(p.FullAddress()) // 123 Main St, New York\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#overriding-embedded-methods","title":"Overriding Embedded Methods","text":"<pre><code>func (p Person) FullAddress() string {\n    return fmt.Sprintf(\"%s: %s, %s\", p.Name, p.Street, p.City)\n}\n\nfunc main() {\n    p := Person{\n        Name: \"Alice\",\n        Address: Address{\n            Street: \"123 Main St\",\n            City:   \"New York\",\n        },\n    }\n\n    fmt.Println(p.FullAddress()) // Alice: 123 Main St, New York\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#struct-tags","title":"Struct Tags","text":"<p>Struct tags are metadata attached to struct fields that provide instructions to other packages, commonly used for serialization, validation, and ORM mapping.</p>"},{"location":"2.%20Intermediate/7.%20Structs/#basic-syntax","title":"Basic Syntax","text":"<pre><code>type User struct {\n    ID       int    `json:\"id\"`\n    Username string `json:\"username\"`\n    Email    string `json:\"email\" validate:\"required\"`\n    Password string `json:\"-\"` // \"-\" means ignore this field\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#common-tag-formats","title":"Common Tag Formats","text":"<ol> <li> <p>JSON Serialization:    <pre><code>type Product struct {\n    ID          int     `json:\"id\"`\n    Name        string  `json:\"name\"`\n    Price       float64 `json:\"price,omitempty\"` // Omit if zero value\n    Description string  `json:\"description,omitempty\"`\n}\n</code></pre></p> </li> <li> <p>Database Mapping:    <pre><code>type Customer struct {\n    ID        int    `db:\"id\"`\n    FirstName string `db:\"first_name\"`\n    LastName  string `db:\"last_name\"`\n    CreatedAt time.Time `db:\"created_at\"`\n}\n</code></pre></p> </li> <li> <p>Validation:    <pre><code>type Registration struct {\n    Email    string `validate:\"required,email\"`\n    Password string `validate:\"required,min=8\"`\n    Age      int    `validate:\"gte=18\"`\n}\n</code></pre></p> </li> </ol>"},{"location":"2.%20Intermediate/7.%20Structs/#comparing-structs","title":"Comparing Structs","text":"<p>Structs can be compared using <code>==</code> and <code>!=</code> operators if all their fields are comparable:</p> <pre><code>type Point struct {\n    X, Y int\n}\n\nfunc main() {\n    p1 := Point{X: 1, Y: 2}\n    p2 := Point{X: 1, Y: 2}\n    p3 := Point{X: 1, Y: 3}\n\n    fmt.Println(p1 == p2) // true\n    fmt.Println(p1 == p3) // false\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#limitations","title":"Limitations:","text":"<ul> <li>Structs with slice or map fields cannot be compared directly</li> <li>Structs with function fields cannot be compared</li> <li>For complex comparisons, implement a custom method</li> </ul>"},{"location":"2.%20Intermediate/7.%20Structs/#real-world-example-json-api-handler","title":"Real-World Example: JSON API Handler","text":"<p>Let's build a practical example that demonstrates struct usage in a web API context:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"time\"\n)\n\n// Product represents a product in our inventory\ntype Product struct {\n    ID          int       `json:\"id\"`\n    Name        string    `json:\"name\" validate:\"required\"`\n    Description string    `json:\"description,omitempty\"`\n    Price       float64   `json:\"price\" validate:\"required,gte=0\"`\n    Category    string    `json:\"category\"`\n    InStock     bool      `json:\"in_stock\"`\n    CreatedAt   time.Time `json:\"created_at\"`\n    UpdatedAt   time.Time `json:\"updated_at\"`\n}\n\n// ProductRequest represents the JSON request body for creating/updating products\ntype ProductRequest struct {\n    Name        string  `json:\"name\" validate:\"required\"`\n    Description string  `json:\"description\"`\n    Price       float64 `json:\"price\" validate:\"required,gte=0\"`\n    Category    string  `json:\"category\"`\n    InStock     bool    `json:\"in_stock\"`\n}\n\n// ProductResponse wraps the product with metadata\ntype ProductResponse struct {\n    Success bool      `json:\"success\"`\n    Message string    `json:\"message,omitempty\"`\n    Data    *Product  `json:\"data,omitempty\"`\n    Errors  []string  `json:\"errors,omitempty\"`\n}\n\n// ProductStore simulates a database\ntype ProductStore struct {\n    products map[int]*Product\n    nextID   int\n}\n\nfunc NewProductStore() *ProductStore {\n    return &amp;ProductStore{\n        products: make(map[int]*Product),\n        nextID:   1,\n    }\n}\n\nfunc (s *ProductStore) AddProduct(p *Product) int {\n    p.ID = s.nextID\n    p.CreatedAt = time.Now()\n    p.UpdatedAt = time.Now()\n    s.products[p.ID] = p\n    s.nextID++\n    return p.ID\n}\n\nfunc (s *ProductStore) GetProduct(id int) (*Product, bool) {\n    product, exists := s.products[id]\n    return product, exists\n}\n\nfunc (s *ProductStore) UpdateProduct(id int, updates *ProductRequest) (*Product, bool) {\n    product, exists := s.products[id]\n    if !exists {\n        return nil, false\n    }\n\n    product.Name = updates.Name\n    product.Description = updates.Description\n    product.Price = updates.Price\n    product.Category = updates.Category\n    product.InStock = updates.InStock\n    product.UpdatedAt = time.Now()\n\n    return product, true\n}\n\n// API Handlers\nfunc createProduct(store *ProductStore) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        var req ProductRequest\n\n        // Decode JSON request\n        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n            respondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n            return\n        }\n\n        // Create product\n        product := &amp;Product{\n            Name:        req.Name,\n            Description: req.Description,\n            Price:       req.Price,\n            Category:    req.Category,\n            InStock:     req.InStock,\n        }\n\n        id := store.AddProduct(product)\n        product, _ = store.GetProduct(id)\n\n        respondWithJSON(w, http.StatusCreated, ProductResponse{\n            Success: true,\n            Message: \"Product created successfully\",\n            Data:    product,\n        })\n    }\n}\n\nfunc getProduct(store *ProductStore) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        id := 1 // In real app, get from URL params\n\n        product, exists := store.GetProduct(id)\n        if !exists {\n            respondWithError(w, http.StatusNotFound, \"Product not found\")\n            return\n        }\n\n        respondWithJSON(w, http.StatusOK, ProductResponse{\n            Success: true,\n            Data:    product,\n        })\n    }\n}\n\nfunc updateProduct(store *ProductStore) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        id := 1 // In real app, get from URL params\n\n        var req ProductRequest\n        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n            respondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n            return\n        }\n\n        product, updated := store.UpdateProduct(id, &amp;req)\n        if !updated {\n            respondWithError(w, http.StatusNotFound, \"Product not found\")\n            return\n        }\n\n        respondWithJSON(w, http.StatusOK, ProductResponse{\n            Success: true,\n            Message: \"Product updated successfully\",\n            Data:    product,\n        })\n    }\n}\n\n// Helper functions\nfunc respondWithError(w http.ResponseWriter, code int, message string) {\n    respondWithJSON(w, code, ProductResponse{\n        Success: false,\n        Message: message,\n    })\n}\n\nfunc respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {\n    response, _ := json.Marshal(payload)\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(code)\n    w.Write(response)\n}\n\nfunc main() {\n    store := NewProductStore()\n\n    // Add some sample data\n    store.AddProduct(&amp;Product{\n        Name:     \"Laptop\",\n        Price:    999.99,\n        Category: \"Electronics\",\n        InStock:  true,\n    })\n\n    // Setup routes\n    http.HandleFunc(\"/products\", createProduct(store))\n    http.HandleFunc(\"/product\", getProduct(store))\n    http.HandleFunc(\"/product/update\", updateProduct(store))\n\n    fmt.Println(\"Server starting on port 8080...\")\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#how-this-example-demonstrates-struct-concepts","title":"How This Example Demonstrates Struct Concepts:","text":"<ol> <li>Struct Definition:</li> <li><code>Product</code> struct with various field types</li> <li><code>ProductRequest</code> for input validation</li> <li> <p><code>ProductResponse</code> for API responses</p> </li> <li> <p>Struct Tags:</p> </li> <li>JSON tags for serialization (<code>json:\"id\"</code>)</li> <li>Validation tags (<code>validate:\"required\"</code>)</li> <li> <p>Special tags like <code>omitempty</code> and <code>-</code></p> </li> <li> <p>Method Definitions:</p> </li> <li>Methods on <code>ProductStore</code> for data operations</li> <li>Pointer receivers for modifying data</li> <li> <p>Value receivers for read operations</p> </li> <li> <p>Composition:</p> </li> <li><code>ProductResponse</code> embeds <code>Product</code> data</li> <li> <p>Clear separation of concerns between structs</p> </li> <li> <p>Real-World Usage:</p> </li> <li>JSON serialization/deserialization</li> <li>API request/response handling</li> <li>Data validation through tags</li> </ol>"},{"location":"2.%20Intermediate/7.%20Structs/#real-world-applications-of-this-pattern","title":"Real-World Applications of This Pattern:","text":"<ol> <li>Web APIs:</li> <li>RESTful API endpoints</li> <li>GraphQL resolvers</li> <li> <p>Microservices communication</p> </li> <li> <p>Database Models:</p> </li> <li>ORM mappings</li> <li>Database schema definitions</li> <li> <p>Data validation layers</p> </li> <li> <p>Configuration Management:</p> </li> <li>Application configuration structs</li> <li>Environment variable mappings</li> <li> <p>Settings validation</p> </li> <li> <p>Message Queues:</p> </li> <li>Event/message definitions</li> <li>Protocol buffer definitions</li> <li>Serialization formats</li> </ol>"},{"location":"2.%20Intermediate/7.%20Structs/#benefits-of-this-approach","title":"Benefits of This Approach:","text":"<ol> <li>Type Safety:</li> <li>Compile-time type checking</li> <li>Clear data contracts</li> <li> <p>Reduced runtime errors</p> </li> <li> <p>Maintainability:</p> </li> <li>Self-documenting code through struct definitions</li> <li>Clear separation of concerns</li> <li> <p>Easy to modify and extend</p> </li> <li> <p>Interoperability:</p> </li> <li>Standardized serialization (JSON, XML, etc.)</li> <li>Easy integration with external systems</li> <li> <p>Consistent data formats</p> </li> <li> <p>Validation:</p> </li> <li>Built-in validation through tags</li> <li>Centralized validation logic</li> <li>Clear error messages</li> </ol>"},{"location":"2.%20Intermediate/7.%20Structs/#best-practices-for-structs","title":"Best Practices for Structs","text":"<ol> <li>Naming Conventions:</li> <li>Use PascalCase for struct names (<code>Product</code>, <code>UserAccount</code>)</li> <li>Use PascalCase for exported fields</li> <li> <p>Use camelCase for unexported fields</p> </li> <li> <p>Field Organization:</p> </li> <li>Group related fields together</li> <li>Place similar types together</li> <li> <p>Consider memory alignment for performance-critical code</p> </li> <li> <p>Embedding Guidelines:</p> </li> <li>Use embedding for true \"is-a\" relationships</li> <li>Avoid deep embedding hierarchies</li> <li> <p>Be aware of name conflicts</p> </li> <li> <p>Tag Usage:</p> </li> <li>Keep tags concise and meaningful</li> <li>Use standard tag formats when possible</li> <li> <p>Document custom tag formats</p> </li> <li> <p>Memory Considerations:</p> </li> <li>Be mindful of struct size for performance</li> <li>Consider using pointers for large fields</li> <li>Understand memory alignment and padding</li> </ol>"},{"location":"2.%20Intermediate/7.%20Structs/#conclusion","title":"Conclusion","text":"<p>Structs are a fundamental building block in Go that enable:</p> <ol> <li>Data Organization:</li> <li>Group related data into logical units</li> <li>Create meaningful domain-specific types</li> <li> <p>Implement complex data structures</p> </li> <li> <p>Behavior Implementation:</p> </li> <li>Attach methods to data types</li> <li>Implement interfaces</li> <li> <p>Create reusable components</p> </li> <li> <p>System Integration:</p> </li> <li>Define clear data contracts</li> <li>Enable serialization/deserialization</li> <li> <p>Facilitate validation and transformation</p> </li> <li> <p>Code Organization:</p> </li> <li>Improve code readability</li> <li>Reduce complexity</li> <li>Enable better testing</li> </ol> <p>The JSON API handler example demonstrates how structs form the backbone of real-world Go applications, providing structure to data, enabling serialization, and facilitating clean API design. Mastering structs is essential for building robust, maintainable Go applications.</p> <p>By understanding and effectively using structs, you can: - Create more organized and maintainable code - Build type-safe applications with clear data contracts - Implement complex business logic in a structured way - Integrate seamlessly with external systems and APIs - Leverage Go's powerful type system to its fullest</p> <p>Structs, combined with interfaces and methods, provide Go's approach to object-oriented programming, emphasizing composition over inheritance and simplicity over complexity.</p>"},{"location":"2.%20Intermediate/8.%20Methods/","title":"Go Methods: Behavior for Custom Types","text":"<p>Overview</p> <p>Master Go methods - functions with receiver arguments that define behavior for custom types. Learn value vs pointer receivers, method sets, and patterns for building expressive, object-oriented Go code.</p> <p>Key Points</p> <ul> <li>Methods are functions with receiver arguments</li> <li>Choose value or pointer receivers based on needs</li> <li>Method sets determine interface satisfaction</li> <li>Can be defined on any custom type</li> <li>Enable object-oriented programming patterns</li> </ul>"},{"location":"2.%20Intermediate/8.%20Methods/#understanding-methods","title":"Understanding Methods","text":"<p>Methods in Go are functions with a special receiver argument that defines behavior for custom types.</p>"},{"location":"2.%20Intermediate/8.%20Methods/#method-basics","title":"Method Basics","text":""},{"location":"2.%20Intermediate/8.%20Methods/#defining-methods","title":"Defining Methods","text":"<p>A method is defined with a receiver parameter between the <code>func</code> keyword and the method name:</p> <pre><code>type Rectangle struct {\n    Width, Height float64\n}\n\n// Method with value receiver\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\n// Method with pointer receiver\nfunc (r *Rectangle) Scale(factor float64) {\n    r.Width *= factor\n    r.Height *= factor\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#value-receivers-vs-pointer-receivers","title":"Value Receivers vs. Pointer Receivers","text":""},{"location":"2.%20Intermediate/8.%20Methods/#value-receivers","title":"Value Receivers","text":"<ul> <li>Operate on a copy of the receiver</li> <li>Cannot modify the original value</li> <li>Used when:</li> <li>The method doesn't need to modify the receiver</li> <li>The receiver is small (to avoid copying overhead)</li> <li>Consistency is needed (if some methods use value receivers)</li> </ul> <pre><code>func (r Rectangle) Perimeter() float64 {\n    return 2 * (r.Width + r.Height)\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#pointer-receivers","title":"Pointer Receivers","text":"<ul> <li>Operate on the original value</li> <li>Can modify the receiver</li> <li>Used when:</li> <li>The method needs to modify the receiver</li> <li>The receiver is large (to avoid copying)</li> <li>The receiver contains fields that shouldn't be copied (like sync.Mutex)</li> </ul> <pre><code>func (r *Rectangle) SetDimensions(width, height float64) {\n    r.Width = width\n    r.Height = height\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#method-invocation","title":"Method Invocation","text":"<p>Go automatically handles the conversion between values and pointers when calling methods:</p> <pre><code>func main() {\n    rect := Rectangle{Width: 10, Height: 5}\n\n    // Value receiver method\n    fmt.Println(\"Area:\", rect.Area()) // 50\n\n    // Pointer receiver method (Go automatically takes address)\n    rect.Scale(2)\n    fmt.Printf(\"Scaled: %+v\\n\", rect) // {Width:20 Height:10}\n\n    // Calling with pointer\n    pRect := &amp;Rectangle{Width: 5, Height: 3}\n    fmt.Println(\"Area:\", pRect.Area()) // 15 (Go automatically dereferences)\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#method-sets-and-interface-satisfaction","title":"Method Sets and Interface Satisfaction","text":""},{"location":"2.%20Intermediate/8.%20Methods/#method-sets","title":"Method Sets","text":"<p>The method set of a type determines which interfaces it can implement: - For a type <code>T</code>, its method set includes all methods with receiver <code>T</code> - For a type <code>*T</code>, its method set includes all methods with receiver <code>*T</code> or <code>T</code></p> <pre><code>type Shaper interface {\n    Area() float64\n    Perimeter() float64\n}\n\n// Rectangle implements Shaper with value receiver methods\nfunc (r Rectangle) Area() float64 { /* ... */ }\nfunc (r Rectangle) Perimeter() float64 { /* ... */ }\n\nfunc main() {\n    var s Shaper\n    s = Rectangle{Width: 10, Height: 5} // OK: Rectangle has required methods\n    s = &amp;Rectangle{Width: 10, Height: 5} // Also OK: *Rectangle has all methods of Rectangle\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#interface-satisfaction-rules","title":"Interface Satisfaction Rules","text":"<ul> <li>A type <code>T</code> satisfies an interface if its method set includes all methods of the interface</li> <li>A type <code>*T</code> satisfies an interface if its method set includes all methods of the interface</li> <li>If an interface has methods with pointer receivers, only <code>*T</code> (not <code>T</code>) can satisfy it</li> </ul> <pre><code>type Scaler interface {\n    Scale(float64)\n}\n\n// Only *Rectangle satisfies Scaler because Scale has a pointer receiver\nfunc main() {\n    var s Scaler\n    s = &amp;Rectangle{Width: 10, Height: 5} // OK\n    // s = Rectangle{Width: 10, Height: 5} // Compile error: Rectangle does not implement Scaler\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#method-expressions-and-values","title":"Method Expressions and Values","text":""},{"location":"2.%20Intermediate/8.%20Methods/#method-expressions","title":"Method Expressions","text":"<p>Method expressions allow you to treat methods as functions, with the receiver as the first parameter:</p> <pre><code>type Calculator struct{}\n\nfunc (c Calculator) Add(a, b int) int {\n    return a + b\n}\n\nfunc main() {\n    // Method expression\n    addFunc := Calculator.Add\n    result := addFunc(Calculator{}, 2, 3) // Pass receiver as first argument\n    fmt.Println(result) // 5\n\n    // With pointer receiver\n    calc := &amp;Calculator{}\n    addFunc2 := (*Calculator).Add\n    result2 := addFunc2(calc, 5, 7)\n    fmt.Println(result2) // 12\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#method-values","title":"Method Values","text":"<p>Method values are like closures that capture the receiver:</p> <pre><code>func main() {\n    rect := Rectangle{Width: 10, Height: 5}\n\n    // Method value\n    areaFunc := rect.Area\n    fmt.Println(areaFunc()) // 50\n\n    // Works with pointers too\n    pRect := &amp;Rectangle{Width: 5, Height: 3}\n    scaleFunc := pRect.Scale\n    scaleFunc(2)\n    fmt.Printf(\"%+v\\n\", pRect) // {Width:10 Height:6}\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#embedded-types-and-method-promotion","title":"Embedded Types and Method Promotion","text":"<p>When a struct embeds another type, methods of the embedded type are promoted to the containing struct:</p> <pre><code>type Point struct {\n    X, Y int\n}\n\nfunc (p Point) Distance() float64 {\n    return math.Sqrt(float64(p.X*p.X + p.Y*p.Y))\n}\n\ntype Circle struct {\n    Point  // Embedded type\n    Radius int\n}\n\nfunc main() {\n    c := Circle{\n        Point:  Point{X: 3, Y: 4},\n        Radius: 5,\n    }\n\n    // Promoted method\n    fmt.Println(\"Distance from origin:\", c.Distance()) // 5\n\n    // Still accessible via embedded type\n    fmt.Println(\"Distance via Point:\", c.Point.Distance()) // 5\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#method-overriding","title":"Method Overriding","text":"<p>A containing type can override methods of an embedded type:</p> <pre><code>func (c Circle) Distance() float64 {\n    centerDist := c.Point.Distance()\n    return math.Abs(float64(c.Radius) - centerDist)\n}\n\nfunc main() {\n    c := Circle{\n        Point:  Point{X: 3, Y: 4},\n        Radius: 5,\n    }\n\n    fmt.Println(\"Circle distance:\", c.Distance()) // 0 (5 - 5)\n    fmt.Println(\"Point distance:\", c.Point.Distance()) // 5\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#best-practices-and-common-patterns","title":"Best Practices and Common Patterns","text":""},{"location":"2.%20Intermediate/8.%20Methods/#1-choosing-between-value-and-pointer-receivers","title":"1. Choosing Between Value and Pointer Receivers","text":"<pre><code>// Use pointer receiver when:\nfunc (u *User) Save() {\n    // Modifies user (e.g., updates database)\n}\n\n// Use value receiver when:\nfunc (u User) Validate() bool {\n    // Only reads user data\n    return u.Email != \"\" &amp;&amp; u.Name != \"\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#2-method-chaining","title":"2. Method Chaining","text":"<p>Return the receiver to enable method chaining:</p> <pre><code>func (b *Builder) SetName(name string) *Builder {\n    b.name = name\n    return b\n}\n\nfunc (b *Builder) SetAge(age int) *Builder {\n    b.age = age\n    return b\n}\n\nfunc main() {\n    builder := &amp;Builder{}\n    user := builder.SetName(\"Alice\").SetAge(30).Build()\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#3-fluent-interfaces","title":"3. Fluent Interfaces","text":"<p>Design methods that work well together:</p> <pre><code>type Query struct {\n    table string\n    where []string\n}\n\nfunc (q *Query) From(table string) *Query {\n    q.table = table\n    return q\n}\n\nfunc (q *Query) Where(condition string) *Query {\n    q.where = append(q.where, condition)\n    return q\n}\n\nfunc (q *Query) String() string {\n    return fmt.Sprintf(\"SELECT * FROM %s WHERE %s\", q.table, strings.Join(q.where, \" AND \"))\n}\n\nfunc main() {\n    query := &amp;Query{}\n    sql := query.From(\"users\").Where(\"age &gt; 18\").Where(\"active = true\").String()\n    fmt.Println(sql)\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#4-interface-segregation","title":"4. Interface Segregation","text":"<p>Define small, focused interfaces that methods can implement:</p> <pre><code>type Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#real-world-example-crud-service-with-methods","title":"Real-World Example: CRUD Service with Methods","text":"<p>Let's build a complete CRUD (Create, Read, Update, Delete) service for a User entity, demonstrating various method patterns:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n)\n\n// User represents a user in our system\ntype User struct {\n    ID        int       `json:\"id\"`\n    Name      string    `json:\"name\" validate:\"required\"`\n    Email     string    `json:\"email\" validate:\"required,email\"`\n    Age       int       `json:\"age\" validate:\"gte=18\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n\n// UserRepository handles data operations\ntype UserRepository struct {\n    users map[int]*User\n    mu    sync.RWMutex\n    nextID int\n}\n\nfunc NewUserRepository() *UserRepository {\n    return &amp;UserRepository{\n        users:  make(map[int]*User),\n        nextID: 1,\n    }\n}\n\n// Create adds a new user to the repository\nfunc (r *UserRepository) Create(user *User) error {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n\n    // Check for duplicate email\n    for _, u := range r.users {\n        if u.Email == user.Email {\n            return errors.New(\"email already exists\")\n        }\n    }\n\n    user.ID = r.nextID\n    user.CreatedAt = time.Now()\n    user.UpdatedAt = time.Now()\n    r.users[user.ID] = user\n    r.nextID++\n\n    return nil\n}\n\n// Get retrieves a user by ID\nfunc (r *UserRepository) Get(id int) (*User, error) {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n\n    user, exists := r.users[id]\n    if !exists {\n        return nil, errors.New(\"user not found\")\n    }\n\n    // Return a copy to avoid external modifications\n    copy := *user\n    return &amp;copy, nil\n}\n\n// Update modifies an existing user\nfunc (r *UserRepository) Update(user *User) error {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n\n    existing, exists := r.users[user.ID]\n    if !exists {\n        return errors.New(\"user not found\")\n    }\n\n    // Check for duplicate email (excluding current user)\n    for id, u := range r.users {\n        if id != user.ID &amp;&amp; u.Email == user.Email {\n            return errors.New(\"email already exists\")\n        }\n    }\n\n    existing.Name = user.Name\n    existing.Email = user.Email\n    existing.Age = user.Age\n    existing.UpdatedAt = time.Now()\n\n    return nil\n}\n\n// Delete removes a user by ID\nfunc (r *UserRepository) Delete(id int) error {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n\n    if _, exists := r.users[id]; !exists {\n        return errors.New(\"user not found\")\n    }\n\n    delete(r.users, id)\n    return nil\n}\n\n// List returns all users\nfunc (r *UserRepository) List() []*User {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n\n    users := make([]*User, 0, len(r.users))\n    for _, user := range r.users {\n        // Return copies to avoid external modifications\n        copy := *user\n        users = append(users, &amp;copy)\n    }\n\n    return users\n}\n\n// UserService provides business logic on top of the repository\ntype UserService struct {\n    repo *UserRepository\n}\n\nfunc NewUserService(repo *UserRepository) *UserService {\n    return &amp;UserService{repo: repo}\n}\n\n// CreateUser handles user creation with business rules\nfunc (s *UserService) CreateUser(name, email string, age int) (*User, error) {\n    if age &lt; 18 {\n        return nil, errors.New(\"user must be at least 18 years old\")\n    }\n\n    user := &amp;User{\n        Name:  name,\n        Email: email,\n        Age:   age,\n    }\n\n    if err := s.repo.Create(user); err != nil {\n        return nil, fmt.Errorf(\"failed to create user: %w\", err)\n    }\n\n    return user, nil\n}\n\n// GetUserProfile returns extended user information\nfunc (s *UserService) GetUserProfile(id int) (map[string]interface{}, error) {\n    user, err := s.repo.Get(id)\n    if err != nil {\n        return nil, err\n    }\n\n    profile := map[string]interface{}{\n        \"id\":         user.ID,\n        \"name\":       user.Name,\n        \"email\":      user.Email,\n        \"age\":        user.Age,\n        \"member_for\": time.Since(user.CreatedAt).String(),\n        \"is_adult\":   user.Age &gt;= 18,\n    }\n\n    return profile, nil\n}\n\n// UpdateUserEmail handles email updates with validation\nfunc (s *UserService) UpdateUserEmail(id int, newEmail string) error {\n    user, err := s.repo.Get(id)\n    if err != nil {\n        return err\n    }\n\n    // Additional business logic\n    if user.Email == newEmail {\n        return errors.New(\"new email is the same as current email\")\n    }\n\n    user.Email = newEmail\n    return s.repo.Update(user)\n}\n\n// HTTP Handlers\ntype UserHandler struct {\n    service *UserService\n}\n\nfunc NewUserHandler(service *UserService) *UserHandler {\n    return &amp;UserHandler{service: service}\n}\n\nfunc (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {\n    var req struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n        Age   int    `json:\"age\"`\n    }\n\n    if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n        http.Error(w, \"Invalid request\", http.StatusBadRequest)\n        return\n    }\n\n    user, err := h.service.CreateUser(req.Name, req.Email, req.Age)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(user)\n}\n\nfunc (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {\n    // In a real app, get ID from URL params\n    id := 1\n\n    profile, err := h.service.GetUserProfile(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusNotFound)\n        return\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(profile)\n}\n\nfunc main() {\n    // Setup dependencies\n    repo := NewUserRepository()\n    service := NewUserService(repo)\n    handler := NewUserHandler(service)\n\n    // Add sample data\n    repo.Create(&amp;User{Name: \"Alice\", Email: \"alice@example.com\", Age: 30})\n    repo.Create(&amp;User{Name: \"Bob\", Email: \"bob@example.com\", Age: 25})\n\n    // Setup routes\n    http.HandleFunc(\"/users\", handler.CreateUser)\n    http.HandleFunc(\"/user\", handler.GetUser)\n\n    fmt.Println(\"Server starting on port 8080...\")\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#how-this-example-demonstrates-method-concepts","title":"How This Example Demonstrates Method Concepts:","text":"<ol> <li>Repository Pattern:</li> <li><code>UserRepository</code> methods encapsulate data access</li> <li>Pointer receivers for modifying data</li> <li>Value receivers for read operations</li> <li> <p>Thread-safe operations with mutex</p> </li> <li> <p>Service Layer:</p> </li> <li><code>UserService</code> methods implement business logic</li> <li>Composition with repository</li> <li> <p>Error handling and validation</p> </li> <li> <p>HTTP Handlers:</p> </li> <li>Methods handle HTTP requests</li> <li>Dependency injection</li> <li> <p>Separation of concerns</p> </li> <li> <p>Method Types:</p> </li> <li>Value receivers for read-only operations</li> <li>Pointer receivers for modifications</li> <li>Method chaining potential</li> <li>Interface implementation readiness</li> </ol>"},{"location":"2.%20Intermediate/8.%20Methods/#real-world-applications-of-this-pattern","title":"Real-World Applications of This Pattern:","text":"<ol> <li>Web Applications:</li> <li>RESTful API services</li> <li>Microservices architecture</li> <li> <p>Domain-driven design</p> </li> <li> <p>Data Access Layers:</p> </li> <li>Database repositories</li> <li>Cache management</li> <li> <p>External API clients</p> </li> <li> <p>Business Logic:</p> </li> <li>Domain services</li> <li>Application services</li> <li> <p>Workflow orchestration</p> </li> <li> <p>Testing Infrastructure:</p> </li> <li>Mock implementations</li> <li>Test fixtures</li> <li>Benchmark helpers</li> </ol>"},{"location":"2.%20Intermediate/8.%20Methods/#benefits-of-this-approach","title":"Benefits of This Approach:","text":"<ol> <li>Encapsulation:</li> <li>Data and behavior are bundled together</li> <li>Clear boundaries between layers</li> <li> <p>Controlled access to data</p> </li> <li> <p>Testability:</p> </li> <li>Easy to mock dependencies</li> <li>Isolated unit testing</li> <li> <p>Clear contracts between components</p> </li> <li> <p>Maintainability:</p> </li> <li>Single responsibility principle</li> <li>Clear separation of concerns</li> <li> <p>Easy to extend and modify</p> </li> <li> <p>Concurrency Safety:</p> </li> <li>Thread-safe operations</li> <li>Proper locking mechanisms</li> <li>Immutable data where possible</li> </ol>"},{"location":"2.%20Intermediate/8.%20Methods/#advanced-method-techniques","title":"Advanced Method Techniques","text":""},{"location":"2.%20Intermediate/8.%20Methods/#1-method-values-as-closures","title":"1. Method Values as Closures","text":"<pre><code>func (u *User) GetValidator() func(string) bool {\n    return func(field string) bool {\n        switch field {\n        case \"name\":\n            return u.Name != \"\"\n        case \"email\":\n            return u.Email != \"\"\n        default:\n            return false\n        }\n    }\n}\n\nfunc main() {\n    user := &amp;User{Name: \"Alice\", Email: \"alice@example.com\"}\n    validate := user.GetValidator()\n    fmt.Println(\"Name valid:\", validate(\"name\")) // true\n    fmt.Println(\"Email valid:\", validate(\"email\")) // true\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#2-method-sets-for-polymorphism","title":"2. Method Sets for Polymorphism","text":"<pre><code>type Animal interface {\n    Speak() string\n    Move() string\n}\n\ntype Dog struct{}\n\nfunc (d Dog) Speak() string { return \"Woof!\" }\nfunc (d Dog) Move() string  { return \"Runs\" }\n\ntype Bird struct{}\n\nfunc (b Bird) Speak() string { return \"Chirp!\" }\nfunc (b Bird) Move() string  { return \"Flies\" }\n\nfunc PerformActions(a Animal) {\n    fmt.Println(a.Speak())\n    fmt.Println(a.Move())\n}\n\nfunc main() {\n    PerformActions(Dog{})\n    PerformActions(Bird{})\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#3-embedded-interfaces","title":"3. Embedded Interfaces","text":"<pre><code>type Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\ntype Buffer struct {\n    data []byte\n}\n\nfunc (b *Buffer) Read(p []byte) (int, error) {\n    // Implementation\n    return 0, nil\n}\n\nfunc (b *Buffer) Write(p []byte) (int, error) {\n    // Implementation\n    return 0, nil\n}\n\nfunc main() {\n    var rw ReadWriter = &amp;Buffer{}\n    // Can use both Read and Write methods\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#conclusion","title":"Conclusion","text":"<p>Methods are a fundamental feature in Go that enable:</p> <ol> <li>Behavior Association:</li> <li>Attach functions to types</li> <li>Implement object-oriented patterns</li> <li> <p>Create expressive APIs</p> </li> <li> <p>Interface Implementation:</p> </li> <li>Satisfy interface contracts</li> <li>Enable polymorphism</li> <li> <p>Support dependency injection</p> </li> <li> <p>Code Organization:</p> </li> <li>Group related functionality</li> <li>Implement design patterns</li> <li> <p>Create reusable components</p> </li> <li> <p>Encapsulation:</p> </li> <li>Control access to data</li> <li>Implement business rules</li> <li>Maintain invariants</li> </ol> <p>The CRUD service example demonstrates how methods form the backbone of well-structured Go applications, providing clear separation of concerns, testability, and maintainability. Mastering methods is essential for building robust, idiomatic Go software.</p> <p>By understanding and effectively using methods, you can: - Create more organized and maintainable code - Implement complex business logic in a structured way - Build flexible and extensible systems - Leverage Go's type system effectively - Write code that's both efficient and expressive</p> <p>Methods, combined with interfaces and structs, provide Go's unique approach to object-oriented programming, emphasizing composition, simplicity, and clarity over inheritance and complexity.</p>"},{"location":"2.%20Intermediate/9.%20Interfaces/","title":"Go Interfaces: Contracts and Polymorphism","text":"<p>Overview</p> <p>Master Go interfaces - contracts that define method signatures without implementation. Learn implicit satisfaction, interface composition, type assertions, and patterns for building flexible, testable code.</p> <p>Key Points</p> <ul> <li>Interfaces define method contracts, not implementations</li> <li>Implicit satisfaction - no explicit \"implements\" keyword</li> <li>Enable polymorphism and dependency injection</li> <li>Empty interface <code>interface{}</code> accepts any type</li> <li>Type assertions provide runtime type checking</li> </ul>"},{"location":"2.%20Intermediate/9.%20Interfaces/#understanding-interfaces","title":"Understanding Interfaces","text":"<p>Interfaces in Go define contracts that specify what methods a type must have, enabling polymorphism and flexible code design.</p>"},{"location":"2.%20Intermediate/9.%20Interfaces/#defining-interfaces","title":"Defining Interfaces","text":""},{"location":"2.%20Intermediate/9.%20Interfaces/#basic-interface-definition","title":"Basic Interface Definition","text":"<pre><code>type Writer interface {\n    Write([]byte) (int, error)\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#interface-with-multiple-methods","title":"Interface with Multiple Methods","text":"<pre><code>type ReadWriter interface {\n    Read([]byte) (int, error)\n    Write([]byte) (int, error)\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#empty-interface","title":"Empty Interface","text":"<p>The empty interface <code>interface{}</code> is satisfied by all types since it has no methods: <pre><code>var anything interface{}\nanything = 42\nanything = \"hello\"\nanything = struct{ Name string }{Name: \"Alice\"}\n</code></pre></p>"},{"location":"2.%20Intermediate/9.%20Interfaces/#implicit-interface-implementation","title":"Implicit Interface Implementation","text":"<p>Go's interfaces are satisfied implicitly - no explicit declaration is needed:</p> <pre><code>type File struct {\n    name string\n}\n\nfunc (f *File) Write(data []byte) (int, error) {\n    // Implementation\n    return len(data), nil\n}\n\n// File automatically implements Writer interface\nfunc useWriter(w Writer) {\n    w.Write([]byte(\"hello\"))\n}\n\nfunc main() {\n    file := &amp;File{name: \"test.txt\"}\n    useWriter(file) // Works because File implements Writer\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#interface-values-and-types","title":"Interface Values and Types","text":""},{"location":"2.%20Intermediate/9.%20Interfaces/#interface-value-structure","title":"Interface Value Structure","text":"<p>An interface value consists of: - A concrete type (the type that implements the interface) - A concrete value (the value of that type)</p> <pre><code>var w Writer\nfmt.Printf(\"(%v, %T)\\n\", w, w) // (&lt;nil&gt;, &lt;nil&gt;)\n\nfile := &amp;File{name: \"test.txt\"}\nw = file\nfmt.Printf(\"(%v, %T)\\n\", w, w) // (&amp;{test.txt}, *main.File)\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#nil-interface-values","title":"Nil Interface Values","text":"<p>An interface value is nil only if both its type and value are nil:</p> <pre><code>var w Writer\nfmt.Println(w == nil) // true\n\nvar file *File\nw = file\nfmt.Println(w == nil) // false (type is *File, value is nil)\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#type-assertions-and-type-switches","title":"Type Assertions and Type Switches","text":""},{"location":"2.%20Intermediate/9.%20Interfaces/#type-assertion","title":"Type Assertion","text":"<p>Extract the concrete value from an interface:</p> <pre><code>func process(i interface{}) {\n    if s, ok := i.(string); ok {\n        fmt.Println(\"String value:\", s)\n    } else {\n        fmt.Println(\"Not a string\")\n    }\n}\n\nfunc main() {\n    process(\"hello\")  // String value: hello\n    process(42)       // Not a string\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#type-switch","title":"Type Switch","text":"<p>Check against multiple types:</p> <pre><code>func describe(i interface{}) {\n    switch v := i.(type) {\n    case string:\n        fmt.Printf(\"String: %q\\n\", v)\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", v)\n    case bool:\n        fmt.Printf(\"Boolean: %t\\n\", v)\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n\nfunc main() {\n    describe(\"hello\")  // String: \"hello\"\n    describe(42)       // Integer: 42\n    describe(true)     // Boolean: true\n    describe(3.14)     // Unknown type: float64\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#common-standard-library-interfaces","title":"Common Standard Library Interfaces","text":""},{"location":"2.%20Intermediate/9.%20Interfaces/#1-ioreader-and-iowriter","title":"1. <code>io.Reader</code> and <code>io.Writer</code>","text":"<pre><code>type Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#2-fmtstringer","title":"2. <code>fmt.Stringer</code>","text":"<pre><code>type Stringer interface {\n    String() string\n}\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc (p Person) String() string {\n    return fmt.Sprintf(\"%s (%d years)\", p.Name, p.Age)\n}\n\nfunc main() {\n    p := Person{\"Alice\", 30}\n    fmt.Println(p) // Automatically calls String()\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#3-error-interface","title":"3. <code>error</code> Interface","text":"<pre><code>type error interface {\n    Error() string\n}\n\ntype MyError struct {\n    Message string\n}\n\nfunc (e MyError) Error() string {\n    return e.Message\n}\n\nfunc main() {\n    err := MyError{\"something went wrong\"}\n    fmt.Println(err) // something went wrong\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#4-sortinterface","title":"4. <code>sort.Interface</code>","text":"<pre><code>type Interface interface {\n    Len() int\n    Less(i, j int) bool\n    Swap(i, j int)\n}\n\ntype ByLength []string\n\nfunc (s ByLength) Len() int           { return len(s) }\nfunc (s ByLength) Less(i, j int) bool { return len(s[i]) &lt; len(s[j]) }\nfunc (s ByLength) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\nfunc main() {\n    fruits := []string{\"apple\", \"banana\", \"cherry\"}\n    sort.Sort(ByLength(fruits))\n    fmt.Println(fruits) // [apple cherry banana]\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#interface-composition","title":"Interface Composition","text":"<p>Interfaces can be composed of other interfaces:</p> <pre><code>type Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\ntype ReadCloser interface {\n    Reader\n    Closer\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#best-practices-for-interfaces","title":"Best Practices for Interfaces","text":""},{"location":"2.%20Intermediate/9.%20Interfaces/#1-keep-interfaces-small","title":"1. Keep Interfaces Small","text":"<p>Follow the interface segregation principle:</p> <pre><code>// Good: Small, focused interface\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\n// Bad: Large, bloated interface\ntype FileSystemObject interface {\n    Read([]byte) (int, error)\n    Write([]byte) (int, error)\n    Seek(offset int64, whence int) (int64, error)\n    Close() error\n    Readdir(count int) ([]os.FileInfo, error)\n    // ... many more methods\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#2-accept-interfaces-return-structs","title":"2. Accept Interfaces, Return Structs","text":"<pre><code>// Good: Accept interface, return concrete type\nfunc ProcessData(r io.Reader) ([]byte, error) {\n    // Process data\n    return result, nil\n}\n\n// Bad: Return interface\nfunc GetData() io.Reader {\n    return bytes.NewReader(data)\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#3-design-for-behavior-not-implementation","title":"3. Design for Behavior, Not Implementation","text":"<p>Focus on what the interface does, not how it's implemented:</p> <pre><code>// Good: Behavior-focused\ntype Storer interface {\n    Store(key string, value interface{}) error\n    Retrieve(key string) (interface{}, error)\n}\n\n// Bad: Implementation-focused\ntype SQLStorer interface {\n    Exec(query string, args ...interface{}) (sql.Result, error)\n    Query(query string, args ...interface{}) (*sql.Rows, error)\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#real-world-example-pluggable-storage-system","title":"Real-World Example: Pluggable Storage System","text":"<p>Let's build a storage system that supports multiple backends (in-memory, file-based, and database) using interfaces:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"errors\"\n    \"fmt\"\n    \"os\"\n    \"sync\"\n)\n\n// Storage defines the interface for our storage backends\ntype Storage interface {\n    Store(key string, value interface{}) error\n    Retrieve(key string) (interface{}, error)\n    Delete(key string) error\n    List() ([]string, error)\n    Close() error\n}\n\n// InMemoryStorage implements Storage using a map\ntype InMemoryStorage struct {\n    data map[string]interface{}\n    mu   sync.RWMutex\n}\n\nfunc NewInMemoryStorage() *InMemoryStorage {\n    return &amp;InMemoryStorage{\n        data: make(map[string]interface{}),\n    }\n}\n\nfunc (s *InMemoryStorage) Store(key string, value interface{}) error {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.data[key] = value\n    return nil\n}\n\nfunc (s *InMemoryStorage) Retrieve(key string) (interface{}, error) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    value, exists := s.data[key]\n    if !exists {\n        return nil, errors.New(\"key not found\")\n    }\n    return value, nil\n}\n\nfunc (s *InMemoryStorage) Delete(key string) error {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    if _, exists := s.data[key]; !exists {\n        return errors.New(\"key not found\")\n    }\n    delete(s.data, key)\n    return nil\n}\n\nfunc (s *InMemoryStorage) List() ([]string, error) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    keys := make([]string, 0, len(s.data))\n    for k := range s.data {\n        keys = append(keys, k)\n    }\n    return keys, nil\n}\n\nfunc (s *InMemoryStorage) Close() error {\n    // Nothing to do for in-memory storage\n    return nil\n}\n\n// FileStorage implements Storage using the filesystem\ntype FileStorage struct {\n    baseDir string\n}\n\nfunc NewFileStorage(baseDir string) (*FileStorage, error) {\n    if err := os.MkdirAll(baseDir, 0755); err != nil {\n        return nil, err\n    }\n    return &amp;FileStorage{baseDir: baseDir}, nil\n}\n\nfunc (s *FileStorage) filePath(key string) string {\n    return fmt.Sprintf(\"%s/%s.json\", s.baseDir, key)\n}\n\nfunc (s *FileStorage) Store(key string, value interface{}) error {\n    data, err := json.Marshal(value)\n    if err != nil {\n        return err\n    }\n    return os.WriteFile(s.filePath(key), data, 0644)\n}\n\nfunc (s *FileStorage) Retrieve(key string) (interface{}, error) {\n    data, err := os.ReadFile(s.filePath(key))\n    if os.IsNotExist(err) {\n        return nil, errors.New(\"key not found\")\n    }\n    if err != nil {\n        return nil, err\n    }\n\n    var value interface{}\n    if err := json.Unmarshal(data, &amp;value); err != nil {\n        return nil, err\n    }\n    return value, nil\n}\n\nfunc (s *FileStorage) Delete(key string) error {\n    err := os.Remove(s.filePath(key))\n    if os.IsNotExist(err) {\n        return errors.New(\"key not found\")\n    }\n    return err\n}\n\nfunc (s *FileStorage) List() ([]string, error) {\n    entries, err := os.ReadDir(s.baseDir)\n    if err != nil {\n        return nil, err\n    }\n\n    keys := make([]string, 0, len(entries))\n    for _, entry := range entries {\n        if !entry.IsDir() {\n            // Remove .json extension\n            name := entry.Name()\n            if len(name) &gt; 5 &amp;&amp; name[len(name)-5:] == \".json\" {\n                keys = append(keys, name[:len(name)-5])\n            }\n        }\n    }\n    return keys, nil\n}\n\nfunc (s *FileStorage) Close() error {\n    // Nothing to do for file storage\n    return nil\n}\n\n// StorageService provides additional functionality on top of Storage\ntype StorageService struct {\n    storage Storage\n}\n\nfunc NewStorageService(storage Storage) *StorageService {\n    return &amp;StorageService{storage: storage}\n}\n\nfunc (s *StorageService) StoreUser(id string, user map[string]interface{}) error {\n    return s.storage.Store(id, user)\n}\n\nfunc (s *StorageService) GetUser(id string) (map[string]interface{}, error) {\n    value, err := s.storage.Retrieve(id)\n    if err != nil {\n        return nil, err\n    }\n\n    user, ok := value.(map[string]interface{})\n    if !ok {\n        return nil, errors.New(\"invalid user data format\")\n    }\n    return user, nil\n}\n\nfunc (s *StorageService) DeleteUser(id string) error {\n    return s.storage.Delete(id)\n}\n\nfunc (s *StorageService) ListUsers() ([]string, error) {\n    return s.storage.List()\n}\n\nfunc (s *StorageService) Close() error {\n    return s.storage.Close()\n}\n\n// Usage example\nfunc main() {\n    // Choose storage backend\n    var storage Storage\n\n    // Option 1: In-memory storage\n    storage = NewInMemoryStorage()\n\n    // Option 2: File storage (uncomment to use)\n    // fileStorage, err := NewFileStorage(\"./data\")\n    // if err != nil {\n    //     panic(err)\n    // }\n    // storage = fileStorage\n\n    // Create service\n    service := NewStorageService(storage)\n    defer service.Close()\n\n    // Store some users\n    users := []map[string]interface{}{\n        {\"name\": \"Alice\", \"age\": 30, \"email\": \"alice@example.com\"},\n        {\"name\": \"Bob\", \"age\": 25, \"email\": \"bob@example.com\"},\n        {\"name\": \"Charlie\", \"age\": 35, \"email\": \"charlie@example.com\"},\n    }\n\n    for i, user := range users {\n        id := fmt.Sprintf(\"user%d\", i+1)\n        if err := service.StoreUser(id, user); err != nil {\n            fmt.Printf(\"Error storing user %s: %v\\n\", id, err)\n        }\n    }\n\n    // List all users\n    fmt.Println(\"\\nStored users:\")\n    ids, err := service.ListUsers()\n    if err != nil {\n        fmt.Printf(\"Error listing users: %v\\n\", err)\n        return\n    }\n\n    for _, id := range ids {\n        user, err := service.GetUser(id)\n        if err != nil {\n            fmt.Printf(\"Error retrieving user %s: %v\\n\", id, err)\n            continue\n        }\n        fmt.Printf(\"%s: %+v\\n\", id, user)\n    }\n\n    // Delete a user\n    if len(ids) &gt; 0 {\n        if err := service.DeleteUser(ids[0]); err != nil {\n            fmt.Printf(\"Error deleting user: %v\\n\", err)\n        } else {\n            fmt.Printf(\"\\nDeleted user: %s\\n\", ids[0])\n        }\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#how-this-example-demonstrates-interface-concepts","title":"How This Example Demonstrates Interface Concepts:","text":"<ol> <li>Interface Definition:</li> <li><code>Storage</code> interface defines the contract for all storage backends</li> <li> <p>Clear separation between interface and implementation</p> </li> <li> <p>Multiple Implementations:</p> </li> <li><code>InMemoryStorage</code> uses a map for storage</li> <li><code>FileStorage</code> uses the filesystem</li> <li> <p>Both implement the same interface</p> </li> <li> <p>Service Layer:</p> </li> <li><code>StorageService</code> adds business logic on top of storage</li> <li> <p>Works with any Storage implementation</p> </li> <li> <p>Polymorphism:</p> </li> <li>Can switch between storage backends without changing service code</li> <li>Code works with any type that satisfies the Storage interface</li> </ol>"},{"location":"2.%20Intermediate/9.%20Interfaces/#real-world-applications-of-this-pattern","title":"Real-World Applications of This Pattern:","text":"<ol> <li>Database Abstraction:</li> <li>Support multiple databases (SQL, NoSQL, in-memory)</li> <li> <p>Easy to switch or add new database backends</p> </li> <li> <p>Logging Systems:</p> </li> <li>Support multiple log outputs (console, file, remote)</li> <li> <p>Pluggable log formatters</p> </li> <li> <p>Message Queues:</p> </li> <li>Support different message brokers (RabbitMQ, Kafka, AWS SQS)</li> <li> <p>Consistent API regardless of backend</p> </li> <li> <p>Caching Layers:</p> </li> <li>Support multiple cache providers (Redis, Memcached, in-memory)</li> <li>Easy to switch caching strategies</li> </ol>"},{"location":"2.%20Intermediate/9.%20Interfaces/#benefits-of-this-approach","title":"Benefits of This Approach:","text":"<ol> <li>Decoupling:</li> <li>Business logic doesn't depend on concrete implementations</li> <li> <p>Easy to replace or add new implementations</p> </li> <li> <p>Testability:</p> </li> <li>Easy to mock dependencies for testing</li> <li> <p>Can test business logic with fake storage</p> </li> <li> <p>Flexibility:</p> </li> <li>Can choose implementation based on environment</li> <li> <p>Easy to extend with new features</p> </li> <li> <p>Maintainability:</p> </li> <li>Clear contracts between components</li> <li>Changes to implementation don't affect consumers</li> </ol>"},{"location":"2.%20Intermediate/9.%20Interfaces/#advanced-interface-patterns","title":"Advanced Interface Patterns","text":""},{"location":"2.%20Intermediate/9.%20Interfaces/#1-interface-embedding","title":"1. Interface Embedding","text":"<pre><code>type Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\ntype ReadCloser interface {\n    Reader\n    Closer\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#2-interface-with-type-parameters-go-118","title":"2. Interface with Type Parameters (Go 1.18+)","text":"<pre><code>type Container[T any] interface {\n    Put(T)\n    Get() T\n}\n\ntype StringContainer struct {\n    items []string\n}\n\nfunc (s *StringContainer) Put(item string) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *StringContainer) Get() string {\n    if len(s.items) == 0 {\n        return \"\"\n    }\n    item := s.items[0]\n    s.items = s.items[1:]\n    return item\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#3-interface-for-dependency-injection","title":"3. Interface for Dependency Injection","text":"<pre><code>type Database interface {\n    Query(query string, args ...interface{}) (*sql.Rows, error)\n    Exec(query string, args ...interface{}) (sql.Result, error)\n}\n\ntype Service struct {\n    db Database\n}\n\nfunc NewService(db Database) *Service {\n    return &amp;Service{db: db}\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#conclusion","title":"Conclusion","text":"<p>Interfaces are a cornerstone of Go's design philosophy, enabling:</p> <ol> <li>Polymorphism:</li> <li>Treat different types uniformly</li> <li>Write flexible, reusable code</li> <li> <p>Implement design patterns effectively</p> </li> <li> <p>Decoupling:</p> </li> <li>Separate contracts from implementations</li> <li>Reduce dependencies between components</li> <li> <p>Enable easier testing and maintenance</p> </li> <li> <p>Extensibility:</p> </li> <li>Add new implementations without changing existing code</li> <li>Support multiple backends or strategies</li> <li> <p>Build pluggable systems</p> </li> <li> <p>Abstraction:</p> </li> <li>Focus on behavior rather than implementation</li> <li>Create clean APIs</li> <li>Hide implementation details</li> </ol> <p>The storage system example demonstrates how interfaces enable building flexible, maintainable systems that can adapt to changing requirements. By defining clear contracts and implementing them consistently, you can create software that's both powerful and easy to understand.</p> <p>Key takeaways: 1. Interfaces define behavior, not data 2. Implementation is implicit - no \"implements\" keyword needed 3. Small, focused interfaces are better than large ones 4. Accept interfaces, return concrete types 5. Use interfaces to decouple components and enable testing</p> <p>Mastering interfaces is essential for writing idiomatic Go code that's flexible, maintainable, and testable. They are one of Go's most powerful features for building robust, scalable software systems.</p>"}]}