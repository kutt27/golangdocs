{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Go Documentation","text":"<p>Go (or Golang) is an open-source programming language developed by Google. It is designed to be simple, reliable, and efficient.</p>"},{"location":"#why-learn-go","title":"Why Learn Go?","text":"<ol> <li>Simplicity: Go has a very small set of keywords and a clean syntax, making it easy to learn and read.</li> <li>Concurrency: Built-in support for \"Goroutines\" and \"Channels\" makes it easy to write programs that do many things at once.</li> <li>Fast: Go compiles to native machine code, making it nearly as fast as C++.</li> <li>Standard Library: A massive built-in library for things like HTTP servers, JSON, and cryptography.</li> <li>Modern: Built-in garbage collection, memory safety, and excellent tooling (<code>gofmt</code>, <code>go test</code>).</li> </ol>"},{"location":"#where-go-is-used","title":"Where Go is Used","text":"<ul> <li>Cloud Infrastructure: Docker, Kubernetes, and Terraform are all written in Go.</li> <li>Microservices: Go's low memory footprint and fast startup times make it perfect for APIs.</li> <li>CLI Tools: Fast compilation and static binaries make it ideal for command-line utilities.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>If you're new to Go, we recommend following the tutorials in order:</p> <ol> <li>Basics: Variables, Loops, and Data Types.</li> <li>Intermediate: Structs, Interfaces, and Concurrency.</li> <li>Advanced: Complex patterns and system utilities.</li> </ol> <p>Happy Coding!</p>"},{"location":"1.%20Basics/1.%20Hello-World/","title":"Go Hello World","text":"<p>Every Go program starts with a <code>main</code> package and a <code>main</code> function. This is the entry point of your application.</p>"},{"location":"1.%20Basics/1.%20Hello-World/#your-first-program","title":"Your First Program","text":"<p>Create a file named <code>hello.go</code>:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}\n</code></pre>"},{"location":"1.%20Basics/1.%20Hello-World/#how-to-run-it","title":"How to Run it","text":"<p>You can run Go programs directly from your terminal:</p> <pre><code># 1. Run directly (compiled and executed in memory)\ngo run hello.go\n\n# 2. Build an executable\ngo build hello.go\n./hello\n</code></pre>"},{"location":"1.%20Basics/1.%20Hello-World/#understanding-the-code","title":"Understanding the Code","text":"<ol> <li><code>package main</code>: This tells the Go compiler that this file should compile as an executable program rather than a shared library.</li> <li><code>import \"fmt\"</code>: We import the \"fmt\" (format) package from the standard library to use its <code>Println</code> function.</li> <li><code>func main()</code>: This is the first function that runs when you start your program.</li> <li><code>fmt.Println()</code>: Prints text to the console and adds a newline at the end. Note that exported functions in Go always start with a Capital Letter.</li> </ol>"},{"location":"1.%20Basics/1.%20Hello-World/#the-go-playground","title":"The Go Playground","text":"<p>If you don't have Go installed locally yet, you can write and run Go code directly in your browser at go.dev/play.</p>"},{"location":"1.%20Basics/10.%20Range/","title":"Go Range","text":"<p>The <code>range</code> keyword is used to iterate over elements in a variety of data structures. It's Go's universal \"for-each\" loop.</p>"},{"location":"1.%20Basics/10.%20Range/#1-range-over-slices","title":"1. Range over Slices","text":"<p>When ranging over a slice, it returns two values: the index and a copy of the element at that index.</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    nums := []int{2, 3, 4}\n    sum := 0\n    for _, num := range nums {\n        sum += num\n    }\n    fmt.Println(\"sum:\", sum)\n\n    for i, num := range nums {\n        if num == 3 {\n            fmt.Println(\"index:\", i)\n        }\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/10.%20Range/#2-range-over-maps","title":"2. Range over Maps","text":"<p>For maps, <code>range</code> iterates over key/value pairs.</p> <pre><code>kvs := map[string]string{\"a\": \"apple\", \"b\": \"banana\"}\nfor k, v := range kvs {\n    fmt.Printf(\"%s -&gt; %s\\n\", k, v)\n}\n\n// Range over keys only\nfor k := range kvs {\n    fmt.Println(\"key:\", k)\n}\n</code></pre>"},{"location":"1.%20Basics/10.%20Range/#3-range-over-strings","title":"3. Range over Strings","text":"<p>Ranging over a string iterates over Unicode code points (runes). The first value is the starting byte index of the rune, and the second is the rune itself.</p> <pre><code>for i, c := range \"go\" {\n    fmt.Println(i, c)\n}\n// 0 103 (g)\n// 1 111 (o)\n</code></pre>"},{"location":"1.%20Basics/10.%20Range/#summary-table","title":"Summary Table","text":"Data Structure 1st Return Value 2nd Return Value Array/Slice Index (<code>int</code>) Value (<code>type</code>) Map Key (<code>type</code>) Value (<code>type</code>) String Index (<code>int</code>) Rune (<code>rune</code>) Channel Value (<code>type</code>) (None)"},{"location":"1.%20Basics/11.%20Functions/","title":"Go Functions","text":"<p>Functions are the central building blocks in Go.</p>"},{"location":"1.%20Basics/11.%20Functions/#1-basic-function","title":"1. Basic Function","text":"<p>Here's a function that takes two <code>int</code>s and returns their sum as an <code>int</code>. Go requires explicit returns.</p> <pre><code>package main\nimport \"fmt\"\n\nfunc plus(a int, b int) int {\n    return a + b\n}\n\nfunc main() {\n    res := plus(1, 2)\n    fmt.Println(\"1+2 =\", res)\n}\n</code></pre> <p>When multiple consecutive parameters are of the same type, you can omit the type for all but the last one: <code>func plus(a, b, c int) int</code>.</p>"},{"location":"1.%20Basics/11.%20Functions/#2-multiple-return-values","title":"2. Multiple Return Values","text":"<p>Go has built-in support for multiple return values. This feature is used often in idiomatic Go, for example, to return both result and error values from a function.</p> <pre><code>func vals() (int, int) {\n    return 3, 7\n}\n\nfunc main() {\n    a, b := vals()\n    fmt.Println(a)\n    fmt.Println(b)\n\n    // If you only want a subset of the values, use the blank identifier _.\n    _, c := vals()\n    fmt.Println(c)\n}\n</code></pre>"},{"location":"1.%20Basics/11.%20Functions/#3-variadic-functions","title":"3. Variadic Functions","text":"<p>Variadic functions can be called with any number of trailing arguments. For example, <code>fmt.Println</code> is a common variadic function.</p> <pre><code>func sum(nums ...int) {\n    fmt.Print(nums, \" \")\n    total := 0\n    for _, num := range nums {\n        total += num\n    }\n    fmt.Println(total)\n}\n\nfunc main() {\n    sum(1, 2)\n    sum(1, 2, 3)\n\n    // If you already have multiple args in a slice, \n    // apply them to a variadic function using func(slice...)\n    nums := []int{1, 2, 3, 4}\n    sum(nums...)\n}\n</code></pre>"},{"location":"1.%20Basics/11.%20Functions/#4-anonymous-functions-and-closures","title":"4. Anonymous Functions and Closures","text":"<p>Go supports anonymous functions, which can form closures.</p> <pre><code>func intSeq() func() int {\n    i := 0\n    return func() int {\n        i++\n        return i\n    }\n}\n\nfunc main() {\n    nextInt := intSeq()\n    fmt.Println(nextInt()) // 1\n    fmt.Println(nextInt()) // 2\n\n    newInts := intSeq()\n    fmt.Println(newInts()) // 1 (state is unique to each closure)\n}\n</code></pre>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/","title":"Go Control Flow: Defer, Panic, and Recover","text":"<p>Go has a few unique control flow mechanisms for handling cleanup and unexpected errors.</p>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#1-defer","title":"1. Defer","text":"<p><code>defer</code> schedules a function call to be run immediately before the surrounding function returns. It is most commonly used for cleanup (like closing a file or a database connection).</p> <pre><code>package main\nimport \"fmt\"\nimport \"os\"\n\nfunc main() {\n    f := createFile(\"/tmp/defer.txt\")\n    defer closeFile(f) // This runs AT THE END of main()\n    writeFile(f)\n}\n\nfunc createFile(p string) *os.File {\n    fmt.Println(\"creating\")\n    f, err := os.Create(p)\n    if err != nil {\n        panic(err)\n    }\n    return f\n}\n\nfunc writeFile(f *os.File) {\n    fmt.Println(\"writing\")\n    fmt.Fprintln(f, \"data\")\n}\n\nfunc closeFile(f *os.File) {\n    fmt.Println(\"closing\")\n    f.Close()\n}\n</code></pre>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#2-panic","title":"2. Panic","text":"<p>A <code>panic</code> typically means something went unexpectedly wrong. We mostly use it to fail fast on errors that shouldn't happen during normal operation.</p> <pre><code>panic(\"a problem occurred\")\n</code></pre> <p>When a function panics, its execution stops, and any deferred functions are executed.</p>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#3-recover","title":"3. Recover","text":"<p><code>recover</code> is a built-in function that regains control of a panicking goroutine. <code>recover</code> is only useful inside deferred functions.</p> <pre><code>func main() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"Recovered from panic:\", r)\n        }\n    }()\n\n    panic(\"CRITICAL ERROR\")\n    fmt.Println(\"This will never run\")\n}\n</code></pre>"},{"location":"1.%20Basics/12.%20Control-Flow-Mechanism/#summary-table","title":"Summary Table","text":"Keyword Purpose <code>defer</code> Delay execution until the function returns. Used for cleanup. <code>panic</code> Stop normal execution immediately. Used for unrecoverable errors. <code>recover</code> Catch a panic and stop the program from crashing."},{"location":"1.%20Basics/13.%20Init/","title":"Go Init Functions","text":"<p>The <code>init</code> function is a special function in Go that runs automatically before the <code>main</code> function or any other code in the package is executed.</p>"},{"location":"1.%20Basics/13.%20Init/#1-basic-usage","title":"1. Basic Usage","text":"<p>You don't call <code>init()</code> yourself. Go calls it for you.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc init() {\n    fmt.Println(\"Init: Running before main\")\n}\n\nfunc main() {\n    fmt.Println(\"Main: Starting now\")\n}\n</code></pre>"},{"location":"1.%20Basics/13.%20Init/#2-execution-order","title":"2. Execution Order","text":"<ol> <li>Variables: All package-level variables are initialized first.</li> <li><code>init()</code> functions: Then, all <code>init()</code> functions are called.</li> <li><code>main()</code> function: Finally, the <code>main()</code> function is called.</li> </ol>"},{"location":"1.%20Basics/13.%20Init/#3-multiple-init-functions","title":"3. Multiple Init Functions","text":"<p>You can have multiple <code>init()</code> functions in the same file or across multiple files in the same package. They will run in the order they appear.</p> <pre><code>func init() {\n    fmt.Println(\"First init\")\n}\n\nfunc init() {\n    fmt.Println(\"Second init\")\n}\n</code></pre>"},{"location":"1.%20Basics/13.%20Init/#why-use-init","title":"Why use <code>init()</code>?","text":"<ul> <li>Variable setup: Initializing complex global variables that can't be set with a simple assignment.</li> <li>Environment check: Checking if necessary environment variables or configuration files are present.</li> <li>Registration: Registering drivers (e.g., database drivers) or plugins.</li> </ul>"},{"location":"1.%20Basics/13.%20Init/#best-practices","title":"Best Practices","text":"<ul> <li>Keep it simple: Don't put heavy logic or long-running tasks in <code>init</code>. It can make your program hard to test and slow to start.</li> <li>Avoid side-effects: Try to keep <code>init</code> functions focused only on setting up the internal state of the package.</li> </ul>"},{"location":"1.%20Basics/2.%20Go-Compiler/","title":"The Go Compiler","text":"<p>Go is a compiled language. This means your source code is converted into machine code (binary) before it is executed.</p>"},{"location":"1.%20Basics/2.%20Go-Compiler/#two-ways-to-run-go","title":"Two Ways to Run Go","text":"Command Action Best for... <code>go run</code> Compiles to a temp folder and runs immediately. Development and testing. <code>go build</code> Compiles to a permanent executable binary. Production and shipping apps."},{"location":"1.%20Basics/2.%20Go-Compiler/#building-for-production","title":"Building for Production","text":"<p>When you run <code>go build</code>, Go creates a self-contained binary. This binary includes everything it needs to run\u2014no need to install Go on the server!</p> <pre><code># Creates a file named 'hello' (or 'hello.exe' on Windows)\ngo build hello.go\n\n# Run the binary\n./hello\n</code></pre>"},{"location":"1.%20Basics/2.%20Go-Compiler/#cross-compilation","title":"Cross-Compilation","text":"<p>One of Go's best features is the ability to build binaries for other operating systems from your current machine.</p> <pre><code># Build for Windows (from Mac/Linux)\nGOOS=windows GOARCH=amd64 go build hello.go\n\n# Build for Linux (from Windows/Mac)\nGOOS=linux GOARCH=amd64 go build hello.go\n</code></pre>"},{"location":"1.%20Basics/2.%20Go-Compiler/#why-is-the-go-compiler-special","title":"Why is the Go Compiler special?","text":"<ol> <li>Fast: Even large projects compile in seconds.</li> <li>Static Binaries: By default, Go binaries don't depend on external libraries (like <code>libc</code>).</li> <li>Optimization: The compiler automatically removes unused code (dead code elimination) to keep binaries small and fast.</li> </ol>"},{"location":"1.%20Basics/3.%20Data-Types/","title":"Go Data Types","text":"<p>Go is statically typed, meaning every variable has a specific type determined at compile time.</p>"},{"location":"1.%20Basics/3.%20Data-Types/#1-variables","title":"1. Variables","text":"<p>There are two main ways to declare variables:</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    // 1. Full declaration (var name type = value)\n    var name string = \"Alice\"\n\n    // 2. Short declaration (name := value)\n    // Type is inferred automatically. Only works inside functions.\n    age := 25\n\n    fmt.Println(name, age)\n}\n</code></pre>"},{"location":"1.%20Basics/3.%20Data-Types/#2-basic-types","title":"2. Basic Types","text":"<ul> <li>Integers: <code>int</code>, <code>int8</code>, <code>int64</code>, <code>uint</code> (unsigned). Usually, just use <code>int</code>.</li> <li>Floats: <code>float32</code>, <code>float64</code>. Usually, just use <code>float64</code>.</li> <li>Booleans: <code>bool</code> (<code>true</code> or <code>false</code>).</li> <li>Strings: <code>string</code> (UTF-8 encoded).</li> </ul>"},{"location":"1.%20Basics/3.%20Data-Types/#3-zero-values","title":"3. Zero Values","text":"<p>Variables declared without an explicit initial value are given their zero value: -   <code>0</code> for numeric types. -   <code>false</code> for booleans. -   <code>\"\"</code> (empty string) for strings.</p>"},{"location":"1.%20Basics/3.%20Data-Types/#4-constants","title":"4. Constants","text":"<p>Constants are values that cannot be changed once declared.</p> <pre><code>const Pi = 3.14\nconst StatusOK = 200\n</code></pre>"},{"location":"1.%20Basics/3.%20Data-Types/#5-type-conversions","title":"5. Type Conversions","text":"<p>Go never performs implicit conversions (e.g., you can't add an <code>int</code> to a <code>float64</code>). You must be explicit.</p> <pre><code>var i int = 42\nvar f float64 = float64(i) // Correct\n// var f float64 = i        // Error!\n</code></pre>"},{"location":"1.%20Basics/3.%20Data-Types/#6-strings-and-immutability","title":"6. Strings and Immutability","text":"<p>Strings in Go are immutable. You cannot change a single character in a string. Instead, you create a new string.</p> <pre><code>s := \"hello\"\n// s[0] = 'H' // Error!\ns = \"H\" + s[1:] // Correct: creates a new string\n</code></pre>"},{"location":"1.%20Basics/4.%20Standard%20Library/","title":"Go Standard Library","text":"<p>One of Go's greatest strengths is its Standard Library. It is a collection of built-in packages that provide everything you need to build professional software without needing external dependencies.</p>"},{"location":"1.%20Basics/4.%20Standard%20Library/#1-commonly-used-packages","title":"1. Commonly Used Packages","text":"Package Purpose <code>fmt</code> Formatted I/O (Printing to console, reading user input). <code>strings</code> String manipulation (Searching, splitting, joining). <code>strconv</code> Converting strings to other types (and vice-versa). <code>math</code> Mathematical constants and functions. <code>os</code> Operating system functions (File I/O, environment variables). <code>net/http</code> Building HTTP clients and web servers. <code>encoding/json</code> Working with JSON data. <code>time</code> Measuring and displaying time."},{"location":"1.%20Basics/4.%20Standard%20Library/#2-importing-packages","title":"2. Importing Packages","text":"<p>You use the <code>import</code> keyword to bring packages into your code. It's best to use \"factored\" imports for multiple packages.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"net/http\"\n)\n\nfunc main() {\n    fmt.Println(math.Pi)\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Standard%20Library/#3-import-aliases","title":"3. Import Aliases","text":"<p>You can give a package a custom name if there is a conflict or if you want it to be shorter.</p> <pre><code>import f \"fmt\"\n\nfunc main() {\n    f.Println(\"Using an alias\")\n}\n</code></pre>"},{"location":"1.%20Basics/4.%20Standard%20Library/#4-side-effect-imports","title":"4. Side-effect Imports","text":"<p>Sometimes you want to import a package just for its initialization logic (like a database driver), but you don't use any of its functions. We use the blank identifier <code>_</code> for this.</p> <pre><code>import _ \"github.com/go-sql-driver/mysql\"\n</code></pre>"},{"location":"1.%20Basics/4.%20Standard%20Library/#tips-for-success","title":"Tips for Success","text":"<ol> <li>Standard Library First: Always check if the standard library can do what you need before looking for a third-party library. It's usually faster, safer, and better documented.</li> <li>Go Doc: You can read documentation for any package from your terminal: <code>go doc fmt</code>.</li> <li>Capitalization: Remember, only functions that start with a Capital Letter (e.g., <code>fmt.Println</code>) are \"exported\" and can be used outside their package.</li> </ol>"},{"location":"1.%20Basics/5.%20If-and%20While/","title":"Go Loops (For and While)","text":"<p>Go only has one looping construct: the <code>for</code> loop. There is no <code>while</code> or <code>do-while</code> keyword in Go, but you can achieve the same behavior using <code>for</code>.</p>"},{"location":"1.%20Basics/5.%20If-and%20While/#1-the-classic-for-loop","title":"1. The Classic For Loop","text":"<p>The most basic type of loop, similar to C or Java.</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    // init; condition; post\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(i)\n    }\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#2-the-while-style-loop","title":"2. The \"While\" Style Loop","text":"<p>By omitting the initialization and post statements, <code>for</code> behaves exactly like a <code>while</code> loop.</p> <pre><code>i := 1\nfor i &lt;= 3 {\n    fmt.Println(i)\n    i = i + 1\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#3-infinite-loops","title":"3. Infinite Loops","text":"<p>A <code>for</code> without any condition will run forever until you <code>break</code> out of it or <code>return</code> from the function.</p> <pre><code>for {\n    fmt.Println(\"looping...\")\n    break // exit the loop\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#4-continue-and-break","title":"4. Continue and Break","text":"<ul> <li><code>continue</code>: Skip the rest of the current iteration and start the next one.</li> <li><code>break</code>: Exit the loop entirely.</li> </ul> <pre><code>for n := 0; n &lt;= 5; n++ {\n    if n%2 == 0 {\n        continue // skip even numbers\n    }\n    fmt.Println(n)\n}\n</code></pre>"},{"location":"1.%20Basics/5.%20If-and%20While/#5-loop-over-collections-range","title":"5. Loop over Collections (Range)","text":"<p>To iterate over arrays, slices, or maps, use the <code>range</code> keyword.</p> <pre><code>nums := []int{2, 3, 4}\nfor index, value := range nums {\n    fmt.Printf(\"index: %d, value: %d\\n\", index, value)\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/","title":"Go Conditionals","text":"<p>Go handles decision-making through <code>if/else</code> and <code>switch</code> statements.</p>"},{"location":"1.%20Basics/6.%20Conditionals/#1-ifelse-statements","title":"1. If/Else Statements","text":"<p>In Go, you don't need parentheses <code>()</code> around the condition, but curly braces <code>{}</code> are required.</p> <pre><code>if 7%2 == 0 {\n    fmt.Println(\"7 is even\")\n} else {\n    fmt.Println(\"7 is odd\")\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#2-if-with-initializer","title":"2. If with Initializer","text":"<p>A unique feature of Go is that <code>if</code> statements can start with a short statement to execute before the condition. Variables declared here are only available inside the <code>if</code> block.</p> <pre><code>if num := 9; num &lt; 0 {\n    fmt.Println(num, \"is negative\")\n} else if num &lt; 10 {\n    fmt.Println(num, \"has 1 digit\")\n} else {\n    fmt.Println(num, \"has multiple digits\")\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#3-switch-statements","title":"3. Switch Statements","text":"<p><code>switch</code> is a cleaner way to write multiple <code>if</code> chains.</p> <pre><code>i := 2\nswitch i {\ncase 1:\n    fmt.Println(\"one\")\ncase 2:\n    fmt.Println(\"two\")\ncase 3:\n    fmt.Println(\"three\")\ndefault:\n    fmt.Println(\"other\")\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#4-switch-without-expression","title":"4. Switch without Expression","text":"<p>A <code>switch</code> without an expression is an alternate way to write long <code>if/else if</code> chains.</p> <pre><code>t := time.Now()\nswitch {\ncase t.Hour() &lt; 12:\n    fmt.Println(\"It's before noon\")\ndefault:\n    fmt.Println(\"It's after noon\")\n}\n</code></pre>"},{"location":"1.%20Basics/6.%20Conditionals/#key-differences-from-other-languages","title":"Key Differences from other languages","text":"<ol> <li>No implicit fallthrough: Go automatically breaks after each case. You don't need to write <code>break</code>.</li> <li><code>fallthrough</code> keyword: If you want the execution to continue to the next case, you must explicitly use the <code>fallthrough</code> keyword.</li> <li>Multiple values: You can use commas to separate multiple values in a single <code>case</code>: <code>case \"Saturday\", \"Sunday\":</code>.</li> </ol>"},{"location":"1.%20Basics/7.%20Arrays/","title":"Go Arrays","text":"<p>In Go, an array is a numbered sequence of elements of a single type with a fixed length.</p>"},{"location":"1.%20Basics/7.%20Arrays/#1-basic-usage","title":"1. Basic Usage","text":"<p>The size of the array is part of its type. <code>[5]int</code> and <code>[10]int</code> are distinct, incompatible types.</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    // 1. Declare an array of 5 integers\n    var a [5]int\n    fmt.Println(\"emp:\", a) // [0 0 0 0 0] (initialized to zero value)\n\n    // 2. Set a value at an index\n    a[4] = 100\n    fmt.Println(\"set:\", a)\n    fmt.Println(\"get:\", a[4])\n\n    // 3. Get the length\n    fmt.Println(\"len:\", len(a))\n\n    // 4. Declare and initialize in one line\n    b := [5]int{1, 2, 3, 4, 5}\n    fmt.Println(\"dcl:\", b)\n}\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#2-multi-dimensional-arrays","title":"2. Multi-Dimensional Arrays","text":"<p>You can compose types to build multi-dimensional data structures.</p> <pre><code>var twoD [2][3]int\nfor i := 0; i &lt; 2; i++ {\n    for j := 0; j &lt; 3; j++ {\n        twoD[i][j] = i + j\n    }\n}\nfmt.Println(\"2d: \", twoD)\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#3-iterating-with-range","title":"3. Iterating with Range","text":"<p>Use <code>range</code> to iterate over an array. If you don't need the index, use the blank identifier (<code>_</code>).</p> <pre><code>nums := [3]int{10, 20, 30}\n\n// i is the index, v is the value\nfor i, v := range nums {\n    fmt.Printf(\"index %d has value %d\\n\", i, v)\n}\n\n// Ignore the index using _\nsum := 0\nfor _, v := range nums {\n    sum += v\n}\n</code></pre>"},{"location":"1.%20Basics/7.%20Arrays/#important-notes","title":"Important Notes","text":"<ol> <li>Value Type: Arrays in Go are value types. If you assign an array to a new variable, or pass it to a function, the entire array is copied.</li> <li>Fixed Size: You cannot resize an array. If you need a dynamic list, use Slices instead (which are much more common in Go).</li> </ol>"},{"location":"1.%20Basics/8.%20Slices/","title":"Go Slices","text":"<p>Slices are a key data type in Go, giving a more powerful interface to sequences than arrays. Unlike arrays, slices are typed only by the elements they contain (not the number of elements).</p>"},{"location":"1.%20Basics/8.%20Slices/#1-creating-slices","title":"1. Creating Slices","text":"<p>An uninitialized slice is <code>nil</code> and has a length of 0.</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    // 1. Using make([]type, length)\n    s := make([]string, 3)\n    fmt.Println(\"emp:\", s) // [  ]\n\n    s[0] = \"a\"\n    s[1] = \"b\"\n    s[2] = \"c\"\n    fmt.Println(\"set:\", s)\n\n    // 2. Slice Literal\n    t := []string{\"g\", \"h\", \"i\"}\n    fmt.Println(\"dcl:\", t)\n}\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#2-the-append-function","title":"2. The <code>append</code> Function","text":"<p><code>append</code> returns a new slice containing one or more new values. It's the standard way to grow a slice.</p> <pre><code>s := []string{\"a\"}\ns = append(s, \"b\")\ns = append(s, \"c\", \"d\")\nfmt.Println(\"apd:\", s) // [a b c d]\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#3-slicing-slices","title":"3. Slicing Slices","text":"<p>Slices support a \"copy\" operator with the syntax <code>slice[low:high]</code>. This creates a new slice that points to a portion of the original.</p> <pre><code>l := s[2:5] // elements from index 2 to 4\nl = s[:5]   // elements from index 0 to 4\nl = s[2:]   // elements from index 2 to end\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#4-copying-slices","title":"4. Copying Slices","text":"<p>To create an entirely new, independent copy of a slice, use the built-in <code>copy</code> function.</p> <pre><code>c := make([]string, len(s))\ncopy(c, s)\n</code></pre>"},{"location":"1.%20Basics/8.%20Slices/#length-vs-capacity","title":"Length vs Capacity","text":"<ul> <li>Length: The number of elements currently in the slice. <code>len(s)</code></li> <li>Capacity: The number of elements the underlying array can hold before needing to reallocate. <code>cap(s)</code></li> </ul>"},{"location":"1.%20Basics/8.%20Slices/#summary-array-vs-slice","title":"Summary: Array vs Slice","text":"Feature Array Slice Size Fixed (part of type) Dynamic (resizable) Declaration <code>[5]int</code> <code>[]int</code> Passing Copied by value Passed by reference Usage Rare Very Common"},{"location":"1.%20Basics/9.%20Maps/","title":"Go Maps","text":"<p>Maps are Go's built-in associative data type (sometimes called hashes or dicts in other languages). They store data in key-value pairs.</p>"},{"location":"1.%20Basics/9.%20Maps/#1-basic-usage","title":"1. Basic Usage","text":"<p>To create an empty map, use the built-in <code>make</code> function.</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    // 1. Create a map with string keys and int values\n    m := make(map[string]int)\n\n    // 2. Set key/value pairs\n    m[\"key1\"] = 7\n    m[\"key2\"] = 13\n    fmt.Println(\"map:\", m)\n\n    // 3. Get a value\n    v1 := m[\"key1\"]\n    fmt.Println(\"v1: \", v1)\n\n    // 4. Delete a key\n    delete(m, \"key2\")\n    fmt.Println(\"map:\", m)\n}\n</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#2-map-literals","title":"2. Map Literals","text":"<p>You can declare and initialize a new map on the same line.</p> <pre><code>n := map[string]int{\"foo\": 1, \"bar\": 2}\nfmt.Println(\"map:\", n)\n</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#3-checking-if-a-key-exists","title":"3. Checking if a Key Exists","text":"<p>When you read from a map, it returns two values: the value and a boolean indicating if the key was actually present.</p> <pre><code>v, ok := m[\"key2\"]\nif ok {\n    fmt.Println(\"Key exists, value:\", v)\n} else {\n    fmt.Println(\"Key not found\")\n}\n</code></pre>"},{"location":"1.%20Basics/9.%20Maps/#important-notes","title":"Important Notes","text":"<ol> <li>Zero Value: If a key doesn't exist, Go returns the zero value for the value type (e.g., <code>0</code> for an <code>int</code> map).</li> <li>Unordered: Maps are inherently unordered. If you iterate over a map multiple times, the order of keys is not guaranteed to be the same.</li> <li>Reference Type: Like slices, maps are passed by reference.</li> </ol>"},{"location":"2.%20Intermediate/1.%20Closures/","title":"Go Closures","text":"<p>A closure is a function that \"closes over\" variables from its surrounding scope. This means the function can remember and access these variables even after the outer function has finished executing.</p>"},{"location":"2.%20Intermediate/1.%20Closures/#basic-example","title":"Basic Example","text":"<p>Closures are often used to create functions with \"memory\" or state.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc intSeq() func() int {\n    i := 0\n    return func() int {\n        i++\n        return i\n    }\n}\n\nfunc main() {\n    // nextInt is a closure that \"captures\" the variable i\n    nextInt := intSeq()\n\n    fmt.Println(nextInt()) // 1\n    fmt.Println(nextInt()) // 2\n    fmt.Println(nextInt()) // 3\n\n    // To confirm that the state is unique to that function instance:\n    newInts := intSeq()\n    fmt.Println(newInts()) // 1\n}\n</code></pre>"},{"location":"2.%20Intermediate/1.%20Closures/#why-use-closures","title":"Why use Closures?","text":"<ol> <li>State Management: They allow functions to maintain state without using global variables.</li> <li>Function Factories: You can create specialized functions on the fly.</li> <li>Callbacks: Frequently used in asynchronous code or when passing logic to other functions.</li> </ol>"},{"location":"2.%20Intermediate/1.%20Closures/#common-pitfall-loop-variables","title":"Common Pitfall: Loop Variables","text":"<p>When creating closures inside a loop, they all share the same loop variable if you aren't careful.</p> <pre><code>// Be careful with this pattern\nfor i := 0; i &lt; 3; i++ {\n    go func() {\n        fmt.Println(i) // Might print 3, 3, 3\n    }()\n}\n</code></pre> <p>To fix this, pass the variable as a parameter or redefine it inside the loop:</p> <pre><code>for i := 0; i &lt; 3; i++ {\n    i := i // Create a unique instance for each closure\n    go func() {\n        fmt.Println(i)\n    }()\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/","title":"Go Struct Embedding","text":"<p>In Go, embedding is the way we achieve composition. It allows one struct to include another, giving it access to its fields and methods directly.</p>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#basic-example","title":"Basic example","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype base struct {\n    num int\n}\n\nfunc (b base) describe() string {\n    return fmt.Sprintf(\"base with num=%v\", b.num)\n}\n\ntype container struct {\n    base // This is an embedded struct\n    str  string\n}\n\nfunc main() {\n    co := container{\n        base: base{num: 1},\n        str:  \"some name\",\n    }\n\n    // We can access fields of 'base' directly on 'co'\n    fmt.Println(\"co.num:\", co.num) // 1\n\n    // We can also call methods of 'base' directly on 'co'\n    fmt.Println(\"describe:\", co.describe())\n}\n</code></pre>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#why-use-embedding","title":"Why use Embedding?","text":"<ul> <li>Code Reuse: Instead of copying fields or methods, you can group them into a base struct and embed it.</li> <li>Polymorphism through Interfaces: If <code>base</code> implements an interface, <code>container</code> will also implement it automatically because it \"inherits\" the methods.</li> </ul>"},{"location":"2.%20Intermediate/10.%20Struct-Embedding/#important-notes","title":"Important Notes","text":"<ul> <li>Shadowing: If both structs have a field with the same name, the outer struct's field \"shadows\" the inner one. You can still access the inner one using the full path (e.g., <code>co.base.num</code>).</li> <li>Not Inheritance: Even though it looks like inheritance, Go uses composition. The <code>base</code> struct doesn't know about the <code>container</code> struct.</li> </ul>"},{"location":"2.%20Intermediate/11.%20Generics/","title":"Go Generics","text":"<p>Generics allow you to write functions and data structures that work with any type, while still keeping the code type-safe.</p>"},{"location":"2.%20Intermediate/11.%20Generics/#basic-generic-function","title":"Basic Generic Function","text":"<p>Instead of writing separate functions for <code>int</code>, <code>float64</code>, and <code>string</code>, you can use a type parameter like <code>[T any]</code>.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// MapKeys takes a map of any type and returns its keys in a slice\nfunc MapKeys[K comparable, V any](m map[K]V) []K {\n    r := make([]K, 0, len(m))\n    for k := range m {\n        r = append(r, k)\n    }\n    return r\n}\n\nfunc main() {\n    var m = map[int]string{1: \"2\", 2: \"4\", 4: \"8\"}\n\n    // Go can often infer the types, so we don't need MapKeys[int, string](m)\n    fmt.Println(\"keys:\", MapKeys(m))\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#generic-structs","title":"Generic Structs","text":"<p>You can also create structs that hold any type.</p> <pre><code>type List[T any] struct {\n    head, tail *element[T]\n}\n\ntype element[T any] struct {\n    next *element[T]\n    val  T\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#type-constraints","title":"Type Constraints","text":"<p>Sometimes you don't want \"any\" type, but only types that support certain operations (like addition).</p> <pre><code>// Number is a constraint that allows only int and float64\ntype Number interface {\n    int | float64\n}\n\nfunc Sum[T Number](nums []T) T {\n    var s T\n    for _, v := range nums {\n        s += v\n    }\n    return s\n}\n</code></pre>"},{"location":"2.%20Intermediate/11.%20Generics/#why-use-generics","title":"Why use Generics?","text":"<ol> <li>Reduce Code Duplication: No need to write the same logic for multiple types.</li> <li>Type Safety: Unlike using <code>any</code> (the empty interface), generics catch errors at compile time.</li> <li>Cleaner Data Structures: You can build generic stacks, queues, or linked lists that work with any type you put in them.</li> </ol>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/","title":"Go Error Handling","text":"<p>In Go, errors are values. Instead of using \"exceptions\" (like try/catch in Java or Python), Go functions return an <code>error</code> as their last return value.</p>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#basic-error-handling","title":"Basic Error Handling","text":"<p>The <code>error</code> type is a built-in interface. If a function succeeds, it returns <code>nil</code> for the error.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc f(arg int) (int, error) {\n    if arg == 42 {\n        // Return a simple error using errors.New\n        return -1, errors.New(\"can't work with 42\")\n    }\n    return arg + 3, nil\n}\n\nfunc main() {\n    result, err := f(42)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Result:\", result)\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#custom-errors","title":"Custom Errors","text":"<p>You can create your own error types by implementing the <code>Error()</code> method. This is useful for passing extra data back to the caller.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype argError struct {\n    arg  int\n    prob string\n}\n\nfunc (e *argError) Error() string {\n    return fmt.Sprintf(\"%d - %s\", e.arg, e.prob)\n}\n\nfunc f(arg int) (int, error) {\n    if arg == 42 {\n        return -1, &amp;argError{arg, \"can't work with it\"}\n    }\n    return arg + 3, nil\n}\n\nfunc main() {\n    _, err := f(42)\n    if ae, ok := err.(*argError); ok {\n        fmt.Println(ae.arg)  // Access custom fields\n        fmt.Println(ae.prob)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#error-wrapping-w","title":"Error Wrapping (<code>%w</code>)","text":"<p>In modern Go (1.13+), you can \"wrap\" an error to add more context while keeping the original error visible.</p> <pre><code>func doSomething() error {\n    err := originalError()\n    return fmt.Errorf(\"extra context: %w\", err)\n}\n\n// To check for a specific error in a chain:\nif errors.Is(err, ErrNotFound) {\n    // ...\n}\n</code></pre>"},{"location":"2.%20Intermediate/12.%20Errors-and-Custom-Error/#why-handle-errors-explicitly","title":"Why handle errors explicitly?","text":"<ol> <li>Safety: You are forced to think about what happens when things go wrong.</li> <li>No Surprises: Control flow is clear; there are no hidden jumps (exceptions).</li> <li>Better Debugging: Error chains give you a clear \"trail\" of what failed and why.</li> </ol>"},{"location":"2.%20Intermediate/13.%20String-Functions/","title":"Go String Functions","text":"<p>Go's standard library provides a powerful <code>strings</code> package for working with text. Here are the most common functions you'll use.</p>"},{"location":"2.%20Intermediate/13.%20String-Functions/#basic-examples","title":"Basic Examples","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    s := \"test\"\n\n    // 1. Searching\n    fmt.Println(\"Contains:  \", strings.Contains(s, \"es\"))  // true\n    fmt.Println(\"Count:     \", strings.Count(s, \"t\"))     // 2\n    fmt.Println(\"HasPrefix: \", strings.HasPrefix(s, \"te\")) // true\n    fmt.Println(\"HasSuffix: \", strings.HasSuffix(s, \"st\")) // true\n    fmt.Println(\"Index:     \", strings.Index(s, \"e\"))     // 1\n\n    // 2. Joining and Splitting\n    fmt.Println(\"Join:      \", strings.Join([]string{\"a\", \"b\"}, \"-\")) // a-b\n    fmt.Println(\"Split:     \", strings.Split(\"a-b-c-d-e\", \"-\"))       // [a b c d e]\n\n    // 3. Transformation\n    fmt.Println(\"Repeat:    \", strings.Repeat(\"a\", 5))        // aaaaa\n    fmt.Println(\"Replace:   \", strings.Replace(\"foo\", \"o\", \"0\", -1)) // f00\n    fmt.Println(\"Replace:   \", strings.Replace(\"foo\", \"o\", \"0\", 1))  // f0o\n    fmt.Println(\"ToLower:   \", strings.ToLower(\"TEST\"))       // test\n    fmt.Println(\"ToUpper:   \", strings.ToUpper(\"test\"))       // TEST\n}\n</code></pre>"},{"location":"2.%20Intermediate/13.%20String-Functions/#reference-table","title":"Reference Table","text":"Function What it does <code>Contains(s, substr)</code> Returns <code>true</code> if <code>substr</code> is in <code>s</code>. <code>Count(s, substr)</code> Returns how many times <code>substr</code> appears. <code>HasPrefix(s, prefix)</code> Checks if <code>s</code> starts with <code>prefix</code>. <code>Index(s, substr)</code> Returns the position of the first <code>substr</code>. <code>Join(slice, sep)</code> Combines a slice of strings into one. <code>Split(s, sep)</code> Breaks a string into a slice. <code>ToLower / ToUpper</code> Changes the case."},{"location":"2.%20Intermediate/13.%20String-Functions/#note-on-efficiency","title":"Note on Efficiency","text":"<p>If you're building a long string piece by piece (like in a loop), don't use <code>+</code>. Instead, use <code>strings.Builder</code>. It's much faster because it doesn't create a new string every time you add to it.</p> <pre><code>var b strings.Builder\nfor i := 0; i &lt; 10; i++ {\n    b.WriteString(\"word\")\n}\nfmt.Println(b.String())\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/","title":"Go String Formatting","text":"<p>String formatting is how you build complex strings from variables. Go uses \"verbs\" (like <code>%d</code>) to tell the program how to format each value.</p>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#common-tasks","title":"Common Tasks","text":""},{"location":"2.%20Intermediate/14.%20String-Formatting/#1-building-a-simple-string","title":"1. Building a simple string","text":"<p>Use <code>fmt.Sprintf</code> to create a new string without printing it to the console.</p> <pre><code>s := fmt.Sprintf(\"A %s and a %d\", \"string\", 123)\nfmt.Println(s) // \"A string and a 123\"\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#2-formatting-numbers","title":"2. Formatting Numbers","text":"<ul> <li>Decimal: <code>%d</code></li> <li>Float: <code>%f</code> (or <code>%.2f</code> for two decimal places)</li> <li>Binary: <code>%b</code></li> </ul> <pre><code>fmt.Printf(\"%.2f\\n\", 3.14159) // 3.14\nfmt.Printf(\"%b\\n\", 15)      // 1111\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#3-working-with-structs","title":"3. Working with Structs","text":"<p>Use <code>%+v</code> to see the field names of a struct.</p> <pre><code>p := struct{ x, y int }{1, 2}\nfmt.Printf(\"%+v\\n\", p) // {x:1 y:2}\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#4-padding-and-alignment","title":"4. Padding and Alignment","text":"<p>Use numbers after the <code>%</code> to set the width.</p> <pre><code>fmt.Printf(\"|%6d|%6d|\\n\", 12, 345) // |    12|   345|\n</code></pre>"},{"location":"2.%20Intermediate/14.%20String-Formatting/#reference-table","title":"Reference Table","text":"Verb Description <code>%v</code> The default value. <code>%T</code> The type of the value. <code>%t</code> Boolean (true/false). <code>%d</code> Signed decimal integer. <code>%f</code> Floating point number. <code>%s</code> String. <code>%p</code> Pointer (memory address)."},{"location":"2.%20Intermediate/15.%20Text-Templates/","title":"Go Text Templates","text":"<p>Templates are a way to generate dynamic text (like HTML, emails, or reports) by combining a static string with dynamic data.</p>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#basic-example","title":"Basic Example","text":"<p>Go templates use double curly braces <code>{{ }}</code> to mark dynamic parts. Inside the template, <code>{{.}}</code> refers to the data passed in.</p> <pre><code>package main\n\nimport (\n    \"os\"\n    \"text/template\"\n)\n\nfunc main() {\n    // 1. Define a template string\n    tmpl := \"Hello {{.Name}}, welcome to {{.City}}!\\n\"\n\n    // 2. Parse the template\n    t, _ := template.New(\"test\").Parse(tmpl)\n\n    // 3. Create data (a struct or a map)\n    data := struct {\n        Name, City string\n    }{\n        Name: \"Alice\",\n        City: \"NY\",\n    }\n\n    // 4. Executing the template sends results to os.Stdout\n    t.Execute(os.Stdout, data)\n}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#control-structures","title":"Control Structures","text":"<p>Templates support loops and conditions:</p> <ul> <li>Conditions: <code>{{if .Condition}} ... {{else}} ... {{end}}</code></li> <li>Loops: <code>{{range .Slice}} ... {{.}} ... {{end}}</code></li> </ul> <pre><code>tmpl := `\n{{if .Admin}}\n  Admin Console\n{{else}}\n  User Dashboard\n{{end}}\n\nFriends:\n{{range .Friends}}\n  - {{.}}\n{{end}}\n`\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#accessing-fields","title":"Accessing Fields","text":"<p>If you pass a struct to a template, you can access its fields using a dot: <code>{{.FieldName}}</code>.</p> <pre><code>type User struct {\n    ID   int\n    Name string\n}\n\n// In template:\n// User ID: {{.ID}}, Name: {{.Name}}\n</code></pre>"},{"location":"2.%20Intermediate/15.%20Text-Templates/#why-use-templates","title":"Why use Templates?","text":"<ol> <li>Separation of Concerns: Keep your text/HTML separate from your Go code.</li> <li>Reusable Layouts: Define a \"base\" layout and swap the content inside.</li> <li>Security: If you use <code>html/template</code> (instead of <code>text/template</code>), Go will automatically escape special characters to prevent XSS attacks. factory methods.</li> </ol>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/","title":"Go Regular Expressions","text":"<p>Regular expressions (regex) are a way to search for patterns in text. Go provides the <code>regexp</code> package for this.</p>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#basic-example","title":"Basic Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc main() {\n    // 1. Simple match check\n    match, _ := regexp.MatchString(\"p([a-z]+)ch\", \"peach\")\n    fmt.Println(match) // true\n\n    // 2. Compile a regex for repeated use (MustCompile panics on error)\n    r := regexp.MustCompile(\"p([a-z]+)ch\")\n\n    // Find first match\n    fmt.Println(r.MatchString(\"peach\")) // true\n\n    // Find string\n    fmt.Println(r.FindString(\"peach punch\")) // peach\n\n    // Find and Replace\n    fmt.Println(r.ReplaceAllString(\"a peach\", \"&lt;fruit&gt;\")) // a &lt;fruit&gt;\n}\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#common-functions","title":"Common Functions","text":"Function What it does <code>MatchString</code> Returns <code>true</code> if pattern is found. <code>FindString</code> Returns the first match found. <code>FindAllString</code> Returns all matches found in a slice. <code>ReplaceAllString</code> Replaces all matches with a new string. <code>Split</code> Splits a string using the regex as a separator."},{"location":"2.%20Intermediate/16.%20Regular-Expression/#submatches-groups","title":"Submatches (Groups)","text":"<p>Use parentheses <code>()</code> to capture specific parts of a match.</p> <pre><code>r := regexp.MustCompile(\"p([a-z]+)ch\")\nres := r.FindStringSubmatch(\"peach\")\nfmt.Println(res) // [\"peach\", \"ea\"]\n// res[0] is the full match, res[1] is the first capture group\n</code></pre>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#why-use-regular-expressions","title":"Why use Regular Expressions?","text":"<ol> <li>Validation: Check if a string is a valid email, phone number, or password.</li> <li>Extraction: Pull specific data (like dates or IP addresses) out of logs.</li> <li>Transformation: Clean up or reformat text.</li> </ol>"},{"location":"2.%20Intermediate/16.%20Regular-Expression/#performance-tip","title":"Performance Tip","text":"<p>Always pre-compile your regex using <code>regexp.MustCompile</code> if you're going to use it more than once (e.g., inside a loop). Compiling a regex is expensive!</p>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/","title":"Go Time and Epochs","text":"<p>Go offers extensive support for time and duration via the <code>time</code> package.</p>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#1-basic-time","title":"1. Basic Time","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    now := time.Now()\n    fmt.Println(now)\n\n    // Build a specific time\n    then := time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC)\n    fmt.Println(then)\n\n    // Components\n    fmt.Println(then.Year())\n    fmt.Println(then.Month())\n    fmt.Println(then.Weekday())\n}\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#2-time-arithmetic","title":"2. Time Arithmetic","text":"<p>You can compare times or calculate the difference between them.</p> <pre><code>fmt.Println(then.Before(now)) // true\nfmt.Println(then.After(now))  // false\n\ndiff := now.Sub(then)\nfmt.Println(diff.Hours())\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#3-epoch-unix-time","title":"3. Epoch (Unix Time)","text":"<p>A common way to store time is as a \"Unix timestamp\"\u2014the number of seconds since January 1, 1970.</p> <pre><code>now := time.Now()\n\nfmt.Println(now.Unix())      // Seconds\nfmt.Println(now.UnixMilli()) // Milliseconds\nfmt.Println(now.UnixNano())  // Nanoseconds\n\n// Convert back to a Time object\nfmt.Println(time.Unix(now.Unix(), 0))\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#4-durations","title":"4. Durations","text":"<p><code>time.Duration</code> represents an elapsed period of time.</p> <pre><code>d := 2 * time.Hour + 30 * time.Minute\nfmt.Println(d.Minutes()) // 150\n</code></pre>"},{"location":"2.%20Intermediate/17.%20Time-and-Epoch/#why-use-the-time-package","title":"Why use the <code>time</code> package?","text":"<ol> <li>Precision: Go's <code>time.Time</code> supports nanosecond precision.</li> <li>Monotonicity: Go uses \"monotonic clocks\" for measuring duration, making it safe from system clock jumps (like Leap Seconds or Daylight Savings changes).</li> <li>Standardization: Working with epochs is the standard for APIs and databases.</li> </ol>"},{"location":"2.%20Intermediate/18.%20Random-Number/","title":"Go Random Numbers","text":"<p>Go provides two main packages for generating random numbers: <code>math/rand</code> for general use and <code>crypto/rand</code> for security-sensitive tasks.</p>"},{"location":"2.%20Intermediate/18.%20Random-Number/#1-general-random-numbers-mathrand","title":"1. General Random Numbers (<code>math/rand</code>)","text":"<p>By default, <code>math/rand</code> is deterministic (it produces the same numbers every time). You should seed it to get different results.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    // Seed with current time to get different numbers each run\n    rand.Seed(time.Now().UnixNano())\n\n    // 1. Random integer between 0 and 99\n    fmt.Println(rand.Intn(100))\n\n    // 2. Random float between 0.0 and 1.0\n    fmt.Println(rand.Float64())\n\n    // 3. Random float between 5.0 and 10.0\n    fmt.Println(5.0 + rand.Float64()*(10.0-5.0))\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#2-shuffling-slices","title":"2. Shuffling Slices","text":"<p>A common task is to shuffle a list of items.</p> <pre><code>s := []int{1, 2, 3, 4, 5}\nrand.Shuffle(len(s), func(i, j int) {\n    s[i], s[j] = s[j], s[i]\n})\nfmt.Println(s)\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#3-secure-random-numbers-cryptorand","title":"3. Secure Random Numbers (<code>crypto/rand</code>)","text":"<p>Use this for passwords, tokens, or encryption keys. It is much slower but safe from prediction.</p> <pre><code>package main\n\nimport (\n    \"crypto/rand\"\n    \"fmt\"\n)\n\nfunc main() {\n    b := make([]byte, 16)\n    _, err := rand.Read(b)\n    if err != nil {\n        return\n    }\n    fmt.Printf(\"%x\\n\", b)\n}\n</code></pre>"},{"location":"2.%20Intermediate/18.%20Random-Number/#why-use-random-numbers","title":"Why use Random Numbers?","text":"<ul> <li>Simulations: Modeling real-world events.</li> <li>Security: Generating unique IDs or tokens.</li> <li>Testing: Fuzzing your code with random inputs.</li> <li>Games: Dice rolls, card shuffling, or spawning enemies.</li> </ul>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/","title":"Go Number Parsing","text":"<p>Parsing numbers from strings is a common task in Go, handled by the <code>strconv</code> package.</p>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#1-integer-parsing","title":"1. Integer Parsing","text":"<ul> <li>Atoi: A quick way to convert a string to a base-10 <code>int</code>.</li> <li>ParseInt: Allows specifying a base (e.g., 2 for binary, 16 for hex) and a bit-size.</li> </ul> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc main() {\n    // 1. Simple base-10 integer\n    i, _ := strconv.Atoi(\"123\")\n    fmt.Println(i)\n\n    // 2. Hexadecimal (base 16)\n    h, _ := strconv.ParseInt(\"0x1c\", 0, 64)\n    fmt.Println(h) // 28\n\n    // 3. Binary (base 2)\n    b, _ := strconv.ParseInt(\"101\", 2, 64)\n    fmt.Println(b) // 5\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#2-float-parsing","title":"2. Float Parsing","text":"<p>Use <code>ParseFloat</code> to convert a string into a decimal number.</p> <pre><code>f, _ := strconv.ParseFloat(\"1.234\", 64)\nfmt.Println(f)\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#3-converting-to-strings","title":"3. Converting to Strings","text":"<p>If you need to go the other way (Number -&gt; String), use <code>Itoa</code> or <code>FormatFloat</code>.</p> <pre><code>s := strconv.Itoa(123)\nfmt.Println(s) // \"123\"\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#error-handling","title":"Error Handling","text":"<p>Parsing functions return an error if the input is not a valid number. You should always check it.</p> <pre><code>_, err := strconv.Atoi(\"wat\")\nif err != nil {\n    fmt.Println(err) // strconv.Atoi: parsing \"wat\": invalid syntax\n}\n</code></pre>"},{"location":"2.%20Intermediate/19.%20Number-Parsing/#why-use-strconv","title":"Why use <code>strconv</code>?","text":"<ul> <li>Safety: Explicitly handles overflow and invalid characters.</li> <li>Performance: Much faster than using <code>fmt.Sscanf</code>.</li> <li>Control: You can specify exactly how many bits (32 or 64) the result should be.</li> </ul>"},{"location":"2.%20Intermediate/2.%20Recursion/","title":"Go Recursion","text":"<p>Recursion is a technique where a function calls itself to solve a problem. It's useful for tasks that can be broken down into smaller, similar sub-tasks.</p>"},{"location":"2.%20Intermediate/2.%20Recursion/#basic-example-factorial","title":"Basic Example: Factorial","text":"<p>A common example is calculating a factorial (n!).</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc fact(n int) int {\n    // Base case: without this, the function would call itself forever\n    if n == 0 {\n        return 1\n    }\n    // Recursive call: the function calls itself with a smaller value\n    return n * fact(n-1)\n}\n\nfunc main() {\n    fmt.Println(fact(7)) // 5040\n}\n</code></pre>"},{"location":"2.%20Intermediate/2.%20Recursion/#essential-rules-for-recursion","title":"Essential Rules for Recursion","text":"<ol> <li>Base Case: You must have a condition that stops the recursion (e.g., <code>if n == 0</code>).</li> <li>Progress: Each recursive call must move closer to the base case.</li> </ol>"},{"location":"2.%20Intermediate/2.%20Recursion/#when-to-use-recursion","title":"When to use Recursion?","text":"<p>Recursion is especially elegant for: -   Mathematical sequences (like Factorial or Fibonacci). -   Navigating tree-like structures (like file directories or JSON objects).</p>"},{"location":"2.%20Intermediate/2.%20Recursion/#important-note-on-performance","title":"Important Note on Performance","text":"<p>Go does not optimize recursive calls (no tail-call optimization). For very deep recursion, a standard loop (<code>for</code> loop) is usually more efficient and avoids \"stack overflow\" errors.</p>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/","title":"Go URL Parsing","text":"<p>URLs consist of many parts like scheme, host, path, and query parameters. Go's <code>net/url</code> package makes it easy to extract or build them.</p>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#1-parsing-a-url","title":"1. Parsing a URL","text":"<p>Use <code>url.Parse</code> to break a string into its components.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net\"\n    \"net/url\"\n)\n\nfunc main() {\n    s := \"postgres://user:pass@host.com:5432/path?k=v#f\"\n\n    u, err := url.Parse(s)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(u.Scheme)   // postgres\n    fmt.Println(u.User)     // user:pass\n    fmt.Println(u.Host)     // host.com:5432\n    fmt.Println(u.Path)     // /path\n    fmt.Println(u.Fragment) // f\n\n    // To get user/pass details:\n    fmt.Println(u.User.Username())\n    p, _ := u.User.Password()\n    fmt.Println(p)\n\n    // To get host/port separately:\n    host, port, _ := net.SplitHostPort(u.Host)\n    fmt.Println(host) // host.com\n    fmt.Println(port) // 5432\n}\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#2-query-parameters","title":"2. Query Parameters","text":"<p>The <code>u.RawQuery</code> returns a string. To work with it as a map, use <code>u.Query()</code>.</p> <pre><code>fmt.Println(u.RawQuery) // k=v\n\nm, _ := url.ParseQuery(u.RawQuery)\nfmt.Println(m)          // map[k:[v]]\nfmt.Println(m[\"k\"][0])  // v\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#3-building-a-url","title":"3. Building a URL","text":"<p>You can also go the other way\u2014building a URL from scratch.</p> <pre><code>values := url.Values{}\nvalues.Add(\"q\", \"golang\")\nvalues.Add(\"page\", \"1\")\n\nu := &amp;url.URL{\n    Scheme:   \"https\",\n    Host:     \"google.com\",\n    Path:     \"search\",\n    RawQuery: values.Encode(),\n}\n\nfmt.Println(u.String()) // https://google.com/search?page=1&amp;q=golang\n</code></pre>"},{"location":"2.%20Intermediate/20.%20URL-Parsing/#why-use-neturl","title":"Why use <code>net/url</code>?","text":"<ol> <li>Correctness: It handles complex rules about what characters are allowed where (e.g., spaces vs <code>%20</code>).</li> <li>Security: It prevents \"injection\" attacks by properly escaping user input.</li> <li>Cross-platform: It follows universal standards for web addresses.</li> </ol>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/","title":"Go Bufio Package","text":"<p>The <code>bufio</code> package (short for \"Buffered I/O\") provides a way to read and write data efficiently by using a buffer. Instead of making many small, slow requests to the disk or network, <code>bufio</code> groups them into one large batch.</p>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#1-reading-with-scanner","title":"1. Reading with <code>Scanner</code>","text":"<p>The <code>Scanner</code> is the easiest way to read text line-by-line.</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Read from standard input (the keyboard)\n    scanner := bufio.NewScanner(os.Stdin)\n\n    fmt.Println(\"Enter some text:\")\n    for scanner.Scan() {\n        line := scanner.Text()\n        if line == \"exit\" {\n            break\n        }\n        fmt.Println(\"You typed:\", line)\n    }\n\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintln(os.Stderr, \"reading error:\", err)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#2-reading-with-reader","title":"2. Reading with <code>Reader</code>","text":"<p>If you need more control (like reading up to a specific character), use <code>bufio.Reader</code>.</p> <pre><code>// Read first 5 bytes\nreader := bufio.NewReader(os.Stdin)\nb, _ := reader.Peek(5)\nfmt.Printf(\"%s\\n\", b)\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#3-writing-with-writer","title":"3. Writing with <code>Writer</code>","text":"<p>Buffered writing is much faster than standard writing. Note: You must call <code>Flush()</code> at the end to make sure all data is actually written.</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"os\"\n)\n\nfunc main() {\n    f, _ := os.Create(\"test.txt\")\n    defer f.Close()\n\n    w := bufio.NewWriter(f)\n    w.WriteString(\"Buffered string\\n\")\n\n    // Crucial step!\n    w.Flush()\n}\n</code></pre>"},{"location":"2.%20Intermediate/21.%20Bufio-Package/#why-use-bufio","title":"Why use <code>bufio</code>?","text":"<ol> <li>Performance: Significantly reduces the number of expensive system calls.</li> <li>Convenience: Provides high-level functions like <code>ReadString</code>, <code>ReadBytes</code>, and <code>Scan</code>.</li> <li>Correctness: Handles complex split logic (like finding where one word ends and another begins) for you.</li> </ol>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/","title":"Go Base64 Encoding","text":"<p>Base64 encoding allows you to represent binary data (like images or encrypted files) as a plain text string. This is useful for sending data over protocols that only support text, like HTTP headers or email.</p>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#1-basic-encoding-and-decoding","title":"1. Basic Encoding and Decoding","text":"<pre><code>package main\n\nimport (\n    \"encoding/base64\"\n    \"fmt\"\n)\n\nfunc main() {\n    data := \"hello go\"\n\n    // 1. Encode simple string\n    // Standard Base64 uses + and / characters\n    encoded := base64.StdEncoding.EncodeToString([]byte(data))\n    fmt.Println(encoded) // aGVsbG8gZ28=\n\n    // 2. Decode back to original\n    decoded, _ := base64.StdEncoding.DecodeString(encoded)\n    fmt.Println(string(decoded)) // hello go\n}\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#2-url-safe-encoding","title":"2. URL-Safe Encoding","text":"<p>Standard Base64 contains characters like <code>+</code> and <code>/</code> that have special meanings in URLs. Use <code>URLEncoding</code> to swap them for <code>-</code> and <code>_</code>.</p> <pre><code>// Use this for URLs or filenames\nuEnc := base64.URLEncoding.EncodeToString([]byte(data))\nfmt.Println(uEnc)\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#3-encodings-without-padding","title":"3. Encodings without Padding","text":"<p>By default, Base64 adds <code>=</code> at the end to make the string a specific length. You can remove this using the <code>Raw</code> variants.</p> <pre><code>// No '=' at the end\nrawEnc := base64.RawStdEncoding.EncodeToString([]byte(data))\nfmt.Println(rawEnc)\n</code></pre>"},{"location":"2.%20Intermediate/22.%20Base64-Coding/#why-use-base64","title":"Why use Base64?","text":"<ol> <li>Transport Safe: Binary data can contain \"invisible\" control characters that break text-based protocols. Base64 is guaranteed safe.</li> <li>Standards: It's the standard for Basic Auth, JWT tokens, and embedding images in HTML.</li> <li>Data URLs: You can represent a whole file inside a single string: <code>data:image/png;base64,iVBORw...</code>.</li> </ol>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/","title":"Go Cryptographic Hashing","text":"<p>Cryptographic hashes are one-way functions that turn data into a fixed-length string of characters. Go's <code>crypto</code> package provides algorithms like SHA-256 and SHA-512.</p>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#1-sha-256-hashing","title":"1. SHA-256 Hashing","text":"<p>SHA-256 is the standard for most applications today (including blockchain and file verification).</p> <pre><code>package main\n\nimport (\n    \"crypto/sha256\"\n    \"fmt\"\n)\n\nfunc main() {\n    s := \"sha256 this string\"\n\n    // 1. Create a new hasher\n    h := sha256.New()\n\n    // 2. Write data to it\n    h.Write([]byte(s))\n\n    // 3. Get the final hash (Sum)\n    bs := h.Sum(nil)\n\n    // Output is usually shown in hex\n    fmt.Printf(\"%x\\n\", bs)\n}\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#2-quick-hashing","title":"2. Quick Hashing","text":"<p>For small pieces of data, you can use the <code>Sum256</code> helper function directly.</p> <pre><code>data := []byte(\"hello\")\nhash := sha256.Sum256(data)\nfmt.Printf(\"%x\\n\", hash)\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#3-password-hashing-warning","title":"3. Password Hashing (Warning!)","text":"<p>Never use SHA-256 or SHA-512 for passwords. They are too fast, making them easy to brute-force. Use slower, specialized algorithms like bcrypt or scrypt.</p> <pre><code>// Example using bcrypt (requires golang.org/x/crypto/bcrypt)\n// hash, _ := bcrypt.GenerateFromPassword([]byte(\"pass\"), bcrypt.DefaultCost)\n</code></pre>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#why-use-cryptographic-hashing","title":"Why use Cryptographic Hashing?","text":"<ol> <li>Integrity: Check if a file was corrupted or tampered with.</li> <li>Uniqueness: Create a \"fingerprint\" for a piece of data.</li> <li>Security: Storing \"signatures\" of sensitive data without storing the data itself.</li> </ol>"},{"location":"2.%20Intermediate/23.%20Cryptographic-Hashing/#important-notes","title":"Important Notes","text":"<ul> <li>SHA-1 and MD5: These are considered \"broken\" and insecure. Don't use them for security purposes.</li> <li>Salting: When hashing for security, always add a unique \"salt\" to the input to prevent rainbow table attacks.</li> </ul>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/","title":"Go Reading and Writing Files","text":"<p>Go's standard library provides several ways to work with files. The most common packages used are <code>os</code>, <code>io</code>, and <code>bufio</code>.</p>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#1-reading-files","title":"1. Reading Files","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#quick-read-entire-file","title":"Quick Read (Entire File)","text":"<p>Use <code>os.ReadFile</code> if the file is small enough to fit in memory.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    data, err := os.ReadFile(\"example.txt\")\n    if err != nil {\n        panic(err)\n    }\n    fmt.Print(string(data))\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#line-by-line-read","title":"Line-by-Line Read","text":"<p>Use <code>bufio.Scanner</code> for large files or when you want to process text line by line.</p> <pre><code>f, _ := os.Open(\"large.txt\")\ndefer f.Close()\n\nscanner := bufio.NewScanner(f)\nfor scanner.Scan() {\n    fmt.Println(scanner.Text())\n}\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#2-writing-files","title":"2. Writing Files","text":""},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#quick-write-overwrite","title":"Quick Write (Overwrite)","text":"<p>Use <code>os.WriteFile</code> to create or overwrite a file with data.</p> <pre><code>d1 := []byte(\"hello\\ngo\\n\")\nerr := os.WriteFile(\"test.txt\", d1, 0644)\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#manual-write","title":"Manual Write","text":"<p>Use <code>os.Create</code> and <code>WriteString</code> for more control.</p> <pre><code>f, _ := os.Create(\"manual.txt\")\ndefer f.Close()\n\nf.WriteString(\"some data\\n\")\nf.Sync() // Flush writes to stable storage\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#3-appending-to-a-file","title":"3. Appending to a File","text":"<p>To add data to the end of a file without overwriting it, use <code>os.OpenFile</code> with the <code>O_APPEND</code> flag.</p> <pre><code>f, _ := os.OpenFile(\"log.txt\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\ndefer f.Close()\n\nf.WriteString(\"new log entry\\n\")\n</code></pre>"},{"location":"2.%20Intermediate/24.%20Read-Write-Files/#best-practices","title":"Best Practices","text":"<ol> <li>Always use <code>defer f.Close()</code>: This ensures the file is closed even if your program panics, preventing memory leaks.</li> <li>Check Errors: File operations (like opening or writing) are very likely to fail (e.g., file not found, permission denied).</li> <li>Use <code>bufio</code> for Many Small Writes: It's much faster because it groups writes into a single batch.</li> </ol>"},{"location":"2.%20Intermediate/25.%20Line-Filters/","title":"Go Line Filters","text":"<p>A line filter is a common type of program that reads input from <code>stdin</code>, processes it line-by-line, and then prints a result to <code>stdout</code>. Examples include <code>grep</code> or <code>sed</code>.</p>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#basic-example-uppercase-filter","title":"Basic Example: Uppercase Filter","text":"<p>This program reads text from <code>stdin</code>, converts it to uppercase, and prints it.</p> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // 1. Create a scanner to read from standard input\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for scanner.Scan() {\n        // 2. Process each line\n        ucl := strings.ToUpper(scanner.Text())\n\n        // 3. Output the result\n        fmt.Println(ucl)\n    }\n\n    // 4. Check for errors during scanning\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintln(os.Stderr, \"error:\", err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#how-to-use-it","title":"How to use it","text":"<p>You can use the pipe (<code>|</code>) operator in your terminal to feed data into your Go program:</p> <pre><code># Compile the program\ngo build uppercase.go\n\n# Pipe another command's output into it\necho \"hello go\" | ./uppercase\n# Output: HELLO GO\n</code></pre>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#common-filter-ideas","title":"Common Filter Ideas","text":"<ol> <li>Grep: Only print lines that contain a specific word.</li> <li>Line Counter: Add a number to the start of every line.</li> <li>Search and Replace: Replace every occurrence of \"foo\" with \"bar\".</li> <li>Log Parser: Extract only the timestamp and error message from a log file.</li> </ol>"},{"location":"2.%20Intermediate/25.%20Line-Filters/#why-use-line-filters","title":"Why use Line Filters?","text":"<ol> <li>Memory Efficiency: By processing data line-by-line, your program can handle files that are much larger than the available RAM.</li> <li>Composability: You can chain multiple small filter programs together to solve complex tasks.</li> </ol>"},{"location":"2.%20Intermediate/26.%20File-Paths/","title":"Go File Paths","text":"<p>Go provides two packages for working with paths: 1.  <code>path</code>: For slash-separated paths (like URLs). 2.  <code>path/filepath</code>: For operating system paths (Window's <code>\\</code> vs Linux's <code>/</code>). Most of the time, you should use <code>filepath</code>.</p>"},{"location":"2.%20Intermediate/26.%20File-Paths/#1-joining-paths","title":"1. Joining Paths","text":"<p>Never use manual string concatenation like <code>dir + \"/\" + file</code>. Use <code>Join</code> to automatically handle separators based on the OS.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"path/filepath\"\n)\n\nfunc main() {\n    p := filepath.Join(\"dir1\", \"dir2\", \"filename.txt\")\n    fmt.Println(p) \n    // Linux/macOS: dir1/dir2/filename.txt\n    // Windows:     dir1\\dir2\\filename.txt\n}\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#2-extracting-parts","title":"2. Extracting Parts","text":"<pre><code>p := \"/home/user/notes.txt\"\n\nfmt.Println(filepath.Dir(p))  // /home/user (Directory)\nfmt.Println(filepath.Base(p)) // notes.txt (Filename)\nfmt.Println(filepath.Ext(p))  // .txt (Extension)\n\n// Get path without extension\nfmt.Println(p[:len(p)-len(filepath.Ext(p))]) // /home/user/notes\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#3-absolute-vs-relative","title":"3. Absolute vs Relative","text":"<pre><code>// Check if a path is absolute\nfmt.Println(filepath.IsAbs(\"/etc/passwd\"))\n\n// Convert a relative path to an absolute one\nabs, _ := filepath.Abs(\"config.json\")\nfmt.Println(abs)\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#4-cleaning-paths","title":"4. Cleaning Paths","text":"<p>The <code>Clean</code> function removes redundant elements like <code>.</code> (current dir) or <code>..</code> (parent dir).</p> <pre><code>fmt.Println(filepath.Clean(\"a/b/../c\")) // a/c\n</code></pre>"},{"location":"2.%20Intermediate/26.%20File-Paths/#why-use-filepath","title":"Why use <code>filepath</code>?","text":"<ol> <li>Cross-platform: Your code will work on Windows, Linux, and macOS without changes.</li> <li>Consistency: It handles trailing slashes and multiple separators (<code>///</code>) correctly.</li> <li>Security: Cleaning paths helps prevent \"Directory Traversal\" attacks (like <code>../../etc/passwd</code>).</li> </ol>"},{"location":"2.%20Intermediate/27.%20Directories/","title":"Go Directories","text":"<p>Working with directories is a core part of many Go applications. You'll primarily use the <code>os</code> package for these tasks.</p>"},{"location":"2.%20Intermediate/27.%20Directories/#1-basic-operations","title":"1. Basic Operations","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // 1. Create a single directory\n    err := os.Mkdir(\"subdir\", 0755)\n    if err != nil {\n        fmt.Println(err)\n    }\n\n    // 2. Create nested directories (like `mkdir -p`)\n    err = os.MkdirAll(\"a/b/c\", 0755)\n\n    // 3. Remove a directory (must be empty)\n    os.Remove(\"subdir\")\n\n    // 4. Remove a directory and all its contents (like `rm -rf`)\n    os.RemoveAll(\"a\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#2-listing-directory-contents","title":"2. Listing Directory Contents","text":"<p>Use <code>os.ReadDir</code> to get a list of files and folders inside a directory.</p> <pre><code>entries, _ := os.ReadDir(\".\")\n\nfor _, entry := range entries {\n    fmt.Println(entry.Name(), entry.IsDir())\n}\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#3-change-working-directory","title":"3. Change Working Directory","text":"<p>You can change where your program searches for files using <code>Chdir</code>.</p> <pre><code>os.Chdir(\"/tmp\")\ncwd, _ := os.Getwd()\nfmt.Println(\"Current dir:\", cwd)\n</code></pre>"},{"location":"2.%20Intermediate/27.%20Directories/#linux-permission-codes-the-0755","title":"Linux Permission Codes (The <code>0755</code>)","text":"<p>When creating directories or files, Go uses numeric permission codes (octal).</p> Code Meaning <code>0755</code> Everyone can read/execute; only owner can write. (Standard for folders) <code>0644</code> Everyone can read; only owner can write. (Standard for files) <code>0700</code> Only the owner can do anything. (Private) <code>0777</code> Everyone can do everything. (Not recommended)"},{"location":"2.%20Intermediate/27.%20Directories/#why-use-mkdirall","title":"Why use <code>MkdirAll</code>?","text":"<p>It is \"idempotent.\" If the directory already exists, it doesn't return an error; it just does nothing. This makes it safer for setup scripts.</p>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/","title":"Temporary Files and Embedding","text":"<p>This guide covers two important file-system concepts: working with temporary data and embedding static files into your Go binary.</p>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#1-temporary-files-and-directories","title":"1. Temporary Files and Directories","text":"<p>Sometimes you need a file just for a few seconds (e.g., to process an upload). Use <code>os.CreateTemp</code> to create a file in the OS's temporary folder with a unique name.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // 1. Create a temporary file\n    // The \"\" means use the default temporary directory\n    f, _ := os.CreateTemp(\"\", \"sample-*.txt\")\n\n    // 2. Clean up when finished\n    defer os.Remove(f.Name())\n\n    fmt.Println(\"Temp file name:\", f.Name())\n\n    // 3. Create a temporary directory\n    d, _ := os.MkdirTemp(\"\", \"sampledir-*\")\n    defer os.RemoveAll(d)\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#2-the-embed-directive","title":"2. The <code>embed</code> Directive","text":"<p>Introduced in Go 1.16, the <code>//go:embed</code> directive allows you to pack static files (like HTML or images) directly into your compiled <code>.exe</code> or binary file. This makes deployment much easier because you only have one file to share.</p> <pre><code>package main\n\nimport (\n    \"embed\"\n    \"fmt\"\n)\n\n// 1. Tell Go which file to embed\n//go:embed folder/version.txt\nvar version string\n\n// 2. You can also embed a whole folder\n//go:embed static/*\nvar staticFiles embed.FS\n\nfunc main() {\n    fmt.Println(\"Version:\", version)\n\n    // Read a file from the embedded folder\n    data, _ := staticFiles.ReadFile(\"static/logo.png\")\n    fmt.Println(\"Logo size:\", len(data))\n}\n</code></pre>"},{"location":"2.%20Intermediate/28.%20Directories-Addon/#why-use-embedding","title":"Why use Embedding?","text":"<ol> <li>Single Binary: No more \"file not found\" errors on production servers. All your CSS, JS, and templates are inside the program.</li> <li>Security: Embedded files are read-only, preventing them from being tampered with at runtime.</li> <li>Speed: Accessing data from memory is faster than reading from a spinning disk or SSD.</li> </ol>"},{"location":"2.%20Intermediate/29.%20Command-Line/","title":"Go Command Line","text":"<p>Go makes it easy to build command-line tools. You can either access arguments directly or use the <code>flag</code> package for a more structured approach.</p>"},{"location":"2.%20Intermediate/29.%20Command-Line/#1-basic-arguments","title":"1. Basic Arguments","text":"<p>The <code>os.Args</code> slice contains everything the user typed to start the program.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // os.Args[0] is the path to the program itself\n    // os.Args[1:] are the actual arguments\n    argsWithProg := os.Args\n    argsWithoutProg := os.Args[1:]\n\n    fmt.Println(argsWithProg)\n    fmt.Println(argsWithoutProg)\n}\n</code></pre>"},{"location":"2.%20Intermediate/29.%20Command-Line/#2-command-line-flags","title":"2. Command-Line Flags","text":"<p>Flags are structured options (like <code>-v</code> or <code>--port=8080</code>). Go's <code>flag</code> package handles parsing.</p> <pre><code>package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n)\n\nfunc main() {\n    // 1. Define flags (name, default value, help text)\n    wordPtr := flag.String(\"word\", \"foo\", \"a string\")\n    numbPtr := flag.Int(\"numb\", 42, \"an int\")\n    forkPtr := flag.Bool(\"fork\", false, \"a bool\")\n\n    // 2. You must call Parse()\n    flag.Parse()\n\n    // 3. Use pointers to access values\n    fmt.Println(\"word:\", *wordPtr)\n    fmt.Println(\"numb:\", *numbPtr)\n    fmt.Println(\"fork:\", *forkPtr)\n\n    // Access non-flag arguments\n    fmt.Println(\"tail:\", flag.Args())\n}\n</code></pre>"},{"location":"2.%20Intermediate/29.%20Command-Line/#3-sub-commands","title":"3. Sub-Commands","text":"<p>For complex tools (like <code>go run</code> or <code>git commit</code>), you can use <code>flag.NewFlagSet</code>.</p> <pre><code>fooCmd := flag.NewFlagSet(\"foo\", flag.ExitOnError)\nbarCmd := flag.NewFlagSet(\"bar\", flag.ExitOnError)\n\nif len(os.Args) &lt; 2 {\n    fmt.Println(\"expected 'foo' or 'bar' subcommands\")\n    os.Exit(1)\n}\n\nswitch os.Args[1] {\ncase \"foo\":\n    fooCmd.Parse(os.Args[2:])\ncase \"bar\":\n    barCmd.Parse(os.Args[2:])\n}\n</code></pre>"},{"location":"2.%20Intermediate/29.%20Command-Line/#why-use-flags","title":"Why use Flags?","text":"<ol> <li>Standardization: Users expect <code>-h</code> or <code>--help</code> to show instructions. Go's <code>flag</code> package generates this automatically.</li> <li>Type Safety: It automatically converts strings (\"8080\") into the correct Go type (<code>int</code>).</li> <li>Third-Party Libraries: For larger apps, most Go developers use Cobra\u2014the same library that powers Docker and Kubernetes.</li> </ol>"},{"location":"2.%20Intermediate/3.%20Pointers/","title":"Go Pointers","text":"<p>A pointer is a variable that stores the memory address of another variable. Instead of holding a value (like <code>42</code>), it holds a location (like <code>0xc0000120b0</code>).</p>"},{"location":"2.%20Intermediate/3.%20Pointers/#basic-syntax","title":"Basic Syntax","text":"<ul> <li><code>&amp;</code>: The \"address of\" operator. It gives you the memory address of a variable.</li> <li><code>*</code>: The \"dereference\" operator. It allows you to access or change the value at the address a pointer is holding.</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    i := 42\n    p := &amp;i // p points to i\n\n    fmt.Println(p)  // Prints the memory address (e.g., 0xc0000120b0)\n    fmt.Println(*p) // Prints the value at that address (42)\n\n    *p = 21         // Changes the value of i through the pointer\n    fmt.Println(i)  // Prints 21\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#why-use-pointers","title":"Why use Pointers?","text":"<ol> <li>Efficiency: Passing a pointer to a large struct is much faster than copying the entire struct.</li> <li>Modification: If you want a function to modify a variable from the outside, you must pass a pointer.</li> </ol>"},{"location":"2.%20Intermediate/3.%20Pointers/#comparison-value-vs-pointer","title":"Comparison: Value vs Pointer","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// This function receives a COPY (value remains unchanged outside)\nfunc zeroval(ival int) {\n    ival = 0\n}\n\n// This function receives a POINTER (modifies the actual variable)\nfunc zeroptr(iptr *int) {\n    *iptr = 0\n}\n\nfunc main() {\n    i := 1\n    zeroval(i)\n    fmt.Println(i) // 1\n\n    zeroptr(&amp;i)\n    fmt.Println(i) // 0\n}\n</code></pre>"},{"location":"2.%20Intermediate/3.%20Pointers/#important-notes","title":"Important Notes","text":"<ul> <li>Nil Pointers: The \"zero value\" of a pointer is <code>nil</code>. Trying to dereference a <code>nil</code> pointer will cause a crash (panic).</li> <li>No Pointer Arithmetic: Unlike C, Go does not allow you to add or subtract from pointers (e.g., <code>p++</code> is not allowed).</li> </ul>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/","title":"Go Environment Variables","text":"<p>Environment variables are a standard way to configure applications without hardcoding values. Go's <code>os</code> package provides the tools to read and set them.</p>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#1-getting-variables","title":"1. Getting Variables","text":"<p>Use <code>os.Getenv</code> to get a value. If the variable isn't set, it returns an empty string.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // 1. Get a common system variable\n    fmt.Println(\"Shell:\", os.Getenv(\"SHELL\"))\n\n    // 2. Get a variable with a default value fallback\n    port := os.Getenv(\"PORT\")\n    if port == \"\" {\n        port = \"8080\"\n    }\n    fmt.Println(\"Port:\", port)\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#2-checking-if-a-variable-exists","title":"2. Checking if a Variable Exists","text":"<p>Use <code>os.LookupEnv</code> if you need to know if a variable was actually defined (it could be defined as an empty string).</p> <pre><code>val, exists := os.LookupEnv(\"MY_SECRET\")\nif !exists {\n    fmt.Println(\"MY_SECRET is not set!\")\n} else {\n    fmt.Println(\"Value:\", val)\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#3-setting-and-unsetting","title":"3. Setting and Unsetting","text":"<pre><code>// Set a variable\nos.Setenv(\"FOO\", \"1\")\n\n// Unset (remove) a variable\nos.Unsetenv(\"FOO\")\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#4-listing-all-variables","title":"4. Listing All Variables","text":"<p><code>os.Environ()</code> returns a slice of strings in the format <code>KEY=VALUE</code>.</p> <pre><code>for _, e := range os.Environ() {\n    fmt.Println(e)\n}\n</code></pre>"},{"location":"2.%20Intermediate/30.%20Environment-Variables/#why-use-environment-variables","title":"Why use Environment Variables?","text":"<ol> <li>Twelve-Factor App: It's a best practice to store configuration in the environment, keeping code separate from dynamic settings.</li> <li>Security: Never hardcode API keys or database passwords in your code. Set them as environment variables instead.</li> <li>Docker/Kubernetes: Modern deployment tools are designed to inject configuration via the environment.</li> </ol>"},{"location":"2.%20Intermediate/31.%20Logging/","title":"Go Logging","text":"<p>Logging is essential for monitoring your application and debugging errors. Go provides a built-in <code>log</code> package, but many developers use \"structured\" logging for production.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#1-the-standard-log-package","title":"1. The Standard <code>log</code> Package","text":"<p>This is the simplest way to log. By default, it prints to <code>stderr</code> and includes the date and time.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    // 1. Basic logging\n    log.Println(\"Hello, logger!\")\n\n    // 2. Fatal - logs the message and calls os.Exit(1)\n    // log.Fatal(\"Critical error! Stopping app.\")\n\n    // 3. Panic - logs the message and calls panic()\n    // log.Panic(\"Unexpected state!\")\n\n    // 4. Customizing the output\n    log.SetFlags(log.LstdFlags | log.Lshortfile)\n    log.Println(\"Log with file name and line number\")\n\n    // 5. Custom prefix\n    log.SetPrefix(\"MYAPP: \")\n    log.Println(\"Log with prefix\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#2-logging-to-a-file","title":"2. Logging to a File","text":"<pre><code>f, _ := os.OpenFile(\"test.log\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\ndefer f.Close()\n\nlog.SetOutput(f)\nlog.Println(\"This message goes to the file\")\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#3-structured-logging-the-modern-way","title":"3. Structured Logging (The Modern Way)","text":"<p>Basic logs are just strings. Structured logs are format-friendly (like JSON), which makes them easy for tools like Datadog or Splunk to search.</p> <p>While Go's standard library is basic, popular third-party packages include: -   <code>slog</code> (Now part of the standard library in Go 1.21+): Recommended for most apps. -   <code>zap</code>: High performance. -   <code>zerolog</code>: Specialized for high-speed JSON logging.</p>"},{"location":"2.%20Intermediate/31.%20Logging/#example-using-slog-standard-since-121","title":"Example using <code>slog</code> (Standard since 1.21)","text":"<pre><code>import \"log/slog\"\n\nfunc main() {\n    slog.Info(\"usage\", \"user\", \"alice\", \"id\", 123)\n}\n// Output: 2023/07/01 12:00:00 INFO usage user=alice id=123\n</code></pre>"},{"location":"2.%20Intermediate/31.%20Logging/#why-use-a-logger-instead-of-fmtprintln","title":"Why use a Logger instead of <code>fmt.Println</code>?","text":"<ol> <li>Metadata: Loggers automatically add timestamps and file locations.</li> <li>Destinations: Easily switch between terminal output, log files, or network streams.</li> <li>Severity Levels: Use levels like <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, and <code>ERROR</code> to filter what you see.</li> </ol>"},{"location":"2.%20Intermediate/32.%20JSON/","title":"JSON in Go","text":"<p>Go makes it incredibly easy to work with JSON using the <code>encoding/json</code> package.</p>"},{"location":"2.%20Intermediate/32.%20JSON/#1-marshalling-go-to-json","title":"1. Marshalling (Go to JSON)","text":"<p>Converting a Go struct or map into a JSON string.</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype Response struct {\n    Page   int      `json:\"page\"`\n    Fruits []string `json:\"fruits\"`\n}\n\nfunc main() {\n    res := Response{\n        Page:   1,\n        Fruits: []string{\"apple\", \"peach\", \"pear\"},\n    }\n\n    // Convert to JSON bytes\n    bytes, _ := json.Marshal(res)\n    fmt.Println(string(bytes)) // {\"page\":1,\"fruits\":[\"apple\",\"peach\",\"pear\"]}\n\n    // Pretty print version\n    pretty, _ := json.MarshalIndent(res, \"\", \"  \")\n    fmt.Println(string(pretty))\n}\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#2-unmarshalling-json-to-go","title":"2. Unmarshalling (JSON to Go)","text":"<p>Converting a JSON string back into a Go struct.</p> <pre><code>str := `{\"page\": 1, \"fruits\": [\"apple\", \"peach\"]}`\nres := Response{}\n\n// Use a pointer so Unmarshal can modify the struct\njson.Unmarshal([]byte(str), &amp;res)\n\nfmt.Println(res.Page) // 1\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#3-maps-for-dynamic-json","title":"3. Maps for Dynamic JSON","text":"<p>If you don't know the keys in advance, use a map.</p> <pre><code>str := `{\"apple\": 5, \"lettuce\": 7}`\nvar data map[string]int\n\njson.Unmarshal([]byte(str), &amp;data)\nfmt.Println(data[\"apple\"]) // 5\n</code></pre>"},{"location":"2.%20Intermediate/32.%20JSON/#4-struct-tags","title":"4. Struct Tags","text":"<p>Struct tags (the text in backticks) tell the JSON package how to name the fields in the output.</p> <ul> <li><code>json:\"name\"</code>: Use \"name\" instead of the Go variable name.</li> <li><code>json:\"-\"</code>: Ignore this field completely.</li> <li><code>json:\"id,omitempty\"</code>: Don't include this field if it's empty (0, \"\", nil).</li> </ul>"},{"location":"2.%20Intermediate/32.%20JSON/#using-encoder-and-decoder","title":"Using <code>Encoder</code> and <code>Decoder</code>","text":"<p>If you are reading from a network connection or a file, use <code>Encoder</code> and <code>Decoder</code> as they work directly with streams.</p> <pre><code>// Writing directly to standard out\njson.NewEncoder(os.Stdout).Encode(res)\n</code></pre>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/","title":"Go Struct Tags","text":"<p>Struct tags are small strings of metadata attached to fields. They are used by other packages (like <code>json</code>, <code>xml</code>, or database drivers) to decide how to handle your data.</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#syntax","title":"Syntax","text":"<p>Tags are placed in backticks after the type of a field.</p> <pre><code>type User struct {\n    Name  string `json:\"user_name\" db:\"customer_name\"`\n    Age   int    `json:\"age\" val:\"min=18\"`\n    Email string `json:\"-\"` // This field is ignored by the JSON package\n}\n</code></pre>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#how-they-work","title":"How they work","text":"<p>The Go compiler ignores struct tags. However, other code can read them at runtime using Reflection.</p>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#common-examples","title":"Common Examples","text":"<ol> <li>JSON: <code>json:\"id,omitempty\"</code> (Change name, skip if empty).</li> <li>Databases (GORM/SQL): <code>db:\"user_id\"</code> (Map field to specific column name).</li> <li>Validation: <code>validate:\"required,email\"</code> (Used by libraries to check input data).</li> <li>XML: <code>xml:\"token,attr\"</code> (Map field to an XML attribute instead of a tag). e</li> </ol>"},{"location":"2.%20Intermediate/33.%20Struct-Tags/#why-use-struct-tags","title":"Why use Struct Tags?","text":"<ol> <li>Cleaner Code: You don't have to write manual conversion logic for every field.</li> <li>Flexibility: You can have one struct that maps to a JSON API, a PostgreSQL database, and an XML file, all with different field names.</li> <li>Declarative: You \"describe\" how the data should behave rather than writing the step-by-step logic.</li> </ol>"},{"location":"2.%20Intermediate/34.%20XML/","title":"XML in Go","text":"<p>Go supports XML through the <code>encoding/xml</code> package. It works very similarly to the JSON package but with a few extra struct tag options for attributes and nesting.</p>"},{"location":"2.%20Intermediate/34.%20XML/#1-marshalling-go-to-xml","title":"1. Marshalling (Go to XML)","text":"<pre><code>package main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n)\n\ntype Plant struct {\n    XMLName xml.Name `xml:\"plant\"`\n    ID      int      `xml:\"id,attr\"` // XML Attribute\n    Name    string   `xml:\"name\"`\n    Origin  []string `xml:\"origin\"`\n}\n\nfunc main() {\n    coffee := &amp;Plant{ID: 27, Name: \"Coffee\"}\n    coffee.Origin = []string{\"Ethiopia\", \"Brazil\"}\n\n    // Use MarshalIndent for human-readable output\n    out, _ := xml.MarshalIndent(coffee, \" \", \"  \")\n    fmt.Println(xml.Header + string(out))\n}\n</code></pre> <p>Output: <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n &lt;plant id=\"27\"&gt;\n   &lt;name&gt;Coffee&lt;/name&gt;\n   &lt;origin&gt;Ethiopia&lt;/origin&gt;\n   &lt;origin&gt;Brazil&lt;/origin&gt;\n &lt;/plant&gt;\n</code></pre></p>"},{"location":"2.%20Intermediate/34.%20XML/#2-unmarshalling-xml-to-go","title":"2. Unmarshalling (XML to Go)","text":"<pre><code>data := []byte(`&lt;plant id=\"27\"&gt;&lt;name&gt;Coffee&lt;/name&gt;&lt;/plant&gt;`)\nvar p Plant\nxml.Unmarshal(data, &amp;p)\nfmt.Println(p.Name) // Coffee\n</code></pre>"},{"location":"2.%20Intermediate/34.%20XML/#3-xml-struct-tags","title":"3. XML Struct Tags","text":"<ul> <li><code>xml:\"tag_name\"</code>: Maps the field to an XML tag.</li> <li><code>xml:\"id,attr\"</code>: Maps the field to an attribute (e.g., <code>&lt;plant id=\"1\"&gt;</code>).</li> <li><code>xml:\"parent&gt;child\"</code>: Maps to nested tags (e.g., <code>&lt;parent&gt;&lt;child&gt;value&lt;/child&gt;&lt;/parent&gt;</code>).</li> <li><code>xml:\",chardata\"</code>: Maps to the raw text inside a tag.</li> <li><code>xml:\",innerxml\"</code>: Maps to the raw, unparsed XML inside a tag.</li> </ul>"},{"location":"2.%20Intermediate/34.%20XML/#why-use-xml","title":"Why use XML?","text":"<ol> <li>Legacy Systems: Many older enterprise APIs and configuration files use XML.</li> <li>Strictness: XML schemas (XSD) allow for very strict data validation.</li> <li>Namespaces: Good for merging data from different sources without name collisions.</li> </ol>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/","title":"Go Extensions (CGO and Plugins)","text":"<p>Most of the time, Go's standard library and the vast ecosystem of Go packages are enough. However, sometimes you need to call code written in C or load a Go plugin at runtime.</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#1-cgo-calling-c-code","title":"1. CGO: Calling C Code","text":"<p>CGO allows your Go program to call C functions. This is useful for using legacy C libraries (like zlib or OpenSSL).</p> <pre><code>package main\n\n/*\n// This is C code inside a comment block\n#include &lt;stdio.h&gt;\n\nvoid hello() {\n    printf(\"Hello from C!\\n\");\n}\n*/\nimport \"C\"\n\nfunc main() {\n    // Call the C function defined above\n    C.hello()\n}\n</code></pre> <p>Note: CGO makes your code harder to compile and slower. Only use it when there is no pure Go alternative.</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#2-go-plugins","title":"2. Go Plugins","text":"<p>Plugins allow you to load shared libraries (<code>.so</code> files) while your program is running. This is great for apps with a \"modular\" architecture (like a web server that loads new handlers without restarting).</p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#plugingo-the-module","title":"plugin.go (The module)","text":"<p><pre><code>package main\n\nfunc Greet() string {\n    return \"Hello from Plugin!\"\n}\n</code></pre> Compile with: <code>go build -buildmode=plugin -o greet.so plugin.go</code></p>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#maingo-the-loader","title":"main.go (The loader)","text":"<pre><code>p, _ := plugin.Open(\"greet.so\")\nsymbol, _ := p.Lookup(\"Greet\")\ngreetFunc := symbol.(func() string)\n\nfmt.Println(greetFunc())\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#3-webassembly-wasm","title":"3. WebAssembly (WASM)","text":"<p>Go can also be compiled to WebAssembly to run in a web browser.</p> <pre><code>GOOS=js GOARCH=wasm go build -o main.wasm main.go\n</code></pre>"},{"location":"2.%20Intermediate/35.%20Go-Extensions/#why-use-extensions","title":"Why use Extensions?","text":"<ol> <li>Reuse: Leverage millions of lines of existing C code.</li> <li>Performance: C can still be faster for certain math-heavy or low-level tasks.</li> <li>Extensibility: Let users write their own logic and plug it into your application at runtime.</li> </ol>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/","title":"Go Type Conversions","text":"<p>Go is statically typed and very strict. It never performs \"implicit\" conversions (e.g., adding an <code>int</code> to a <code>float64</code> automatically). You must always be explicit.</p>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#1-numeric-conversions","title":"1. Numeric Conversions","text":"<p>To convert between numbers, use the type name as a function.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i int = 42\n    var f float64 = float64(i) // int to float\n    var u uint = uint(f)       // float to uint\n\n    fmt.Println(i, f, u)\n}\n</code></pre> <p>Warning: Converting a <code>float64(3.9)</code> to an <code>int</code> will result in <code>3</code> (truncation), not <code>4</code>.</p>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#2-string-conversions-strconv","title":"2. String Conversions (<code>strconv</code>)","text":"<p>Converting a number to a string (or vice versa) requires the <code>strconv</code> package.</p> <pre><code>import \"strconv\"\n\n// 1. String to Int\ni, _ := strconv.Atoi(\"123\")\n\n// 2. Int to String\ns := strconv.Itoa(123)\n\n// 3. String to Float\nf, _ := strconv.ParseFloat(\"3.14\", 64)\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#3-type-assertions-interfaces","title":"3. Type Assertions (Interfaces)","text":"<p>A type assertion provides access to an interface value's underlying concrete value.</p> <pre><code>var i interface{} = \"hello\"\n\n// 1. Basic assertion (Dangerous: panics if not a string)\ns := i.(string)\n\n// 2. Safe assertion (Comma-ok idiom)\ns, ok := i.(string)\nif ok {\n    fmt.Println(s)\n} else {\n    fmt.Println(\"Not a string!\")\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#4-type-switches","title":"4. Type Switches","text":"<p>A type switch is a cleaner way to handle multiple possible types for an interface.</p> <pre><code>switch v := i.(type) {\ncase int:\n    fmt.Println(\"It's an int:\", v)\ncase string:\n    fmt.Println(\"It's a string:\", v)\ndefault:\n    fmt.Printf(\"Unknown type %T\\n\", v)\n}\n</code></pre>"},{"location":"2.%20Intermediate/36.%20Type-Conversions/#why-is-go-so-strict","title":"Why is Go so strict?","text":"<ol> <li>Safety: Prevents hidden bugs where precision is lost or numbers overflow without you noticing.</li> <li>Clarity: By forcing you to write <code>int64(x)</code>, the code clearly communicates that a conversion is happening.</li> </ol>"},{"location":"2.%20Intermediate/37.%20IO-Package/","title":"Go IO Package","text":"<p>The <code>io</code> package provides the fundamental building blocks for working with data streams. Almost everything in Go that reads or writes data (files, network connections, buffers) uses the interfaces defined here.</p>"},{"location":"2.%20Intermediate/37.%20IO-Package/#1-core-interfaces","title":"1. Core Interfaces","text":"<p>There are two primary interfaces you will see everywhere:</p> <ul> <li><code>Reader</code>: Anything that has a <code>Read(p []byte)</code> method. It fills the slice <code>p</code> with data.</li> <li><code>Writer</code>: Anything that has a <code>Write(p []byte)</code> method. It sends data from the slice <code>p</code> to a destination (like a file).</li> </ul> <pre><code>package main\n\nimport (\n    \"io\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // 1. A Reader (strings.Reader)\n    r := strings.NewReader(\"some data\\n\")\n\n    // 2. A Writer (os.Stdout)\n    w := os.Stdout\n\n    // 3. io.Copy connects them together\n    io.Copy(w, r)\n}\n</code></pre>"},{"location":"2.%20Intermediate/37.%20IO-Package/#2-common-utility-functions","title":"2. Common Utility Functions","text":"<ul> <li><code>io.Copy(dst, src)</code>: Read everything from <code>src</code> and write it to <code>dst</code> until EOF.</li> <li><code>io.ReadAll(r)</code>: Reads everything from a reader into a single <code>[]byte</code>.</li> <li><code>io.WriteString(w, s)</code>: A convenience function to write a string directly to a writer.</li> </ul>"},{"location":"2.%20Intermediate/37.%20IO-Package/#3-combining-streams","title":"3. Combining Streams","text":"<ul> <li><code>io.MultiReader(r1, r2, ...)</code>: Combines multiple readers into one big reader that reads them in order.</li> <li><code>io.MultiWriter(w1, w2, ...)</code>: A single writer that duplicates every write to multiple destinations (useful for logging to both terminal and file).</li> <li><code>io.LimitReader(r, n)</code>: Reads at most <code>n</code> bytes from <code>r</code>.</li> <li><code>io.TeeReader(r, w)</code>: Returns a reader that writes everything it reads to <code>w</code> (like the Unix <code>tee</code> command).</li> </ul>"},{"location":"2.%20Intermediate/37.%20IO-Package/#why-use-io-interfaces","title":"Why use <code>io</code> interfaces?","text":"<ol> <li>Flexibility: You can write a function that takes an <code>io.Reader</code>, and it will work with files, HTTP bodies, ZIP archives, or plain strings without any changes.</li> <li>Efficiency: By using streams instead of loading everything into memory at once, your program can process gigabytes of data using only a few kilobytes of RAM.</li> <li>Standardization: Because the whole Go ecosystem uses these interfaces, libraries usually \"just work\" together.</li> </ol>"},{"location":"2.%20Intermediate/38.%20Math-Package/","title":"Go Math Package","text":"<p>The <code>math</code> package provides standard mathematical constants and functions. It works primarily with the <code>float64</code> type.</p>"},{"location":"2.%20Intermediate/38.%20Math-Package/#1-common-constants","title":"1. Common Constants","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    fmt.Println(math.Pi)   // 3.14159...\n    fmt.Println(math.E)    // 2.71828...\n    fmt.Println(math.Phi)  // 1.61803...\n}\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#2-basic-functions","title":"2. Basic Functions","text":"<ul> <li><code>math.Abs(x)</code>: Absolute value.</li> <li><code>math.Max(x, y)</code>: Maximum of two numbers.</li> <li><code>math.Min(x, y)</code>: Minimum of two numbers.</li> <li><code>math.Sqrt(x)</code>: Square root.</li> <li><code>math.Pow(x, y)</code>: x to the power of y.</li> </ul> <pre><code>fmt.Println(math.Max(10, 20)) // 20\nfmt.Println(math.Sqrt(16))     // 4\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#3-rounding","title":"3. Rounding","text":"<ul> <li><code>math.Floor(x)</code>: Rounds down to nearest integer.</li> <li><code>math.Ceil(x)</code>: Rounds up to nearest integer.</li> <li><code>math.Round(x)</code>: Rounds to the nearest integer (0.5 rounds away from zero).</li> </ul> <pre><code>fmt.Println(math.Floor(3.8)) // 3\nfmt.Println(math.Ceil(3.1))  // 4\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#4-special-values","title":"4. Special Values","text":"<p>Go treats things like \"Not a Number\" (NaN) and Infinity as valid <code>float64</code> values.</p> <pre><code>inf := math.Inf(1)  // Positive Infinity\nnan := math.NaN()   // Not a Number\n\nfmt.Println(math.IsNaN(nan)) // true\n</code></pre>"},{"location":"2.%20Intermediate/38.%20Math-Package/#best-practices","title":"Best Practices","text":"<ol> <li>Floating-Point Accuracy: Remember that <code>0.1 + 0.2</code> might not exactly equal <code>0.3</code> due to how computers store decimals. For money, use an <code>int</code> (cents) or a specialized decimal library.</li> <li>Explicit Conversion: If you have an <code>int</code>, you must convert it to <code>float64</code> before using math functions: <code>math.Sqrt(float64(myInt))</code>.</li> <li>Trigonometry: Functions like <code>math.Sin</code> and <code>math.Cos</code> expect radians, not degrees.</li> </ol>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/","title":"Go Strings and Runes","text":"<p>In Go, strings are read-only slices of bytes. When we talk about \"characters,\" Go uses a concept called a rune.</p>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#what-is-a-rune","title":"What is a Rune?","text":"<p>A <code>rune</code> is an alias for <code>int32</code>. It represents a single Unicode character (code point). Since some characters (like '\u4e16' or emojis) take up multiple bytes, a simple index like <code>s[i]</code> might only give you a fraction of a character.</p>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#basic-example","title":"Basic Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    // A string with a multi-byte character\n    const s = \"Hello, \u4e16\u754c\"\n\n    // len() returns the number of BYTES\n    fmt.Println(\"Len:\", len(s)) // 13\n\n    // RuneCountInString returns the number of CHARACTERS\n    fmt.Println(\"Rune count:\", utf8.RuneCountInString(s)) // 9\n\n    // To access characters correctly, we use a range loop\n    for i, runeValue := range s {\n        fmt.Printf(\"%#U starts at byte position %d\\n\", runeValue, i)\n    }\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#key-differences","title":"Key Differences","text":"Feature String Byte (<code>s[i]</code>) Rune (<code>rune</code>) Represents A single byte (8 bits) A Unicode character (32 bits) Best for Raw data, ASCII text International text, Emojis"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#string-operations","title":"String Operations","text":"<p>Go provides a powerful <code>strings</code> package for common tasks:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    s := \"test\"\n\n    fmt.Println(strings.Contains(s, \"es\")) // true\n    fmt.Println(strings.Count(s, \"t\"))    // 2\n    fmt.Println(strings.HasPrefix(s, \"te\")) // true\n    fmt.Println(strings.ToUpper(s))         // TEST\n}\n</code></pre>"},{"location":"2.%20Intermediate/4.%20String-and-Runes/#important-rule-immutability","title":"Important Rule: Immutability","text":"<p>Strings in Go are immutable. You cannot change a character inside a string once it is created.</p> <pre><code>s := \"hello\"\n// s[0] = 'H' // This will cause an error\n</code></pre> <p>To modify a string, you must convert it to a slice of runes or bytes, change it, and convert it back:</p> <pre><code>runes := []rune(s)\nrunes[0] = 'H'\ns = string(runes) // \"Hello\"\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/","title":"Go Formatting Verbs","text":"<p>In Go, \"formatting verbs\" are special placeholders used with functions like <code>fmt.Printf</code> to control how values are displayed.</p>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#common-verbs","title":"Common Verbs","text":"Verb Usage Example Output <code>%v</code> Default format (works for almost anything) <code>{val: 123}</code> <code>%+v</code> Struct with field names <code>{Name: \"John\"}</code> <code>%T</code> The Type of the value <code>int</code>, <code>string</code> <code>%d</code> Decimal integer <code>15</code> <code>%b</code> Binary integer <code>1111</code> <code>%f</code> Float (decimal) <code>1.234567</code> <code>%.2f</code> Float with 2 decimal places <code>1.23</code> <code>%s</code> Basic string <code>hello</code> <code>%q</code> Quoted string <code>\"hello\"</code> <code>%p</code> Pointer (memory address) <code>0xc000...</code>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#basic-example","title":"Basic Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype point struct {\n    x, y int\n}\n\nfunc main() {\n    p := point{1, 2}\n\n    // %v is the safest bet for any value\n    fmt.Printf(\"Default: %v\\n\", p)   // {1 2}\n    fmt.Printf(\"Fields:  %+v\\n\", p)  // {x:1 y:2}\n    fmt.Printf(\"Type:    %T\\n\", p)   // main.point\n\n    // Numbers and Strings\n    fmt.Printf(\"Binary: %b\\n\", 15)      // 1111\n    fmt.Printf(\"Float:  %.2f\\n\", 3.1415) // 3.14\n    fmt.Printf(\"Quoted: %q\\n\", \"cafe\")   // \"cafe\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/5.%20Formatting-Verbs/#width-and-padding","title":"Width and Padding","text":"<p>You can also control the spacing of your output:</p> <ul> <li><code>%5d</code>: Puts at least 5 spaces of width, right-justified.</li> <li><code>%-5d</code>: Puts at least 5 spaces of width, left-justified.</li> <li><code>%05d</code>: Pads with zeros (e.g., <code>00042</code>).</li> </ul> <pre><code>fmt.Printf(\"|%5d|%5d|\\n\", 1, 2)   // |    1|    2|\nfmt.Printf(\"|%-5d|%-5d|\\n\", 1, 2) // |1    |2    |\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/","title":"Go <code>fmt</code> Package","text":"<p>The <code>fmt</code> package (short for \"format\") is the most commonly used package for printing and reading data.</p>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#1-printing-functions","title":"1. Printing Functions","text":"<p>There are three main ways to print output:</p> <ul> <li><code>fmt.Println</code>: Prints arguments with spaces between them and a newline at the end.</li> <li><code>fmt.Print</code>: Like <code>Println</code>, but no newline or extra spaces.</li> <li><code>fmt.Printf</code>: Used for formatted strings (incorporates \"verbs\" like <code>%d</code>).</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Go\"\n    version := 1.21\n\n    fmt.Println(\"Hello\", name) // Prints \"Hello Go\" + \\n\n    fmt.Printf(\"%s version is %f\\n\", name, version)\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#2-creating-strings-sprintf","title":"2. Creating Strings (<code>Sprintf</code>)","text":"<p>If you want to \"print\" to a variable instead of the console, use <code>fmt.Sprintf</code>.</p> <pre><code>s := fmt.Sprintf(\"Formatting %s into a string\", \"this\")\nfmt.Println(s)\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#3-reading-input-scan","title":"3. Reading Input (<code>Scan</code>)","text":"<p>To get input from the user, use <code>fmt.Scan</code> or <code>fmt.Scanln</code>.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var age int\n    fmt.Print(\"Enter your age: \")\n    fmt.Scan(&amp;age) // Takes a pointer to the variable\n    fmt.Println(\"Your age is:\", age)\n}\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#4-errors-errorf","title":"4. Errors (<code>Errorf</code>)","text":"<p><code>fmt.Errorf</code> is a quick way to create a formatted error message.</p> <pre><code>err := fmt.Errorf(\"user %d not found\", 404)\nfmt.Println(err.Error())\n</code></pre>"},{"location":"2.%20Intermediate/6.%20FMT-Package/#quick-summary","title":"Quick Summary","text":"Function Description <code>Print</code> / <code>Println</code> Basic console output. <code>Printf</code> Formatted console output. <code>Sprintf</code> Returns a formatted string. <code>Scan</code> Reads input from console. <code>Errorf</code> Creates a formatted error."},{"location":"2.%20Intermediate/7.%20Structs/","title":"Go Structs","text":"<p>A struct (short for \"structure\") is a collection of fields. It allows you to group different types of data into a single custom type.</p>"},{"location":"2.%20Intermediate/7.%20Structs/#defining-a-struct","title":"Defining a Struct","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// person struct has a Name and an Age\ntype person struct {\n    name string\n    age  int\n}\n\nfunc main() {\n    // 1. Basic initialization\n    fmt.Println(person{\"Bob\", 20})\n\n    // 2. Named fields (recommended for clarity)\n    p := person{name: \"Alice\", age: 30}\n    fmt.Println(p.name)\n\n    // 3. Pointers to structs\n    sp := &amp;p\n    fmt.Println(sp.age)\n\n    // 4. Modifying a field\n    sp.age = 51\n    fmt.Println(p.age) // Now 51\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#why-use-structs","title":"Why use Structs?","text":"<ul> <li>Organization: Keep related data together (e.g., a <code>User</code> struct with <code>ID</code>, <code>Email</code>, and <code>Password</code>).</li> <li>Method Receivers: You can attach functions (methods) to structs.</li> <li>JSON/Database Mapping: Use \"tags\" to tell Go how to convert a struct to JSON or a database row.</li> </ul>"},{"location":"2.%20Intermediate/7.%20Structs/#struct-tags","title":"Struct Tags","text":"<p>Tags are small pieces of metadata added to fields, usually to help with JSON.</p> <pre><code>type User struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n</code></pre>"},{"location":"2.%20Intermediate/7.%20Structs/#important-notes","title":"Important Notes","text":"<ul> <li>Zero Values: If you don't provide a value for a field, it gets its \"zero value\" (e.g., <code>0</code> for <code>int</code>, <code>\"\"</code> for <code>string</code>).</li> <li>Exporting: If a struct field starts with a Capital Letter, it is public (exported). If it starts with a lowercase letter, it is private to its package.</li> </ul>"},{"location":"2.%20Intermediate/8.%20Methods/","title":"Go Methods","text":"<p>In Go, a method is simply a function with a special \"receiver\" argument. This allows you to \"attach\" behavior to your custom types (usually structs).</p>"},{"location":"2.%20Intermediate/8.%20Methods/#defining-a-method","title":"Defining a Method","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype rect struct {\n    width, height int\n}\n\n// This 'area' method has a receiver of type 'rect'\nfunc (r rect) area() int {\n    return r.width * r.height\n}\n\nfunc main() {\n    r := rect{width: 10, height: 5}\n\n    // Call the method using the dot operator\n    fmt.Println(\"Area:\", r.area())\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#pointer-vs-value-receivers","title":"Pointer vs. Value Receivers","text":"<p>There are two ways to define methods:</p> <ol> <li>Value Receiver (<code>r rect</code>): The method gets a copy of the struct. It cannot change the original data.</li> <li>Pointer Receiver (<code>r *rect</code>): The method gets a pointer to the struct. It can modify the original data.</li> </ol> <pre><code>package main\n\nimport \"fmt\"\n\ntype counter struct {\n    val int\n}\n\n// Value receiver: won't change the original counter\nfunc (c counter) incrementCopy() {\n    c.val++\n}\n\n// Pointer receiver: WILL change the original counter\nfunc (c *counter) incrementReal() {\n    c.val++\n}\n\nfunc main() {\n    c := counter{val: 0}\n\n    c.incrementCopy()\n    fmt.Println(c.val) // 0\n\n    c.incrementReal()\n    fmt.Println(c.val) // 1\n}\n</code></pre>"},{"location":"2.%20Intermediate/8.%20Methods/#why-use-methods","title":"Why use Methods?","text":"<ul> <li>Encapsulation: Group logic together with the data it belongs to.</li> <li>Interfaces: To satisfy an interface, a type must implement specific methods.</li> <li>Clean Syntax: It often feels more natural to write <code>user.Save()</code> than <code>SaveUser(user)</code>.</li> </ul>"},{"location":"2.%20Intermediate/8.%20Methods/#important-rule","title":"Important Rule","text":"<p>Go automatically handles conversion between values and pointers for method calls. If you call a pointer-receiver method on a value, Go will automatically pass the address (<code>&amp;</code>).</p>"},{"location":"2.%20Intermediate/9.%20Interfaces/","title":"Go Interfaces","text":"<p>An interface is a collection of method signatures. It defines a \"contract\"\u2014any type that provides those methods is said to \"implement\" the interface.</p>"},{"location":"2.%20Intermediate/9.%20Interfaces/#defining-an-interface","title":"Defining an Interface","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// geometry interface defines the methods any shape must have\ntype geometry interface {\n    area() float64\n}\n\ntype rect struct {\n    width, height float64\n}\n\n// rect implements geometry because it has an area() method\nfunc (r rect) area() float64 {\n    return r.width * r.height\n}\n\nfunc measure(g geometry) {\n    fmt.Println(\"Area:\", g.area())\n}\n\nfunc main() {\n    r := rect{width: 3, height: 4}\n    measure(r)\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#why-use-interfaces","title":"Why use Interfaces?","text":"<ul> <li>Polymorphism: You can write a single function (like <code>measure</code>) that works with many different types, as long as they follow the contract.</li> <li>Decoupling: Your code doesn't need to know the exact type of object it's working with, only what it can do.</li> <li>Mocking/Testing: You can swap real implementations (like a database) with \"mock\" versions for testing.</li> </ul>"},{"location":"2.%20Intermediate/9.%20Interfaces/#the-empty-interface-any-or-interface","title":"The Empty Interface (<code>any</code> or <code>interface{}</code>)","text":"<p>An interface with zero methods is satisfied by every type. In modern Go, we often use the keyword <code>any</code>.</p> <pre><code>func printAnything(i any) {\n    fmt.Println(i)\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#type-assertions","title":"Type Assertions","text":"<p>If you have an interface value and need to get the original type back, use a type assertion:</p> <pre><code>var i any = \"hello\"\n\ns, ok := i.(string)\nif ok {\n    fmt.Println(s) // \"hello\"\n}\n</code></pre>"},{"location":"2.%20Intermediate/9.%20Interfaces/#important-notes","title":"Important Notes","text":"<ul> <li>Implicit Implementation: You don't need to say <code>implements geometry</code>. If your type has the right methods, it just works.</li> <li>Small Interfaces: In Go, smaller interfaces (1 or 2 methods) are usually better than large ones.</li> </ul>"},{"location":"3.%20Advanced/1.%20Goroutines/","title":"Go Goroutines","text":"<p>A goroutine is a lightweight thread managed by the Go runtime. They are the core of Go's concurrency model, allowing you to run functions independently and simultaneously.</p>"},{"location":"3.%20Advanced/1.%20Goroutines/#1-basic-usage","title":"1. Basic Usage","text":"<p>To run a function in a goroutine, simply add the <code>go</code> keyword before the function call.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc f(from string) {\n    for i := 0; i &lt; 3; i++ {\n        fmt.Println(from, \":\", i)\n    }\n}\n\nfunc main() {\n    // 1. Direct call (synchronous)\n    f(\"direct\")\n\n    // 2. Start a goroutine (asynchronous)\n    go f(\"goroutine\")\n\n    // 3. Start a goroutine for an anonymous function\n    go func(msg string) {\n        fmt.Println(msg)\n    }(\"going\")\n\n    // Wait for goroutines to finish (Basic approach)\n    time.Sleep(time.Second)\n    fmt.Println(\"done\")\n}\n</code></pre>"},{"location":"3.%20Advanced/1.%20Goroutines/#2-synchronization-waitgroups","title":"2. Synchronization (WaitGroups)","text":"<p>The <code>time.Sleep</code> approach is unreliable. In real apps, we use <code>sync.WaitGroup</code> to wait for all goroutines to finish correctly.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc worker(id int, wg *sync.WaitGroup) {\n    defer wg.Done() // Signal this worker is finished\n    fmt.Printf(\"Worker %d starting\\n\", id)\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n\n    for i := 1; i &lt;= 5; i++ {\n        wg.Add(1) // Tell WaitGroup we are starting 1 worker\n        go worker(i, &amp;wg)\n    }\n\n    wg.Wait() // Block until all workers call wg.Done()\n}\n</code></pre>"},{"location":"3.%20Advanced/1.%20Goroutines/#why-use-goroutines-over-threads","title":"Why use Goroutines over Threads?","text":"<ol> <li>Memory: Goroutines start with only 2KB of stack memory, compared to 1MB or more for OS threads.</li> <li>Speed: Switching between goroutines (context switching) is much faster because it happens entirely within the Go runtime, not the OS kernel.</li> <li>Scalability: You can easily run hundreds of thousands of goroutines on a single machine where threads would crash it.</li> </ol>"},{"location":"3.%20Advanced/1.%20Goroutines/#best-practices","title":"Best Practices","text":"<ul> <li>Don't leak them: Always make sure a goroutine has a way to finish.</li> <li>No global state: Avoid modifying global variables from multiple goroutines (use channels or mutexes instead).</li> <li>Channel communication: Prefer \"communicating by sharing\" (Channels) over \"sharing by communicating\" (Mutexes).</li> </ul>"},{"location":"3.%20Advanced/2.%20Channels-and-Unbuffered-Channels/","title":"Go Channels","text":"<p>Channels are the pipes that connect concurrent goroutines. You can send values into channels from one goroutine and receive those values into another goroutine.</p>"},{"location":"3.%20Advanced/2.%20Channels-and-Unbuffered-Channels/#1-basic-channels","title":"1. Basic Channels","text":"<p>By default, channels are unbuffered, meaning they only accept sends (<code>chan &lt;-</code>) if there is a corresponding receive (<code>&lt;- chan</code>) ready to receive the sent value.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 1. Create a new channel with make(chan val-type)\n    messages := make(chan string)\n\n    // 2. Send a value into a channel using the &lt;- syntax\n    go func() { messages &lt;- \"ping\" }()\n\n    // 3. Receive the value from the channel\n    msg := &lt;-messages\n    fmt.Println(msg)\n}\n</code></pre>"},{"location":"3.%20Advanced/2.%20Channels-and-Unbuffered-Channels/#2-channel-synchronization","title":"2. Channel Synchronization","text":"<p>We can use channels to synchronize execution across goroutines. Here's an example of using a blocking receive to wait for a goroutine to finish.</p> <pre><code>func worker(done chan bool) {\n    fmt.Print(\"working...\")\n    time.Sleep(time.Second)\n    fmt.Println(\"done\")\n\n    // Send a value to notify that we're done\n    done &lt;- true\n}\n\nfunc main() {\n    done := make(chan bool, 1)\n    go worker(done)\n\n    // Block until we receive a notification from the worker\n    &lt;-done\n}\n</code></pre>"},{"location":"3.%20Advanced/2.%20Channels-and-Unbuffered-Channels/#3-channel-directions","title":"3. Channel Directions","text":"<p>When using channels as function parameters, you can specify if a channel is meant to only send or receive values. This increases type safety.</p> <pre><code>// This function only accepts a channel for sending values\nfunc ping(pings chan&lt;- string, msg string) {\n    pings &lt;- msg\n}\n\n// This function accepts one channel for receives (pings) \n// and a second for sends (pongs)\nfunc pong(pings &lt;-chan string, pongs chan&lt;- string) {\n    msg := &lt;-pings\n    pongs &lt;- msg\n}\n</code></pre>"},{"location":"3.%20Advanced/2.%20Channels-and-Unbuffered-Channels/#why-use-channels","title":"Why use Channels?","text":"<ol> <li>Thread Safety: Channels handle the locking logic internally, so you don't have to use Mutexes for simple data passing.</li> <li>Orchestration: They are great for \"handing off\" work from one stage of a program to another (Pipelines).</li> <li>Clean Code: They follow the Go mantra: \"Do not communicate by sharing memory; instead, share memory by communicating.\"</li> </ol>"},{"location":"3.%20Advanced/3.%20Buffered-Channels/","title":"Go Buffered Channels","text":"<p>By default, channels are unbuffered, meaning they only accept sends if there is a corresponding receive ready. Buffered channels accept a limited number of values without a corresponding receiver for those values.</p>"},{"location":"3.%20Advanced/3.%20Buffered-Channels/#1-basic-example","title":"1. Basic Example","text":"<p>You specify the buffer capacity as the second argument to <code>make</code>.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 1. Create a channel buffered up to 2 values\n    messages := make(chan string, 2)\n\n    // 2. Because this channel is buffered, we can send these \n    // values into the channel without a corresponding concurrent receive.\n    messages &lt;- \"buffered\"\n    messages &lt;- \"channel\"\n\n    // 3. Later we can receive these two values as usual.\n    fmt.Println(&lt;-messages)\n    fmt.Println(&lt;-messages)\n}\n</code></pre>"},{"location":"3.%20Advanced/3.%20Buffered-Channels/#2-blocking-behavior","title":"2. Blocking Behavior","text":"<ul> <li>Sending: A send into a buffered channel blocks only when the buffer is full.</li> <li>Receiving: A receive from a buffered channel blocks only when the buffer is empty.</li> </ul> <pre><code>ch := make(chan int, 1)\n\nch &lt;- 1    // Works immediately\n// ch &lt;- 2 // Would BLOCK here because the buffer is full\n\nfmt.Println(&lt;-ch) // 1\n// fmt.Println(&lt;-ch) // Would BLOCK here because the buffer is empty\n</code></pre>"},{"location":"3.%20Advanced/3.%20Buffered-Channels/#why-use-buffered-channels","title":"Why use Buffered Channels?","text":"<ol> <li>Performance: They can reduce overhead by allowing a \"burst\" of work to be sent without waiting for the consumer to catch up immediately.</li> <li>Decoupling: Senders and receivers don't have to stay in perfect \"lock-step.\"</li> <li>Rate Limiting: They are often used to limit the number of concurrent operations (e.g., only allow 100 HTTP requests at a time).</li> </ol>"},{"location":"3.%20Advanced/3.%20Buffered-Channels/#common-pattern-waiting-for-workers","title":"Common Pattern: Waiting for Workers","text":"<p>Buffered channels are useful when you know exactly how many results you are waiting for.</p> <pre><code>results := make(chan int, 3)\n\nfor i := 0; i &lt; 3; i++ {\n    go func(n int) {\n        results &lt;- n * 2\n    }(i)\n}\n\n// We can receive 3 results without worrying about timing\nfor i := 0; i &lt; 3; i++ {\n    fmt.Println(&lt;-results)\n}\n</code></pre>"},{"location":"3.%20Advanced/4.%20Select/","title":"Go Select","text":"<p>Go's <code>select</code> statement lets you wait on multiple channel operations. Combining <code>select</code> with goroutines and channels is a powerful feature of Go.</p>"},{"location":"3.%20Advanced/4.%20Select/#1-basic-example","title":"1. Basic Example","text":"<p><code>select</code> blocks until one of its cases can run, then it executes that case. It's like a <code>switch</code> statement but for channels.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    c1 := make(chan string)\n    c2 := make(chan string)\n\n    go func() {\n        time.Sleep(1 * time.Second)\n        c1 &lt;- \"one\"\n    }()\n    go func() {\n        time.Sleep(2 * time.Second)\n        c2 &lt;- \"two\"\n    }()\n\n    for i := 0; i &lt; 2; i++ {\n        select {\n        case msg1 := &lt;-c1:\n            fmt.Println(\"received\", msg1)\n        case msg2 := &lt;-c2:\n            fmt.Println(\"received\", msg2)\n        }\n    }\n}\n</code></pre>"},{"location":"3.%20Advanced/4.%20Select/#2-timeouts","title":"2. Timeouts","text":"<p>You can use <code>select</code> with <code>time.After</code> to prevent a program from waiting forever on a channel.</p> <pre><code>select {\ncase res := &lt;-c1:\n    fmt.Println(res)\ncase &lt;-time.After(1 * time.Second):\n    fmt.Println(\"timeout 1\")\n}\n</code></pre>"},{"location":"3.%20Advanced/4.%20Select/#3-non-blocking-channel-operations","title":"3. Non-Blocking Channel Operations","text":"<p>If a <code>default</code> case is present, the <code>select</code> statement becomes non-blocking. It will try to send/receive, and if it can't, it immediately executes the default code.</p> <pre><code>select {\ncase msg := &lt;-messages:\n    fmt.Println(\"received message\", msg)\ndefault:\n    fmt.Println(\"no message received\")\n}\n</code></pre>"},{"location":"3.%20Advanced/4.%20Select/#important-notes","title":"Important Notes","text":"<ol> <li>Fairness: If multiple channels are ready at the same time, Go picks one at random.</li> <li>Empty Select: An empty select <code>select {}</code> will block forever.</li> <li>Sending: <code>select</code> also works for sending: <code>case c1 &lt;- \"data\":</code>. This will run only if <code>c1</code> is ready to accept data.</li> </ol>"},{"location":"3.%20Advanced/5.%20Concurrency/","title":"Go Concurrency Primitives","text":"<p>Go provides several tools to manage complex concurrent workflows. Beyond basic goroutines and channels, you often need these primitives for synchronization and data safety.</p>"},{"location":"3.%20Advanced/5.%20Concurrency/#1-waitgroups-syncwaitgroup","title":"1. WaitGroups (<code>sync.WaitGroup</code>)","text":"<p>Used to wait for a collection of goroutines to finish.</p> <pre><code>var wg sync.WaitGroup\n\nfor i := 0; i &lt; 5; i++ {\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        fmt.Println(\"Doing work\")\n    }()\n}\n\nwg.Wait() // Wait for all 5 goroutines\n</code></pre>"},{"location":"3.%20Advanced/5.%20Concurrency/#2-mutexes-syncmutex","title":"2. Mutexes (<code>sync.Mutex</code>)","text":"<p>Used to protect \"critical sections\" of code where you access shared data. A Mutex (Mutual Exclusion) ensures only one goroutine can access the data at a time.</p> <pre><code>type SafeCounter struct {\n    mu    sync.Mutex\n    value int\n}\n\nfunc (c *SafeCounter) Inc() {\n    c.mu.Lock()\n    c.value++\n    c.mu.Unlock()\n}\n</code></pre>"},{"location":"3.%20Advanced/5.%20Concurrency/#3-atomic-counters-syncatomic","title":"3. Atomic Counters (<code>sync/atomic</code>)","text":"<p>For simple numeric updates (like a global counter), the <code>atomic</code> package is much faster than a Mutex because it uses low-level hardware instructions.</p> <pre><code>import \"sync/atomic\"\n\nvar ops uint64\n\n// Increment safely from multiple goroutines\natomic.AddUint64(&amp;ops, 1)\n\n// Read safely\ncurrentOps := atomic.LoadUint64(&amp;ops)\n</code></pre>"},{"location":"3.%20Advanced/5.%20Concurrency/#4-worker-pools","title":"4. Worker Pools","text":"<p>A common pattern to limit resources by running a fixed number of goroutines that process a queue of work.</p> <pre><code>func worker(id int, jobs &lt;-chan int, results chan&lt;- int) {\n    for j := range jobs {\n        results &lt;- j * 2\n    }\n}\n\nfunc main() {\n    jobs := make(chan int, 100)\n    results := make(chan int, 100)\n\n    // Start 3 workers\n    for w := 1; w &lt;= 3; w++ {\n        go worker(w, jobs, results)\n    }\n\n    // Send 5 pieces of work\n    for j := 1; j &lt;= 5; j++ {\n        jobs &lt;- j\n    }\n    close(jobs)\n}\n</code></pre>"},{"location":"3.%20Advanced/5.%20Concurrency/#summary-table","title":"Summary Table","text":"Primitive Use Case Channels Passing data between goroutines. WaitGroup Waiting for multiple tasks to complete. Mutex Protecting complex shared objects (maps, structs). Atomic Updating simple numbers (counters, flags). Worker Pool limiting the amount of concurrent work."},{"location":"3.%20Advanced/6.%20Rate-Limiting-and-Algorithms/","title":"Go Rate Limiting","text":"<p>Rate limiting is an important mechanism for controlling resource utilization and maintaining quality of service. Go supports rate limiting with goroutines, channels, and tickers.</p>"},{"location":"3.%20Advanced/6.%20Rate-Limiting-and-Algorithms/#1-basic-rate-limiting","title":"1. Basic Rate Limiting","text":"<p>The simplest way to implement rate limiting is using a <code>time.Ticker</code>. This example limits requests to once every 200 milliseconds.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    requests := make(chan int, 5)\n    for i := 1; i &lt;= 5; i++ {\n        requests &lt;- i\n    }\n    close(requests)\n\n    // This limiter will send a value every 200ms\n    limiter := time.Tick(200 * time.Millisecond)\n\n    for req := range requests {\n        &lt;-limiter // Block until ticker sends a pulse\n        fmt.Println(\"request\", req, time.Now())\n    }\n}\n</code></pre>"},{"location":"3.%20Advanced/6.%20Rate-Limiting-and-Algorithms/#2-bursty-rate-limiting","title":"2. Bursty Rate Limiting","text":"<p>Sometimes you want to allow a short \"burst\" of requests but still limit the overall rate. We can achieve this by using a buffered channel as our limiter.</p> <pre><code>// Allow up to 3 requests at once, but only refill 1 slot every 200ms\nburstyLimiter := make(chan time.Time, 3)\n\nfor i := 0; i &lt; 3; i++ {\n    burstyLimiter &lt;- time.Now()\n}\n\ngo func() {\n    for t := range time.Tick(200 * time.Millisecond) {\n        burstyLimiter &lt;- t\n    }\n}()\n\n// Now handle more requests\nburstyRequests := make(chan int, 5)\nfor i := 1; i &lt;= 5; i++ {\n    burstyRequests &lt;- i\n}\nclose(burstyRequests)\n\nfor req := range burstyRequests {\n    &lt;-burstyLimiter\n    fmt.Println(\"request\", req, time.Now())\n}\n</code></pre>"},{"location":"3.%20Advanced/6.%20Rate-Limiting-and-Algorithms/#why-use-rate-limiting","title":"Why use Rate Limiting?","text":"<ol> <li>Prevent Abuse: Stop users from overwhelming your API with thousands of requests per second.</li> <li>Resource Management: Ensure your database or external dependencies aren't overloaded.</li> <li>Cost Control: If you pay for third-party APIs by the request, rate limiting keeps costs predictable.</li> </ol>"},{"location":"3.%20Advanced/6.%20Rate-Limiting-and-Algorithms/#best-practices","title":"Best Practices","text":"<ul> <li>Client Side: If you are calling an external API, implement rate limiting on your side to stay within their limits and avoid getting banned.</li> <li>Context: Use <code>context.Context</code> to allow cancellation of waiting requests.</li> <li>Packages: For complex production use cases, consider the <code>golang.org/x/time/rate</code> package, which implements a \"Token Bucket\" algorithm.</li> </ul>"},{"location":"3.%20Advanced/7.%20Utilities-and-System-Operations/","title":"Go System Utilities","text":"<p>Go provides powerful packages for common system-level tasks like sorting data, writing tests, and interacting with the Operating System.</p>"},{"location":"3.%20Advanced/7.%20Utilities-and-System-Operations/#1-sorting-sort-package","title":"1. Sorting (<code>sort</code> package)","text":"<p>Go's <code>sort</code> package is highly optimized for sorting slices of any built-in or custom type.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    // Sorting built-ins\n    strs := []string{\"c\", \"a\", \"b\"}\n    sort.Strings(strs)\n    fmt.Println(\"Strings:\", strs)\n\n    ints := []int{7, 2, 4}\n    sort.Ints(ints)\n    fmt.Println(\"Ints:   \", ints)\n\n    // Checking if sorted\n    s := sort.IntsAreSorted(ints)\n    fmt.Println(\"Sorted: \", s)\n}\n</code></pre>"},{"location":"3.%20Advanced/7.%20Utilities-and-System-Operations/#2-testing-testing-package","title":"2. Testing (<code>testing</code> package)","text":"<p>Go has a built-in testing framework. Files must end in <code>_test.go</code> and functions must start with <code>Test</code>.</p> <p><pre><code>// main_test.go\nfunc TestAdd(t *testing.T) {\n    ans := Add(2, -2)\n    if ans != 0 {\n        t.Errorf(\"Add(2, -2) = %d; want 0\", ans)\n    }\n}\n</code></pre> Run with: <code>go test</code></p>"},{"location":"3.%20Advanced/7.%20Utilities-and-System-Operations/#3-benchmarking","title":"3. Benchmarking","text":"<p>You can measure the performance of your code using benchmark functions.</p> <p><pre><code>func BenchmarkAdd(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        Add(1, 2)\n    }\n}\n</code></pre> Run with: <code>go test -bench=.</code></p>"},{"location":"3.%20Advanced/7.%20Utilities-and-System-Operations/#4-executing-processes-osexec","title":"4. Executing Processes (<code>os/exec</code>)","text":"<p>You can run external commands (like <code>ls</code> or <code>grep</code>) directly from Go.</p> <pre><code>import \"os/exec\"\n\nfunc main() {\n    // 1. Simple command\n    dateCmd := exec.Command(\"date\")\n    dateOut, _ := dateCmd.Output()\n    fmt.Println(\"&gt; date\")\n    fmt.Println(string(dateOut))\n\n    // 2. Command with arguments\n    grepCmd := exec.Command(\"grep\", \"hello\")\n}\n</code></pre>"},{"location":"3.%20Advanced/7.%20Utilities-and-System-Operations/#5-signals-ossignal","title":"5. Signals (<code>os/signal</code>)","text":"<p>Use signals to handle events like <code>Ctrl+C</code> (SIGINT) for a graceful shutdown.</p> <pre><code>sigs := make(chan os.Signal, 1)\nsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\n// Block until a signal is received\nsig := &lt;-sigs\nfmt.Println(\"Received signal:\", sig)\n</code></pre>"},{"location":"3.%20Advanced/7.%20Utilities-and-System-Operations/#summary-table","title":"Summary Table","text":"Package Purpose <code>sort</code> Functions for sorting slices and user-defined collections. <code>testing</code> Automated testing of Go packages. <code>os/exec</code> Running external commands. <code>os/signal</code> Access to incoming Unix signals."},{"location":"3.%20Advanced/8.%20Reflection/","title":"Go Reflection","text":"<p>Reflection allows a Go program to inspect its own structure (types and values) at runtime. This is handled by the <code>reflect</code> package.</p>"},{"location":"3.%20Advanced/8.%20Reflection/#1-type-and-value","title":"1. Type and Value","text":"<p>The two most important concepts are <code>reflect.Type</code> and <code>reflect.Value</code>.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main() {\n    x := 3.4\n\n    // 1. Get the Type (float64)\n    fmt.Println(\"type:\", reflect.TypeOf(x))\n\n    // 2. Get the Value (3.4)\n    v := reflect.ValueOf(x)\n    fmt.Println(\"value:\", v)\n    fmt.Println(\"kind is float64:\", v.Kind() == reflect.Float64)\n}\n</code></pre>"},{"location":"3.%20Advanced/8.%20Reflection/#2-inspecting-structs","title":"2. Inspecting Structs","text":"<p>Reflection is commonly used to look inside structs, read their field names, and check their \"tags.\"</p> <pre><code>type User struct {\n    ID   int    `json:\"id\"`\n    Name string `json:\"user_name\"`\n}\n\nu := User{1, \"Alice\"}\nt := reflect.TypeOf(u)\n\nfor i := 0; i &lt; t.NumField(); i++ {\n    field := t.Field(i)\n    fmt.Printf(\"Field: %s, Tag: %s\\n\", field.Name, field.Tag.Get(\"json\"))\n}\n</code></pre>"},{"location":"3.%20Advanced/8.%20Reflection/#3-modifying-values","title":"3. Modifying Values","text":"<p>To modify a value through reflection, you must pass a pointer to the data and use <code>Elem()</code>.</p> <pre><code>x := 10\nv := reflect.ValueOf(&amp;x).Elem() // Get the value the pointer points to\n\nif v.CanSet() {\n    v.SetInt(20)\n}\nfmt.Println(x) // 20\n</code></pre>"},{"location":"3.%20Advanced/8.%20Reflection/#why-use-reflection","title":"Why use Reflection?","text":"<ol> <li>Generic Libraries: Packages like <code>encoding/json</code> use reflection because they don't know the type of your struct until the program is running.</li> <li>Object Mapping: Libraries that map database rows to Go structs.</li> <li>Validation: Checking struct tags (e.g., <code>validate:\"required\"</code>) at runtime.</li> </ol>"},{"location":"3.%20Advanced/8.%20Reflection/#downsides","title":"Downsides","text":"<ul> <li>Performance: Reflection is much slower than regular code.</li> <li>Type Safety: Reflection bypasses compile-time checks. If you try to set a <code>string</code> field with an <code>int</code>, the program will panic at runtime.</li> <li>Complexity: Reflection code is often harder to read and maintain.</li> </ul>"},{"location":"3.%20Advanced/9.%20Stateful-Goroutines/","title":"Go Stateful Goroutines","text":"<p>In Go, you can manage shared state by using stateful goroutines. Instead of using a Mutex to lock a variable, you \"own\" the state inside one goroutine and communicate with it using channels.</p> <p>This follows the Go mantra: \"Do not communicate by sharing memory; instead, share memory by communicating.\"</p>"},{"location":"3.%20Advanced/9.%20Stateful-Goroutines/#1-the-core-pattern","title":"1. The Core Pattern","text":"<p>A stateful goroutine consists of: 1.  A private variable (the state). 2.  A channel to receive read/write requests. 3.  A loop that processes requests one by one.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"sync/atomic\"\n    \"time\"\n)\n\n// readOp and writeOp represent requests to the stateful goroutine\ntype readOp struct {\n    key  int\n    resp chan int\n}\ntype writeOp struct {\n    key  int\n    val  int\n    resp chan bool\n}\n\nfunc main() {\n    // These channels will be used to issue requests\n    reads := make(chan readOp)\n    writes := make(chan writeOp)\n\n    // This goroutine owns the state\n    go func() {\n        var state = make(map[int]int)\n        for {\n            select {\n            case read := &lt;-reads:\n                read.resp &lt;- state[read.key]\n            case write := &lt;-writes:\n                state[write.key] = write.val\n                write.resp &lt;- true\n            }\n        }\n    }()\n\n    // Now other goroutines can safely \"read\" and \"write\" via channels\n    // without ever using a Mutex!\n}\n</code></pre>"},{"location":"3.%20Advanced/9.%20Stateful-Goroutines/#2-benefits-of-stateful-goroutines","title":"2. Benefits of Stateful Goroutines","text":"<ol> <li>No Race Conditions: Since only one goroutine ever touches the <code>state</code> map, it's impossible to have a data race.</li> <li>Sequential Consistency: Operations are processed in the order they arrive in the channel.</li> <li>Encapsulation: The logic for how state is updated is hidden inside the goroutine.</li> </ol>"},{"location":"3.%20Advanced/9.%20Stateful-Goroutines/#3-comparison-with-mutexes","title":"3. Comparison with Mutexes","text":"Feature Mutex Stateful Goroutine Complexity Simple for small state. Better for complex logic. Performance Usually faster (less overhead). Slower due to channel context switching. Safety Requires careful <code>Lock/Unlock</code>. Inherently safe by design."},{"location":"3.%20Advanced/9.%20Stateful-Goroutines/#when-to-use-this","title":"When to use this?","text":"<p>Use stateful goroutines when: -   The state management logic is complex (e.g., a chat room server where users join/leave). -   You want to avoid the mental overhead of tracking multiple Mutexes. -   The performance overhead of channels is acceptable for your use case.</p>"},{"location":"Backend/go-backend/","title":"Go Backend Development","text":"<p>Go is an excellent choice for backend development due to its performance, static binaries, and built-in HTTP support.</p>"},{"location":"Backend/go-backend/#creating-a-basic-http-server","title":"Creating a Basic HTTP Server","text":"<p>You don't need any frameworks to start a web server in Go. The standard library (<code>net/http</code>) is enough.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello, you've requested: %s\\n\", r.URL.Path)\n}\n\nfunc main() {\n    // 1. Assign a handler function to a route\n    http.HandleFunc(\"/\", helloHandler)\n\n    // 2. Start the server on port 8080\n    fmt.Println(\"Server starting on :8080...\")\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre>"},{"location":"Backend/go-backend/#next-steps-in-backend","title":"Next Steps in Backend","text":"<p>Once you have the basics down, you can explore:</p> <ol> <li>JSON APIs: Use the <code>encoding/json</code> package to parse request bodies and return JSON responses.</li> <li>Databases: Use <code>database/sql</code> with a driver (like <code>pq</code> for Postgres or <code>go-sql-driver/mysql</code>) to store data.</li> <li>Middleware: Functions that wrap handlers to provide logging, authentication, or compression.</li> <li>Frameworks: If you need more structure, consider light frameworks like Gin, Echo, or Fiber.</li> </ol>"}]}